Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03: ChangeLog.csl
diff -ru ./config/mh-mingw /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/config/mh-mingw
--- ./config/mh-mingw	2014-06-06 11:50:13.083598507 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/config/mh-mingw	2012-03-29 17:53:53.000000000 +1000
@@ -1,7 +1,9 @@
 # Add -D__USE_MINGW_ACCESS to enable the built compiler to work on Windows
 # Vista (see PR33281 for details).
-BOOT_CFLAGS += -D__USE_MINGW_ACCESS -Wno-pedantic-ms-format
-CFLAGS += -D__USE_MINGW_ACCESS
+# Because we wrap access in libiberty/cygpath.c, we do not want to use
+# the MinGW wrappers for access.
+BOOT_CFLAGS += -Wno-pedantic-ms-format
+# CFLAGS += -D__USE_MINGW_ACCESS
 # Increase stack limit to a figure based on the Linux default, with 4MB added
 # as GCC turns out to need that much more to pass all the limits-* tests.
 LDFLAGS += -Wl,--stack,12582912
diff -ru ./config/stdint.m4 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/config/stdint.m4
--- ./config/stdint.m4	2014-06-06 11:50:13.087598508 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/config/stdint.m4	2012-03-29 17:53:53.000000000 +1000
@@ -129,19 +129,19 @@
 
 # Lacking an uintptr_t?  Test size of void *
 case "$acx_cv_header_stdint:$ac_cv_type_uintptr_t" in
-  stddef.h:* | *:no) AC_CHECK_SIZEOF(void *) ;;
+  stddef.h:* | *:no) AC_CHECK_SIZEOF(void *,,/* no standard headers */) ;;
 esac
 
 # Lacking an uint64_t?  Test size of long
 case "$acx_cv_header_stdint:$ac_cv_type_uint64_t:$ac_cv_type_u_int64_t" in
-  stddef.h:*:* | *:no:no) AC_CHECK_SIZEOF(long) ;;
+  stddef.h:*:* | *:no:no) AC_CHECK_SIZEOF(long,,/* no standard headers */) ;;
 esac
 
 if test $acx_cv_header_stdint = stddef.h; then
   # Lacking a good header?  Test size of everything and deduce all types.
-  AC_CHECK_SIZEOF(int)
-  AC_CHECK_SIZEOF(short)
-  AC_CHECK_SIZEOF(char)
+  AC_CHECK_SIZEOF(int,,/* no standard headers */)
+  AC_CHECK_SIZEOF(short,,/* no standard headers */)
+  AC_CHECK_SIZEOF(char,,/* no standard headers */)
 
   AC_MSG_CHECKING(for type equivalent to int8_t)
   case "$ac_cv_sizeof_char" in
diff -ru ./configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/configure
--- ./configure	2014-06-06 11:50:13.111598508 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/configure	2012-03-29 18:03:38.000000000 +1000
@@ -3180,7 +3180,7 @@
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
@@ -3241,6 +3241,10 @@
     esac
     libgloss_dir=arm
     ;;
+  arm*-*-nucleuseabi)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    libgloss_dir=arm
+    ;;
   arm*-*-symbianelf*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     libgloss_dir=arm
diff -ru ./configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/configure.ac
--- ./configure.ac	2014-06-06 11:50:13.111598508 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/configure.ac	2012-03-29 18:03:38.000000000 +1000
@@ -626,7 +626,7 @@
     noconfigdirs="$noconfigdirs target-newlib target-libgloss target-rda ${libgcj}"
     ;;
   *-*-vxworks*)
-    noconfigdirs="$noconfigdirs target-newlib target-libgloss target-libstdc++-v3 ${libgcj}"
+    noconfigdirs="$noconfigdirs target-newlib target-libgloss ${libgcj}"
     ;;
   alpha*-dec-osf*)
     # ld works, but does not support shared libraries.
@@ -687,6 +687,10 @@
     esac
     libgloss_dir=arm
     ;;
+  arm*-*-nucleuseabi)
+    noconfigdirs="$noconfigdirs ${libgcj}"
+    libgloss_dir=arm
+    ;;
   arm*-*-symbianelf*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     libgloss_dir=arm
diff -ru ./fixincludes/fixincl.tpl /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/fixincl.tpl
--- ./fixincludes/fixincl.tpl	2014-06-06 11:50:13.147598510 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/fixincl.tpl	2012-03-29 18:03:38.000000000 +1000
@@ -38,7 +38,7 @@
 #ifndef SED_PROGRAM
 #define SED_PROGRAM "/usr/bin/sed"
 #endif
-static char const sed_cmd_z[] = SED_PROGRAM;
+static char const sed_cmd_z[] = "sed";
 [=
 
 FOR fix =]
diff -ru ./fixincludes/fixincl.x /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/fixincl.x
--- ./fixincludes/fixincl.x	2014-06-06 11:50:13.155598510 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/fixincl.x	2012-03-29 18:03:38.000000000 +1000
@@ -2,11 +2,11 @@
  * 
  * DO NOT EDIT THIS FILE   (fixincl.x)
  * 
- * It has been AutoGen-ed  Monday November  8, 2010 at 08:33:47 PM MET
+ * It has been AutoGen-ed  Thursday July  7, 2011 at 04:49:46 AM PDT
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Mon Nov  8 20:33:47 MET 2010
+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Jul  7 04:49:46 PDT 2011
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -39,7 +39,7 @@
 #ifndef SED_PROGRAM
 #define SED_PROGRAM "/usr/bin/sed"
 #endif
-static char const sed_cmd_z[] = SED_PROGRAM;
+static char const sed_cmd_z[] = "sed";
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
@@ -6620,8 +6620,7 @@
  *  Machine/OS name selection pattern
  */
 tSCC* apzSolaris_Mutex_Init_2Machs[] = {
-        "*-*-solaris2.[0-9]",
-        "*-*-solaris2.[0-9][!0-9]*",
+        "*-*-solaris*",
         (const char*)NULL };
 
 /*
@@ -6630,8 +6629,15 @@
 tSCC zSolaris_Mutex_Init_2Select0[] =
        "@\\(#\\)pthread.h[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
 
-#define    SOLARIS_MUTEX_INIT_2_TEST_CT  1
+/*
+ *  perform the 'test' shell command - do fix on success
+ */
+tSCC zSolaris_Mutex_Init_2Test0[] =
+       " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
+
+#define    SOLARIS_MUTEX_INIT_2_TEST_CT  2
 static tTestDesc aSolaris_Mutex_Init_2Tests[] = {
+  { TT_TEST,     zSolaris_Mutex_Init_2Test0,   0 /* unused */ },
   { TT_EGREP,    zSolaris_Mutex_Init_2Select0, (regex_t*)NULL }, };
 
 /*
@@ -6673,8 +6679,15 @@
 tSCC zSolaris_Rwlock_Init_1Select0[] =
        "@\\(#\\)pthread.h[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
 
-#define    SOLARIS_RWLOCK_INIT_1_TEST_CT  1
+/*
+ *  perform the 'test' shell command - do fix on success
+ */
+tSCC zSolaris_Rwlock_Init_1Test0[] =
+       " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
+
+#define    SOLARIS_RWLOCK_INIT_1_TEST_CT  2
 static tTestDesc aSolaris_Rwlock_Init_1Tests[] = {
+  { TT_TEST,     zSolaris_Rwlock_Init_1Test0,   0 /* unused */ },
   { TT_EGREP,    zSolaris_Rwlock_Init_1Select0, (regex_t*)NULL }, };
 
 /*
@@ -6744,8 +6757,7 @@
  *  Machine/OS name selection pattern
  */
 tSCC* apzSolaris_Once_Init_2Machs[] = {
-        "*-*-solaris2.[0-9]",
-        "*-*-solaris2.[0-9][!0-9]*",
+        "*-*-solaris*",
         (const char*)NULL };
 
 /*
@@ -6754,8 +6766,15 @@
 tSCC zSolaris_Once_Init_2Select0[] =
        "@\\(#\\)pthread.h[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
 
-#define    SOLARIS_ONCE_INIT_2_TEST_CT  1
+/*
+ *  perform the 'test' shell command - do fix on success
+ */
+tSCC zSolaris_Once_Init_2Test0[] =
+       " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
+
+#define    SOLARIS_ONCE_INIT_2_TEST_CT  2
 static tTestDesc aSolaris_Once_Init_2Tests[] = {
+  { TT_TEST,     zSolaris_Once_Init_2Test0,   0 /* unused */ },
   { TT_EGREP,    zSolaris_Once_Init_2Select0, (regex_t*)NULL }, };
 
 /*
@@ -8553,7 +8572,7 @@
  *  List of all fixes
  */
 #define REGEX_COUNT          249
-#define MACH_LIST_SIZE_LIMIT 181
+#define MACH_LIST_SIZE_LIMIT 169
 #define FIX_COUNT            210
 
 /*
diff -ru ./fixincludes/inclhack.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/inclhack.def
--- ./fixincludes/inclhack.def	2014-06-06 11:50:13.159598510 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/inclhack.def	2012-03-29 18:03:38.000000000 +1000
@@ -3478,24 +3478,32 @@
 };
 
 /*
- * Sun Solaris defines PTHREAD_MUTEX_INITIALIZER with a trailing
- * "0" for the last field of the pthread_mutex_t structure, which is
- * of type upad64_t, which itself is typedef'd to int64_t, but with
- * __STDC__ defined (e.g. by -ansi) it is a union. So change the
- * initializer to "{0}" instead
+ * Sun Solaris defines the last field of the pthread_mutex_t structure
+ * to have type upad64_t.  Whether upad64_t is an integer type or a
+ * union depends on whether or not the headers believe that a 64-bit
+ * integer type is available.  But, PTHREAD_MUTEX_INITIALIZER is not
+ * appropriately conditionalized; it always uses "0", and never "{0}".
+ * In order to avoid warnings/errors from the compiler, we must make
+ * the initializer use braces where appropriate.
+ *
+ * Prior to Solaris 10, if __STDC__ is 1 (as when compiling with
+ * -ansi), the definition would be a union.  Beginning with Solaris
+ * 10, the headers check for __GNUC__, and will never use a union with
+ * GCC.  We check /usr/include/sys/types.h to see if it checks for
+ * __STDC__.
+ *
+ * A "mach" test for Solaris 10 is undesirable because we want to
+ * allow a compiler built for Solaris <10 to be used on Solaris >=10,
+ * but the installed version of fixincludes hard-wires the target
+ * machine to the configure-time $target, rather than automatically
+ * determining it at installation time.
  */
 fix = {
     hackname = solaris_mutex_init_2;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
-    /*
-     * On Solaris 10, this fix is unnecessary because upad64_t is
-     * always defined correctly regardless of the definition of the
-     * __STDC__ macro.  The first "mach" pattern matches up to
-     * solaris9.  The second "mach" pattern will not match any two (or
-     * more) digit solaris version, but it will match e.g. 2.5.1.
-     */
-    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
+    mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
@@ -3506,6 +3514,7 @@
                 "(|/\*.*\*/[ \t]*\\\\\n[ \t]*)\\{.*)"
                 ",[ \t]*0\\}" "(|[ \t].*)$";
     test_text =
+    "`mkdir -p sys; echo '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' >> sys/types.h`"
     '#ident "@(#)pthread.h  1.26  98/04/12 SMI"'"\n"
     "#define PTHREAD_MUTEX_INITIALIZER\t{{{0},0}, {{{0}}}, 0}\n"
     "#define PTHREAD_COND_INITIALIZER\t{{{0}, 0}, 0}\t/* DEFAULTCV */\n"
@@ -3517,17 +3526,14 @@
 
 
 /*
- * Sun Solaris defines PTHREAD_RWLOCK_INITIALIZER with a "0" for some
- *  fields of the pthread_rwlock_t structure, which are of type
- *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
- *  defined (e.g. by -ansi) it is a union. So change the initializer
- *  to "{0}" instead.
+ * See comments for solaris_mutex_init_2 re. upad64_t.
  */
 fix = {
     hackname = solaris_rwlock_init_1;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
     mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
@@ -3563,24 +3569,14 @@
 
 
 /*
- * Sun Solaris defines PTHREAD_ONCE_INIT with a "0" for some
- *  fields of the pthread_once_t structure, which are of type
- *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
- *  defined (e.g. by -ansi) it is a union. So change the initializer
- *  to "{0}" instead.  This test relies on solaris_once_init_1.
+ * See comments for solaris_mutex_init_2 re. upad64_t.
  */
 fix = {
     hackname = solaris_once_init_2;
     select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
     files = pthread.h;
-    /*
-     * On Solaris 10, this fix is unnecessary because upad64_t is
-     * always defined correctly regardless of the definition of the
-     * __STDC__ macro.  The first "mach" pattern matches up to
-     * solaris9.  The second "mach" pattern will not match any two (or
-     * more) digit solaris version, but it will match e.g. 2.5.1.
-     */
-    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
+    mach = '*-*-solaris*';
+    test = " -n \"`grep '#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)' \\`dirname $file\\`/sys/types.h`\"";
     c_fix = format;
     c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                 "%0\n"
diff -ru ./fixincludes/tests/base/sys/types.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/tests/base/sys/types.h
--- ./fixincludes/tests/base/sys/types.h	2014-06-06 11:50:13.167598511 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/fixincludes/tests/base/sys/types.h	2012-03-29 18:03:37.000000000 +1000
@@ -28,3 +28,4 @@
 
 #endif /* ushort_t */
 #endif  /* GNU_TYPES_CHECK */
+#if  !defined(__STRICT_ANSI__) && !defined(_NO_LONGLONG)
diff -ru ./gcc/acinclude.m4 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/acinclude.m4
--- ./gcc/acinclude.m4	2014-06-06 11:50:13.363598518 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/acinclude.m4	2012-03-29 18:03:19.000000000 +1000
@@ -521,3 +521,53 @@
 AC_DEFUN([gcc_AC_BUILD_EXEEXT], [
 ac_executable_extensions="$build_exeext"])
 
+
+# --with-license=PATH
+AC_DEFUN([CSL_AC_LICENSE],[
+  AC_ARG_WITH(license,
+    AC_HELP_STRING([--with-license],
+                   [the path to the installed license component]),
+    [case "$withval" in
+     (yes) AC_MSG_ERROR([license not specified]) ;;
+     (no)  with_license= ;;
+     (*) ;;
+  esac],
+  [with_license=])
+  AC_SUBST(licensedir, $with_license)
+])
+
+# --with-csl-license-feature=FOO
+AC_DEFUN([CSL_AC_LICENSE_FEATURE],[
+  AC_ARG_WITH(csl-license-feature,
+    AC_HELP_STRING([--with-csl-license-feature=FEATURE],
+                   [Use FEATURE to communicate with the license manager]),
+    [case "$withval" in
+      (yes) AC_MSG_ERROR([license feature not specified]) ;;
+      (no)  CSL_LICENSE_FEATURE="" ;; 
+      (*)   CSL_LICENSE_FEATURE="$withval" ;;
+     esac],
+     CSL_LICENSE_FEATURE=""
+  )
+  if test x"$CSL_LICENSE_FEATURE" != x; then
+    AC_DEFINE_UNQUOTED(CSL_LICENSE_FEATURE, "$CSL_LICENSE_FEATURE",
+                       [Required license feature])
+  fi
+])
+
+# --with-csl-license-version=VERSION
+AC_DEFUN([CSL_AC_LICENSE_VERSION],[
+  AC_ARG_WITH(csl-license-version,
+    AC_HELP_STRING([--with-csl-license-version=VERSION],
+                   [Use VERSION to communicate with the license manager]),
+    [case "$withval" in
+      (yes) AC_MSG_ERROR([license version not specified]) ;;
+      (no)  CSL_LICENSE_VERSION="" ;; 
+      (*)   CSL_LICENSE_VERSION="$withval" ;;
+     esac],
+     CSL_LICENSE_VERSION=""
+  )
+  if test x"$CSL_LICENSE_VERSION" != x; then
+    AC_DEFINE_UNQUOTED(CSL_LICENSE_VERSION, "$CSL_LICENSE_VERSION",
+                       [Required license version])
+  fi
+])
diff -ru ./gcc/addresses.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/addresses.h
--- ./gcc/addresses.h	2014-06-06 11:50:14.187598549 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/addresses.h	2012-03-29 18:03:19.000000000 +1000
@@ -79,3 +79,42 @@
 
   return ok_for_base_p_1 (regno, mode, outer_code, index_code);
 }
+
+/* Wrapper function to unify target macros MODE_INDEX_REG_CLASS and
+   INDEX_REG_CLASS.  Arguments as for the MODE_INDEX_REG_CLASS macro.  */
+
+static inline enum reg_class
+index_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+#ifdef MODE_INDEX_REG_CLASS
+  return MODE_INDEX_REG_CLASS (mode);
+#else
+  return INDEX_REG_CLASS;
+#endif
+}
+
+/* Wrapper function to unify target macros REGNO_MODE_OK_FOR_INDEX_P
+   and REGNO_OK_FOR_INDEX_P.  Arguments as for the
+   REGNO_MODE_OK_FOR_INDEX_P macro.  */
+
+static inline bool
+ok_for_index_p_1 (unsigned regno, enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+#ifdef REGNO_MODE_OK_FOR_INDEX_P
+  return REGNO_MODE_OK_FOR_INDEX_P (regno, mode);
+#else
+  return REGNO_OK_FOR_INDEX_P (regno);
+#endif
+}
+
+/* Wrapper around ok_for_index_p_1, for use after register allocation is
+   complete.  Arguments as for the called function.  */
+
+static inline bool
+regno_ok_for_index_p (unsigned regno, enum machine_mode mode)
+{
+  if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)
+    regno = reg_renumber[regno];
+
+  return ok_for_index_p_1 (regno, mode);
+}
diff -ru ./gcc/attribs.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/attribs.c
--- ./gcc/attribs.c	2014-06-06 11:50:14.191598550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/attribs.c	2012-03-29 18:03:19.000000000 +1000
@@ -303,8 +303,9 @@
 
       if (spec == NULL)
 	{
-	  warning (OPT_Wattributes, "%qE attribute directive ignored",
-		   name);
+	  if (!(flags & (int) ATTR_FLAG_BUILT_IN))
+	    warning (OPT_Wattributes, "%qE attribute directive ignored",
+		     name);
 	  continue;
 	}
       else if (list_length (args) < spec->min_length
diff -ru ./gcc/basic-block.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/basic-block.h
--- ./gcc/basic-block.h	2014-06-06 11:50:14.191598550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/basic-block.h	2012-03-29 18:03:19.000000000 +1000
@@ -795,6 +795,7 @@
 
 /* In cfgrtl.c  */
 extern basic_block force_nonfallthru (edge);
+extern basic_block force_nonfallthru_and_redirect (edge, basic_block, rtx);
 extern rtx block_label (basic_block);
 extern bool purge_all_dead_edges (void);
 extern bool purge_dead_edges (basic_block);
diff -ru ./gcc/builtin-attrs.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/builtin-attrs.def
--- ./gcc/builtin-attrs.def	2014-06-06 11:50:14.199598550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/builtin-attrs.def	2012-03-29 18:03:19.000000000 +1000
@@ -59,6 +59,14 @@
 DEF_ATTR_FOR_INT (6)
 #undef DEF_ATTR_FOR_INT
 
+/* Construct a tree for a given string and a list containing it.  */
+#define DEF_ATTR_FOR_STRING(ENUM, VALUE)					\
+  DEF_ATTR_STRING (ATTR_##ENUM, VALUE)			\
+  DEF_ATTR_TREE_LIST (ATTR_LIST_##ENUM, ATTR_NULL,	\
+		      ATTR_##ENUM, ATTR_NULL)
+DEF_ATTR_FOR_STRING (STR1, "1")
+#undef DEF_ATTR_FOR_STRING
+
 /* Construct a tree for a list of two integers.  */
 #define DEF_LIST_INT_INT(VALUE1, VALUE2)				 \
   DEF_ATTR_TREE_LIST (ATTR_LIST_##VALUE1##_##VALUE2, ATTR_NULL,		 \
@@ -84,6 +92,7 @@
 DEF_ATTR_IDENT (ATTR_NORETURN, "noreturn")
 DEF_ATTR_IDENT (ATTR_NOTHROW, "nothrow")
 DEF_ATTR_IDENT (ATTR_LEAF, "leaf")
+DEF_ATTR_IDENT (ATTR_FNSPEC, "fn spec")
 DEF_ATTR_IDENT (ATTR_PRINTF, "printf")
 DEF_ATTR_IDENT (ATTR_ASM_FPRINTF, "asm_fprintf")
 DEF_ATTR_IDENT (ATTR_GCC_DIAG, "gcc_diag")
@@ -167,6 +176,10 @@
 /* Nothrow const functions whose pointer parameter(s) are all nonnull.  */
 DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL, ATTR_CONST, ATTR_NULL, \
 			ATTR_NOTHROW_NONNULL)
+/* Nothrow leaf functions whose pointer parameter(s) are all nonnull,
+   and which return their first argument.  */
+DEF_ATTR_TREE_LIST (ATTR_RET1_NOTHROW_NONNULL_LEAF, ATTR_FNSPEC, ATTR_LIST_STR1, \
+			ATTR_NOTHROW_NONNULL_LEAF)
 /* Nothrow const leaf functions whose pointer parameter(s) are all nonnull.  */
 DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL_LEAF, ATTR_CONST, ATTR_NULL, \
 			ATTR_NOTHROW_NONNULL_LEAF)
diff -ru ./gcc/builtins.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/builtins.c
--- ./gcc/builtins.c	2014-06-06 14:25:27.222150542 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/builtins.c	2012-03-29 18:03:19.000000000 +1000
@@ -13894,6 +13894,7 @@
       case BUILT_IN_ISUNORDERED:
       case BUILT_IN_VA_ARG_PACK:
       case BUILT_IN_VA_ARG_PACK_LEN:
+      case BUILT_IN_VA_START:
       case BUILT_IN_VA_COPY:
       case BUILT_IN_TRAP:
       case BUILT_IN_SAVEREGS:
diff -ru ./gcc/builtins.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/builtins.def
--- ./gcc/builtins.def	2014-06-06 11:50:14.211598550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/builtins.def	2012-03-29 18:03:19.000000000 +1000
@@ -510,8 +510,8 @@
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_INDEX, "index", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)
 DEF_LIB_BUILTIN        (BUILT_IN_MEMCHR, "memchr", BT_FN_PTR_CONST_PTR_INT_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)
 DEF_LIB_BUILTIN        (BUILT_IN_MEMCMP, "memcmp", BT_FN_INT_CONST_PTR_CONST_PTR_SIZE, ATTR_PURE_NOTHROW_NONNULL_LEAF)
-DEF_LIB_BUILTIN        (BUILT_IN_MEMCPY, "memcpy", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
-DEF_LIB_BUILTIN        (BUILT_IN_MEMMOVE, "memmove", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
+DEF_LIB_BUILTIN        (BUILT_IN_MEMCPY, "memcpy", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)
+DEF_LIB_BUILTIN        (BUILT_IN_MEMMOVE, "memmove", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY, "mempcpy", BT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
 DEF_LIB_BUILTIN        (BUILT_IN_MEMSET, "memset", BT_FN_PTR_PTR_INT_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_RINDEX, "rindex", BT_FN_STRING_CONST_STRING_INT, ATTR_PURE_NOTHROW_NONNULL_LEAF)
@@ -724,8 +724,8 @@
 
 /* Object size checking builtins.  */
 DEF_GCC_BUILTIN	       (BUILT_IN_OBJECT_SIZE, "object_size", BT_FN_SIZE_CONST_PTR_INT, ATTR_PURE_NOTHROW_LEAF_LIST)
-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, "__memcpy_chk", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
-DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, "__memmove_chk", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, "__memcpy_chk", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)
+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, "__memmove_chk", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY_CHK, "__mempcpy_chk", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMSET_CHK, "__memset_chk", BT_FN_PTR_PTR_INT_SIZE_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
 DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY_CHK, "__stpcpy_chk", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL_LEAF)
@@ -748,6 +748,13 @@
 DEF_BUILTIN (BUILT_IN_PROFILE_FUNC_EXIT, "__cyg_profile_func_exit", BUILT_IN_NORMAL, BT_FN_VOID_PTR_PTR, BT_LAST,
 	     false, false, false, ATTR_NULL, true, true)
 
+DEF_BUILTIN (BUILT_IN_PROFILE_CALL_ENTER, "__cyg_profile_call_enter", BUILT_IN_NORMAL, BT_FN_VOID_PTR, BT_LAST,
+	     false, false, false, ATTR_NULL, true, true)
+DEF_BUILTIN (BUILT_IN_PROFILE_CALL_INSIDE, "__cyg_profile_call_inside", BUILT_IN_NORMAL, BT_FN_VOID_PTR, BT_LAST,
+	     false, false, false, ATTR_NULL, true, true)
+DEF_BUILTIN (BUILT_IN_PROFILE_CALL_EXIT, "__cyg_profile_call_exit", BUILT_IN_NORMAL, BT_FN_VOID_PTR, BT_LAST,
+	     false, false, false, ATTR_NULL, true, true)
+
 /* TLS emulation.  */
 DEF_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, targetm.emutls.get_address,
 	     BUILT_IN_NORMAL,
diff -ru ./gcc/caller-save.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/caller-save.c
--- ./gcc/caller-save.c	2014-06-06 11:50:14.267598552 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/caller-save.c	2012-03-29 18:03:19.000000000 +1000
@@ -441,7 +441,7 @@
       freq = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn));
       REG_SET_TO_HARD_REG_SET (hard_regs_to_save,
 			       &chain->live_throughout);
-      COPY_HARD_REG_SET (used_regs, call_used_reg_set);
+      get_call_reg_set_usage (insn, &used_regs, call_used_reg_set);
 
       /* Record all registers set in this call insn.  These don't
 	 need to be saved.  N.B. the call insn might set a subreg
@@ -516,7 +516,7 @@
 	    continue;
 	  REG_SET_TO_HARD_REG_SET (hard_regs_to_save,
 				   &chain->live_throughout);
-	  COPY_HARD_REG_SET (used_regs, call_used_reg_set);
+	  get_call_reg_set_usage (insn, &used_regs, call_used_reg_set);
 
 	  /* Record all registers set in this call insn.  These don't
 	     need to be saved.  N.B. the call insn might set a subreg
@@ -795,6 +795,7 @@
 	    {
 	      unsigned regno;
 	      HARD_REG_SET hard_regs_to_save;
+	      HARD_REG_SET call_def_reg_set;
 	      reg_set_iterator rsi;
 
 	      /* Use the register life information in CHAIN to compute which
@@ -840,7 +841,9 @@
 	      AND_COMPL_HARD_REG_SET (hard_regs_to_save, call_fixed_reg_set);
 	      AND_COMPL_HARD_REG_SET (hard_regs_to_save, this_insn_sets);
 	      AND_COMPL_HARD_REG_SET (hard_regs_to_save, hard_regs_saved);
-	      AND_HARD_REG_SET (hard_regs_to_save, call_used_reg_set);
+	      get_call_reg_set_usage (insn, &call_def_reg_set,
+				      call_used_reg_set);
+	      AND_HARD_REG_SET (hard_regs_to_save, call_def_reg_set);
 
 	      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
 		if (TEST_HARD_REG_BIT (hard_regs_to_save, regno))
diff -ru ./gcc/calls.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/calls.c
--- ./gcc/calls.c	2014-06-06 11:50:14.271598553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/calls.c	2012-03-29 18:03:19.000000000 +1000
@@ -543,6 +543,41 @@
   return flags;
 }
 
+/* Similar to special_function_p; return a set of ERF_ flags for the
+   function FNDECL.  */
+static int
+decl_return_flags (tree fndecl)
+{
+  tree attr;
+  tree type = TREE_TYPE (fndecl);
+  if (!type)
+    return 0;
+
+  attr = lookup_attribute ("fn spec", TYPE_ATTRIBUTES (type));
+  if (!attr)
+    return 0;
+
+  attr = TREE_VALUE (TREE_VALUE (attr));
+  if (!attr || TREE_STRING_LENGTH (attr) < 1)
+    return 0;
+
+  switch (TREE_STRING_POINTER (attr)[0])
+    {
+    case '1':
+    case '2':
+    case '3':
+    case '4':
+      return ERF_RETURNS_ARG | (TREE_STRING_POINTER (attr)[0] - '1');
+
+    case 'm':
+      return ERF_NOALIAS;
+
+    case '.':
+    default:
+      return 0;
+    }
+}
+
 /* Return nonzero when FNDECL represents a call to setjmp.  */
 
 int
@@ -715,7 +750,9 @@
 
 	   For small register classes, also do this if this call uses
 	   register parameters.  This is to avoid reload conflicts while
-	   loading the parameters registers.  */
+	   loading the parameters registers.
+	   
+	   Avoid creating the extra move if optimizing for size.  */
 
 	else if ((! (REG_P (args[i].value)
 		     || (GET_CODE (args[i].value) == SUBREG
@@ -723,6 +760,7 @@
 		 && args[i].mode != BLKmode
 		 && rtx_cost (args[i].value, SET, optimize_insn_for_speed_p ())
 		    > COSTS_N_INSNS (1)
+		 && !optimize_size
 		 && ((*reg_parm_seen
 		      && targetm.small_register_classes_for_mode_p (args[i].mode))
 		     || optimize))
@@ -905,8 +943,8 @@
 	    emit_move_insn (reg, const0_rtx);
 
 	    bytes -= bitsize / BITS_PER_UNIT;
-	    store_bit_field (reg, bitsize, endian_correction, word_mode,
-			     word);
+	    store_bit_field (reg, bitsize, endian_correction, false,
+			     word_mode, word);
 	  }
       }
 }
@@ -2137,8 +2175,9 @@
      (on machines that lack push insns), or 0 if space not preallocated.  */
   rtx argblock = 0;
 
-  /* Mask of ECF_ flags.  */
+  /* Mask of ECF_ and ERF_ flags.  */
   int flags = 0;
+  int return_flags = 0;
 #ifdef REG_PARM_STACK_SPACE
   /* Define the boundary of the register parm stack space that needs to be
      saved, if any.  */
@@ -2183,6 +2222,7 @@
     {
       fntype = TREE_TYPE (fndecl);
       flags |= flags_from_decl_or_type (fndecl);
+      return_flags |= decl_return_flags (fndecl);
     }
   else
     {
@@ -2998,6 +3038,20 @@
 						   VOIDmode, void_type_node,
 						   true);
 
+      if (pass == 1 && (return_flags & ERF_RETURNS_ARG))
+	{
+	  int arg_nr = return_flags & ERF_RETURN_ARG_MASK;
+	  if (PUSH_ARGS_REVERSED)
+	    arg_nr = num_actuals - arg_nr - 1;
+	  if (args[arg_nr].reg
+	      && valreg
+	      && REG_P (valreg)
+	      && GET_MODE (args[arg_nr].reg) == GET_MODE (valreg))
+	  call_fusage
+	    = gen_rtx_EXPR_LIST (TYPE_MODE (TREE_TYPE (args[arg_nr].tree_value)),
+				 gen_rtx_SET (VOIDmode, valreg, args[arg_nr].reg),
+				 call_fusage);
+	}
       /* All arguments and registers used for the call must be set up by
 	 now!  */
 
@@ -3611,6 +3665,7 @@
     {
       rtx val = va_arg (p, rtx);
       enum machine_mode mode = (enum machine_mode) va_arg (p, int);
+      int unsigned_p = 0;
 
       /* We cannot convert the arg value to the mode the library wants here;
 	 must do it earlier where we know the signedness of the arg.  */
@@ -3658,29 +3713,38 @@
 	  val = force_operand (XEXP (slot, 0), NULL_RTX);
 	}
 
-      argvec[count].value = val;
+      mode = promote_function_mode (NULL_TREE, mode, &unsigned_p, NULL_TREE, 0);
       argvec[count].mode = mode;
-
+      argvec[count].value = convert_modes (mode, GET_MODE (val), val, unsigned_p);
       argvec[count].reg = targetm.calls.function_arg (&args_so_far, mode,
 						      NULL_TREE, true);
 
       argvec[count].partial
 	= targetm.calls.arg_partial_bytes (&args_so_far, mode, NULL_TREE, 1);
 
-      locate_and_pad_parm (mode, NULL_TREE,
+      if (argvec[count].reg == 0
+	  || argvec[count].partial != 0
+	  || reg_parm_stack_space > 0)
+	{
+	  locate_and_pad_parm (mode, NULL_TREE,
 #ifdef STACK_PARMS_IN_REG_PARM_AREA
-			   1,
+			       1,
 #else
-			   argvec[count].reg != 0,
+			       argvec[count].reg != 0,
+#endif
+			       argvec[count].partial,
+			       NULL_TREE, &args_size, &argvec[count].locate);
+	  args_size.constant += argvec[count].locate.size.constant;
+	  gcc_assert (!argvec[count].locate.size.var);
+	}
+#ifdef BLOCK_REG_PADDING
+      else
+	/* The argument is passed entirely in registers.  See at which
+	   end it should be padded.  */
+	argvec[count].locate.where_pad =
+	  BLOCK_REG_PADDING (mode, NULL_TREE,
+			     GET_MODE_SIZE (mode) <= UNITS_PER_WORD);
 #endif
-			   argvec[count].partial,
-			   NULL_TREE, &args_size, &argvec[count].locate);
-
-      gcc_assert (!argvec[count].locate.size.var);
-
-      if (argvec[count].reg == 0 || argvec[count].partial != 0
-	  || reg_parm_stack_space > 0)
-	args_size.constant += argvec[count].locate.size.constant;
 
       targetm.calls.function_arg_advance (&args_so_far, mode, (tree) 0, true);
     }
@@ -3931,13 +3995,44 @@
       rtx val = argvec[argnum].value;
       rtx reg = argvec[argnum].reg;
       int partial = argvec[argnum].partial;
-
+#ifdef BLOCK_REG_PADDING
+      int size = 0;
+#endif
+      
       /* Handle calls that pass values in multiple non-contiguous
 	 locations.  The PA64 has examples of this for library calls.  */
       if (reg != 0 && GET_CODE (reg) == PARALLEL)
 	emit_group_load (reg, val, NULL_TREE, GET_MODE_SIZE (mode));
       else if (reg != 0 && partial == 0)
-	emit_move_insn (reg, val);
+        {
+	  emit_move_insn (reg, val);
+#ifdef BLOCK_REG_PADDING
+	  size = GET_MODE_SIZE (argvec[argnum].mode);
+
+	  /* Copied from load_register_parameters.  */
+
+	  /* Handle case where we have a value that needs shifting
+	     up to the msb.  eg. a QImode value and we're padding
+	     upward on a BYTES_BIG_ENDIAN machine.  */
+	  if (size < UNITS_PER_WORD
+	      && (argvec[argnum].locate.where_pad
+		  == (BYTES_BIG_ENDIAN ? upward : downward)))
+	    {
+	      rtx x;
+	      int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;
+
+	      /* Assigning REG here rather than a temp makes CALL_FUSAGE
+		 report the whole reg as used.  Strictly speaking, the
+		 call only uses SIZE bytes at the msb end, but it doesn't
+		 seem worth generating rtl to say that.  */
+	      reg = gen_rtx_REG (word_mode, REGNO (reg));
+	      x = expand_shift (LSHIFT_EXPR, word_mode, reg,
+				build_int_cst (NULL_TREE, shift), reg, 1);
+	      if (x != reg)
+		emit_move_insn (reg, x);
+	    }
+#endif
+	}
 
       NO_DEFER_POP;
     }
@@ -4003,6 +4098,15 @@
 	       valreg,
 	       old_inhibit_defer_pop + 1, call_fusage, flags, & args_so_far);
 
+  /* Right-shift returned value if necessary.  */
+  if (!pcc_struct_value
+      && TYPE_MODE (tfom) != BLKmode
+      && targetm.calls.return_in_msb (tfom))
+    {
+      shift_return_value (TYPE_MODE (tfom), false, valreg);
+      valreg = gen_rtx_REG (TYPE_MODE (tfom), REGNO (valreg));
+    }
+
   /* For calls to `setjmp', etc., inform function.c:setjmp_warnings
      that it should complain if nonvolatile values are live.  For
      functions that cannot return, inform flow that control does not
@@ -4223,8 +4327,17 @@
 	      /* We need to make a save area.  */
 	      unsigned int size = arg->locate.size.constant * BITS_PER_UNIT;
 	      enum machine_mode save_mode = mode_for_size (size, MODE_INT, 1);
-	      rtx adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));
-	      rtx stack_area = gen_rtx_MEM (save_mode, adr);
+	      rtx adr;
+	      rtx stack_area;
+
+	      /* We can only use save_mode if the arg is sufficiently
+	         aligned.  */
+	      if (STRICT_ALIGNMENT
+		  && GET_MODE_ALIGNMENT (save_mode) > arg->locate.boundary)
+		save_mode = BLKmode;
+
+	      adr = memory_address (save_mode, XEXP (arg->stack_slot, 0));
+	      stack_area = gen_rtx_MEM (save_mode, adr);
 
 	      if (save_mode == BLKmode)
 		{
diff -ru ./gcc/c-family/c-common.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/c-family/c-common.c
--- ./gcc/c-family/c-common.c	2014-06-06 11:50:14.235598551 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/c-family/c-common.c	2012-03-29 17:55:07.000000000 +1000
@@ -4348,11 +4348,13 @@
 {
 #define DEF_ATTR_NULL_TREE(ENUM) ENUM,
 #define DEF_ATTR_INT(ENUM, VALUE) ENUM,
+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,
 #define DEF_ATTR_IDENT(ENUM, STRING) ENUM,
 #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,
 #include "builtin-attrs.def"
 #undef DEF_ATTR_NULL_TREE
 #undef DEF_ATTR_INT
+#undef DEF_ATTR_STRING
 #undef DEF_ATTR_IDENT
 #undef DEF_ATTR_TREE_LIST
   ATTR_LAST
@@ -5677,6 +5679,8 @@
   built_in_attributes[(int) ENUM] = NULL_TREE;
 #define DEF_ATTR_INT(ENUM, VALUE)				\
   built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);
+#define DEF_ATTR_STRING(ENUM, VALUE)				\
+  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);
 #define DEF_ATTR_IDENT(ENUM, STRING)				\
   built_in_attributes[(int) ENUM] = get_identifier (STRING);
 #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)	\
diff -ru ./gcc/c-family/c.opt /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/c-family/c.opt
--- ./gcc/c-family/c.opt	2014-06-06 11:50:14.247598552 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/c-family/c.opt	2012-03-29 17:55:07.000000000 +1000
@@ -929,6 +929,10 @@
 C++ ObjC++ Var(flag_pretty_templates) Init(1)
 -fno-pretty-templates Do not pretty-print template specializations as the template signature followed by the arguments
 
+fremove-local-statics
+C C++ Var(flag_remove_local_statics) Optimization
+Convert function-local static variables to automatic variables when it is safe to do so
+
 freplace-objc-classes
 ObjC ObjC++ Var(flag_replace_objc_classes)
 Used in Fix-and-Continue mode to indicate that object files may be swapped in at runtime
diff -ru ./gcc/c-family/c-pch.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/c-family/c-pch.c
--- ./gcc/c-family/c-pch.c	2014-06-06 11:50:14.243598552 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/c-family/c-pch.c	2012-03-29 17:55:07.000000000 +1000
@@ -180,6 +180,8 @@
 
   timevar_push (TV_PCH_SAVE);
 
+  targetm.prepare_pch_save ();
+
   (*debug_hooks->handle_pch) (1);
 
   cpp_write_pch_deps (parse_in, pch_outfile);
diff -ru ./gcc/cfgexpand.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cfgexpand.c
--- ./gcc/cfgexpand.c	2014-06-06 11:50:14.279598553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cfgexpand.c	2012-03-29 18:03:19.000000000 +1000
@@ -212,6 +212,9 @@
 get_decl_align_unit (tree decl)
 {
   unsigned int align = LOCAL_DECL_ALIGNMENT (decl);
+
+  align = alignment_for_aligned_arrays (TREE_TYPE (decl), align);
+  
   return align / BITS_PER_UNIT;
 }
 
@@ -372,8 +375,9 @@
 		 to elements will conflict.  In case of unions we have
 		 to be careful as type based aliasing rules may say
 		 access to the same memory does not conflict.  So play
-		 safe and add a conflict in this case.  */
-	      || contains_union)
+		 safe and add a conflict in this case when
+                 -fstrict-aliasing is used.  */
+              || (contains_union && flag_strict_aliasing))
 	    add_stack_var_conflict (i, j);
 	}
     }
diff -ru ./gcc/cfglayout.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cfglayout.c
--- ./gcc/cfglayout.c	2014-06-06 11:50:14.283598553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cfglayout.c	2012-03-29 18:03:19.000000000 +1000
@@ -609,8 +609,14 @@
 
 	  this_block = NULL;
 	  for (i = 0; i < XVECLEN (body, 0); i++)
-	    this_block = choose_inner_scope (this_block,
-					 insn_scope (XVECEXP (body, 0, i)));
+	    {
+	      rtx subinsn = XVECEXP (body, 0, i);
+	      if (LABEL_P (subinsn) || DELETED_NOTE_P (subinsn))
+		continue;
+
+	      this_block
+		= choose_inner_scope (this_block, insn_scope (subinsn));
+	    }
 	}
       if (! this_block)
 	continue;
@@ -767,6 +773,7 @@
     {
       edge e_fall, e_taken, e;
       rtx bb_end_insn;
+      rtx ret_label = NULL_RTX;
       basic_block nb;
       edge_iterator ei;
 
@@ -786,6 +793,7 @@
       bb_end_insn = BB_END (bb);
       if (JUMP_P (bb_end_insn))
 	{
+	  ret_label = JUMP_LABEL (bb_end_insn);
 	  if (any_condjump_p (bb_end_insn))
 	    {
 	      /* This might happen if the conditional jump has side
@@ -896,7 +904,7 @@
 	}
 
       /* We got here if we need to add a new jump insn.  */
-      nb = force_nonfallthru (e_fall);
+      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);
       if (nb)
 	{
 	  nb->il.rtl->visited = 1;
@@ -1130,24 +1138,30 @@
 bool
 cfg_layout_can_duplicate_bb_p (const_basic_block bb)
 {
+  rtx insn;
+
   /* Do not attempt to duplicate tablejumps, as we need to unshare
      the dispatch table.  This is difficult to do, as the instructions
      computing jump destination may be hoisted outside the basic block.  */
   if (tablejump_p (BB_END (bb), NULL, NULL))
     return false;
 
-  /* Do not duplicate blocks containing insns that can't be copied.  */
-  if (targetm.cannot_copy_insn_p)
+  insn = BB_HEAD (bb);
+  while (1)
     {
-      rtx insn = BB_HEAD (bb);
-      while (1)
-	{
-	  if (INSN_P (insn) && targetm.cannot_copy_insn_p (insn))
-	    return false;
-	  if (insn == BB_END (bb))
-	    break;
-	  insn = NEXT_INSN (insn);
-	}
+      /* Do not duplicate blocks containing insns that can't be copied.  */
+      if (INSN_P (insn) && targetm.cannot_copy_insn_p
+	  && targetm.cannot_copy_insn_p (insn))
+	return false;
+      /* dwarf2out expects that these notes are always paired with a
+	 returnjump or sibling call.  */
+      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG
+	  && !returnjump_p (BB_END (bb))
+	  && (!CALL_P (BB_END (bb)) || !SIBLING_CALL_P (BB_END (bb))))
+	return false;
+      if (insn == BB_END (bb))
+	break;
+      insn = NEXT_INSN (insn);
     }
 
   return true;
@@ -1192,6 +1206,9 @@
 	      break;
 	    }
 	  copy = emit_copy_of_insn_after (insn, get_last_insn ());
+	  if (JUMP_P (insn) && JUMP_LABEL (insn) != NULL_RTX
+	      && ANY_RETURN_P (JUMP_LABEL (insn)))
+	    JUMP_LABEL (copy) = JUMP_LABEL (insn);
           maybe_copy_prologue_epilogue_insn (insn, copy);
 	  break;
 
diff -ru ./gcc/cfgrtl.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cfgrtl.c
--- ./gcc/cfgrtl.c	2014-06-06 11:50:14.291598553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cfgrtl.c	2012-03-29 18:03:19.000000000 +1000
@@ -843,11 +843,10 @@
       if (dump_file)
 	fprintf (dump_file, "Redirecting jump %i from %i to %i.\n",
 		 INSN_UID (insn), e->dest->index, target->index);
-      if (!redirect_jump (insn, block_label (target), 0))
-	{
-	  gcc_assert (target == EXIT_BLOCK_PTR);
-	  return NULL;
-	}
+      if (target == EXIT_BLOCK_PTR)
+	return NULL;
+      if (! redirect_jump (insn, block_label (target), 0))
+	gcc_unreachable ();
     }
 
   /* Cannot do anything for target exit block.  */
@@ -1027,11 +1026,10 @@
 	  /* If the substitution doesn't succeed, die.  This can happen
 	     if the back end emitted unrecognizable instructions or if
 	     target is exit block on some arches.  */
-	  if (!redirect_jump (insn, block_label (new_bb), 0))
-	    {
-	      gcc_assert (new_bb == EXIT_BLOCK_PTR);
-	      return false;
-	    }
+	  if (new_bb == EXIT_BLOCK_PTR)
+	    return false;
+	  if (! redirect_jump (insn, block_label (new_bb), 0))
+	    gcc_unreachable ();
 	}
     }
   return true;
@@ -1114,10 +1112,13 @@
 }
 
 /* Like force_nonfallthru below, but additionally performs redirection
-   Used by redirect_edge_and_branch_force.  */
+   Used by redirect_edge_and_branch_force.  JUMP_LABEL is used only
+   when redirecting to the EXIT_BLOCK, it is either a return or a
+   simple_return rtx indicating which kind of returnjump to create.
+   It should be NULL otherwise.  */
 
-static basic_block
-force_nonfallthru_and_redirect (edge e, basic_block target)
+basic_block
+force_nonfallthru_and_redirect (edge e, basic_block target, rtx jump_label)
 {
   basic_block jump_block, new_bb = NULL, src = e->src;
   rtx note;
@@ -1284,11 +1285,25 @@
   e->flags &= ~EDGE_FALLTHRU;
   if (target == EXIT_BLOCK_PTR)
     {
+      if (jump_label == ret_rtx)
+	{
 #ifdef HAVE_return
-	emit_jump_insn_after_setloc (gen_return (), BB_END (jump_block), loc);
+	  emit_jump_insn_after_setloc (gen_return (), BB_END (jump_block),
+				       loc);
 #else
-	gcc_unreachable ();
+	  gcc_unreachable ();
+#endif
+	}
+      else
+	{
+	  gcc_assert (jump_label == simple_return_rtx);
+#ifdef HAVE_simple_return
+	  emit_jump_insn_after_setloc (gen_simple_return (),
+				       BB_END (jump_block), loc);
+#else
+	  gcc_unreachable ();
 #endif
+	}
     }
   else
     {
@@ -1315,7 +1330,7 @@
 basic_block
 force_nonfallthru (edge e)
 {
-  return force_nonfallthru_and_redirect (e, e->dest);
+  return force_nonfallthru_and_redirect (e, e->dest, NULL_RTX);
 }
 
 /* Redirect edge even at the expense of creating new jump insn or
@@ -1332,7 +1347,7 @@
   /* In case the edge redirection failed, try to force it to be non-fallthru
      and redirect newly created simplejump.  */
   df_set_bb_dirty (e->src);
-  return force_nonfallthru_and_redirect (e, target);
+  return force_nonfallthru_and_redirect (e, target, NULL_RTX);
 }
 
 /* The given edge should potentially be a fallthru edge.  If that is in
diff -ru ./gcc/cgraph.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cgraph.c
--- ./gcc/cgraph.c	2014-06-06 14:25:27.226150542 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cgraph.c	2012-03-29 18:03:19.000000000 +1000
@@ -515,8 +515,10 @@
   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)
     {
       node->origin = cgraph_node (DECL_CONTEXT (decl));
+      node->origin->ever_was_nested = 1;
       node->next_nested = node->origin->nested;
       node->origin->nested = node;
+      node->ever_was_nested = 1;
     }
   if (assembler_name_hash)
     {
diff -ru ./gcc/cgraph.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cgraph.h
--- ./gcc/cgraph.h	2014-06-06 14:25:27.230150543 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cgraph.h	2012-03-29 18:03:19.000000000 +1000
@@ -284,6 +284,8 @@
   unsigned process : 1;
   /* Set for aliases once they got through assemble_alias.  */
   unsigned alias : 1;
+  /* Set if the function is a nested function or has nested functions.  */
+  unsigned ever_was_nested : 1;
   /* Set for nodes that was constructed and finalized by frontend.  */
   unsigned finalized_by_frontend : 1;
   /* Set for alias and thunk nodes, same_body points to the node they are alias
diff -ru ./gcc/cgraphunit.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cgraphunit.c
--- ./gcc/cgraphunit.c	2014-06-06 14:25:27.230150543 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cgraphunit.c	2012-03-29 18:03:19.000000000 +1000
@@ -2067,6 +2067,10 @@
   SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));
   SET_DECL_RTL (new_decl, NULL);
 
+  /* When the old decl was a con-/destructor make sure the clone isn't.  */
+  DECL_STATIC_CONSTRUCTOR(new_decl) = 0;
+  DECL_STATIC_DESTRUCTOR(new_decl) = 0;
+
   /* Create the new version's call-graph node.
      and update the edges of the new node. */
   new_version_node =
diff -ru ./gcc/collect2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/collect2.c
--- ./gcc/collect2.c	2014-06-06 11:50:14.303598554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/collect2.c	2012-03-29 18:03:19.000000000 +1000
@@ -177,7 +177,6 @@
 bool vflag;				/* true if -v or --version */ 
 static int rflag;			/* true if -r */
 static int strip_flag;			/* true if -s */
-static const char *demangle_flag;
 #ifdef COLLECT_EXPORT_LIST
 static int export_flag;                 /* true if -bE */
 static int aix64_flag;			/* true if -b64 */
@@ -1159,10 +1158,12 @@
 
   num_c_args = argc + 9;
 
+#ifndef HAVE_LD_DEMANGLE
   no_demangle = !! getenv ("COLLECT_NO_DEMANGLE");
 
   /* Suppress demangling by the real linker, which may be broken.  */
-  putenv (xstrdup ("COLLECT_NO_DEMANGLE="));
+  putenv (xstrdup ("COLLECT_NO_DEMANGLE=1"));
+#endif
 
 #if defined (COLLECT2_HOST_INITIALIZATION)
   /* Perform system dependent initialization, if necessary.  */
@@ -1450,12 +1451,6 @@
   /* After the first file, put in the c++ rt0.  */
 
   first_file = 1;
-#ifdef HAVE_LD_DEMANGLE
-  if (!demangle_flag && !no_demangle)
-    demangle_flag = "--demangle";
-  if (demangle_flag)
-    *ld1++ = *ld2++ = demangle_flag;
-#endif
   while ((arg = *++argv) != (char *) 0)
     {
       *ld1++ = *ld2++ = arg;
@@ -1559,16 +1554,16 @@
 	    case '-':
 	      if (strcmp (arg, "--no-demangle") == 0)
 		{
-		  demangle_flag = arg;
+#ifndef HAVE_LD_DEMANGLE
 		  no_demangle = 1;
 		  ld1--;
 		  ld2--;
+#endif
 		}
 	      else if (strncmp (arg, "--demangle", 10) == 0)
 		{
-		  demangle_flag = arg;
-		  no_demangle = 0;
 #ifndef HAVE_LD_DEMANGLE
+		  no_demangle = 0;
 		  if (arg[10] == '=')
 		    {
 		      enum demangling_styles style
@@ -1578,9 +1573,9 @@
 		      else
 			current_demangling_style = style;
 		    }
-#endif
 		  ld1--;
 		  ld2--;
+#endif
 		}
 	      else if (strncmp (arg, "--sysroot=", 10) == 0)
 		target_system_root = arg + 10;
diff -ru ./gcc/combine.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/combine.c
--- ./gcc/combine.c	2014-06-06 14:25:27.238150543 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/combine.c	2012-03-29 18:03:19.000000000 +1000
@@ -391,8 +391,8 @@
 static void undo_all (void);
 static void undo_commit (void);
 static rtx *find_split_point (rtx *, rtx, bool);
-static rtx subst (rtx, rtx, rtx, int, int);
-static rtx combine_simplify_rtx (rtx, enum machine_mode, int);
+static rtx subst (rtx, rtx, rtx, int, int, int);
+static rtx combine_simplify_rtx (rtx, enum machine_mode, int, int);
 static rtx simplify_if_then_else (rtx);
 static rtx simplify_set (rtx);
 static rtx simplify_logical (rtx);
@@ -1788,6 +1788,10 @@
   if (set == 0)
     return 0;
 
+  /* The simplification in expand_field_assignment may call back to
+     get_last_value, so set safe guard here.  */
+  subst_low_luid = DF_INSN_LUID (insn);
+
   set = expand_field_assignment (set);
   src = SET_SRC (set), dest = SET_DEST (set);
 
@@ -3119,12 +3123,12 @@
 	  if (i1)
 	    {
 	      subst_low_luid = DF_INSN_LUID (i1);
-	      i1src = subst (i1src, pc_rtx, pc_rtx, 0, 0);
+	      i1src = subst (i1src, pc_rtx, pc_rtx, 0, 0, 0);
 	    }
 	  else
 	    {
 	      subst_low_luid = DF_INSN_LUID (i2);
-	      i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);
+	      i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0, 0);
 	    }
 	}
 
@@ -3136,7 +3140,7 @@
 	 self-referential RTL when we will be substituting I1SRC for I1DEST
 	 later.  Likewise if I0 feeds into I2, either directly or indirectly
 	 through I1, and I0DEST is in I0SRC.  */
-      newpat = subst (PATTERN (i3), i2dest, i2src, 0,
+      newpat = subst (PATTERN (i3), i2dest, i2src, 0, 0,
 		      (i1_feeds_i2_n && i1dest_in_i1src)
 		      || ((i0_feeds_i2_n || (i0_feeds_i1_n && i1_feeds_i2_n))
 			  && i0dest_in_i0src));
@@ -3180,7 +3184,7 @@
 	 copy of I1SRC each time we substitute it, in order to avoid creating
 	 self-referential RTL when we will be substituting I0SRC for I0DEST
 	 later.  */
-      newpat = subst (newpat, i1dest, i1src, 0,
+      newpat = subst (newpat, i1dest, i1src, 0, 0,
 		      i0_feeds_i1_n && i0dest_in_i0src);
       substed_i1 = 1;
 
@@ -3214,7 +3218,7 @@
 
       n_occurrences = 0;
       subst_low_luid = DF_INSN_LUID (i0);
-      newpat = subst (newpat, i0dest, i0src, 0, 0);
+      newpat = subst (newpat, i0dest, i0src, 0, 0, 0);
       substed_i0 = 1;
     }
 
@@ -3276,7 +3280,7 @@
 	{
 	  rtx t = i1pat;
 	  if (i0_feeds_i1_n)
-	    t = subst (t, i0dest, i0src_copy ? i0src_copy : i0src, 0, 0);
+	    t = subst (t, i0dest, i0src_copy ? i0src_copy : i0src, 0, 0, 0);
 
 	  XVECEXP (newpat, 0, --total_sets) = t;
 	}
@@ -3284,10 +3288,10 @@
 	{
 	  rtx t = i2pat;
 	  if (i1_feeds_i2_n)
-	    t = subst (t, i1dest, i1src_copy ? i1src_copy : i1src, 0,
+	    t = subst (t, i1dest, i1src_copy ? i1src_copy : i1src, 0, 0,
 		       i0_feeds_i1_n && i0dest_in_i0src);
 	  if ((i0_feeds_i1_n && i1_feeds_i2_n) || i0_feeds_i2_n)
-	    t = subst (t, i0dest, i0src_copy2 ? i0src_copy2 : i0src, 0, 0);
+	    t = subst (t, i0dest, i0src_copy2 ? i0src_copy2 : i0src, 0, 0, 0);
 
 	  XVECEXP (newpat, 0, --total_sets) = t;
 	}
@@ -4959,11 +4963,13 @@
 
    IN_DEST is nonzero if we are processing the SET_DEST of a SET.
 
+   IN_COND is nonzero if we are at the top level of a condition.
+
    UNIQUE_COPY is nonzero if each substitution must be unique.  We do this
    by copying if `n_occurrences' is nonzero.  */
 
 static rtx
-subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)
+subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)
 {
   enum rtx_code code = GET_CODE (x);
   enum machine_mode op0_mode = VOIDmode;
@@ -5024,7 +5030,7 @@
       && GET_CODE (XVECEXP (x, 0, 0)) == SET
       && GET_CODE (SET_SRC (XVECEXP (x, 0, 0))) == ASM_OPERANDS)
     {
-      new_rtx = subst (XVECEXP (x, 0, 0), from, to, 0, unique_copy);
+      new_rtx = subst (XVECEXP (x, 0, 0), from, to, 0, 0, unique_copy);
 
       /* If this substitution failed, this whole thing fails.  */
       if (GET_CODE (new_rtx) == CLOBBER
@@ -5041,7 +5047,7 @@
 	      && GET_CODE (dest) != CC0
 	      && GET_CODE (dest) != PC)
 	    {
-	      new_rtx = subst (dest, from, to, 0, unique_copy);
+	      new_rtx = subst (dest, from, to, 0, 0, unique_copy);
 
 	      /* If this substitution failed, this whole thing fails.  */
 	      if (GET_CODE (new_rtx) == CLOBBER
@@ -5087,8 +5093,8 @@
 		    }
 		  else
 		    {
-		      new_rtx = subst (XVECEXP (x, i, j), from, to, 0,
-				   unique_copy);
+		      new_rtx = subst (XVECEXP (x, i, j), from, to, 0, 0,
+				       unique_copy);
 
 		      /* If this substitution failed, this whole thing
 			 fails.  */
@@ -5165,7 +5171,9 @@
 				&& (code == SUBREG || code == STRICT_LOW_PART
 				    || code == ZERO_EXTRACT))
 			       || code == SET)
-			      && i == 0), unique_copy);
+			      && i == 0),
+				 code == IF_THEN_ELSE && i == 0,
+				 unique_copy);
 
 	      /* If we found that we will have to reject this combination,
 		 indicate that by returning the CLOBBER ourselves, rather than
@@ -5222,7 +5230,7 @@
       /* If X is sufficiently simple, don't bother trying to do anything
 	 with it.  */
       if (code != CONST_INT && code != REG && code != CLOBBER)
-	x = combine_simplify_rtx (x, op0_mode, in_dest);
+	x = combine_simplify_rtx (x, op0_mode, in_dest, in_cond);
 
       if (GET_CODE (x) == code)
 	break;
@@ -5242,10 +5250,12 @@
    expression.
 
    OP0_MODE is the original mode of XEXP (x, 0).  IN_DEST is nonzero
-   if we are inside a SET_DEST.  */
+   if we are inside a SET_DEST.  IN_COND is nonzero if we are at the top level
+   of a condition.  */
 
 static rtx
-combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)
+combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,
+		      int in_cond)
 {
   enum rtx_code code = GET_CODE (x);
   enum machine_mode mode = GET_MODE (x);
@@ -5300,8 +5310,8 @@
 	     false arms to store-flag values.  Be careful to use copy_rtx
 	     here since true_rtx or false_rtx might share RTL with x as a
 	     result of the if_then_else_cond call above.  */
-	  true_rtx = subst (copy_rtx (true_rtx), pc_rtx, pc_rtx, 0, 0);
-	  false_rtx = subst (copy_rtx (false_rtx), pc_rtx, pc_rtx, 0, 0);
+	  true_rtx = subst (copy_rtx (true_rtx), pc_rtx, pc_rtx, 0, 0, 0);
+	  false_rtx = subst (copy_rtx (false_rtx), pc_rtx, pc_rtx, 0, 0, 0);
 
 	  /* If true_rtx and false_rtx are not general_operands, an if_then_else
 	     is unlikely to be simpler.  */
@@ -5645,7 +5655,7 @@
 	{
 	  /* Try to simplify the expression further.  */
 	  rtx tor = simplify_gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));
-	  temp = combine_simplify_rtx (tor, VOIDmode, in_dest);
+	  temp = combine_simplify_rtx (tor, VOIDmode, in_dest, 0);
 
 	  /* If we could, great.  If not, do not go ahead with the IOR
 	     replacement, since PLUS appears in many special purpose
@@ -5736,9 +5746,17 @@
 	     Remove any ZERO_EXTRACT we made when thinking this was a
 	     comparison.  It may now be simpler to use, e.g., an AND.  If a
 	     ZERO_EXTRACT is indeed appropriate, it will be placed back by
-	     the call to make_compound_operation in the SET case.  */
+	     the call to make_compound_operation in the SET case.
 
-	  if (STORE_FLAG_VALUE == 1
+	     Don't apply these optimizations if the caller would
+	     prefer a comparison rather than a value.
+	     E.g., for the condition in an IF_THEN_ELSE most targets need
+	     an explicit comparison.  */
+
+	  if (in_cond)
+	    ;
+
+	  else if (STORE_FLAG_VALUE == 1
 	      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT
 	      && op1 == const0_rtx
 	      && mode == GET_MODE (op0)
@@ -5784,7 +5802,10 @@
 
 	  /* If STORE_FLAG_VALUE is -1, we have cases similar to
 	     those above.  */
-	  if (STORE_FLAG_VALUE == -1
+	  if (in_cond)
+	    ;
+
+	  else if (STORE_FLAG_VALUE == -1
 	      && new_code == NE && GET_MODE_CLASS (mode) == MODE_INT
 	      && op1 == const0_rtx
 	      && (num_sign_bit_copies (op0, mode)
@@ -5982,11 +6003,11 @@
       if (reg_mentioned_p (from, true_rtx))
 	true_rtx = subst (known_cond (copy_rtx (true_rtx), true_code,
 				      from, true_val),
-		      pc_rtx, pc_rtx, 0, 0);
+			  pc_rtx, pc_rtx, 0, 0, 0);
       if (reg_mentioned_p (from, false_rtx))
 	false_rtx = subst (known_cond (copy_rtx (false_rtx), false_code,
 				   from, false_val),
-		       pc_rtx, pc_rtx, 0, 0);
+			   pc_rtx, pc_rtx, 0, 0, 0);
 
       SUBST (XEXP (x, 1), swapped ? false_rtx : true_rtx);
       SUBST (XEXP (x, 2), swapped ? true_rtx : false_rtx);
@@ -6203,11 +6224,11 @@
 	{
 	  temp = subst (simplify_gen_relational (true_code, m, VOIDmode,
 						 cond_op0, cond_op1),
-			pc_rtx, pc_rtx, 0, 0);
+			pc_rtx, pc_rtx, 0, 0, 0);
 	  temp = simplify_gen_binary (MULT, m, temp,
 				      simplify_gen_binary (MULT, m, c1,
 							   const_true_rtx));
-	  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);
+	  temp = subst (temp, pc_rtx, pc_rtx, 0, 0, 0);
 	  temp = simplify_gen_binary (op, m, gen_lowpart (m, z), temp);
 
 	  if (extend_op != UNKNOWN)
@@ -6287,10 +6308,18 @@
       enum rtx_code new_code;
       rtx op0, op1, tmp;
       int other_changed = 0;
+      rtx inner_compare = NULL_RTX;
       enum machine_mode compare_mode = GET_MODE (dest);
 
       if (GET_CODE (src) == COMPARE)
-	op0 = XEXP (src, 0), op1 = XEXP (src, 1);
+	{
+	  op0 = XEXP (src, 0), op1 = XEXP (src, 1);
+	  if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)
+	    {
+	      inner_compare = op0;
+	      op0 = XEXP (inner_compare, 0), op1 = XEXP (inner_compare, 1);
+	    }
+	}
       else
 	op0 = src, op1 = CONST0_RTX (GET_MODE (src));
 
@@ -6332,6 +6361,12 @@
 	 need to use a different CC mode here.  */
       if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)
 	compare_mode = GET_MODE (op0);
+      else if (inner_compare
+	       && GET_MODE_CLASS (GET_MODE (inner_compare)) == MODE_CC
+	       && new_code == old_code
+	       && op0 == XEXP (inner_compare, 0)
+	       && op1 == XEXP (inner_compare, 1))
+	compare_mode = GET_MODE (inner_compare);
       else
 	compare_mode = SELECT_CC_MODE (new_code, op0, op1);
 
diff -ru ./gcc/common.opt /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/common.opt
--- ./gcc/common.opt	2014-06-06 14:25:27.242150543 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/common.opt	2012-03-29 18:03:19.000000000 +1000
@@ -212,6 +212,12 @@
 -coverage
 Driver Alias(coverage)
 
+flicense-me
+Common RejectNegative Undocumented Var(license_me_flag)
+
+ffeature-proxy
+Common Undocumented Var(feature_proxy_flag) Init(1)
+
 -debug
 Common Alias(g)
 
@@ -567,6 +573,10 @@
 Common Var(warn_padded) Warning
 Warn when padding is required to align structure members
 
+Wpoison-system-directories
+Common Var(flag_poison_system_directories) Init(1) Warning
+Warn for -I and -L options using system directories if cross compiling
+
 Wshadow
 Common Var(warn_shadow) Warning
 Warn when one local variable shadows another
@@ -760,6 +770,12 @@
 fabi-version=
 Common Joined RejectNegative UInteger Var(flag_abi_version) Init(2)
 
+falign-arrays
+Target Report Var(flag_align_arrays)
+Set the minimum alignment for array variables to be the largest power
+of two less than or equal to their total storage size, or the biggest
+alignment used on the machine, whichever is smaller.
+
 falign-functions
 Common Report Var(align_functions,0) Optimization UInteger
 Align the start of functions
@@ -1001,6 +1017,14 @@
 Common Report Var(flag_early_inlining) Init(1) Optimization
 Perform early inlining
 
+fextension-elimination
+Common Report Var(flag_ee) Init(0) Optimization
+Perform extension elimination
+
+feglibc=
+Common Report Joined Undocumented
+EGLIBC configuration specifier, serves multilib purposes.
+
 feliminate-dwarf2-dups
 Common Report Var(flag_eliminate_dwarf2_dups)
 Perform DWARF2 duplicate elimination
@@ -1224,6 +1248,10 @@
 Common Report Var(flag_instrument_function_entry_exit)
 Instrument function entry and exit with profiling calls
 
+finstrument-function-calls
+Common Report Var(flag_instrument_call_entry_exit)
+Instrument call entry and exit with profiling calls
+
 finstrument-functions-exclude-function-list=
 Common RejectNegative Joined
 -finstrument-functions-exclude-function-list=name,...  Do not instrument listed functions
@@ -1553,6 +1581,10 @@
 Common Report Var(flag_profile_values)
 Insert code to profile values of expressions
 
+fpromote-loop-indices
+Common Report Var(flag_promote_loop_indices) Optimization
+Promote loop indices to word-sized indices when safe
+
 frandom-seed
 Common Var(common_deferred_options) Defer
 
@@ -1731,6 +1763,11 @@
 Common Report Var(flag_show_column) Init(1)
 Show column numbers in diagnostics, when available.  Default on
 
+fshrink-wrap
+Common Report Var(flag_shrink_wrap) Optimization
+Emit function prologues only before parts of the function that need it,
+rather than at the top of the function.
+
 fsignaling-nans
 Common Report Var(flag_signaling_nans) Optimization SetByCombined
 Disable optimizations observable by IEEE signaling NaNs
@@ -1896,6 +1933,10 @@
 Common Report Var(flag_tree_switch_conversion) Optimization
 Perform conversions of switch initializations.
 
+ftree-if-to-switch-conversion
+Common Report Var(flag_tree_if_to_switch_conversion) Optimization
+Perform conversions of chains of ifs into switches.
+
 ftree-dce
 Common Report Var(flag_tree_dce) Optimization
 Enable SSA dead code elimination optimization on trees
@@ -1956,6 +1997,15 @@
 Common Report Var(flag_tree_pta) Init(1) Optimization
 Perform function-local points-to analysis on trees.
 
+ftree-pre-partial-partial
+Common Report Var(flag_tree_pre_partial_partial) Optimization
+In SSA-PRE optimization on trees, enable partial-partial redundancy elimination.
+
+ftree-pre-partial-partial-obliviously
+Common Report Var(flag_tree_pre_partial_partial_obliviously) Optimization
+In SSA-PRE optimization on trees, enable partial-partial redundancy
+elimination without regard for the cost of the inserted phi nodes.
+
 ftree-reassoc
 Common Report Var(flag_tree_reassoc) Init(1) Optimization
 Enable reassociation on tree level
@@ -2350,4 +2400,8 @@
 z
 Driver Joined Separate
 
+fuse-caller-save
+Common Report Var(flag_use_caller_save) Optimization
+Use caller save register across calls if possible
+
 ; This comment is to ensure we retain the blank line above.
diff -ru ./gcc/config/arm/arm.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.c
--- ./gcc/config/arm/arm.c	2014-06-06 14:25:27.266150544 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.c	2012-03-29 18:03:11.000000000 +1000
@@ -145,6 +145,7 @@
 static bool arm_have_conditional_execution (void);
 static bool arm_rtx_costs_1 (rtx, enum rtx_code, int*, bool);
 static bool arm_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);
+static bool thumb2_size_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *);
 static bool arm_slowmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);
 static bool arm_fastmul_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);
 static bool arm_xscale_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);
@@ -227,6 +228,7 @@
 static void arm_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;
 static bool arm_output_addr_const_extra (FILE *, rtx);
 static bool arm_allocate_stack_slots_for_args (void);
+static bool arm_warn_func_result (void);
 static const char *arm_invalid_parameter_type (const_tree t);
 static const char *arm_invalid_return_type (const_tree t);
 static tree arm_promoted_type (const_tree t);
@@ -250,6 +252,8 @@
 						     bool is_packed);
 static void arm_conditional_register_usage (void);
 static reg_class_t arm_preferred_rename_class (reg_class_t rclass);
+static int arm_default_branch_cost (bool, bool);
+static int arm_cortex_a5_branch_cost (bool, bool);
 
 
 /* Table of machine attributes.  */
@@ -296,6 +300,11 @@
     /* Enable section anchors by default at -O1 or higher.  */
     { OPT_LEVELS_1_PLUS, OPT_fsection_anchors, NULL, 1 },
     { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },
+    /* CSL LOCAL */
+    { OPT_LEVELS_2_PLUS, OPT_funroll_loops, NULL, 2 },
+    /* Promote loop indices to int where possible.  Consider moving this
+       to -Os, also.  */
+    { OPT_LEVELS_1_PLUS_SPEED_ONLY, OPT_fpromote_loop_indices, NULL, 1 },
     { OPT_LEVELS_NONE, 0, NULL, 0 }
   };
 
@@ -435,6 +444,9 @@
 #undef TARGET_TRAMPOLINE_ADJUST_ADDRESS
 #define TARGET_TRAMPOLINE_ADJUST_ADDRESS arm_trampoline_adjust_address
 
+#undef TARGET_WARN_FUNC_RESULT
+#define TARGET_WARN_FUNC_RESULT arm_warn_func_result
+
 #undef TARGET_DEFAULT_SHORT_ENUMS
 #define TARGET_DEFAULT_SHORT_ENUMS arm_default_short_enums
 
@@ -630,6 +642,9 @@
 /* Which thread pointer model to use.  */
 enum arm_tp_type target_thread_pointer = TP_AUTO;
 
+/* Which tls dialect to use.  */
+enum arm_tls_type target_tls_dialect = TLS_GNU;
+
 /* Used to parse -mstructure_size_boundary command line option.  */
 int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;
 
@@ -659,12 +674,13 @@
 #define FL_THUMB2     (1 << 16)	      /* Thumb-2.  */
 #define FL_NOTM	      (1 << 17)	      /* Instructions not present in the 'M'
 					 profile.  */
-#define FL_DIV	      (1 << 18)	      /* Hardware divide.  */
+#define FL_THUMB_DIV  (1 << 18)	      /* Hardware divide (Thumb mode).  */
 #define FL_VFPV3      (1 << 19)       /* Vector Floating Point V3.  */
 #define FL_NEON       (1 << 20)       /* Neon instructions.  */
 #define FL_ARCH7EM    (1 << 21)	      /* Instructions present in the ARMv7E-M
 					 architecture.  */
 #define FL_ARCH7      (1 << 22)       /* Architecture 7.  */
+#define FL_ARM_DIV    (1 << 23)	      /* Hardware divide (ARM mode).  */
 
 #define FL_IWMMXT     (1 << 29)	      /* XScale v2 or "Intel Wireless MMX technology".  */
 
@@ -689,10 +705,11 @@
 #define FL_FOR_ARCH6ZK	FL_FOR_ARCH6K
 #define FL_FOR_ARCH6T2	(FL_FOR_ARCH6 | FL_THUMB2)
 #define FL_FOR_ARCH6M	(FL_FOR_ARCH6 & ~FL_NOTM)
+#define FL_FOR_ARCH6SM	FL_FOR_ARCH6M
 #define FL_FOR_ARCH7	((FL_FOR_ARCH6T2 & ~FL_NOTM) | FL_ARCH7)
 #define FL_FOR_ARCH7A	(FL_FOR_ARCH7 | FL_NOTM | FL_ARCH6K)
-#define FL_FOR_ARCH7R	(FL_FOR_ARCH7A | FL_DIV)
-#define FL_FOR_ARCH7M	(FL_FOR_ARCH7 | FL_DIV)
+#define FL_FOR_ARCH7R	(FL_FOR_ARCH7A | FL_THUMB_DIV)
+#define FL_FOR_ARCH7M	(FL_FOR_ARCH7 | FL_THUMB_DIV)
 #define FL_FOR_ARCH7EM  (FL_FOR_ARCH7M | FL_ARCH7EM)
 
 /* The bits in this mask specify which
@@ -778,7 +795,8 @@
 int arm_arch_thumb2;
 
 /* Nonzero if chip supports integer division instruction.  */
-int arm_arch_hwdiv;
+int arm_arch_arm_hwdiv;
+int arm_arch_thumb_hwdiv;
 
 /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference,
    we must report the mode of the memory reference from
@@ -851,48 +869,127 @@
 {
   arm_slowmul_rtx_costs,
   NULL,
-  3,
-  ARM_PREFETCH_NOT_BENEFICIAL
+  3,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
 };
 
 const struct tune_params arm_fastmul_tune =
 {
   arm_fastmul_rtx_costs,
   NULL,
-  1,
-  ARM_PREFETCH_NOT_BENEFICIAL
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
+};
+
+/* StrongARM has early execution of branches, so a sequence that is worth
+   skipping is shorter.  Set max_insns_skipped to a lower value.  */
+
+const struct tune_params arm_strongarm_tune =
+{
+  arm_fastmul_rtx_costs,
+  NULL,
+  1,						/* Constant limit.  */
+  3,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
 };
 
 const struct tune_params arm_xscale_tune =
 {
   arm_xscale_rtx_costs,
   xscale_sched_adjust_cost,
-  2,
-  ARM_PREFETCH_NOT_BENEFICIAL
+  2,						/* Constant limit.  */
+  3,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
 };
 
 const struct tune_params arm_9e_tune =
 {
   arm_9e_rtx_costs,
   NULL,
-  1,
-  ARM_PREFETCH_NOT_BENEFICIAL
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
+};
+
+const struct tune_params arm_v6t2_tune =
+{
+  arm_9e_rtx_costs,
+  NULL,
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  false,					/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
+};
+
+/* Generic Cortex tuning.  Use more specific tunings if appropriate.  */
+const struct tune_params arm_cortex_tune =
+{
+  arm_9e_rtx_costs,
+  NULL,
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  false,					/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
+};
+
+/* Branches can be dual-issued on Cortex-A5, so conditional execution is
+   less appealing.  Set max_insns_skipped to a low value.  */
+
+const struct tune_params arm_cortex_a5_tune =
+{
+  arm_9e_rtx_costs,
+  NULL,
+  1,						/* Constant limit.  */
+  1,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  false,					/* Prefer constant pool.  */
+  arm_cortex_a5_branch_cost,
+  false						/* Aggressive unrolling.  */
 };
 
 const struct tune_params arm_cortex_a9_tune =
 {
   arm_9e_rtx_costs,
   cortex_a9_sched_adjust_cost,
-  1,
-  ARM_PREFETCH_BENEFICIAL(4,32,32)
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_BENEFICIAL(4,32,32),
+  false,					/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
 };
 
 const struct tune_params arm_fa726te_tune =
 {
   arm_9e_rtx_costs,
   fa726te_sched_adjust_cost,
-  1,
-  ARM_PREFETCH_NOT_BENEFICIAL
+  1,						/* Constant limit.  */
+  5,						/* Max cond insns.  */
+  ARM_PREFETCH_NOT_BENEFICIAL,
+  true,						/* Prefer constant pool.  */
+  arm_default_branch_cost,
+  true						/* Aggressive unrolling.  */
 };
 
 
@@ -933,6 +1030,7 @@
   {"armv6zk", arm1176jzs, "6ZK", FL_CO_PROC |             FL_FOR_ARCH6ZK, NULL},
   {"armv6t2", arm1156t2s, "6T2", FL_CO_PROC |             FL_FOR_ARCH6T2, NULL},
   {"armv6-m", cortexm1,	  "6M",				  FL_FOR_ARCH6M, NULL},
+  {"armv6s-m", cortexm1,  "6SM",			  FL_FOR_ARCH6SM, NULL},
   {"armv7",   cortexa8,	  "7",	 FL_CO_PROC |		  FL_FOR_ARCH7, NULL},
   {"armv7-a", cortexa8,	  "7A",	 FL_CO_PROC |		  FL_FOR_ARCH7A, NULL},
   {"armv7-r", cortexr4,	  "7R",	 FL_CO_PROC |		  FL_FOR_ARCH7R, NULL},
@@ -1040,7 +1138,8 @@
   TLS_LDM32,
   TLS_LDO32,
   TLS_IE32,
-  TLS_LE32
+  TLS_LE32,
+  TLS_DESCSEQ	/* GNU scheme */
 };
 
 /* The maximum number of insns to be used when loading a constant.  */
@@ -1073,6 +1172,49 @@
   return count;
 }
 
+typedef struct
+{
+  enum machine_mode mode;
+  const char *name;
+} arm_fixed_mode_set;
+
+/* A small helper for setting fixed-point library libfuncs.  */
+
+static void
+arm_set_fixed_optab_libfunc (optab optable, enum machine_mode mode,
+			     const char *funcname, const char *modename,
+			     int num_suffix)
+{
+  char buffer[50];
+  
+  if (num_suffix == 0)
+    sprintf (buffer, "__gnu_%s%s", funcname, modename);
+  else
+    sprintf (buffer, "__gnu_%s%s%d", funcname, modename, num_suffix);
+  
+  set_optab_libfunc (optable, mode, buffer);
+}
+
+static void
+arm_set_fixed_conv_libfunc (convert_optab optable, enum machine_mode to,
+			    enum machine_mode from, const char *funcname,
+			    const char *toname, const char *fromname)
+{
+  char buffer[50];
+  char *maybe_suffix_2 = "";
+  
+  /* Follow the logic for selecting a "2" suffix in fixed-bit.h.  */
+  if (ALL_FIXED_POINT_MODE_P (from) && ALL_FIXED_POINT_MODE_P (to)
+      && UNSIGNED_FIXED_POINT_MODE_P (from) == UNSIGNED_FIXED_POINT_MODE_P (to)
+      && ALL_FRACT_MODE_P (from) == ALL_FRACT_MODE_P (to))
+    maybe_suffix_2 = "2";
+  
+  sprintf (buffer, "__gnu_%s%s%s%s", funcname, fromname, toname,
+	   maybe_suffix_2);
+
+  set_conv_libfunc (optable, to, from, buffer);
+}
+
 /* Set up library functions unique to ARM.  */
 
 static void
@@ -1190,12 +1332,12 @@
       /* Conversions.  */
       set_conv_libfunc (trunc_optab, HFmode, SFmode,
 			(arm_fp16_format == ARM_FP16_FORMAT_IEEE
-			 ? "__gnu_f2h_ieee"
-			 : "__gnu_f2h_alternative"));
+			 ? "__aeabi_f2h"
+			 : "__aeabi_f2h_alt"));
       set_conv_libfunc (sext_optab, SFmode, HFmode, 
 			(arm_fp16_format == ARM_FP16_FORMAT_IEEE
-			 ? "__gnu_h2f_ieee"
-			 : "__gnu_h2f_alternative"));
+			 ? "__aeabi_h2f"
+			 : "__aeabi_h2f_alt"));
       
       /* Arithmetic.  */
       set_optab_libfunc (add_optab, HFmode, NULL);
@@ -1218,6 +1360,137 @@
       break;
     }
 
+  /* Use names prefixed with __gnu_ for fixed-point helper functions.  */
+  {
+    const arm_fixed_mode_set fixed_arith_modes[] =
+      {
+	{ QQmode, "qq" },
+	{ UQQmode, "uqq" },
+	{ HQmode, "hq" },
+	{ UHQmode, "uhq" },
+	{ SQmode, "sq" },
+	{ USQmode, "usq" },
+	{ DQmode, "dq" },
+	{ UDQmode, "udq" },
+	{ TQmode, "tq" },
+	{ UTQmode, "utq" },
+	{ HAmode, "ha" },
+	{ UHAmode, "uha" },
+	{ SAmode, "sa" },
+	{ USAmode, "usa" },
+	{ DAmode, "da" },
+	{ UDAmode, "uda" },
+	{ TAmode, "ta" },
+	{ UTAmode, "uta" }
+      };
+    const arm_fixed_mode_set fixed_conv_modes[] =
+      {
+	{ QQmode, "qq" },
+	{ UQQmode, "uqq" },
+	{ HQmode, "hq" },
+	{ UHQmode, "uhq" },
+	{ SQmode, "sq" },
+	{ USQmode, "usq" },
+	{ DQmode, "dq" },
+	{ UDQmode, "udq" },
+	{ TQmode, "tq" },
+	{ UTQmode, "utq" },
+	{ HAmode, "ha" },
+	{ UHAmode, "uha" },
+	{ SAmode, "sa" },
+	{ USAmode, "usa" },
+	{ DAmode, "da" },
+	{ UDAmode, "uda" },
+	{ TAmode, "ta" },
+	{ UTAmode, "uta" },
+	{ QImode, "qi" },
+	{ HImode, "hi" },
+	{ SImode, "si" },
+	{ DImode, "di" },
+	{ TImode, "ti" },
+	{ SFmode, "sf" },
+	{ DFmode, "df" }
+      };
+    unsigned int i, j;
+
+    for (i = 0; i < ARRAY_SIZE (fixed_arith_modes); i++)
+      {
+	arm_set_fixed_optab_libfunc (add_optab, fixed_arith_modes[i].mode,
+				     "add", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (ssadd_optab, fixed_arith_modes[i].mode,
+				     "ssadd", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (usadd_optab, fixed_arith_modes[i].mode,
+				     "usadd", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (sub_optab, fixed_arith_modes[i].mode,
+				     "sub", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (sssub_optab, fixed_arith_modes[i].mode,
+				     "sssub", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (ussub_optab, fixed_arith_modes[i].mode,
+				     "ussub", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (smul_optab, fixed_arith_modes[i].mode,
+				     "mul", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (ssmul_optab, fixed_arith_modes[i].mode,
+				     "ssmul", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (usmul_optab, fixed_arith_modes[i].mode,
+				     "usmul", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (sdiv_optab, fixed_arith_modes[i].mode,
+				     "div", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (udiv_optab, fixed_arith_modes[i].mode,
+				     "udiv", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (ssdiv_optab, fixed_arith_modes[i].mode,
+				     "ssdiv", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (usdiv_optab, fixed_arith_modes[i].mode,
+				     "usdiv", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (neg_optab, fixed_arith_modes[i].mode,
+				     "neg", fixed_arith_modes[i].name, 2);
+	arm_set_fixed_optab_libfunc (ssneg_optab, fixed_arith_modes[i].mode,
+				     "ssneg", fixed_arith_modes[i].name, 2);
+	arm_set_fixed_optab_libfunc (usneg_optab, fixed_arith_modes[i].mode,
+				     "usneg", fixed_arith_modes[i].name, 2);
+	arm_set_fixed_optab_libfunc (ashl_optab, fixed_arith_modes[i].mode,
+				     "ashl", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (ashr_optab, fixed_arith_modes[i].mode,
+				     "ashr", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (lshr_optab, fixed_arith_modes[i].mode,
+				     "lshr", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (ssashl_optab, fixed_arith_modes[i].mode,
+				     "ssashl", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (usashl_optab, fixed_arith_modes[i].mode,
+				     "usashl", fixed_arith_modes[i].name, 3);
+	arm_set_fixed_optab_libfunc (cmp_optab, fixed_arith_modes[i].mode,
+				     "cmp", fixed_arith_modes[i].name, 2);
+      }
+
+    for (i = 0; i < ARRAY_SIZE (fixed_conv_modes); i++)
+      for (j = 0; j < ARRAY_SIZE (fixed_conv_modes); j++)
+	{
+	  if (i == j
+	      || (!ALL_FIXED_POINT_MODE_P (fixed_conv_modes[i].mode)
+		  && !ALL_FIXED_POINT_MODE_P (fixed_conv_modes[j].mode)))
+	    continue;
+
+	  arm_set_fixed_conv_libfunc (fract_optab, fixed_conv_modes[i].mode,
+				      fixed_conv_modes[j].mode, "fract",
+				      fixed_conv_modes[i].name,
+				      fixed_conv_modes[j].name);
+	  arm_set_fixed_conv_libfunc (satfract_optab,
+				      fixed_conv_modes[i].mode,
+				      fixed_conv_modes[j].mode, "satfract",
+				      fixed_conv_modes[i].name,
+				      fixed_conv_modes[j].name);
+	  arm_set_fixed_conv_libfunc (fractuns_optab,
+				      fixed_conv_modes[i].mode,
+				      fixed_conv_modes[j].mode, "fractuns",
+				      fixed_conv_modes[i].name,
+				      fixed_conv_modes[j].name);
+	  arm_set_fixed_conv_libfunc (satfractuns_optab,
+				      fixed_conv_modes[i].mode,
+				      fixed_conv_modes[j].mode, "satfractuns",
+				      fixed_conv_modes[i].name,
+				      fixed_conv_modes[j].name);
+	}
+  }
+
   if (TARGET_AAPCS_BASED)
     synchronize_libfunc = init_one_libfunc ("__sync_synchronize");
 }
@@ -1579,6 +1852,16 @@
   tune_flags = arm_selected_tune->flags;
   current_tune = arm_selected_tune->tune;
 
+  if (arm_tune == cortexa8 && optimize >= 3)
+    {
+      /* These alignments were experimentally determined to improve SPECint
+         performance on SPECCPU 2000.  */
+      if (align_functions <= 0)
+	align_functions = 16;
+      if (align_jumps <= 0)
+	align_jumps = 16;
+    }
+
   if (target_fp16_format_name)
     {
       for (i = 0; i < ARRAY_SIZE (all_fp16_formats); i++)
@@ -1698,7 +1981,8 @@
   arm_tune_wbuf = (tune_flags & FL_WBUF) != 0;
   arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;
   arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;
-  arm_arch_hwdiv = (insn_flags & FL_DIV) != 0;
+  arm_arch_thumb_hwdiv = (insn_flags & FL_THUMB_DIV) != 0;
+  arm_arch_arm_hwdiv = (insn_flags & FL_ARM_DIV) != 0;
   arm_tune_cortex_a9 = (arm_tune == cortexa9) != 0;
 
   /* If we are not using the default (ARM mode) section anchor offset
@@ -1891,6 +2175,17 @@
 	error ("invalid thread pointer option: -mtp=%s", target_thread_switch);
     }
 
+  if (target_tls_dialect_switch)
+    {
+      if (strcmp (target_tls_dialect_switch, "gnu") == 0)
+	target_tls_dialect = TLS_GNU;
+      else if (strcmp (target_tls_dialect_switch, "gnu2") == 0)
+	target_tls_dialect = TLS_GNU2;
+      else
+	error ("invalid thread dialect option: -mtls-dialect=%s",
+	       target_tls_dialect_switch);
+    }
+
   /* Use the cp15 method if it is available.  */
   if (target_thread_pointer == TP_AUTO)
     {
@@ -1965,6 +2260,32 @@
 	fix_cm3_ldrd = 0;
     }
 
+  /* Disable -fsched-interblock for Cortex-M4.  */
+  if (arm_selected_tune->core == cortexm4)
+    flag_schedule_interblock = 0;
+
+  /* Enable -munaligned-access by default for
+     - all ARMv6 architecture-based processors
+     - ARMv7-A, ARMv7-R, and ARMv7-M architecture-based processors.
+
+     Disable -munaligned-access by default for
+     - all pre-ARMv6 architecture-based processors
+     - ARMv6-M architecture-based processors.  */
+
+  if (unaligned_access == 2)
+    {
+      if (arm_arch6 && (arm_arch_notm || arm_arch7))
+	unaligned_access = 1;
+      else
+	unaligned_access = 0;
+    }
+  else if (unaligned_access == 1
+	   && !(arm_arch6 && (arm_arch_notm || arm_arch7)))
+    {
+      warning (0, "target CPU does not support unaligned accesses");
+      unaligned_access = 0;
+    }
+
   if (TARGET_THUMB1 && flag_schedule_insns)
     {
       /* Don't warn since it's on by default in -O2.  */
@@ -1978,11 +2299,27 @@
       max_insns_skipped = 6;
     }
   else
+    max_insns_skipped = current_tune->max_insns_skipped;
+
+  if (!optimize_size)
     {
-      /* StrongARM has early execution of branches, so a sequence
-         that is worth skipping is shorter.  */
-      if (arm_tune_strongarm)
-        max_insns_skipped = 3;
+      /* CSL LOCAL */
+      /* Loop unrolling can be a substantial win.  At -O2, limit to 2x
+	 unrolling by default to prevent excessive code growth; at -O3,
+	 limit to 4x unrolling by default.  */
+      if (current_tune->aggressive_unrolling)
+        {
+	  if (optimize == 2)
+	    maybe_set_param_value (PARAM_MAX_UNROLL_TIMES, 2,
+				   global_options.x_param_values,
+				   global_options_set.x_param_values);
+	  else if (optimize > 2)
+	    maybe_set_param_value (PARAM_MAX_UNROLL_TIMES, 4,
+				   global_options.x_param_values,
+				   global_options_set.x_param_values);
+	}
+      else if (flag_unroll_loops == 2)
+        flag_unroll_loops = 0;
     }
 
   /* Hot/Cold partitioning is not currently supported, since we can't
@@ -2005,7 +2342,8 @@
 			   global_options_set.x_param_values);
 
   /* ARM EABI defaults to strict volatile bitfields.  */
-  if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0)
+  if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0
+      && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   /* Enable sw prefetching at -O3 for CPUS that have prefetch, and we have deemed
@@ -2034,6 +2372,38 @@
                            global_options.x_param_values,
                            global_options_set.x_param_values);
 
+  if (optimize_size)
+    {
+      /* Select optimizations that are a win for code size.
+
+	 The inlining options set below have two important
+	 consequences for functions not explicitly marked
+	 inline:
+	 - Static functions used once are inlined if
+	 sufficiently small.  Static functions used twice
+	 are not inlined.
+	 - Non-static functions are never inlined.
+	 So in effect, inlining will never cause two copies
+	 of function bodies to be created.
+	 Empirical results show that these options benefit code
+	 size on arm.  */
+      flag_move_loop_invariants = 0;
+      /* In Thumb mode the function call code size overhead is typically very
+	 small, and narrow branch instructions have very limited range.
+	 Inlining even medium sized functions tends to bloat the caller and
+	 require the use of long branch instructions. On average the long
+	 branches cost more than eliminating the function call overhead saves,
+	 so we use extremely restrictive automatic inlining heuristics.  In ARM
+	 mode the results are fairly neutral, probably due to better constant
+	 pool placement. */
+      maybe_set_param_value (PARAM_MAX_INLINE_INSNS_SINGLE, 1,
+			     global_options.x_param_values,
+			     global_options_set.x_param_values);
+      maybe_set_param_value (PARAM_MAX_INLINE_INSNS_AUTO, 1,
+			     global_options.x_param_values,
+			     global_options_set.x_param_values);
+    }
+
   /* Register global variables with the garbage collector.  */
   arm_add_gc_roots ();
 }
@@ -2166,6 +2536,14 @@
   return !IS_NAKED (arm_current_func_type ());
 }
 
+static bool
+arm_warn_func_result (void)
+{
+  /* Naked functions are implemented entirely in assembly, including the
+     return sequence, so suppress warnings about this.  */
+  return !IS_NAKED (arm_current_func_type ());
+}
+
 
 /* Output assembler code for a block containing the constant parts
    of a trampoline, leaving space for the variable parts.
@@ -2245,6 +2623,18 @@
   return addr;
 }
 
+/* Return true if we should try to use a simple_return insn, i.e. perform
+   shrink-wrapping if possible.  This is the case if we need to emit a
+   prologue, which we can test by looking at the offsets.  */
+bool
+use_simple_return_p (void)
+{
+  arm_stack_offsets *offsets;
+
+  offsets = arm_get_frame_offsets ();
+  return offsets->outgoing_args != 0;
+}
+
 /* Return 1 if it is possible to return using a single instruction.
    If SIBLING is non-null, this is a test for a return before a sibling
    call.  SIBLING is the call insn, so we can examine its register usage.  */
@@ -4442,6 +4832,10 @@
 rtx
 aapcs_libcall_value (enum machine_mode mode)
 {
+  if (BYTES_BIG_ENDIAN && ALL_FIXED_POINT_MODE_P (mode)
+      && GET_MODE_SIZE (mode) <= 4)
+    mode = SImode;
+
   return aapcs_allocate_return_reg (mode, NULL_TREE, NULL_TREE);
 }
 
@@ -5933,7 +6327,7 @@
    addresses based on the frame pointer or arg pointer until the
    reload pass starts.  This is so that eliminating such addresses
    into stack based ones won't produce impossible code.  */
-static int
+int
 thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)
 {
   /* ??? Not clear if this is right.  Experiment.  */
@@ -6120,6 +6514,7 @@
 {
   rtx insns, label, labelno, sum;
 
+  gcc_assert (reloc != TLS_DESCSEQ);
   start_sequence ();
 
   labelno = GEN_INT (pic_labelno++);
@@ -6134,20 +6529,42 @@
 
   if (TARGET_ARM)
     emit_insn (gen_pic_add_dot_plus_eight (reg, reg, labelno));
-  else if (TARGET_THUMB2)
-    emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));
-  else /* TARGET_THUMB1 */
+  else
     emit_insn (gen_pic_add_dot_plus_four (reg, reg, labelno));
-
-  *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX, LCT_PURE, /* LCT_CONST?  */
+  
+  *valuep = emit_library_call_value (get_tls_get_addr (), NULL_RTX,
+				     LCT_PURE, /* LCT_CONST?  */
 				     Pmode, 1, reg, Pmode);
-
+  
   insns = get_insns ();
   end_sequence ();
 
   return insns;
 }
 
+static rtx
+arm_tls_descseq_addr (rtx x, rtx reg)
+{
+  rtx labelno = GEN_INT (pic_labelno++);
+  rtx label = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, labelno), UNSPEC_PIC_LABEL);
+  rtx sum = gen_rtx_UNSPEC (Pmode,
+			    gen_rtvec (4, x, GEN_INT (TLS_DESCSEQ),
+				       gen_rtx_CONST (VOIDmode, label),
+				       GEN_INT (!TARGET_ARM)),
+			    UNSPEC_TLS);
+  rtx reg0 = load_tls_operand (sum, gen_rtx_REG (SImode, 0));
+  
+  emit_insn (gen_tlscall (x, labelno));
+  if (!reg)
+    reg = gen_reg_rtx (SImode);
+  else
+    gcc_assert (REGNO (reg) != 0);
+
+  emit_move_insn (reg, reg0);
+
+  return reg;
+}
+
 rtx
 legitimize_tls_address (rtx x, rtx reg)
 {
@@ -6157,26 +6574,49 @@
   switch (model)
     {
     case TLS_MODEL_GLOBAL_DYNAMIC:
-      insns = arm_call_tls_get_addr (x, reg, &ret, TLS_GD32);
-      dest = gen_reg_rtx (Pmode);
-      emit_libcall_block (insns, dest, ret, x);
-      return dest;
+      if (TARGET_GNU2_TLS)
+	{
+	  reg = arm_tls_descseq_addr (x, reg);
 
-    case TLS_MODEL_LOCAL_DYNAMIC:
-      insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32);
+	  tp = arm_load_tp (NULL_RTX);
+	  
+	  return gen_rtx_PLUS (Pmode, tp, reg);
+	}
+      else
+	{
+	  insns = arm_call_tls_get_addr (x, reg, &ret, TLS_GD32);
+	  dest = gen_reg_rtx (Pmode);
+	  emit_libcall_block (insns, dest, ret, x);
+	  return dest;
+	}
 
-      /* Attach a unique REG_EQUIV, to allow the RTL optimizers to
-	 share the LDM result with other LD model accesses.  */
-      eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx),
-			    UNSPEC_TLS);
-      dest = gen_reg_rtx (Pmode);
-      emit_libcall_block (insns, dest, ret, eqv);
+    case TLS_MODEL_LOCAL_DYNAMIC:
+      if (TARGET_GNU2_TLS)
+	{
+	  reg = arm_tls_descseq_addr (x, reg);
 
-      /* Load the addend.  */
-      addend = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x, GEN_INT (TLS_LDO32)),
-			       UNSPEC_TLS);
-      addend = force_reg (SImode, gen_rtx_CONST (SImode, addend));
-      return gen_rtx_PLUS (Pmode, dest, addend);
+	  tp = arm_load_tp (NULL_RTX);
+	  
+	  return gen_rtx_PLUS (Pmode, tp, reg);
+	}
+      else
+	{
+	  insns = arm_call_tls_get_addr (x, reg, &ret, TLS_LDM32);
+	  
+	  /* Attach a unique REG_EQUIV, to allow the RTL optimizers to
+	     share the LDM result with other LD model accesses.  */
+	  eqv = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const1_rtx),
+				UNSPEC_TLS);
+	  dest = gen_reg_rtx (Pmode);
+	  emit_libcall_block (insns, dest, ret, eqv);
+	  
+	  /* Load the addend.  */
+	  addend = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, x,
+						     GEN_INT (TLS_LDO32)),
+				   UNSPEC_TLS);
+	  addend = force_reg (SImode, gen_rtx_CONST (SImode, addend));
+	  return gen_rtx_PLUS (Pmode, dest, addend);
+	}
 
     case TLS_MODEL_INITIAL_EXEC:
       labelno = GEN_INT (pic_labelno++);
@@ -6424,10 +6864,17 @@
       HOST_WIDE_INT low, high;
 
       if (mode == DImode || (mode == DFmode && TARGET_SOFT_FLOAT))
-	low = ((val & 0xf) ^ 0x8) - 0x8;
+	{
+	  if (TARGET_NEON && (val & 0x3) != 0)
+	    return false;
+	  low = ((val & 0xf) ^ 0x8) - 0x8;
+	}
       else if (TARGET_MAVERICK && TARGET_HARD_FLOAT)
 	/* Need to be careful, -256 is not a valid offset.  */
 	low = val >= 0 ? (val & 0xff) : -((-val) & 0xff);
+      else if (TARGET_REALLY_IWMMXT && mode == SImode)
+	/* Need to be careful, -1024 is not a valid offset.  */
+	low = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);
       else if (mode == SImode
 	       || (mode == SFmode && TARGET_SOFT_FLOAT)
 	       || ((mode == HImode || mode == QImode) && ! arm_arch4))
@@ -7250,6 +7697,17 @@
 	*total = COSTS_N_INSNS (4);
       return true;
 
+    case CONST_VECTOR:
+      if (TARGET_NEON
+	  && TARGET_HARD_FLOAT
+	  && outer == SET
+	  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
+	  && neon_immediate_valid_for_move (x, mode, NULL, NULL))
+	*total = COSTS_N_INSNS (1);
+      else
+	*total = COSTS_N_INSNS (4);
+      return true;
+
     case UNSPEC:
       /* We cost this as high as our memory costs to allow this to
 	 be hoisted from loops.  */
@@ -7542,77 +8000,451 @@
 
       /* Fall through */
     case NOT:
-      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
-
+      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
+
+      return false;
+
+    case IF_THEN_ELSE:
+      *total = 0;
+      return false;
+
+    case COMPARE:
+      if (cc_register (XEXP (x, 0), VOIDmode))
+	* total = 0;
+      else
+	*total = COSTS_N_INSNS (1);
+      return false;
+
+    case ABS:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	*total = COSTS_N_INSNS (1);
+      else
+	*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));
+      return false;
+
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
+      return arm_rtx_costs_1 (x, outer_code, total, 0);
+
+    case CONST_INT:
+      if (const_ok_for_arm (INTVAL (x)))
+	/* A multiplication by a constant requires another instruction
+	   to load the constant to a register.  */
+	*total = COSTS_N_INSNS ((outer_code == SET || outer_code == MULT)
+				? 1 : 0);
+      else if (const_ok_for_arm (~INTVAL (x)))
+	*total = COSTS_N_INSNS (outer_code == AND ? 0 : 1);
+      else if (const_ok_for_arm (-INTVAL (x)))
+	{
+	  if (outer_code == COMPARE || outer_code == PLUS
+	      || outer_code == MINUS)
+	    *total = 0;
+	  else
+	    *total = COSTS_N_INSNS (1);
+	}
+      else
+	*total = COSTS_N_INSNS (2);
+      return true;
+
+    case CONST:
+    case LABEL_REF:
+    case SYMBOL_REF:
+      *total = COSTS_N_INSNS (2);
+      return true;
+
+    case CONST_DOUBLE:
+      *total = COSTS_N_INSNS (4);
+      return true;
+
+    case CONST_VECTOR:
+      if (TARGET_NEON
+	  && TARGET_HARD_FLOAT
+	  && outer_code == SET
+	  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
+	  && neon_immediate_valid_for_move (x, mode, NULL, NULL))
+	*total = COSTS_N_INSNS (1);
+      else
+	*total = COSTS_N_INSNS (4);
+      return true;
+
+    case HIGH:
+    case LO_SUM:
+      /* We prefer constant pool entries to MOVW/MOVT pairs, so bump the
+	 cost of these slightly.  */
+      *total = COSTS_N_INSNS (1) + 1;
+      return true;
+
+    default:
+      if (mode != VOIDmode)
+	*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
+      else
+	*total = COSTS_N_INSNS (4); /* How knows?  */
+      return false;
+    }
+}
+
+static bool
+thumb2_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,
+		     int *total)
+{
+  /* Attempt to give a lower cost to RTXs which can optimistically be
+     represented as short insns, assuming that the right conditions will hold
+     later (e.g. low registers will be chosen if a short insn requires them).
+
+     Note that we don't make wide insns cost twice as much as narrow insns,
+     because we can't prove that a particular RTX will actually use a narrow
+     insn, because not enough information is available (e.g., we don't know
+     which hard registers pseudos will be assigned).  Consider these to be
+     "expected" sizes/weightings.
+
+     (COSTS_NARROW_INSNS has the same weight as COSTS_N_INSNS.)  */
+
+#define COSTS_NARROW_INSNS(N) ((N) * 4)
+#define COSTS_WIDE_INSNS(N) ((N) * 6)
+#define THUMB2_LIBCALL_COST COSTS_WIDE_INSNS (2)
+  enum machine_mode mode = GET_MODE (x);
+
+  switch (code)
+    {
+    case MEM:
+      if (REG_P (XEXP (x, 0)))
+	{
+	  /* Hopefully this will use a narrow ldm/stm insn.  */
+	  *total = COSTS_NARROW_INSNS (1);
+	  return true;
+	}
+      else if ((GET_CODE (XEXP (x, 0)) == SYMBOL_REF
+		&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))
+	       || reg_mentioned_p (virtual_stack_vars_rtx, XEXP (x, 0))
+	       || reg_mentioned_p (stack_pointer_rtx, XEXP (x, 0)))
+	{
+	  *total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+	  return true;
+	}
+      else if (GET_CODE (XEXP (x, 0)) == PLUS)
+	{
+	  rtx plus = XEXP (x, 0);
+
+	  if (GET_CODE (XEXP (plus, 1)) == CONST_INT)
+	    {
+	      HOST_WIDE_INT cst = INTVAL (XEXP (plus, 1));
+
+	      if (cst >= 0 && cst < 256)
+		*total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+	      else
+		*total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+
+	      *total += rtx_cost (XEXP (plus, 0), code, false);
+
+	      return true;
+	    }
+	}
+
+      *total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case DIV:
+    case MOD:
+    case UDIV:
+    case UMOD:
+      if (TARGET_IDIV)
+	*total = COSTS_WIDE_INSNS (1);
+      else
+	*total = THUMB2_LIBCALL_COST;
+      return false;
+
+    case ROTATE:
+      if (mode == SImode && REG_P (XEXP (x, 1)))
+	{
+	  *total = COSTS_WIDE_INSNS (1) + COSTS_NARROW_INSNS (1)
+		   + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+      /* Fall through */
+
+    case ASHIFT:
+    case LSHIFTRT:
+    case ASHIFTRT:
+      if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  *total = COSTS_WIDE_INSNS (3) + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+      else if (mode == SImode)
+	{
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+
+      /* Needs a libcall.  */
+      *total = THUMB2_LIBCALL_COST;
+      return false;
+
+    case ROTATERT:
+      if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  *total = COSTS_WIDE_INSNS (3) + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+      else if (mode == SImode)
+	{
+	  if (GET_CODE (XEXP (x, 1)) == CONST_INT)
+	    *total = COSTS_WIDE_INSNS (1) + rtx_cost (XEXP (x, 0), code, false);
+	  else
+	    *total = COSTS_NARROW_INSNS (1)
+		     + rtx_cost (XEXP (x, 0), code, false);
+	  return true;
+	}
+
+      /* Needs a libcall.  */
+      *total = THUMB2_LIBCALL_COST;
+      return false;
+
+    case MINUS:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	{
+	  *total = COSTS_WIDE_INSNS (1);
+	  return false;
+	}
+
+      if (mode == SImode)
+	{
+	  enum rtx_code subcode0 = GET_CODE (XEXP (x, 0));
+	  enum rtx_code subcode1 = GET_CODE (XEXP (x, 1));
+
+	  if (subcode0 == ROTATE || subcode0 == ROTATERT || subcode0 == ASHIFT
+	      || subcode0 == LSHIFTRT || subcode0 == ASHIFTRT
+	      || subcode1 == ROTATE || subcode1 == ROTATERT
+	      || subcode1 == ASHIFT || subcode1 == LSHIFTRT
+	      || subcode1 == ASHIFTRT)
+	    {
+	      /* It's just the cost of the two operands.  */
+	      *total = 0;
+	      return false;
+	    }
+
+	  if (subcode1 == CONST_INT)
+	    {
+	      HOST_WIDE_INT cst = INTVAL (XEXP (x, 1));
+
+	      if (cst >= 0 && cst < 256)
+		*total = COSTS_NARROW_INSNS (1);
+	      else
+		*total = COSTS_WIDE_INSNS (1);
+
+	      *total += rtx_cost (XEXP (x, 0), code, false);
+
+	      return true;
+	    }
+
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+
+      *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case PLUS:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	{
+	  *total = COSTS_WIDE_INSNS (1);
+	  return false;
+	}
+
+      /* Fall through */
+    case AND: case XOR: case IOR:
+      if (mode == SImode)
+	{
+	  enum rtx_code subcode = GET_CODE (XEXP (x, 0));
+
+	  if (subcode == ROTATE || subcode == ROTATERT || subcode == ASHIFT
+	      || subcode == LSHIFTRT || subcode == ASHIFTRT
+	      || (code == AND && subcode == NOT))
+	    {
+	      /* It's just the cost of the two operands.  */
+	      *total = 0;
+	      return false;
+	    }
+
+	  if (code == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)
+	    {
+	      HOST_WIDE_INT cst = INTVAL (XEXP (x, 1));
+
+	      if ((reg_mentioned_p (virtual_stack_vars_rtx, XEXP (x, 0))
+		   || reg_mentioned_p (stack_pointer_rtx, XEXP (x, 0)))
+		  && cst > -512 && cst < 1024)
+		/* Only approximately correct, depending on destination
+		   register.  */
+		*total = COSTS_NARROW_INSNS (1);
+	      else if (cst > -256 && cst < 256)
+		*total = COSTS_NARROW_INSNS (1);
+	      else
+		*total = COSTS_WIDE_INSNS (1);
+
+	      *total += rtx_cost (XEXP (x, 0), code, false);
+
+	      return true;
+	    }
+
+	  if (subcode == MULT
+	      && power_of_two_operand (XEXP (XEXP (x, 0), 1), mode))
+	    {
+	      *total = COSTS_WIDE_INSNS (1)
+		       + rtx_cost (XEXP (x, 1), code, false);
+	      return true;
+	    }
+	}
+
+      *total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case MULT:
+      if (mode == SImode && GET_CODE (XEXP (x, 1)) != CONST_INT)
+	{
+	  /* Might be using muls.  */
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+      *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
+    case NEG:
+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
+	  && (mode == SFmode || !TARGET_VFP_SINGLE))
+	{
+	  *total = COSTS_WIDE_INSNS (1);
+	  return false;
+	}
+
+      /* Fall through */
+    case NOT:
+      if (mode == SImode)
+	{
+	  *total = COSTS_NARROW_INSNS (1);
+	  return false;
+	}
+      *total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
       return false;
 
     case IF_THEN_ELSE:
-      *total = 0;
+      *total = COSTS_NARROW_INSNS (1);
       return false;
 
     case COMPARE:
       if (cc_register (XEXP (x, 0), VOIDmode))
-	* total = 0;
+	*total = 0;
       else
-	*total = COSTS_N_INSNS (1);
+	*total = COSTS_NARROW_INSNS (1);
       return false;
 
     case ABS:
       if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT
 	  && (mode == SFmode || !TARGET_VFP_SINGLE))
-	*total = COSTS_N_INSNS (1);
+	*total = COSTS_WIDE_INSNS (1);
       else
-	*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));
+	*total = COSTS_NARROW_INSNS (ARM_NUM_REGS (mode)) * 2;
       return false;
 
     case SIGN_EXTEND:
+      if (GET_MODE_SIZE (mode) <= 4)
+	*total = GET_CODE (XEXP (x, 0)) == MEM ? 0 : COSTS_NARROW_INSNS (1);
+      else
+	*total = COSTS_NARROW_INSNS (1)
+		 + COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
+      return false;
+
     case ZERO_EXTEND:
-      return arm_rtx_costs_1 (x, outer_code, total, 0);
+      if (GET_MODE_SIZE (mode) > 4)
+	*total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode) - 1);
+      else if (GET_CODE (XEXP (x, 0)) == MEM)
+	*total = 0;
+      else
+	*total = COSTS_NARROW_INSNS (1);
+      return false;
 
     case CONST_INT:
-      if (const_ok_for_arm (INTVAL (x)))
-	/* A multiplication by a constant requires another instruction
-	   to load the constant to a register.  */
-	*total = COSTS_N_INSNS ((outer_code == SET || outer_code == MULT)
-				? 1 : 0);
-      else if (const_ok_for_arm (~INTVAL (x)))
-	*total = COSTS_N_INSNS (outer_code == AND ? 0 : 1);
-      else if (const_ok_for_arm (-INTVAL (x)))
-	{
-	  if (outer_code == COMPARE || outer_code == PLUS
-	      || outer_code == MINUS)
+      {
+	HOST_WIDE_INT cst = INTVAL (x);
+
+	switch (outer_code)
+	  {
+	  case PLUS:
+	    if (cst > -256 && cst < 256)
+	      *total = 0;
+	    else
+	      /* See note about optabs below.  */
+	      *total = COSTS_N_INSNS (1);
+	    return true;
+
+	  case MINUS:
+	  case COMPARE:
+	    if (cst >= 0 && cst < 256)
+	      *total = 0;
+	    else
+	      /* See note about optabs below.  */
+	      *total = COSTS_N_INSNS (1);
+	    return true;
+
+	  case ASHIFT:
+	  case ASHIFTRT:
+	  case LSHIFTRT:
 	    *total = 0;
-	  else
+	    return true;
+
+	  default:
+	    /* Constants are compared explicitly against COSTS_N_INSNS (1) in
+	       optabs.c, creating an alternative, larger code sequence for more
+	       expensive constants).  So, it doesn't pay to make some constants
+	       cost more than this.  */
 	    *total = COSTS_N_INSNS (1);
-	}
-      else
-	*total = COSTS_N_INSNS (2);
-      return true;
+	  }
+	return true;
+      }
 
     case CONST:
     case LABEL_REF:
     case SYMBOL_REF:
-      *total = COSTS_N_INSNS (2);
+      *total = COSTS_WIDE_INSNS (2);
       return true;
 
     case CONST_DOUBLE:
-      *total = COSTS_N_INSNS (4);
+      *total = COSTS_WIDE_INSNS (4);
+      return true;
+
+    case CONST_VECTOR:
+      if (TARGET_NEON
+	  && TARGET_HARD_FLOAT
+	  && outer_code == SET
+	  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
+	  && neon_immediate_valid_for_move (x, mode, NULL, NULL))
+	*total = COSTS_WIDE_INSNS (1);
+      else
+	*total = COSTS_WIDE_INSNS (4);
       return true;
 
     case HIGH:
     case LO_SUM:
       /* We prefer constant pool entries to MOVW/MOVT pairs, so bump the
-	 cost of these slightly.  */
-      *total = COSTS_N_INSNS (1) + 1;
+       cost of these slightly.  */
+      *total = COSTS_WIDE_INSNS (1) + 1;
       return true;
 
     default:
       if (mode != VOIDmode)
-	*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));
+	*total = COSTS_WIDE_INSNS (ARM_NUM_REGS (mode));
       else
-	*total = COSTS_N_INSNS (4); /* How knows?  */
+	/* A guess (inherited from arm_size_rtx_costs).  */
+	*total = COSTS_WIDE_INSNS (4);
       return false;
     }
+
+  return true;
+#undef THUMB2_LIBCALL_COST
+#undef COSTS_WIDE_INSNS
+#undef COSTS_NARROW_INSNS
 }
 
 /* RTX costs when optimizing for size.  */
@@ -7621,8 +8453,14 @@
 	       bool speed)
 {
   if (!speed)
-    return arm_size_rtx_costs (x, (enum rtx_code) code,
-			       (enum rtx_code) outer_code, total);
+    {
+      if (TARGET_THUMB2)
+	return thumb2_size_rtx_costs (x, (enum rtx_code) code,
+				      (enum rtx_code) outer_code, total);
+      else
+	return arm_size_rtx_costs (x, (enum rtx_code) code,
+				   (enum rtx_code) outer_code, total);
+    }
   else
     return current_tune->rtx_costs (x, (enum rtx_code) code,
 				    (enum rtx_code) outer_code,
@@ -8186,6 +9024,21 @@
   return cost;
 }
 
+static int
+arm_default_branch_cost (bool speed_p, bool predictable_p ATTRIBUTE_UNUSED)
+{
+  if (TARGET_32BIT)
+    return (TARGET_THUMB2 && !speed_p) ? 1 : 4;
+  else
+    return (optimize > 0) ? 2 : 0;
+}
+
+static int
+arm_cortex_a5_branch_cost (bool speed_p, bool predictable_p)
+{
+  return speed_p ? 0 : arm_default_branch_cost (speed_p, predictable_p);
+}
+
 static int fp_consts_inited = 0;
 
 /* Only zero is valid for VFP.  Other values are also valid for FPA.  */
@@ -8391,11 +9244,14 @@
    vmov  i64    17    aaaaaaaa bbbbbbbb cccccccc dddddddd
                       eeeeeeee ffffffff gggggggg hhhhhhhh
    vmov  f32    18    aBbbbbbc defgh000 00000000 00000000
+   vmov  f32    19    00000000 00000000 00000000 00000000
 
    For case 18, B = !b. Representable values are exactly those accepted by
    vfp3_const_double_index, but are output as floating-point numbers rather
    than indices.
 
+   For case 19, we will change it to vmov.i32 when assembling.
+
    Variants 0-5 (inclusive) may also be used as immediates for the second
    operand of VORR/VBIC instructions.
 
@@ -8438,7 +9294,7 @@
       rtx el0 = CONST_VECTOR_ELT (op, 0);
       REAL_VALUE_TYPE r0;
 
-      if (!vfp3_const_double_rtx (el0))
+      if (!vfp3_const_double_rtx (el0) && el0 != CONST0_RTX (GET_MODE (el0)))
         return -1;
 
       REAL_VALUE_FROM_CONST_DOUBLE (r0, el0);
@@ -8460,7 +9316,10 @@
       if (elementwidth)
         *elementwidth = 0;
 
-      return 18;
+      if (el0 == CONST0_RTX (GET_MODE (el0)))
+	return 19;
+      else
+	return 18;
     }
 
   /* Splat vector constant out into a byte vector.  */
@@ -9137,6 +9996,11 @@
   if (GET_CODE (ind) == REG)
     return arm_address_register_rtx_p (ind, 0);
 
+  /* vldm/vstm allows POST_INC (ia) and PRE_DEC (db).  */
+  if (GET_CODE (ind) == POST_INC
+      || GET_CODE (ind) == PRE_DEC)
+    return arm_address_register_rtx_p (XEXP (ind, 0), 0);
+
   return FALSE;
 }
 
@@ -9185,8 +10049,9 @@
 {
   return (TARGET_AAPCS_BASED
           && BYTES_BIG_ENDIAN
-          && (AGGREGATE_TYPE_P (valtype)
-              || TREE_CODE (valtype) == COMPLEX_TYPE));
+	  && (AGGREGATE_TYPE_P (valtype)
+	      || TREE_CODE (valtype) == COMPLEX_TYPE
+	      || FIXED_POINT_TYPE_P (valtype)));
 }
 
 /* Returns TRUE if INSN is an "LDR REG, ADDR" instruction.
@@ -9461,6 +10326,11 @@
 static bool
 arm_cannot_copy_insn_p (rtx insn)
 {
+  /* The tls call insn cannot be copied, as it is paired with a data
+     word.  */
+  if (recog_memoized (insn) == CODE_FOR_tlscall)
+    return true;
+  
   return for_each_rtx (&PATTERN (insn), arm_note_pic_base, NULL);
 }
 
@@ -10363,6 +11233,335 @@
   return true;
 }
 
+/* Copy a block of memory using plain ldr/str/ldrh/strh instructions, to permit
+   unaligned copies on processors which support unaligned semantics for those
+   instructions.  INTERLEAVE_FACTOR can be used to attempt to hide load latency
+   (using more registers) by doing e.g. load/load/store/store for a factor of 2.
+   An interleave factor of 1 (the minimum) will perform no interleaving. 
+   Load/store multiple are used for aligned addresses where possible.  */
+
+static void
+arm_block_move_unaligned_straight (rtx dstbase, rtx srcbase,
+				   HOST_WIDE_INT length,
+				   unsigned int interleave_factor)
+{
+  rtx *regs = XALLOCAVEC (rtx, interleave_factor);
+  int *regnos = XALLOCAVEC (int, interleave_factor);
+  HOST_WIDE_INT block_size_bytes = interleave_factor * UNITS_PER_WORD;
+  HOST_WIDE_INT i, j;
+  HOST_WIDE_INT remaining = length, words;
+  rtx halfword_tmp = NULL, byte_tmp = NULL;
+  rtx dst, src;
+  bool src_aligned = MEM_ALIGN (srcbase) >= BITS_PER_WORD;
+  bool dst_aligned = MEM_ALIGN (dstbase) >= BITS_PER_WORD;
+  HOST_WIDE_INT srcoffset, dstoffset;
+  HOST_WIDE_INT src_autoinc, dst_autoinc;
+  rtx mem, addr;
+  
+  gcc_assert (1 <= interleave_factor && interleave_factor <= 4);
+  
+  /* Use hard registers if we have aligned source or destination so we can use
+     load/store multiple with contiguous registers.  */
+  if (dst_aligned || src_aligned)
+    for (i = 0; i < interleave_factor; i++)
+      regs[i] = gen_rtx_REG (SImode, i);
+  else
+    for (i = 0; i < interleave_factor; i++)
+      regs[i] = gen_reg_rtx (SImode);
+
+  dst = copy_addr_to_reg (XEXP (dstbase, 0));
+  src = copy_addr_to_reg (XEXP (srcbase, 0));
+
+  srcoffset = dstoffset = 0;
+  
+  /* Calls to arm_gen_load_multiple and arm_gen_store_multiple update SRC/DST.
+     For copying the last bytes we want to subtract this offset again.  */
+  src_autoinc = dst_autoinc = 0;
+
+  for (i = 0; i < interleave_factor; i++)
+    regnos[i] = i;
+
+  /* Copy BLOCK_SIZE_BYTES chunks.  */
+
+  for (i = 0; i + block_size_bytes <= length; i += block_size_bytes)
+    {
+      /* Load words.  */
+      if (src_aligned && interleave_factor > 1)
+        {
+	  emit_insn (arm_gen_load_multiple (regnos, interleave_factor, src,
+					    TRUE, srcbase, &srcoffset));
+	  src_autoinc += UNITS_PER_WORD * interleave_factor;
+	}
+      else
+        {
+	  for (j = 0; j < interleave_factor; j++)
+	    {
+	      addr = plus_constant (src, srcoffset + j * UNITS_PER_WORD
+					 - src_autoinc);
+	      mem = adjust_automodify_address (srcbase, SImode, addr,
+					       srcoffset + j * UNITS_PER_WORD);
+	      emit_insn (gen_unaligned_loadsi (regs[j], mem));
+	    }
+	  srcoffset += block_size_bytes;
+	}
+
+      /* Store words.  */
+      if (dst_aligned && interleave_factor > 1)
+        {
+          emit_insn (arm_gen_store_multiple (regnos, interleave_factor, dst,
+					     TRUE, dstbase, &dstoffset));
+	  dst_autoinc += UNITS_PER_WORD * interleave_factor;
+	}
+      else
+        {
+	  for (j = 0; j < interleave_factor; j++)
+	    {
+	      addr = plus_constant (dst, dstoffset + j * UNITS_PER_WORD
+					 - dst_autoinc);
+	      mem = adjust_automodify_address (dstbase, SImode, addr,
+					       dstoffset + j * UNITS_PER_WORD);
+	      emit_insn (gen_unaligned_storesi (mem, regs[j]));
+	    }
+	  dstoffset += block_size_bytes;
+	}
+
+      remaining -= block_size_bytes;
+    }
+  
+  /* Copy any whole words left (note these aren't interleaved with any
+     subsequent halfword/byte load/stores in the interests of simplicity).  */
+  
+  words = remaining / UNITS_PER_WORD;
+
+  gcc_assert (words < interleave_factor);
+  
+  if (src_aligned && words > 1)
+    {
+      emit_insn (arm_gen_load_multiple (regnos, words, src, TRUE, srcbase,
+					&srcoffset));
+      src_autoinc += UNITS_PER_WORD * words;
+    }
+  else
+    {
+      for (j = 0; j < words; j++)
+        {
+	  addr = plus_constant (src,
+				srcoffset + j * UNITS_PER_WORD - src_autoinc);
+	  mem = adjust_automodify_address (srcbase, SImode, addr,
+					   srcoffset + j * UNITS_PER_WORD);
+	  emit_insn (gen_unaligned_loadsi (regs[j], mem));
+	}
+      srcoffset += words * UNITS_PER_WORD;
+    }
+
+  if (dst_aligned && words > 1)
+    {
+      emit_insn (arm_gen_store_multiple (regnos, words, dst, TRUE, dstbase,
+					 &dstoffset));
+      dst_autoinc += words * UNITS_PER_WORD;
+    }
+  else
+    {
+      for (j = 0; j < words; j++)
+        {
+	  addr = plus_constant (dst,
+				dstoffset + j * UNITS_PER_WORD - dst_autoinc);
+	  mem = adjust_automodify_address (dstbase, SImode, addr,
+					   dstoffset + j * UNITS_PER_WORD);
+	  emit_insn (gen_unaligned_storesi (mem, regs[j]));
+	}
+      dstoffset += words * UNITS_PER_WORD;
+    }
+
+  remaining -= words * UNITS_PER_WORD;
+  
+  gcc_assert (remaining < 4);
+  
+  /* Copy a halfword if necessary.  */
+  
+  if (remaining >= 2)
+    {
+      halfword_tmp = gen_reg_rtx (SImode);
+
+      addr = plus_constant (src, srcoffset - src_autoinc);
+      mem = adjust_automodify_address (srcbase, HImode, addr, srcoffset);
+      emit_insn (gen_unaligned_loadhiu (halfword_tmp, mem));
+
+      /* Either write out immediately, or delay until we've loaded the last
+	 byte, depending on interleave factor.  */
+      if (interleave_factor == 1)
+        {
+	  addr = plus_constant (dst, dstoffset - dst_autoinc);
+	  mem = adjust_automodify_address (dstbase, HImode, addr, dstoffset);
+	  emit_insn (gen_unaligned_storehi (mem,
+		       gen_lowpart (HImode, halfword_tmp)));
+	  halfword_tmp = NULL;
+	  dstoffset += 2;
+	}
+
+      remaining -= 2;
+      srcoffset += 2;
+    }
+  
+  gcc_assert (remaining < 2);
+  
+  /* Copy last byte.  */
+  
+  if ((remaining & 1) != 0)
+    {
+      byte_tmp = gen_reg_rtx (SImode);
+
+      addr = plus_constant (src, srcoffset - src_autoinc);
+      mem = adjust_automodify_address (srcbase, QImode, addr, srcoffset);
+      emit_move_insn (gen_lowpart (QImode, byte_tmp), mem);
+
+      if (interleave_factor == 1)
+        {
+	  addr = plus_constant (dst, dstoffset - dst_autoinc);
+	  mem = adjust_automodify_address (dstbase, QImode, addr, dstoffset);
+	  emit_move_insn (mem, gen_lowpart (QImode, byte_tmp));
+	  byte_tmp = NULL;
+	  dstoffset++;
+	}
+
+      remaining--;
+      srcoffset++;
+    }
+  
+  /* Store last halfword if we haven't done so already.  */
+  
+  if (halfword_tmp)
+    {
+      addr = plus_constant (dst, dstoffset - dst_autoinc);
+      mem = adjust_automodify_address (dstbase, HImode, addr, dstoffset);
+      emit_insn (gen_unaligned_storehi (mem,
+		   gen_lowpart (HImode, halfword_tmp)));
+      dstoffset += 2;
+    }
+
+  /* Likewise for last byte.  */
+
+  if (byte_tmp)
+    {
+      addr = plus_constant (dst, dstoffset - dst_autoinc);
+      mem = adjust_automodify_address (dstbase, QImode, addr, dstoffset);
+      emit_move_insn (mem, gen_lowpart (QImode, byte_tmp));
+      dstoffset++;
+    }
+  
+  gcc_assert (remaining == 0 && srcoffset == dstoffset);
+}
+
+/* From mips_adjust_block_mem:
+
+   Helper function for doing a loop-based block operation on memory
+   reference MEM.  Each iteration of the loop will operate on LENGTH
+   bytes of MEM.
+
+   Create a new base register for use within the loop and point it to
+   the start of MEM.  Create a new memory reference that uses this
+   register.  Store them in *LOOP_REG and *LOOP_MEM respectively.  */
+
+static void
+arm_adjust_block_mem (rtx mem, HOST_WIDE_INT length, rtx *loop_reg,
+		      rtx *loop_mem)
+{
+  *loop_reg = copy_addr_to_reg (XEXP (mem, 0));
+  
+  /* Although the new mem does not refer to a known location,
+     it does keep up to LENGTH bytes of alignment.  */
+  *loop_mem = change_address (mem, BLKmode, *loop_reg);
+  set_mem_align (*loop_mem, MIN (MEM_ALIGN (mem), length * BITS_PER_UNIT));
+}
+
+/* From mips_block_move_loop:
+
+   Move LENGTH bytes from SRC to DEST using a loop that moves BYTES_PER_ITER
+   bytes at a time.  LENGTH must be at least BYTES_PER_ITER.  Assume that
+   the memory regions do not overlap.  */
+
+static void
+arm_block_move_unaligned_loop (rtx dest, rtx src, HOST_WIDE_INT length,
+			       unsigned int interleave_factor,
+			       HOST_WIDE_INT bytes_per_iter)
+{
+  rtx label, src_reg, dest_reg, final_src, test;
+  HOST_WIDE_INT leftover;
+  
+  leftover = length % bytes_per_iter;
+  length -= leftover;
+  
+  /* Create registers and memory references for use within the loop.  */
+  arm_adjust_block_mem (src, bytes_per_iter, &src_reg, &src);
+  arm_adjust_block_mem (dest, bytes_per_iter, &dest_reg, &dest);
+  
+  /* Calculate the value that SRC_REG should have after the last iteration of
+     the loop.  */
+  final_src = expand_simple_binop (Pmode, PLUS, src_reg, GEN_INT (length),
+				   0, 0, OPTAB_WIDEN);
+
+  /* Emit the start of the loop.  */
+  label = gen_label_rtx ();
+  emit_label (label);
+  
+  /* Emit the loop body.  */
+  arm_block_move_unaligned_straight (dest, src, bytes_per_iter,
+				     interleave_factor);
+
+  /* Move on to the next block.  */
+  emit_move_insn (src_reg, plus_constant (src_reg, bytes_per_iter));
+  emit_move_insn (dest_reg, plus_constant (dest_reg, bytes_per_iter));
+  
+  /* Emit the loop condition.  */
+  test = gen_rtx_NE (VOIDmode, src_reg, final_src);
+  emit_jump_insn (gen_cbranchsi4 (test, src_reg, final_src, label));
+  
+  /* Mop up any left-over bytes.  */
+  if (leftover)
+    arm_block_move_unaligned_straight (dest, src, leftover, interleave_factor);
+}
+
+/* Emit a block move when either the source or destination is unaligned (not
+   aligned to a four-byte boundary).  This may need further tuning depending on
+   core type, optimize_size setting, etc.  */
+
+static int
+arm_movmemqi_unaligned (rtx *operands)
+{
+  HOST_WIDE_INT length = INTVAL (operands[2]);
+  
+  if (optimize_size)
+    {
+      bool src_aligned = MEM_ALIGN (operands[1]) >= BITS_PER_WORD;
+      bool dst_aligned = MEM_ALIGN (operands[0]) >= BITS_PER_WORD;
+      /* Inlined memcpy using ldr/str/ldrh/strh can be quite big: try to limit
+         size of code if optimizing for size.  We'll use ldm/stm if src_aligned
+	 or dst_aligned though: allow more interleaving in those cases since the
+	 resulting code can be smaller.  */
+      unsigned int interleave_factor = (src_aligned || dst_aligned) ? 2 : 1;
+      HOST_WIDE_INT bytes_per_iter = (src_aligned || dst_aligned) ? 8 : 4;
+      
+      if (length > 12)
+	arm_block_move_unaligned_loop (operands[0], operands[1], length,
+				       interleave_factor, bytes_per_iter);
+      else
+	arm_block_move_unaligned_straight (operands[0], operands[1], length,
+					   interleave_factor);
+    }
+  else
+    {
+      /* Note that the loop created by arm_block_move_unaligned_loop may be
+         subject to loop unrolling, which makes tuning this condition a little
+	 redundant.  */
+      if (length > 32)
+	arm_block_move_unaligned_loop (operands[0], operands[1], length, 4, 16);
+      else
+	arm_block_move_unaligned_straight (operands[0], operands[1], length, 4);
+    }
+  
+  return 1;
+}
+
 int
 arm_gen_movmemqi (rtx *operands)
 {
@@ -10375,8 +11574,13 @@
 
   if (GET_CODE (operands[2]) != CONST_INT
       || GET_CODE (operands[3]) != CONST_INT
-      || INTVAL (operands[2]) > 64
-      || INTVAL (operands[3]) & 3)
+      || INTVAL (operands[2]) > 64)
+    return 0;
+
+  if (unaligned_access && (INTVAL (operands[3]) & 3) != 0)
+    return arm_movmemqi_unaligned (operands);
+
+  if (INTVAL (operands[3]) & 3)
     return 0;
 
   dstbase = operands[0];
@@ -11187,7 +12391,7 @@
    aggregate types are placed in the lowest memory address.  */
 
 bool
-arm_pad_arg_upward (enum machine_mode mode, const_tree type)
+arm_pad_arg_upward (enum machine_mode mode ATTRIBUTE_UNUSED, const_tree type)
 {
   if (!TARGET_AAPCS_BASED)
     return DEFAULT_FUNCTION_ARG_PADDING(mode, type) == upward;
@@ -11200,21 +12404,33 @@
 
 
 /* Similarly, for use by BLOCK_REG_PADDING (MODE, TYPE, FIRST).
-   For non-AAPCS, return !BYTES_BIG_ENDIAN if the least significant
-   byte of the register has useful data, and return the opposite if the
-   most significant byte does.
-   For AAPCS, small aggregates and small complex types are always padded
-   upwards.  */
+   Return !BYTES_BIG_ENDIAN if the least significant byte of the
+   register has useful data, and return the opposite if the most
+   significant byte does.  */
 
 bool
-arm_pad_reg_upward (enum machine_mode mode ATTRIBUTE_UNUSED,
+arm_pad_reg_upward (enum machine_mode mode,
                     tree type, int first ATTRIBUTE_UNUSED)
 {
-  if (TARGET_AAPCS_BASED
-      && BYTES_BIG_ENDIAN
-      && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == COMPLEX_TYPE)
-      && int_size_in_bytes (type) <= 4)
-    return true;
+  if (TARGET_AAPCS_BASED && BYTES_BIG_ENDIAN)
+    {
+      /* For AAPCS, small aggregates, small fixed-point types,
+	 and small complex types are always padded upwards.  */
+      if (type)
+	{
+	  if ((AGGREGATE_TYPE_P (type)
+	       || TREE_CODE (type) == COMPLEX_TYPE
+	       || FIXED_POINT_TYPE_P (type))
+	      && int_size_in_bytes (type) <= 4)
+	    return true;
+	}
+      else
+	{
+	  if ((COMPLEX_MODE_P (mode) || ALL_FIXED_POINT_MODE_P (mode))
+	      && GET_MODE_SIZE (mode) <= 4)
+	    return true;
+	}
+    }
 
   /* Otherwise, use default padding.  */
   return !BYTES_BIG_ENDIAN;
@@ -11413,6 +12629,7 @@
 
   if (GET_CODE (insn) == JUMP_INSN
       && JUMP_LABEL (insn) != NULL
+      && !ANY_RETURN_P (JUMP_LABEL (insn))
       && ((table = next_real_insn (JUMP_LABEL (insn)))
 	  == next_real_insn (insn))
       && table != NULL
@@ -12012,7 +13229,10 @@
       gcc_assert (GET_CODE (from) != BARRIER);
 
       /* Count the length of this insn.  */
-      count += get_attr_length (from);
+      if (LABEL_P (from) && (align_jumps > 0 || align_loops > 0))
+        count += MAX (align_jumps, align_loops);
+      else
+        count += get_attr_length (from);
 
       /* If there is a jump table, add its length.  */
       tmp = is_jump_table (from);
@@ -12432,6 +13652,8 @@
 	      insn = table;
 	    }
 	}
+      else if (LABEL_P (insn) && (align_jumps > 0 || align_loops > 0))
+	address += MAX (align_jumps, align_loops);
     }
 
   fix = minipool_fix_head;
@@ -14249,7 +15471,7 @@
 /* Generate a function exit sequence.  If REALLY_RETURN is false, then do
    everything bar the final return instruction.  */
 const char *
-output_return_instruction (rtx operand, int really_return, int reverse)
+output_return_instruction (rtx operand, bool really_return, bool reverse, bool simple)
 {
   char conditional[10];
   char instr[100];
@@ -14287,10 +15509,15 @@
 
   sprintf (conditional, "%%?%%%c0", reverse ? 'D' : 'd');
 
-  cfun->machine->return_used_this_function = 1;
+  if (simple)
+    live_regs_mask = 0;
+  else
+    {
+      cfun->machine->return_used_this_function = 1;
 
-  offsets = arm_get_frame_offsets ();
-  live_regs_mask = offsets->saved_regs_mask;
+      offsets = arm_get_frame_offsets ();
+      live_regs_mask = offsets->saved_regs_mask;
+    }
 
   if (live_regs_mask)
     {
@@ -15447,7 +16674,10 @@
   offsets->soft_frame = offsets->saved_regs + CALLER_INTERWORKING_SLOT_SIZE;
   /* A leaf function does not need any stack alignment if it has nothing
      on the stack.  */
-  if (leaf && frame_size == 0)
+  if (leaf && frame_size == 0
+      /* However if it calls alloca(), we have a dynamically allocated
+	 block of BIGGEST_ALIGNMENT on stack, so still do stack alignment.  */
+      && ! cfun->calls_alloca)
     {
       offsets->outgoing_args = offsets->soft_frame;
       offsets->locals_base = offsets->soft_frame;
@@ -17054,10 +18284,10 @@
    decremented/zeroed by arm_asm_output_opcode as the insns are output.  */
 
 /* Returns the index of the ARM condition code string in
-   `arm_condition_codes'.  COMPARISON should be an rtx like
-   `(eq (...) (...))'.  */
-static enum arm_cond_code
-get_arm_condition_code (rtx comparison)
+   `arm_condition_codes', or ARM_NV if the comparison is invalid.
+   COMPARISON should be an rtx like `(eq (...) (...))'.  */
+enum arm_cond_code
+maybe_get_arm_condition_code (rtx comparison)
 {
   enum machine_mode mode = GET_MODE (XEXP (comparison, 0));
   enum arm_cond_code code;
@@ -17081,11 +18311,11 @@
     case CC_DLTUmode: code = ARM_CC;
 
     dominance:
-      gcc_assert (comp_code == EQ || comp_code == NE);
-
       if (comp_code == EQ)
 	return ARM_INVERSE_CONDITION_CODE (code);
-      return code;
+      if (comp_code == NE)
+	return code;
+      return ARM_NV;
 
     case CC_NOOVmode:
       switch (comp_code)
@@ -17094,7 +18324,7 @@
 	case EQ: return ARM_EQ;
 	case GE: return ARM_PL;
 	case LT: return ARM_MI;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CC_Zmode:
@@ -17102,7 +18332,7 @@
 	{
 	case NE: return ARM_NE;
 	case EQ: return ARM_EQ;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CC_Nmode:
@@ -17110,7 +18340,7 @@
 	{
 	case NE: return ARM_MI;
 	case EQ: return ARM_PL;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CCFPEmode:
@@ -17135,7 +18365,7 @@
 	  /* UNEQ and LTGT do not have a representation.  */
 	case UNEQ: /* Fall through.  */
 	case LTGT: /* Fall through.  */
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CC_SWPmode:
@@ -17151,7 +18381,7 @@
 	case GTU: return ARM_CC;
 	case LEU: return ARM_CS;
 	case LTU: return ARM_HI;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CC_Cmode:
@@ -17159,7 +18389,7 @@
 	{
 	case LTU: return ARM_CS;
 	case GEU: return ARM_CC;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CC_CZmode:
@@ -17171,7 +18401,7 @@
 	case GTU: return ARM_HI;
 	case LEU: return ARM_LS;
 	case LTU: return ARM_CC;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CC_NCVmode:
@@ -17181,7 +18411,7 @@
 	case LT: return ARM_LT;
 	case GEU: return ARM_CS;
 	case LTU: return ARM_CC;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     case CCmode:
@@ -17197,13 +18427,22 @@
 	case GTU: return ARM_HI;
 	case LEU: return ARM_LS;
 	case LTU: return ARM_CC;
-	default: gcc_unreachable ();
+	default: return ARM_NV;
 	}
 
     default: gcc_unreachable ();
     }
 }
 
+/* Like maybe_get_arm_condition_code, but never return ARM_NV.  */
+static enum arm_cond_code
+get_arm_condition_code (rtx comparison)
+{
+  enum arm_cond_code code = maybe_get_arm_condition_code (comparison);
+  gcc_assert (code != ARM_NV);
+  return code;
+}
+
 /* Tell arm_asm_output_opcode to output IT blocks for conditionally executed
    instructions.  */
 void
@@ -17295,6 +18534,7 @@
 
   /* If we start with a return insn, we only succeed if we find another one.  */
   int seeking_return = 0;
+  enum rtx_code return_code = UNKNOWN;
 
   /* START_INSN will hold the insn from where we start looking.  This is the
      first insn after the following code_label if REVERSE is true.  */
@@ -17333,7 +18573,7 @@
 	  else
 	    return;
 	}
-      else if (GET_CODE (body) == RETURN)
+      else if (ANY_RETURN_P (body))
         {
 	  start_insn = next_nonnote_insn (start_insn);
 	  if (GET_CODE (start_insn) == BARRIER)
@@ -17344,6 +18584,7 @@
 	    {
 	      reverse = TRUE;
 	      seeking_return = 1;
+	      return_code = GET_CODE (body);
 	    }
 	  else
 	    return;
@@ -17384,11 +18625,15 @@
 	  label = XEXP (XEXP (SET_SRC (body), 2), 0);
 	  then_not_else = FALSE;
 	}
-      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN)
-	seeking_return = 1;
-      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN)
+      else if (ANY_RETURN_P (XEXP (SET_SRC (body), 1)))
+	{
+	  seeking_return = 1;
+	  return_code = GET_CODE (XEXP (SET_SRC (body), 1));
+	}
+      else if (ANY_RETURN_P (XEXP (SET_SRC (body), 2)))
         {
 	  seeking_return = 1;
+	  return_code = GET_CODE (XEXP (SET_SRC (body), 2));
 	  then_not_else = FALSE;
         }
       else
@@ -17489,8 +18734,7 @@
 		       && !use_return_insn (TRUE, NULL)
 		       && !optimize_size)
 		fail = TRUE;
-	      else if (GET_CODE (scanbody) == RETURN
-		       && seeking_return)
+	      else if (GET_CODE (scanbody) == return_code)
 	        {
 		  arm_ccfsm_state = 2;
 		  succeed = TRUE;
@@ -17657,7 +18901,7 @@
 	return mode == SImode;
 
       if (IS_IWMMXT_REGNUM (regno))
-	return VALID_IWMMXT_REG_MODE (mode);
+	return VALID_IWMMXT_REG_MODE (mode) && mode != SImode;
     }
   
   /* We allow almost any value to be stored in the general registers.
@@ -19205,6 +20449,8 @@
 {
   if (mode == HFmode)
     return (arm_fp16_format != ARM_FP16_FORMAT_NONE);
+  else if (ALL_FIXED_POINT_MODE_P (mode))
+    return true;
   else
     return default_scalar_mode_supported_p (mode);
 }
@@ -21547,6 +22793,10 @@
 	val = 6;
       asm_fprintf (asm_out_file, "\t.eabi_attribute 30, %d\n", val);
 
+      /* Tag_CPU_unaligned_access.  */
+      asm_fprintf (asm_out_file, "\t.eabi_attribute 34, %d\n",
+		   unaligned_access);
+
       /* Tag_ABI_FP_16bit_format.  */
       if (arm_fp16_format)
 	asm_fprintf (asm_out_file, "\t.eabi_attribute 38, %d\n",
@@ -22287,6 +23537,11 @@
 	  || (mode == V8QImode)))
     return true;
 
+  if (TARGET_INT_SIMD && (mode == V4UQQmode || mode == V4QQmode
+      || mode == V2UHQmode || mode == V2HQmode || mode == V2UHAmode
+      || mode == V2HAmode))
+    return true;
+
   return false;
 }
 
@@ -22333,15 +23588,18 @@
 }
 
 /* Implement TARGET_CLASS_LIKELY_SPILLED_P.
- 
-   We need to define this for LO_REGS on thumb.  Otherwise we can end up
+
+   We need to define this for LO_REGS on Thumb-1.  Otherwise we can end up
    using r0-r4 for function arguments, r7 for the stack frame and don't
-   have enough left over to do doubleword arithmetic.  */
+   have enough left over to do doubleword arithmetic.  For Thumb-2 all the
+   potentially problematic instructions accept high registers so this is not
+   necessary.  Care needs to be taken to avoid adding new Thumb-2 patterns
+   that require many low registers.  */
 
 static bool
 arm_class_likely_spilled_p (reg_class_t rclass)
 {
-  if ((TARGET_THUMB && rclass == LO_REGS)
+  if ((TARGET_THUMB1 && rclass == LO_REGS)
       || rclass  == CC_REG)
     return true;
 
@@ -22820,6 +24078,9 @@
     case TLS_LE32:
       fputs ("(tpoff)", fp);
       break;
+    case TLS_DESCSEQ:
+      fputs ("(tlsdesc)", fp);
+      break;
     default:
       gcc_unreachable ();
     }
@@ -22829,9 +24090,11 @@
     case TLS_GD32:
     case TLS_LDM32:
     case TLS_IE32:
+    case TLS_DESCSEQ:
       fputs (" + (. - ", fp);
       output_addr_const (fp, XVECEXP (x, 0, 2));
-      fputs (" - ", fp);
+      /* For DESCSEQ the 3rd operand encodes thumbness, and is added */
+      fputs (reloc == TLS_DESCSEQ ? " + " : " - ", fp);
       output_addr_const (fp, XVECEXP (x, 0, 3));
       fputc (')', fp);
       break;
@@ -22995,6 +24258,7 @@
     {
     case cortexr4:
     case cortexr4f:
+    case cortexr5:
     case cortexa5:
     case cortexa8:
     case cortexa9:
@@ -23539,10 +24803,13 @@
 static bool
 arm_vector_alignment_reachable (const_tree type, bool is_packed)
 {
-  /* Vectors which aren't in packed structures will not be less aligned than
-     the natural alignment of their element type, so this is safe.  */
+  /* NOTE: returning true here will unconditionally peel loop iterations so
+     that aligned accesses can be used.  This is undesirable when misaligned
+     accesses are available, particularly for small loop iteration counts,
+     since the overhead for dispatching to multiple versions of the loop is
+     quite high.  */
   if (TARGET_NEON && !BYTES_BIG_ENDIAN)
-    return !is_packed;
+    return false;
 
   return default_builtin_vector_alignment_reachable (type, is_packed);
 }
diff -ru ./gcc/config/arm/arm-cores.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-cores.def
--- ./gcc/config/arm/arm-cores.def	2014-06-06 11:50:14.367598556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-cores.def	2012-03-29 18:03:11.000000000 +1000
@@ -70,10 +70,10 @@
 /* V4 Architecture Processors */
 ARM_CORE("arm8",          arm8,		4,	             FL_MODE26 | FL_LDSCHED, fastmul)
 ARM_CORE("arm810",        arm810,	4,	             FL_MODE26 | FL_LDSCHED, fastmul)
-ARM_CORE("strongarm",     strongarm,	4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)
-ARM_CORE("strongarm110",  strongarm110,	4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)
-ARM_CORE("strongarm1100", strongarm1100, 4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)
-ARM_CORE("strongarm1110", strongarm1110, 4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, fastmul)
+ARM_CORE("strongarm",     strongarm,	4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
+ARM_CORE("strongarm110",  strongarm110,	4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
+ARM_CORE("strongarm1100", strongarm1100, 4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
+ARM_CORE("strongarm1110", strongarm1110, 4,	             FL_MODE26 | FL_LDSCHED | FL_STRONG, strongarm)
 ARM_CORE("fa526",         fa526,        4,                               FL_LDSCHED, fastmul)
 ARM_CORE("fa626",         fa626,        4,                               FL_LDSCHED, fastmul)
 
@@ -122,15 +122,16 @@
 ARM_CORE("arm1176jzf-s",  arm1176jzfs,	6ZK,				 FL_LDSCHED | FL_VFPV2, 9e)
 ARM_CORE("mpcorenovfp",	  mpcorenovfp,	6K,				 FL_LDSCHED, 9e)
 ARM_CORE("mpcore",	  mpcore,	6K,				 FL_LDSCHED | FL_VFPV2, 9e)
-ARM_CORE("arm1156t2-s",	  arm1156t2s,	6T2,				 FL_LDSCHED, 9e)
-ARM_CORE("arm1156t2f-s",  arm1156t2fs,  6T2,				 FL_LDSCHED | FL_VFPV2, 9e)
-ARM_CORE("cortex-a5",	  cortexa5,	7A,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-a8",	  cortexa8,	7A,				 FL_LDSCHED, 9e)
+ARM_CORE("arm1156t2-s",	  arm1156t2s,	6T2,				 FL_LDSCHED, v6t2)
+ARM_CORE("arm1156t2f-s",  arm1156t2fs,  6T2,				 FL_LDSCHED | FL_VFPV2, v6t2)
+ARM_CORE("cortex-a5",	  cortexa5,	7A,				 FL_LDSCHED, cortex_a5)
+ARM_CORE("cortex-a8",	  cortexa8,	7A,				 FL_LDSCHED, cortex)
 ARM_CORE("cortex-a9",	  cortexa9,	7A,				 FL_LDSCHED, cortex_a9)
-ARM_CORE("cortex-a15",	  cortexa15,	7A,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-r4",	  cortexr4,	7R,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-r4f",	  cortexr4f,	7R,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-m4",	  cortexm4,	7EM,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-m3",	  cortexm3,	7M,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-m1",	  cortexm1,	6M,				 FL_LDSCHED, 9e)
-ARM_CORE("cortex-m0",	  cortexm0,	6M,				 FL_LDSCHED, 9e)
+ARM_CORE("cortex-a15",	  cortexa15,	7A,				 FL_LDSCHED, cortex)
+ARM_CORE("cortex-r4",	  cortexr4,	7R,				 FL_LDSCHED, cortex)
+ARM_CORE("cortex-r4f",	  cortexr4f,	7R,				 FL_LDSCHED, cortex)
+ARM_CORE("cortex-r5",	  cortexr5,	7R,				 FL_LDSCHED | FL_ARM_DIV, cortex)
+ARM_CORE("cortex-m4",	  cortexm4,	7EM,				 FL_LDSCHED, cortex)
+ARM_CORE("cortex-m3",	  cortexm3,	7M,				 FL_LDSCHED, cortex)
+ARM_CORE("cortex-m1",	  cortexm1,	6SM,				 FL_LDSCHED, cortex)
+ARM_CORE("cortex-m0",	  cortexm0,	6SM,				 FL_LDSCHED, cortex)
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: arm-fixed.md
diff -ru ./gcc/config/arm/arm.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.h
--- ./gcc/config/arm/arm.h	2014-06-06 14:25:27.270150544 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.h	2012-03-29 18:03:11.000000000 +1000
@@ -103,6 +103,8 @@
 	      builtin_define ("__ARM_PCS");		\
 	    builtin_define ("__ARM_EABI__");		\
 	  }						\
+	if (TARGET_IDIV)				\
+	  builtin_define ("__ARM_ARCH_EXT_IDIV__");	\
     } while (0)
 
 /* The various ARM cores.  */
@@ -233,6 +235,7 @@
 
 #define TARGET_HARD_TP			(target_thread_pointer == TP_CP15)
 #define TARGET_SOFT_TP			(target_thread_pointer == TP_SOFT)
+#define TARGET_GNU2_TLS			(target_tls_dialect == TLS_GNU2)
 
 /* Only 16-bit thumb code.  */
 #define TARGET_THUMB1			(TARGET_THUMB && !arm_arch_thumb2)
@@ -284,7 +287,8 @@
   (TARGET_32BIT && arm_arch6 && (arm_arch_notm || arm_arch7em))
 
 /* Should MOVW/MOVT be used in preference to a constant pool.  */
-#define TARGET_USE_MOVT (arm_arch_thumb2 && !optimize_size)
+#define TARGET_USE_MOVT \
+  (arm_arch_thumb2 && !optimize_size && !current_tune->prefer_constant_pool)
 
 /* We could use unified syntax for arm mode, but for now we just use it
    for Thumb-2.  */
@@ -305,6 +309,10 @@
 /* Nonzero if this chip supports ldrex{bhd} and strex{bhd}.  */
 #define TARGET_HAVE_LDREXBHD	((arm_arch6k && TARGET_ARM) || arm_arch7)
 
+/* Nonzero if integer division instructions supported.  */
+#define TARGET_IDIV		((TARGET_ARM && arm_arch_arm_hwdiv) \
+				 || (TARGET_THUMB2 && arm_arch_thumb_hwdiv))
+
 /* True iff the full BPABI is being used.  If TARGET_BPABI is true,
    then TARGET_AAPCS_BASED must be true -- but the converse does not
    hold.  TARGET_BPABI implies the use of the BPABI runtime library,
@@ -322,7 +330,8 @@
    --with-float is ignored if -mhard-float, -msoft-float or -mfloat-abi are
    specified.
    --with-fpu is ignored if -mfpu is specified.
-   --with-abi is ignored is -mabi is specified.  */
+   --with-abi is ignored is -mabi is specified.
+   --with-tls is ignored if -mtls-dialect is specified. */
 #define OPTION_DEFAULT_SPECS \
   {"arch", "%{!march=*:%{!mcpu=*:-march=%(VALUE)}}" }, \
   {"cpu", "%{!march=*:%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
@@ -331,7 +340,8 @@
     "%{!msoft-float:%{!mhard-float:%{!mfloat-abi=*:-mfloat-abi=%(VALUE)}}}" }, \
   {"fpu", "%{!mfpu=*:-mfpu=%(VALUE)}"}, \
   {"abi", "%{!mabi=*:-mabi=%(VALUE)}"}, \
-  {"mode", "%{!marm:%{!mthumb:-m%(VALUE)}}"},
+  {"mode", "%{!marm:%{!mthumb:-m%(VALUE)}}"}, \
+  {"tls", "%{!mtls-dialect=*:-mtls-dialect=%(VALUE)}"},
 
 /* Which floating point model to use.  */
 enum arm_fp_model
@@ -417,7 +427,13 @@
   TP_CP15
 };
 
+enum arm_tls_type {
+  TLS_GNU,
+  TLS_GNU2
+};
+
 extern enum arm_tp_type target_thread_pointer;
+extern enum arm_tls_type target_tls_dialect;
 
 /* Nonzero if this chip supports the ARM Architecture 3M extensions.  */
 extern int arm_arch3m;
@@ -489,8 +505,11 @@
 /* Nonzero if chip supports Thumb 2.  */
 extern int arm_arch_thumb2;
 
-/* Nonzero if chip supports integer division instruction.  */
-extern int arm_arch_hwdiv;
+/* Nonzero if chip supports integer division instruction in ARM mode.  */
+extern int arm_arch_arm_hwdiv;
+
+/* Nonzero if chip supports integer division instruction in Thumb mode.  */
+extern int arm_arch_thumb_hwdiv;
 
 #ifndef TARGET_DEFAULT
 #define TARGET_DEFAULT  (MASK_APCS_FRAME)
@@ -652,6 +671,20 @@
 #define WCHAR_TYPE_SIZE BITS_PER_WORD
 #endif
 
+/* Sized for fixed-point types.  */
+
+#define SHORT_FRACT_TYPE_SIZE 8
+#define FRACT_TYPE_SIZE 16
+#define LONG_FRACT_TYPE_SIZE 32
+#define LONG_LONG_FRACT_TYPE_SIZE 64
+
+#define SHORT_ACCUM_TYPE_SIZE 16
+#define ACCUM_TYPE_SIZE 32
+#define LONG_ACCUM_TYPE_SIZE 64
+#define LONG_LONG_ACCUM_TYPE_SIZE 64
+
+#define MAX_FIXED_MODE_SIZE 64
+
 #ifndef SIZE_TYPE
 #define SIZE_TYPE (TARGET_AAPCS_BASED ? "unsigned int" : "long unsigned int")
 #endif
@@ -1001,7 +1034,7 @@
   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))
 
 #define VALID_IWMMXT_REG_MODE(MODE) \
- (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)
+ (arm_vector_mode_supported_p (MODE) || (MODE) == DImode || (MODE) == SImode)
 
 /* Modes valid for Neon D registers.  */
 #define VALID_NEON_DREG_MODE(MODE) \
@@ -1187,7 +1220,7 @@
    when addressing quantities in QI or HI mode; if we don't know the
    mode, then we must be conservative.  */
 #define MODE_BASE_REG_CLASS(MODE)					\
-    (TARGET_32BIT ? CORE_REGS :					\
+    (TARGET_ARM || (TARGET_THUMB2 && !optimize_size) ? CORE_REGS :	\
      (((MODE) == SImode) ? BASE_REGS : LO_REGS))
 
 /* For Thumb we can not support SP+reg addressing, so we return LO_REGS
@@ -1209,6 +1242,7 @@
   (TARGET_32BIT ? (CLASS) :				\
    ((CLASS) == GENERAL_REGS || (CLASS) == HI_REGS	\
     || (CLASS) == NO_REGS || (CLASS) == STACK_REG	\
+    || (CLASS) == CORE_REGS				\
    ? LO_REGS : (CLASS)))
 
 /* Must leave BASE_REGS reloads alone */
@@ -2041,7 +2075,8 @@
 /* Try to generate sequences that don't involve branches, we can then use
    conditional instructions */
 #define BRANCH_COST(speed_p, predictable_p) \
-  (TARGET_32BIT ? 4 : (optimize > 0 ? 2 : 0))
+  (current_tune->branch_cost (speed_p, predictable_p))
+
 
 /* Position Independent Code.  */
 /* We decide which register to use based on the compilation options and
@@ -2257,6 +2292,8 @@
 #define RETURN_ADDR_RTX(COUNT, FRAME) \
   arm_return_addr (COUNT, FRAME)
 
+#define RETURN_ADDR_REGNUM LR_REGNUM
+
 /* Mask of the bits in the PC that contain the real return address
    when running in 26-bit mode.  */
 #define RETURN_ADDR_MASK26 (0x03fffffc)
diff -ru ./gcc/config/arm/arm.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.md
--- ./gcc/config/arm/arm.md	2014-06-06 11:50:15.127598585 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.md	2012-04-18 18:11:41.000000000 +1000
@@ -31,6 +31,7 @@
 ;; Register numbers
 (define_constants
   [(R0_REGNUM        0)		; First CORE register
+   (R1_REGNUM	     1)		; Second CORE register
    (IP_REGNUM	    12)		; Scratch register
    (SP_REGNUM	    13)		; Stack pointer
    (LR_REGNUM       14)		; Return address register
@@ -104,7 +105,11 @@
    (UNSPEC_SYMBOL_OFFSET 27) ; The offset of the start of the symbol from
                              ; another symbolic address.
    (UNSPEC_MEMORY_BARRIER 28) ; Represent a memory barrier.
-   (UNSPEC_PIC_UNIFIED 29)  ; Create a common pic addressing form.
+   (UNSPEC_UNALIGNED_LOAD 29) ; Used to represent ldr/ldrh instructions that
+			      ; access unaligned locations, on architectures
+			      ; which support that.
+   (UNSPEC_UNALIGNED_STORE 30) ; Same for str/strh.
+   (UNSPEC_PIC_UNIFIED 31)  ; Create a common pic addressing form.
   ]
 )
 
@@ -137,6 +142,8 @@
    (VUNSPEC_WCMP_EQ  12) ; Used by the iWMMXt WCMPEQ instructions
    (VUNSPEC_WCMP_GTU 13) ; Used by the iWMMXt WCMPGTU instructions
    (VUNSPEC_WCMP_GT  14) ; Used by the iwMMXT WCMPGT instructions
+   (VUNSPEC_ALIGN16  15) ; Used to force 16-byte alignment.
+   (VUNSPEC_ALIGN32  16) ; Used to force 32-byte alignment.
    (VUNSPEC_EH_RETURN 20); Use to override the return address for exception
 			 ; handling.
    (VUNSPEC_SYNC_COMPARE_AND_SWAP 21)	; Represent an atomic compare swap.
@@ -150,6 +157,9 @@
 ;;---------------------------------------------------------------------------
 ;; Attributes
 
+;; Processor type.  This is created automatically from arm-cores.def.
+(include "arm-tune.md")
+
 ; IS_THUMB is set to 'yes' when we are generating Thumb code, and 'no' when
 ; generating ARM code.  This is used to control the length of some insn
 ; patterns that share the same RTL in both ARM and Thumb code.
@@ -193,7 +203,7 @@
 ; for ARM or Thumb-2 with arm_arch6, and nov6 for ARM without
 ; arm_arch6.  This attribute is used to compute attribute "enabled",
 ; use type "any" to enable an alternative in all cases.
-(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6"
+(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6,onlya8,nota8,vfp9,notvfp9"
   (const_string "any"))
 
 (define_attr "arch_enabled" "no,yes"
@@ -226,6 +236,24 @@
 
 	 (and (eq_attr "arch" "nov6")
 	      (ne (symbol_ref "(TARGET_32BIT && !arm_arch6)") (const_int 0)))
+	 (const_string "yes")
+
+	 (and (eq_attr "arch" "onlya8")
+	      (eq_attr "tune" "cortexa8"))
+	 (const_string "yes")
+
+	 (and (eq_attr "arch" "nota8")
+	      (not (eq_attr "tune" "cortexa8")))
+	 (const_string "yes")
+
+	 (and (eq_attr "arch" "vfp9")
+	      (ne (symbol_ref "(TARGET_32BIT && !(arm_arch6 || TARGET_VFP3))")
+	          (const_int 0)))
+	 (const_string "yes")
+
+	 (and (eq_attr "arch" "notvfp9")
+	      (ne (symbol_ref "(TARGET_32BIT && (arm_arch6 || TARGET_VFP3))")
+	          (const_int 0)))
 	 (const_string "yes")]
 	(const_string "no")))
 
@@ -338,8 +366,6 @@
 (define_attr "ldsched" "no,yes" (const (symbol_ref "arm_ld_sched")))
 
 ;; Classification of NEON instructions for scheduling purposes.
-;; Do not set this attribute and the "type" attribute together in
-;; any one instruction pattern.
 (define_attr "neon_type"
    "neon_int_1,\
    neon_int_2,\
@@ -486,12 +512,9 @@
 ;;---------------------------------------------------------------------------
 ;; Pipeline descriptions
 
-;; Processor type.  This is created automatically from arm-cores.def.
-(include "arm-tune.md")
-
 (define_attr "tune_cortexr4" "yes,no"
   (const (if_then_else
-	  (eq_attr "tune" "cortexr4,cortexr4f")
+	  (eq_attr "tune" "cortexr4,cortexr4f,cortexr5")
 	  (const_string "yes")
 	  (const_string "no"))))
 
@@ -2385,10 +2408,10 @@
 ;;; this insv pattern, so this pattern needs to be reevalutated.
 
 (define_expand "insv"
-  [(set (zero_extract:SI (match_operand:SI 0 "s_register_operand" "")
-                         (match_operand:SI 1 "general_operand" "")
-                         (match_operand:SI 2 "general_operand" ""))
-        (match_operand:SI 3 "reg_or_int_operand" ""))]
+  [(set (zero_extract (match_operand 0 "nonimmediate_operand" "")
+                      (match_operand 1 "general_operand" "")
+                      (match_operand 2 "general_operand" ""))
+        (match_operand 3 "reg_or_int_operand" ""))]
   "TARGET_ARM || arm_arch_thumb2"
   "
   {
@@ -2399,35 +2422,70 @@
 
     if (arm_arch_thumb2)
       {
-	bool use_bfi = TRUE;
-
-	if (GET_CODE (operands[3]) == CONST_INT)
+        if (unaligned_access && MEM_P (operands[0])
+	    && s_register_operand (operands[3], GET_MODE (operands[3]))
+	    && (width == 16 || width == 32) && (start_bit % BITS_PER_UNIT) == 0)
 	  {
-	    HOST_WIDE_INT val = INTVAL (operands[3]) & mask;
+	    rtx base_addr;
 
-	    if (val == 0)
+	    if (BYTES_BIG_ENDIAN)
+	      start_bit = GET_MODE_BITSIZE (GET_MODE (operands[3])) - width
+			  - start_bit;
+
+	    if (width == 32)
 	      {
-		emit_insn (gen_insv_zero (operands[0], operands[1],
-					  operands[2]));
-		DONE;
+	        base_addr = adjust_address (operands[0], SImode,
+					    start_bit / BITS_PER_UNIT);
+		emit_insn (gen_unaligned_storesi (base_addr, operands[3]));
 	      }
+	    else
+	      {
+	        rtx tmp = gen_reg_rtx (HImode);
 
-	    /* See if the set can be done with a single orr instruction.  */
-	    if (val == mask && const_ok_for_arm (val << start_bit))
-	      use_bfi = FALSE;
+	        base_addr = adjust_address (operands[0], HImode,
+					    start_bit / BITS_PER_UNIT);
+		emit_move_insn (tmp, gen_lowpart (HImode, operands[3]));
+		emit_insn (gen_unaligned_storehi (base_addr, tmp));
+	      }
+	    DONE;
 	  }
-	  
-	if (use_bfi)
+	else if (s_register_operand (operands[0], GET_MODE (operands[0])))
 	  {
-	    if (GET_CODE (operands[3]) != REG)
-	      operands[3] = force_reg (SImode, operands[3]);
+	    bool use_bfi = TRUE;
 
-	    emit_insn (gen_insv_t2 (operands[0], operands[1], operands[2],
-				    operands[3]));
-	    DONE;
+	    if (GET_CODE (operands[3]) == CONST_INT)
+	      {
+		HOST_WIDE_INT val = INTVAL (operands[3]) & mask;
+
+		if (val == 0)
+		  {
+		    emit_insn (gen_insv_zero (operands[0], operands[1],
+					      operands[2]));
+		    DONE;
+		  }
+
+		/* See if the set can be done with a single orr instruction.  */
+		if (val == mask && const_ok_for_arm (val << start_bit))
+		  use_bfi = FALSE;
+	      }
+
+	    if (use_bfi)
+	      {
+		if (GET_CODE (operands[3]) != REG)
+		  operands[3] = force_reg (SImode, operands[3]);
+
+		emit_insn (gen_insv_t2 (operands[0], operands[1], operands[2],
+					operands[3]));
+		DONE;
+	      }
 	  }
+	else
+	  FAIL;
       }
 
+    if (!s_register_operand (operands[0], GET_MODE (operands[0])))
+      FAIL;
+
     target = copy_rtx (operands[0]);
     /* Avoid using a subreg as a subtarget, and avoid writing a paradoxical 
        subreg as the final target.  */
@@ -3619,12 +3677,10 @@
 ;; to reduce register pressure later on.
 
 (define_expand "extzv"
-  [(set (match_dup 4)
-	(ashift:SI (match_operand:SI   1 "register_operand" "")
-		   (match_operand:SI   2 "const_int_operand" "")))
-   (set (match_operand:SI              0 "register_operand" "")
-	(lshiftrt:SI (match_dup 4)
-		     (match_operand:SI 3 "const_int_operand" "")))]
+  [(set (match_operand 0 "s_register_operand" "")
+	(zero_extract (match_operand 1 "nonimmediate_operand" "")
+		      (match_operand 2 "const_int_operand" "")
+		      (match_operand 3 "const_int_operand" "")))]
   "TARGET_THUMB1 || arm_arch_thumb2"
   "
   {
@@ -3633,10 +3689,57 @@
     
     if (arm_arch_thumb2)
       {
-	emit_insn (gen_extzv_t2 (operands[0], operands[1], operands[2],
-				 operands[3]));
-	DONE;
+	HOST_WIDE_INT width = INTVAL (operands[2]);
+	HOST_WIDE_INT bitpos = INTVAL (operands[3]);
+
+	if (unaligned_access && MEM_P (operands[1])
+	    && (width == 16 || width == 32) && (bitpos % BITS_PER_UNIT) == 0)
+	  {
+	    rtx base_addr;
+
+	    if (BYTES_BIG_ENDIAN)
+	      bitpos = GET_MODE_BITSIZE (GET_MODE (operands[0])) - width
+		       - bitpos;
+
+	    if (width == 32)
+              {
+		base_addr = adjust_address (operands[1], SImode,
+					    bitpos / BITS_PER_UNIT);
+		emit_insn (gen_unaligned_loadsi (operands[0], base_addr));
+              }
+	    else
+              {
+		rtx dest = operands[0];
+		rtx tmp = gen_reg_rtx (SImode);
+
+		/* We may get a paradoxical subreg here.  Strip it off.  */
+		if (GET_CODE (dest) == SUBREG
+		    && GET_MODE (dest) == SImode
+		    && GET_MODE (SUBREG_REG (dest)) == HImode)
+		  dest = SUBREG_REG (dest);
+
+		if (GET_MODE_BITSIZE (GET_MODE (dest)) != width)
+		  FAIL;
+
+		base_addr = adjust_address (operands[1], HImode,
+					    bitpos / BITS_PER_UNIT);
+		emit_insn (gen_unaligned_loadhiu (tmp, base_addr));
+		emit_move_insn (gen_lowpart (SImode, dest), tmp);
+	      }
+	    DONE;
+	  }
+	else if (s_register_operand (operands[1], GET_MODE (operands[1])))
+	  {
+	    emit_insn (gen_extzv_t2 (operands[0], operands[1], operands[2],
+				     operands[3]));
+	    DONE;
+	  }
+	else
+	  FAIL;
       }
+    
+    if (!s_register_operand (operands[1], GET_MODE (operands[1])))
+      FAIL;
 
     operands[3] = GEN_INT (rshift);
     
@@ -3646,12 +3749,154 @@
         DONE;
       }
       
-    operands[2] = GEN_INT (lshift);
-    operands[4] = gen_reg_rtx (SImode);
+    emit_insn (gen_extzv_t1 (operands[0], operands[1], GEN_INT (lshift),
+			     operands[3], gen_reg_rtx (SImode)));
+    DONE;
   }"
 )
 
-(define_insn "extv"
+;; Helper for extzv, for the Thumb-1 register-shifts case.
+
+(define_expand "extzv_t1"
+  [(set (match_operand:SI 4 "s_register_operand" "")
+	(ashift:SI (match_operand:SI 1 "nonimmediate_operand" "")
+		   (match_operand:SI 2 "const_int_operand" "")))
+   (set (match_operand:SI 0 "s_register_operand" "")
+	(lshiftrt:SI (match_dup 4)
+		     (match_operand:SI 3 "const_int_operand" "")))]
+  "TARGET_THUMB1"
+  "")
+
+(define_expand "extv"
+  [(set (match_operand 0 "s_register_operand" "")
+	(sign_extract (match_operand 1 "nonimmediate_operand" "")
+		      (match_operand 2 "const_int_operand" "")
+		      (match_operand 3 "const_int_operand" "")))]
+  "arm_arch_thumb2"
+{
+  HOST_WIDE_INT width = INTVAL (operands[2]);
+  HOST_WIDE_INT bitpos = INTVAL (operands[3]);
+
+  if (unaligned_access && MEM_P (operands[1]) && (width == 16 || width == 32)
+      && (bitpos % BITS_PER_UNIT)  == 0)
+    {
+      rtx base_addr;
+      
+      if (BYTES_BIG_ENDIAN)
+	bitpos = GET_MODE_BITSIZE (GET_MODE (operands[0])) - width - bitpos;
+      
+      if (width == 32)
+        {
+	  base_addr = adjust_address (operands[1], SImode,
+				      bitpos / BITS_PER_UNIT);
+	  emit_insn (gen_unaligned_loadsi (operands[0], base_addr));
+        }
+      else
+        {
+	  rtx dest = operands[0];
+	  rtx tmp = gen_reg_rtx (SImode);
+	  
+	  /* We may get a paradoxical subreg here.  Strip it off.  */
+	  if (GET_CODE (dest) == SUBREG
+	      && GET_MODE (dest) == SImode
+	      && GET_MODE (SUBREG_REG (dest)) == HImode)
+	    dest = SUBREG_REG (dest);
+	  
+	  if (GET_MODE_BITSIZE (GET_MODE (dest)) != width)
+	    FAIL;
+	  
+	  base_addr = adjust_address (operands[1], HImode,
+				      bitpos / BITS_PER_UNIT);
+	  emit_insn (gen_unaligned_loadhis (tmp, base_addr));
+	  emit_move_insn (gen_lowpart (SImode, dest), tmp);
+	}
+
+      DONE;
+    }
+  else if (!s_register_operand (operands[1], GET_MODE (operands[1])))
+    FAIL;
+  else if (GET_MODE (operands[0]) == SImode
+	   && GET_MODE (operands[1]) == SImode)
+    {
+      emit_insn (gen_extv_regsi (operands[0], operands[1], operands[2],
+				 operands[3]));
+      DONE;
+    }
+
+  FAIL;
+})
+
+; Helper to expand register forms of extv with the proper modes.
+
+(define_expand "extv_regsi"
+  [(set (match_operand:SI 0 "s_register_operand" "")
+	(sign_extract:SI (match_operand:SI 1 "s_register_operand" "")
+			 (match_operand 2 "const_int_operand" "")
+			 (match_operand 3 "const_int_operand" "")))]
+  ""
+{
+})
+
+; ARMv6+ unaligned load/store instructions (used for packed structure accesses).
+
+(define_insn "unaligned_loadsi"
+  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+	(unspec:SI [(match_operand:SI 1 "memory_operand" "Uw,m")]
+		   UNSPEC_UNALIGNED_LOAD))]
+  "unaligned_access && TARGET_32BIT"
+  "ldr%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t2,any")
+   (set_attr "length" "2,4")
+   (set_attr "predicable" "yes")
+   (set_attr "type" "load1")])
+
+(define_insn "unaligned_loadhis"
+  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+	(sign_extend:SI
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+		     UNSPEC_UNALIGNED_LOAD)))]
+  "unaligned_access && TARGET_32BIT"
+  "ldr%(sh%)\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t2,any")
+   (set_attr "length" "2,4")
+   (set_attr "predicable" "yes")
+   (set_attr "type" "load_byte")])
+
+(define_insn "unaligned_loadhiu"
+  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+	(zero_extend:SI
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+		     UNSPEC_UNALIGNED_LOAD)))]
+  "unaligned_access && TARGET_32BIT"
+  "ldr%(h%)\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t2,any")
+   (set_attr "length" "2,4")
+   (set_attr "predicable" "yes")
+   (set_attr "type" "load_byte")])
+
+(define_insn "unaligned_storesi"
+  [(set (match_operand:SI 0 "memory_operand" "=Uw,m")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,r")]
+		   UNSPEC_UNALIGNED_STORE))]
+  "unaligned_access && TARGET_32BIT"
+  "str%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t2,any")
+   (set_attr "length" "2,4")
+   (set_attr "predicable" "yes")
+   (set_attr "type" "store1")])
+
+(define_insn "unaligned_storehi"
+  [(set (match_operand:HI 0 "memory_operand" "=Uw,m")
+	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,r")]
+		   UNSPEC_UNALIGNED_STORE))]
+  "unaligned_access && TARGET_32BIT"
+  "str%(h%)\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t2,any")
+   (set_attr "length" "2,4")
+   (set_attr "predicable" "yes")
+   (set_attr "type" "store1")])
+
+(define_insn "*extv_reg"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extract:SI (match_operand:SI 1 "s_register_operand" "r")
                          (match_operand:SI 2 "const_int_operand" "M")
@@ -3673,6 +3918,28 @@
    (set_attr "predicable" "yes")]
 )
 
+
+;; Division instructions
+(define_insn "divsi3"
+  [(set (match_operand:SI	  0 "s_register_operand" "=r")
+	(div:SI (match_operand:SI 1 "s_register_operand"  "r")
+		(match_operand:SI 2 "s_register_operand"  "r")))]
+  "TARGET_IDIV"
+  "sdiv%?\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "sdiv")]
+)
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI	   0 "s_register_operand" "=r")
+	(udiv:SI (match_operand:SI 1 "s_register_operand"  "r")
+		 (match_operand:SI 2 "s_register_operand"  "r")))]
+  "TARGET_IDIV"
+  "udiv%?\t%0, %1, %2"
+  [(set_attr "predicable" "yes")
+   (set_attr "insn" "udiv")]
+)
+
 
 ;; Unary arithmetic insns
 
@@ -4045,8 +4312,8 @@
 
 (define_insn "zero_extend<mode>di2"
   [(set (match_operand:DI 0 "s_register_operand" "=r")
-        (zero_extend:DI (match_operand:QHSI 1 "<qhs_extenddi_op>"
-					    "<qhs_extenddi_cstr>")))]
+        (zero_extend:DI (match_operand:QHSI 1 "<qhs_zextenddi_op>"
+					    "<qhs_zextenddi_cstr>")))]
   "TARGET_32BIT <qhs_zextenddi_cond>"
   "#"
   [(set_attr "length" "8")
@@ -4200,7 +4467,9 @@
    #
    ldr%(h%)\\t%0, %1"
   [(set_attr "type" "alu_shift,load_byte")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "pool_range" "*,256")
+   (set_attr "neg_pool_range" "*,244")]
 )
 
 (define_insn "*arm_zero_extendhisi2_v6"
@@ -4211,7 +4480,9 @@
    uxth%?\\t%0, %1
    ldr%(h%)\\t%0, %1"
   [(set_attr "type" "alu_shift,load_byte")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "pool_range" "*,256")
+   (set_attr "neg_pool_range" "*,244")]
 )
 
 (define_insn "*arm_zero_extendhisi2addsi"
@@ -4293,7 +4564,9 @@
    ldr%(b%)\\t%0, %1\\t%@ zero_extendqisi2"
   [(set_attr "length" "8,4")
    (set_attr "type" "alu_shift,load_byte")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "pool_range" "*,256")
+   (set_attr "neg_pool_range" "*,244")]
 )
 
 (define_insn "*arm_zero_extendqisi2_v6"
@@ -4304,7 +4577,9 @@
    uxtb%(%)\\t%0, %1
    ldr%(b%)\\t%0, %1\\t%@ zero_extendqisi2"
   [(set_attr "type" "alu_shift,load_byte")
-   (set_attr "predicable" "yes")]
+   (set_attr "predicable" "yes")
+   (set_attr "pool_range" "*,256")
+   (set_attr "neg_pool_range" "*,244")]
 )
 
 (define_insn "*arm_zero_extendqisi2addsi"
@@ -5049,14 +5324,6 @@
 			       optimize && can_create_pseudo_p ());
           DONE;
         }
-
-      if (TARGET_USE_MOVT && !target_word_relocations
-	  && GET_CODE (operands[1]) == SYMBOL_REF
-	  && !flag_pic && !arm_tls_referenced_p (operands[1]))
-	{
-	  arm_emit_movpair (operands[0], operands[1]);
-	  DONE;
-	}
     }
   else /* TARGET_THUMB1...  */
     {
@@ -5165,6 +5432,19 @@
   "
 )
 
+(define_split
+  [(set (match_operand:SI 0 "arm_general_register_operand" "")
+	(match_operand:SI 1 "general_operand" ""))]
+  "TARGET_32BIT
+   && TARGET_USE_MOVT && GET_CODE (operands[1]) == SYMBOL_REF
+   && !flag_pic && !target_word_relocations
+   && !arm_tls_referenced_p (operands[1])"
+  [(clobber (const_int 0))]
+{
+  arm_emit_movpair (operands[0], operands[1]);
+  DONE;
+})
+
 (define_insn "*thumb1_movsi_insn"
   [(set (match_operand:SI 0 "nonimmediate_operand" "=l,l,l,l,l,>,l, m,*l*h*k")
 	(match_operand:SI 1 "general_operand"      "l, I,J,K,>,l,mi,l,*l*h*k"))]
@@ -5877,7 +6157,7 @@
 (define_expand "reload_inhi"
   [(parallel [(match_operand:HI 0 "s_register_operand" "=r")
 	      (match_operand:HI 1 "arm_reload_memory_operand" "o")
-	      (match_operand:DI 2 "s_register_operand" "=&r")])]
+	      (match_operand:DI 2 "s_register_operand" "=&l")])]
   "TARGET_EITHER"
   "
   if (TARGET_ARM)
@@ -6468,7 +6748,7 @@
 
 (define_expand "cbranchsi4"
   [(set (pc) (if_then_else
-	      (match_operator 0 "arm_comparison_operator"
+	      (match_operator 0 "expandable_comparison_operator"
 	       [(match_operand:SI 1 "s_register_operand" "")
 	        (match_operand:SI 2 "nonmemory_operand" "")])
 	      (label_ref (match_operand 3 "" ""))
@@ -6519,7 +6799,7 @@
 
 (define_expand "cbranchsf4"
   [(set (pc) (if_then_else
-	      (match_operator 0 "arm_comparison_operator"
+	      (match_operator 0 "expandable_comparison_operator"
 	       [(match_operand:SF 1 "s_register_operand" "")
 	        (match_operand:SF 2 "arm_float_compare_operand" "")])
 	      (label_ref (match_operand 3 "" ""))
@@ -6531,7 +6811,7 @@
 
 (define_expand "cbranchdf4"
   [(set (pc) (if_then_else
-	      (match_operator 0 "arm_comparison_operator"
+	      (match_operator 0 "expandable_comparison_operator"
 	       [(match_operand:DF 1 "s_register_operand" "")
 	        (match_operand:DF 2 "arm_float_compare_operand" "")])
 	      (label_ref (match_operand 3 "" ""))
@@ -6543,7 +6823,7 @@
 
 (define_expand "cbranchdi4"
   [(set (pc) (if_then_else
-	      (match_operator 0 "arm_comparison_operator"
+	      (match_operator 0 "expandable_comparison_operator"
 	       [(match_operand:DI 1 "cmpdi_operand" "")
 	        (match_operand:DI 2 "cmpdi_operand" "")])
 	      (label_ref (match_operand 3 "" ""))
@@ -7380,7 +7660,7 @@
 
 (define_expand "cstoresi4"
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(match_operator:SI 1 "arm_comparison_operator"
+	(match_operator:SI 1 "expandable_comparison_operator"
 	 [(match_operand:SI 2 "s_register_operand" "")
 	  (match_operand:SI 3 "reg_or_int_operand" "")]))]
   "TARGET_32BIT || TARGET_THUMB1"
@@ -7516,7 +7796,7 @@
 
 (define_expand "cstoresf4"
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(match_operator:SI 1 "arm_comparison_operator"
+	(match_operator:SI 1 "expandable_comparison_operator"
 	 [(match_operand:SF 2 "s_register_operand" "")
 	  (match_operand:SF 3 "arm_float_compare_operand" "")]))]
   "TARGET_32BIT && TARGET_HARD_FLOAT"
@@ -7526,7 +7806,7 @@
 
 (define_expand "cstoredf4"
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(match_operator:SI 1 "arm_comparison_operator"
+	(match_operator:SI 1 "expandable_comparison_operator"
 	 [(match_operand:DF 2 "s_register_operand" "")
 	  (match_operand:DF 3 "arm_float_compare_operand" "")]))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE"
@@ -7536,7 +7816,7 @@
 
 (define_expand "cstoredi4"
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(match_operator:SI 1 "arm_comparison_operator"
+	(match_operator:SI 1 "expandable_comparison_operator"
 	 [(match_operand:DI 2 "cmpdi_operand" "")
 	  (match_operand:DI 3 "cmpdi_operand" "")]))]
   "TARGET_32BIT"
@@ -7656,7 +7936,7 @@
 
 (define_expand "movsicc"
   [(set (match_operand:SI 0 "s_register_operand" "")
-	(if_then_else:SI (match_operand 1 "arm_comparison_operator" "")
+	(if_then_else:SI (match_operand 1 "expandable_comparison_operator" "")
 			 (match_operand:SI 2 "arm_not_operand" "")
 			 (match_operand:SI 3 "arm_not_operand" "")))]
   "TARGET_32BIT"
@@ -7676,7 +7956,7 @@
 
 (define_expand "movsfcc"
   [(set (match_operand:SF 0 "s_register_operand" "")
-	(if_then_else:SF (match_operand 1 "arm_comparison_operator" "")
+	(if_then_else:SF (match_operand 1 "expandable_comparison_operator" "")
 			 (match_operand:SF 2 "s_register_operand" "")
 			 (match_operand:SF 3 "nonmemory_operand" "")))]
   "TARGET_32BIT && TARGET_HARD_FLOAT"
@@ -7702,7 +7982,7 @@
 
 (define_expand "movdfcc"
   [(set (match_operand:DF 0 "s_register_operand" "")
-	(if_then_else:DF (match_operand 1 "arm_comparison_operator" "")
+	(if_then_else:DF (match_operand 1 "expandable_comparison_operator" "")
 			 (match_operand:DF 2 "s_register_operand" "")
 			 (match_operand:DF 3 "arm_float_add_operand" "")))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)"
@@ -8139,66 +8419,65 @@
   [(set_attr "type" "call")]
 )
 
-(define_expand "return"
-  [(return)]
-  "TARGET_32BIT && USE_RETURN_INSN (FALSE)"
+(define_expand "<return_str>return"
+  [(returns)]
+  "TARGET_32BIT<return_cond>"
   "")
 
-;; Often the return insn will be the same as loading from memory, so set attr
-(define_insn "*arm_return"
-  [(return)]
-  "TARGET_ARM && USE_RETURN_INSN (FALSE)"
-  "*
-  {
-    if (arm_ccfsm_state == 2)
-      {
-        arm_ccfsm_state += 2;
-        return \"\";
-      }
-    return output_return_instruction (const_true_rtx, TRUE, FALSE);
-  }"
+(define_insn "*arm_<return_str>return"
+  [(returns)]
+  "TARGET_ARM<return_cond>"
+{
+  if (arm_ccfsm_state == 2)
+    {
+      arm_ccfsm_state += 2;
+      return "";
+    }
+  return output_return_instruction (const_true_rtx, true, false,
+				    <return_simple_p>);
+}
   [(set_attr "type" "load1")
    (set_attr "length" "12")
    (set_attr "predicable" "yes")]
 )
 
-(define_insn "*cond_return"
+(define_insn "*cond_<return_str>return"
   [(set (pc)
         (if_then_else (match_operator 0 "arm_comparison_operator"
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
-                      (return)
+                      (returns)
                       (pc)))]
-  "TARGET_ARM && USE_RETURN_INSN (TRUE)"
-  "*
-  {
-    if (arm_ccfsm_state == 2)
-      {
-        arm_ccfsm_state += 2;
-        return \"\";
-      }
-    return output_return_instruction (operands[0], TRUE, FALSE);
-  }"
+  "TARGET_ARM<return_cond>"
+{
+  if (arm_ccfsm_state == 2)
+    {
+      arm_ccfsm_state += 2;
+      return "";
+    }
+  return output_return_instruction (operands[0], true, false,
+				    <return_simple_p>);
+}
   [(set_attr "conds" "use")
    (set_attr "length" "12")
    (set_attr "type" "load1")]
 )
 
-(define_insn "*cond_return_inverted"
+(define_insn "*cond_<return_str>return_inverted"
   [(set (pc)
         (if_then_else (match_operator 0 "arm_comparison_operator"
 		       [(match_operand 1 "cc_register" "") (const_int 0)])
                       (pc)
-		      (return)))]
-  "TARGET_ARM && USE_RETURN_INSN (TRUE)"
-  "*
-  {
-    if (arm_ccfsm_state == 2)
-      {
-        arm_ccfsm_state += 2;
-        return \"\";
-      }
-    return output_return_instruction (operands[0], TRUE, TRUE);
-  }"
+		      (returns)))]
+  "TARGET_ARM<return_cond>"
+{
+  if (arm_ccfsm_state == 2)
+    {
+      arm_ccfsm_state += 2;
+      return "";
+    }
+  return output_return_instruction (operands[0], true, true,
+				    <return_simple_p>);
+}
   [(set_attr "conds" "use")
    (set_attr "length" "12")
    (set_attr "type" "load1")]
@@ -8377,7 +8656,8 @@
 	rtx reg = gen_reg_rtx (SImode);
 
 	emit_insn (gen_addsi3 (reg, operands[0],
-			       GEN_INT (-INTVAL (operands[1]))));
+			       gen_int_mode (-INTVAL (operands[1]),
+			       		     SImode)));
 	operands[0] = reg;
       }
 
@@ -10001,8 +10281,7 @@
       DONE;
     }
   emit_jump_insn (gen_rtx_UNSPEC_VOLATILE (VOIDmode,
-	gen_rtvec (1,
-		gen_rtx_RETURN (VOIDmode)),
+	gen_rtvec (1, ret_rtx),
 	VUNSPEC_EPILOGUE));
   DONE;
   "
@@ -10019,7 +10298,7 @@
   "TARGET_32BIT"
   "*
   if (use_return_insn (FALSE, next_nonnote_insn (insn)))
-    return output_return_instruction (const_true_rtx, FALSE, FALSE);
+    return output_return_instruction (const_true_rtx, false, false, false);
   return arm_output_epilogue (next_nonnote_insn (insn));
   "
 ;; Length is absolute worst case
@@ -10338,6 +10617,24 @@
   "
 )
 
+(define_insn "align_16"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN16)]
+  "TARGET_EITHER"
+  "*
+  assemble_align (128);
+  return \"\";
+  "
+)
+
+(define_insn "align_32"
+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN32)]
+  "TARGET_EITHER"
+  "*
+  assemble_align (256);
+  return \"\";
+  "
+)
+
 (define_insn "consttable_end"
   [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_END)]
   "TARGET_EITHER"
@@ -10611,6 +10908,24 @@
   [(set_attr "conds" "clob")]
 )
 
+;; tls descriptor call
+(define_insn "tlscall"
+  [(set (reg:SI R0_REGNUM) (unspec:SI [(reg:SI R0_REGNUM)
+                               (match_operand:SI 0 "" "X")
+			       (match_operand 1 "" "")] UNSPEC_TLS))
+   (clobber (reg:SI R1_REGNUM))
+   (clobber (reg:SI LR_REGNUM))
+   (clobber (reg:SI CC_REGNUM))]
+  "TARGET_GNU2_TLS"
+  {
+    targetm.asm_out.internal_label (asm_out_file, "LPIC",
+				    INTVAL (operands[1]));
+    return "bl\\t+%c0(tlscall)";
+  }
+  [(set_attr "conds" "clob")
+   (set_attr "length" "4")]
+)
+
 ;; We only care about the lower 16 bits of the constant 
 ;; being inserted into the upper 16 bits of the register.
 (define_insn "*arm_movtas_ze" 
@@ -10744,3 +11059,5 @@
 (include "neon.md")
 ;; Synchronization Primitives
 (include "sync.md")
+;; Fixed-point patterns
+(include "arm-fixed.md")
diff -ru ./gcc/config/arm/arm-modes.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-modes.def
--- ./gcc/config/arm/arm-modes.def	2014-06-06 11:50:14.367598556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-modes.def	2012-03-29 18:03:11.000000000 +1000
@@ -70,6 +70,12 @@
 VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */
 VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */
 
+/* Fraction and accumulator vector modes.  */
+VECTOR_MODES (FRACT, 4);      /* V4QQ  V2HQ */
+VECTOR_MODES (UFRACT, 4);     /* V4UQQ V2UHQ */
+VECTOR_MODES (ACCUM, 4);      /*       V2HA */
+VECTOR_MODES (UACCUM, 4);     /*       V2UHA */
+
 /* Opaque integer modes for 3, 4, 6 or 8 Neon double registers (2 is
    TImode).  */
 INT_MODE (EI, 24);
diff -ru ./gcc/config/arm/arm.opt /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.opt
--- ./gcc/config/arm/arm.opt	2014-06-06 11:50:15.135598585 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm.opt	2012-03-29 18:03:11.000000000 +1000
@@ -137,6 +137,10 @@
 Target Report Mask(INTERWORK)
 Support calls between Thumb and ARM instruction sets
 
+mtls-dialect=
+Target RejectNegative Joined Var(target_tls_dialect_switch)
+Specify thread local storage scheme
+
 mtp=
 Target RejectNegative Joined Var(target_thread_switch)
 Specify how to access the thread pointer
@@ -169,3 +173,7 @@
 Target Report Var(fix_cm3_ldrd) Init(2)
 Avoid overlapping destination and address registers on LDRD instructions
 that may trigger Cortex-M3 errata.
+
+munaligned-access
+Target Report Var(unaligned_access) Init(2)
+Enable unaligned word and halfword accesses to packed data.
diff -ru ./gcc/config/arm/arm-protos.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-protos.h
--- ./gcc/config/arm/arm-protos.h	2014-06-06 11:50:14.375598557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-protos.h	2012-03-29 18:03:11.000000000 +1000
@@ -24,6 +24,7 @@
 #define GCC_ARM_PROTOS_H
 
 extern int use_return_insn (int, rtx);
+extern bool use_simple_return_p (void);
 extern enum reg_class arm_regno_class (int);
 extern void arm_load_pic_register (unsigned long);
 extern int arm_volatile_func (void);
@@ -54,6 +55,7 @@
 extern rtx legitimize_tls_address (rtx, rtx);
 extern int arm_legitimate_address_outer_p (enum machine_mode, rtx, RTX_CODE, int);
 extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);
+extern int thumb1_legitimate_address_p (enum machine_mode, rtx, int);
 extern bool arm_legitimize_reload_address (rtx *, enum machine_mode, int, int,
 					   int);
 extern rtx thumb_legitimize_reload_address (rtx *, enum machine_mode, int, int,
@@ -135,7 +137,7 @@
 extern const char *output_add_immediate (rtx *);
 extern const char *arithmetic_instr (rtx, int);
 extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);
-extern const char *output_return_instruction (rtx, int, int);
+extern const char *output_return_instruction (rtx, bool, bool, bool);
 extern void arm_poke_function_name (FILE *, const char *);
 extern void arm_final_prescan_insn (rtx);
 extern int arm_debugger_arg_offset (int, rtx);
@@ -175,6 +177,7 @@
 #endif
 extern int thumb_shiftable_const (unsigned HOST_WIDE_INT);
 #ifdef RTX_CODE
+extern enum arm_cond_code maybe_get_arm_condition_code (rtx);
 extern void thumb1_final_prescan_insn (rtx);
 extern void thumb2_final_prescan_insn (rtx);
 extern const char *thumb_load_double_from_address (rtx *);
@@ -220,9 +223,15 @@
   bool (*rtx_costs) (rtx, RTX_CODE, RTX_CODE, int *, bool);
   bool (*sched_adjust_cost) (rtx, rtx, rtx, int *);
   int constant_limit;
+  /* Maximum number of instructions to conditionalise in
+     arm_final_prescan_insn.  */
+  int max_insns_skipped;
   int num_prefetch_slots;
   int l1_cache_size;
   int l1_cache_line_size;
+  bool prefer_constant_pool;
+  int (*branch_cost) (bool, bool);
+  bool aggressive_unrolling;
 };
 
 extern const struct tune_params *current_tune;
diff -ru ./gcc/config/arm/arm-tune.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-tune.md
--- ./gcc/config/arm/arm-tune.md	2014-06-06 11:50:14.411598558 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/arm-tune.md	2012-03-29 18:03:38.000000000 +1000
@@ -1,5 +1,5 @@
 ;; -*- buffer-read-only: t -*-
 ;; Generated automatically by gentune.sh from arm-cores.def
 (define_attr "tune"
-	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,fa526,fa626,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,fa606te,fa626te,fmp626,fa726te,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,arm1156t2fs,cortexa5,cortexa8,cortexa9,cortexa15,cortexr4,cortexr4f,cortexm4,cortexm3,cortexm1,cortexm0"
+	"arm2,arm250,arm3,arm6,arm60,arm600,arm610,arm620,arm7,arm7d,arm7di,arm70,arm700,arm700i,arm710,arm720,arm710c,arm7100,arm7500,arm7500fe,arm7m,arm7dm,arm7dmi,arm8,arm810,strongarm,strongarm110,strongarm1100,strongarm1110,fa526,fa626,arm7tdmi,arm7tdmis,arm710t,arm720t,arm740t,arm9,arm9tdmi,arm920,arm920t,arm922t,arm940t,ep9312,arm10tdmi,arm1020t,arm9e,arm946es,arm966es,arm968es,arm10e,arm1020e,arm1022e,xscale,iwmmxt,iwmmxt2,fa606te,fa626te,fmp626,fa726te,arm926ejs,arm1026ejs,arm1136js,arm1136jfs,arm1176jzs,arm1176jzfs,mpcorenovfp,mpcore,arm1156t2s,arm1156t2fs,cortexa5,cortexa8,cortexa9,cortexa15,cortexr4,cortexr4f,cortexr5,cortexm4,cortexm3,cortexm1,cortexm0"
 	(const (symbol_ref "((enum attr_tune) arm_tune)")))
diff -ru ./gcc/config/arm/constraints.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/constraints.md
--- ./gcc/config/arm/constraints.md	2014-06-06 11:50:15.147598586 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/constraints.md	2012-03-29 18:03:11.000000000 +1000
@@ -29,13 +29,14 @@
 ;; in Thumb-1 state: I, J, K, L, M, N, O
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy, Di, Dz
+;; in ARM/Thumb-2 state: D0, Da, Db, Dc, Dn, Dl, DL, Dv, Dy, Di, Dz
 ;; in Thumb-1 state: Pa, Pb, Pc, Pd
 ;; in Thumb-2 state: Ps, Pt, Pu, Pv, Pw, Px
 
 ;; The following memory constraints have been used:
 ;; in ARM/Thumb-2 state: Q, Ut, Uv, Uy, Un, Um, Us
 ;; in ARM state: Uq
+;; in Thumb state: Uw
 
 
 (define_register_constraint "f" "TARGET_ARM ? FPA_REGS : NO_REGS"
@@ -205,6 +206,13 @@
  (and (match_code "const_vector")
       (match_test "TARGET_NEON && op == CONST0_RTX (mode)")))
 
+(define_constraint "D0"
+ "@internal
+  In ARM/Thumb-2 state a 0.0 floating point constant which can
+  be loaded with a Neon vmov immediate instruction."
+ (and (match_code "const_double")
+      (match_test "TARGET_NEON && op == CONST0_RTX (mode)")))
+
 (define_constraint "Da"
  "@internal
   In ARM/Thumb-2 state a const_int, const_double or const_vector that can
@@ -327,6 +335,19 @@
  (and (match_code "mem")
       (match_test "REG_P (XEXP (op, 0))")))
 
+; The 16-bit post-increment LDR/STR accepted by thumb1_legitimate_address_p
+; are actually LDM/STM instructions, so cannot be used to access unaligned
+; data.
+(define_memory_constraint "Uw"
+ "@internal
+  In Thumb state an address that is valid in 16bit encoding, and that can be
+  used for unaligned accesses."
+ (and (match_code "mem")
+      (match_test "TARGET_THUMB
+		   && thumb1_legitimate_address_p (GET_MODE (op), XEXP (op, 0),
+						   0)
+		   && GET_CODE (XEXP (op, 0)) != POST_INC")))
+
 ;; We used to have constraint letters for S and R in ARM state, but
 ;; all uses of these now appear to have been removed.
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: eabi-memcpy.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: eabi-memset.c
diff -ru ./gcc/config/arm/elf.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/elf.h
--- ./gcc/config/arm/elf.h	2014-06-06 11:50:15.151598586 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/elf.h	2012-03-29 18:03:11.000000000 +1000
@@ -152,7 +152,7 @@
 
 /* Horrible hack: We want to prevent some libgcc routines being included
    for some multilibs.  */
-#ifndef __ARM_ARCH_6M__
+#if !(defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_6SM__))
 #undef L_fixdfsi
 #undef L_fixunsdfsi
 #undef L_truncdfsf2
diff -ru ./gcc/config/arm/fp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/fp16.c
--- ./gcc/config/arm/fp16.c	2014-06-06 11:50:15.167598587 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/fp16.c	2012-03-29 18:03:11.000000000 +1000
@@ -22,10 +22,10 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
-static inline unsigned short
+static inline unsigned int
 __gnu_f2h_internal(unsigned int a, int ieee)
 {
-  unsigned short sign = (a >> 16) & 0x8000;
+  unsigned int sign = (a >> 16) & 0x8000;
   int aexp = (a >> 23) & 0xff;
   unsigned int mantissa = a & 0x007fffff;
   unsigned int mask;
@@ -95,10 +95,10 @@
   return sign | (((aexp + 14) << 10) + (mantissa >> 13));
 }
 
-unsigned int
-__gnu_h2f_internal(unsigned short a, int ieee)
+static inline unsigned int
+__gnu_h2f_internal(unsigned int a, int ieee)
 {
-  unsigned int sign = (unsigned int)(a & 0x8000) << 16;
+  unsigned int sign = (a & 0x00008000) << 16;
   int aexp = (a >> 10) & 0x1f;
   unsigned int mantissa = a & 0x3ff;
 
@@ -120,26 +120,33 @@
   return sign | (((aexp + 0x70) << 23) + (mantissa << 13));
 }
 
-unsigned short
+#define ALIAS(src, dst) \
+  typeof (src) dst __attribute__ ((alias (#src)));
+
+unsigned int
 __gnu_f2h_ieee(unsigned int a)
 {
   return __gnu_f2h_internal(a, 1);
 }
+ALIAS (__gnu_f2h_ieee, __aeabi_f2h)
 
 unsigned int
-__gnu_h2f_ieee(unsigned short a)
+__gnu_h2f_ieee(unsigned int a)
 {
   return __gnu_h2f_internal(a, 1);
 }
+ALIAS (__gnu_h2f_ieee, __aeabi_h2f)
 
-unsigned short
+unsigned int
 __gnu_f2h_alternative(unsigned int x)
 {
   return __gnu_f2h_internal(x, 0);
 }
+ALIAS (__gnu_f2h_alternative, __aeabi_f2h_alt)
 
 unsigned int
-__gnu_h2f_alternative(unsigned short a)
+__gnu_h2f_alternative(unsigned int a)
 {
   return __gnu_h2f_internal(a, 0);
 }
+ALIAS (__gnu_h2f_alternative, __aeabi_h2f_alt)
diff -ru ./gcc/config/arm/iterators.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/iterators.md
--- ./gcc/config/arm/iterators.md	2014-06-06 11:50:15.375598595 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/iterators.md	2012-03-29 18:03:11.000000000 +1000
@@ -140,7 +140,18 @@
 
 ;; Modes with 8-bit, 16-bit and 32-bit elements.
 (define_mode_iterator VU [V16QI V8HI V4SI])
- 
+
+;; Iterators used for fixed-point support.
+(define_mode_iterator FIXED [QQ HQ SQ UQQ UHQ USQ HA SA UHA USA])
+
+(define_mode_iterator ADDSUB [V4QQ V2HQ V2HA])
+
+(define_mode_iterator UQADDSUB [V4UQQ V2UHQ UQQ UHQ V2UHA UHA])
+
+(define_mode_iterator QADDSUB [V4QQ V2HQ QQ HQ V2HA HA SQ SA])
+
+(define_mode_iterator QMUL [HQ HA])
+
 ;;----------------------------------------------------------------------------
 ;; Code iterators
 ;;----------------------------------------------------------------------------
@@ -381,10 +392,20 @@
 (define_mode_attr qhs_zextenddi_cond [(SI "") (HI "&& arm_arch6") (QI "")])
 (define_mode_attr qhs_sextenddi_cond [(SI "") (HI "&& arm_arch6")
 				      (QI "&& arm_arch6")])
-(define_mode_attr qhs_extenddi_op [(SI "s_register_operand")
+(define_mode_attr qhs_zextenddi_op [(SI "s_register_operand")
 				   (HI "nonimmediate_operand")
 				   (QI "nonimmediate_operand")])
-(define_mode_attr qhs_extenddi_cstr [(SI "r") (HI "rm") (QI "rm")])
+(define_mode_attr qhs_extenddi_op [(SI "s_register_operand")
+				   (HI "nonimmediate_operand")
+				   (QI "arm_reg_or_extendqisi_mem_op")])
+(define_mode_attr qhs_extenddi_cstr [(SI "r") (HI "rm") (QI "rUq")])
+(define_mode_attr qhs_zextenddi_cstr [(SI "r") (HI "rm") (QI "rm")])
+
+;; Mode attributes used for fixed-point support.
+(define_mode_attr qaddsub_suf [(V4UQQ "8") (V2UHQ "16") (UQQ "8") (UHQ "16")
+			       (V2UHA "16") (UHA "16")
+			       (V4QQ "8") (V2HQ "16") (QQ "8") (HQ "16")
+			       (V2HA "16") (HA "16") (SQ "") (SA "")])
 
 ;;----------------------------------------------------------------------------
 ;; Code attributes
@@ -403,3 +424,11 @@
 
 ;; Assembler mnemonics for signedness of widening operations.
 (define_code_attr US [(sign_extend "s") (zero_extend "u")])
+
+;; Both kinds of return insn.
+(define_code_iterator returns [return simple_return])
+(define_code_attr return_str [(return "") (simple_return "simple_")])
+(define_code_attr return_simple_p [(return "false") (simple_return "true")])
+(define_code_attr return_cond [(return " && USE_RETURN_INSN (FALSE)")
+			       (simple_return " && use_simple_return_p ()")])
+
diff -ru ./gcc/config/arm/lib1funcs.asm /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/lib1funcs.asm
--- ./gcc/config/arm/lib1funcs.asm	2014-06-06 11:50:15.375598595 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/lib1funcs.asm	2012-03-29 18:03:11.000000000 +1000
@@ -99,7 +99,7 @@
 #if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \
 	|| defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \
 	|| defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) \
-	|| defined(__ARM_ARCH_6M__)
+	|| defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_6SM__)
 # define __ARM_ARCH__ 6
 #endif
 
@@ -113,6 +113,10 @@
 #error Unable to determine architecture.
 #endif
 
+#if defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_6SM__)
+#define __thumb1_only
+#endif
+
 /* There are times when we might prefer Thumb1 code even if ARM code is
    permitted, for example, the code might be smaller, or there might be
    interworking problems with switching to ARM state if interworking is
@@ -121,7 +125,7 @@
      && !defined(__thumb2__)		\
      && (!defined(__THUMB_INTERWORK__)	\
 	 || defined (__OPTIMIZE_SIZE__)	\
-	 || defined(__ARM_ARCH_6M__)))
+	 || defined(__thumb1_only)))
 # define __prefer_thumb__
 #endif
 
@@ -302,7 +306,7 @@
 
 #ifdef __ARM_EABI__
 .macro THUMB_LDIV0 name signed
-#if defined(__ARM_ARCH_6M__)
+#ifdef __thumb1_only
 	.ifc \signed, unsigned
 	cmp	r0, #0
 	beq	1f
@@ -461,7 +465,7 @@
 
 #else /* !(__INTERWORKING_STUBS__ || __thumb2__) */
 
-#ifdef __ARM_ARCH_6M__
+#ifdef __thumb1_only
 #define EQUIV .thumb_set
 #else
 .macro	ARM_FUNC_START name
@@ -489,7 +493,7 @@
 #endif
 .endm
 
-#ifndef __ARM_ARCH_6M__
+#ifndef __thumb1_only
 .macro	ARM_FUNC_ALIAS new old
 	.globl	SYM (__\new)
 	EQUIV	SYM (__\new), SYM (__\old)
@@ -1312,9 +1316,6 @@
 #define ah	r1
 #endif
 
-/* Prevent __aeabi double-word shifts from being produced on SymbianOS.  */
-#ifndef __symbian__
-
 #ifdef L_lshrdi3
 
 	FUNC_START lshrdi3
@@ -1416,16 +1417,14 @@
 
 #endif
 
-#endif /* __symbian__ */
-
-#if ((__ARM_ARCH__ > 5) && !defined(__ARM_ARCH_6M__)) \
+#if ((__ARM_ARCH__ > 5) && !defined(__thumb1_only)) \
     || defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \
     || defined(__ARM_ARCH_5TEJ__)
 #define HAVE_ARM_CLZ 1
 #endif
 
 #ifdef L_clzsi2
-#if defined(__ARM_ARCH_6M__)
+#ifdef __thumb1_only
 FUNC_START clzsi2
 	mov	r1, #28
 	mov	r3, #1
@@ -1486,7 +1485,7 @@
 #ifdef L_clzdi2
 #if !defined(HAVE_ARM_CLZ)
 
-# if defined(__ARM_ARCH_6M__)
+# ifdef __thumb1_only
 FUNC_START clzdi2
 	push	{r4, lr}
 # else
@@ -1511,7 +1510,7 @@
 	bl	__clzsi2
 # endif
 2:
-# if defined(__ARM_ARCH_6M__)
+# ifdef __thumb1_only
 	pop	{r4, pc}
 # else
 	RETLDM	r4
@@ -1584,7 +1583,7 @@
 
 /* Don't bother with the old interworking routines for Thumb-2.  */
 /* ??? Maybe only omit these on "m" variants.  */
-#if !defined(__thumb2__) && !defined(__ARM_ARCH_6M__)
+#if !defined(__thumb2__) && !defined(__thumb1_only)
 
 #if defined L_interwork_call_via_rX
 
@@ -1818,12 +1817,10 @@
 
 #endif /* Arch supports thumb.  */
 
-#ifndef __symbian__
-#ifndef __ARM_ARCH_6M__
+#ifndef __thumb1_only
 #include "ieee754-df.S"
 #include "ieee754-sf.S"
 #include "bpabi.S"
-#else /* __ARM_ARCH_6M__ */
+#else /* __thumb1_only */
 #include "bpabi-v6m.S"
-#endif /* __ARM_ARCH_6M__ */
-#endif /* !__symbian__ */
+#endif /* __thumb1_only */
diff -ru ./gcc/config/arm/libunwind.S /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/libunwind.S
--- ./gcc/config/arm/libunwind.S	2014-06-06 11:50:15.375598595 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/libunwind.S	2012-03-29 18:03:11.000000000 +1000
@@ -38,8 +38,6 @@
 	.eabi_attribute 25, 1
 #endif /* __ARM_EABI__ */
 
-#ifndef __symbian__
-
 #include "lib1funcs.asm"
 
 .macro UNPREFIX name
@@ -59,7 +57,7 @@
 #endif
 #endif
 
-#ifdef __ARM_ARCH_6M__
+#if defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_6SM__)
 
 /* r0 points to a 16-word block.  Upload these values to the actual core
    state.  */
@@ -359,5 +357,3 @@
 UNWIND_WRAPPER _Unwind_Resume_or_Rethrow 1
 UNWIND_WRAPPER _Unwind_ForcedUnwind 3
 UNWIND_WRAPPER _Unwind_Backtrace 2
-
-#endif  /* ndef __symbian__ */
diff -ru ./gcc/config/arm/neon.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/neon.md
--- ./gcc/config/arm/neon.md	2014-06-06 11:50:15.395598595 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/neon.md	2012-03-29 18:03:11.000000000 +1000
@@ -583,23 +583,25 @@
 )
 
 (define_insn "adddi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r")
-        (plus:DI (match_operand:DI 1 "s_register_operand" "%w,0,0")
-                 (match_operand:DI 2 "s_register_operand" "w,r,0")))
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r,?w")
+        (plus:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,w")
+                 (match_operand:DI 2 "s_register_operand" "w,r,0,w")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_NEON"
 {
   switch (which_alternative)
     {
-    case 0: return "vadd.i64\t%P0, %P1, %P2";
+    case 0: /* fall through */
+    case 3: return "vadd.i64\t%P0, %P1, %P2";
     case 1: return "#";
     case 2: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1,*,*")
-   (set_attr "conds" "*,clob,clob")
-   (set_attr "length" "*,8,8")]
+  [(set_attr "neon_type" "neon_int_1,*,*,neon_int_1")
+   (set_attr "conds" "*,clob,clob,*")
+   (set_attr "length" "*,8,8,*")
+   (set_attr "arch" "nota8,*,*,onlya8")]
 )
 
 (define_insn "*sub<mode>3_neon"
@@ -617,24 +619,26 @@
 )
 
 (define_insn "subdi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r,?&r")
-        (minus:DI (match_operand:DI 1 "s_register_operand" "w,0,r,0")
-                  (match_operand:DI 2 "s_register_operand" "w,r,0,0")))
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r,?&r,?w")
+        (minus:DI (match_operand:DI 1 "s_register_operand" "w,0,r,0,w")
+                  (match_operand:DI 2 "s_register_operand" "w,r,0,0,w")))
    (clobber (reg:CC CC_REGNUM))]
   "TARGET_NEON"
 {
   switch (which_alternative)
     {
-    case 0: return "vsub.i64\t%P0, %P1, %P2";
+    case 0: /* fall through */
+    case 4: return "vsub.i64\t%P0, %P1, %P2";
     case 1: /* fall through */ 
     case 2: /* fall through */
     case 3: return  "subs\\t%Q0, %Q1, %Q2\;sbc\\t%R0, %R1, %R2";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_2,*,*,*")
-   (set_attr "conds" "*,clob,clob,clob")
-   (set_attr "length" "*,8,8,8")]
+  [(set_attr "neon_type" "neon_int_2,*,*,*,neon_int_2")
+   (set_attr "conds" "*,clob,clob,clob,*")
+   (set_attr "length" "*,8,8,8,*")
+   (set_attr "arch" "nota8,*,*,*,onlya8")]
 )
 
 (define_insn "*mul<mode>3_neon"
@@ -720,23 +724,26 @@
 )
 
 (define_insn "iordi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,w,?&r,?&r")
-        (ior:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,r")
-		(match_operand:DI 2 "neon_logic_op2" "w,Dl,r,r")))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,w,?&r,?&r,?w,?w")
+        (ior:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,r,w,0")
+		(match_operand:DI 2 "neon_logic_op2" "w,Dl,r,r,w,Dl")))]
   "TARGET_NEON"
 {
   switch (which_alternative)
     {
-    case 0: return "vorr\t%P0, %P1, %P2";
-    case 1: return neon_output_logic_immediate ("vorr", &operands[2],
+    case 0: /* fall through */
+    case 4: return "vorr\t%P0, %P1, %P2";
+    case 1: /* fall through */
+    case 5: return neon_output_logic_immediate ("vorr", &operands[2],
 		     DImode, 0, VALID_NEON_QREG_MODE (DImode));
     case 2: return "#";
     case 3: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*")
-   (set_attr "length" "*,*,8,8")]
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*,neon_int_1,neon_int_1")
+   (set_attr "length" "*,*,8,8,*,*")
+   (set_attr "arch" "nota8,nota8,*,*,onlya8,onlya8")]
 )
 
 ;; The concrete forms of the Neon immediate-logic instructions are vbic and
@@ -762,23 +769,26 @@
 )
 
 (define_insn "anddi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,w,?&r,?&r")
-        (and:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,r")
-		(match_operand:DI 2 "neon_inv_logic_op2" "w,DL,r,r")))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,w,?&r,?&r,?w,?w")
+        (and:DI (match_operand:DI 1 "s_register_operand" "%w,0,0,r,w,0")
+		(match_operand:DI 2 "neon_inv_logic_op2" "w,DL,r,r,w,DL")))]
   "TARGET_NEON"
 {
   switch (which_alternative)
     {
-    case 0: return "vand\t%P0, %P1, %P2";
-    case 1: return neon_output_logic_immediate ("vand", &operands[2],
+    case 0: /* fall through */
+    case 4: return "vand\t%P0, %P1, %P2";
+    case 1: /* fall through */
+    case 5: return neon_output_logic_immediate ("vand", &operands[2],
     		     DImode, 1, VALID_NEON_QREG_MODE (DImode));
     case 2: return "#";
     case 3: return "#";
     default: gcc_unreachable ();
     }
 }
-  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*")
-   (set_attr "length" "*,*,8,8")]
+  [(set_attr "neon_type" "neon_int_1,neon_int_1,*,*,neon_int_1,neon_int_1")
+   (set_attr "length" "*,*,8,8,*,*")
+   (set_attr "arch" "nota8,nota8,*,*,onlya8,onlya8")]
 )
 
 (define_insn "orn<mode>3_neon"
@@ -836,16 +846,18 @@
 )
 
 (define_insn "xordi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r")
-        (xor:DI (match_operand:DI 1 "s_register_operand" "%w,0,r")
-	        (match_operand:DI 2 "s_register_operand" "w,r,r")))]
+  [(set (match_operand:DI 0 "s_register_operand" "=w,?&r,?&r,?w")
+        (xor:DI (match_operand:DI 1 "s_register_operand" "%w,0,r,w")
+	        (match_operand:DI 2 "s_register_operand" "w,r,r,w")))]
   "TARGET_NEON"
   "@
    veor\t%P0, %P1, %P2
    #
-   #"
-  [(set_attr "neon_type" "neon_int_1,*,*")
-   (set_attr "length" "*,8,8")]
+   #
+   veor\t%P0, %P1, %P2"
+  [(set_attr "neon_type" "neon_int_1,*,*,neon_int_1")
+   (set_attr "length" "*,8,8,*")
+   (set_attr "arch" "nota8,*,*,onlya8")]
 )
 
 (define_insn "one_cmpl<mode>2"
@@ -1028,11 +1040,14 @@
 ;; shift-count granularity. That's good enough for the middle-end's current
 ;; needs.
 
+;; Note that it's not safe to perform such an operation in big-endian mode,
+;; due to element-ordering issues.
+
 (define_expand "vec_shr_<mode>"
   [(match_operand:VDQ 0 "s_register_operand" "")
    (match_operand:VDQ 1 "s_register_operand" "")
    (match_operand:SI 2 "const_multiple_of_8_operand" "")]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
 {
   rtx zero_reg;
   HOST_WIDE_INT num_bits = INTVAL (operands[2]);
@@ -1060,7 +1075,7 @@
   [(match_operand:VDQ 0 "s_register_operand" "")
    (match_operand:VDQ 1 "s_register_operand" "")
    (match_operand:SI 2 "const_multiple_of_8_operand" "")]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
 {
   rtx zero_reg;
   HOST_WIDE_INT num_bits = INTVAL (operands[2]);
@@ -1256,7 +1271,8 @@
 (define_expand "reduc_splus_<mode>"
   [(match_operand:VQ 0 "s_register_operand" "")
    (match_operand:VQ 1 "s_register_operand" "")]
-  "TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)"
+  "TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)
+   && !BYTES_BIG_ENDIAN"
 {
   rtx step1 = gen_reg_rtx (<V_HALF>mode);
   rtx res_d = gen_reg_rtx (<V_HALF>mode);
@@ -1272,7 +1288,7 @@
   [(set (match_operand:V2DI 0 "s_register_operand" "=w")
 	(unspec:V2DI [(match_operand:V2DI 1 "s_register_operand" "w")]
 		     UNSPEC_VPADD))]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
   "vadd.i64\t%e0, %e1, %f1"
   [(set_attr "neon_type" "neon_int_1")]
 )
@@ -1282,7 +1298,7 @@
 (define_expand "reduc_uplus_<mode>"
   [(match_operand:VDQI 0 "s_register_operand" "")
    (match_operand:VDQI 1 "s_register_operand" "")]
-  "TARGET_NEON"
+  "TARGET_NEON && (<Is_d_reg> || !BYTES_BIG_ENDIAN)"
 {
   emit_insn (gen_reduc_splus_<mode> (operands[0], operands[1]));
   DONE;
@@ -1301,7 +1317,8 @@
 (define_expand "reduc_smin_<mode>"
   [(match_operand:VQ 0 "s_register_operand" "")
    (match_operand:VQ 1 "s_register_operand" "")]
-  "TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)"
+  "TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)
+   && !BYTES_BIG_ENDIAN"
 {
   rtx step1 = gen_reg_rtx (<V_HALF>mode);
   rtx res_d = gen_reg_rtx (<V_HALF>mode);
@@ -1326,7 +1343,8 @@
 (define_expand "reduc_smax_<mode>"
   [(match_operand:VQ 0 "s_register_operand" "")
    (match_operand:VQ 1 "s_register_operand" "")]
-  "TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)"
+  "TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)
+   && !BYTES_BIG_ENDIAN"
 {
   rtx step1 = gen_reg_rtx (<V_HALF>mode);
   rtx res_d = gen_reg_rtx (<V_HALF>mode);
@@ -1351,7 +1369,7 @@
 (define_expand "reduc_umin_<mode>"
   [(match_operand:VQI 0 "s_register_operand" "")
    (match_operand:VQI 1 "s_register_operand" "")]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
 {
   rtx step1 = gen_reg_rtx (<V_HALF>mode);
   rtx res_d = gen_reg_rtx (<V_HALF>mode);
@@ -1376,7 +1394,7 @@
 (define_expand "reduc_umax_<mode>"
   [(match_operand:VQI 0 "s_register_operand" "")
    (match_operand:VQI 1 "s_register_operand" "")]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
 {
   rtx step1 = gen_reg_rtx (<V_HALF>mode);
   rtx res_d = gen_reg_rtx (<V_HALF>mode);
@@ -5241,7 +5259,7 @@
         (SE:<V_unpack> (vec_select:<V_HALF>
 			  (match_operand:VU 1 "register_operand" "w")
 			  (match_operand:VU 2 "vect_par_constant_low" ""))))]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
   "vmovl.<US><V_sz_elem> %q0, %e1"
   [(set_attr "neon_type" "neon_shift_1")]
 )
@@ -5251,7 +5269,7 @@
         (SE:<V_unpack> (vec_select:<V_HALF>
 			  (match_operand:VU 1 "register_operand" "w")
 			  (match_operand:VU 2 "vect_par_constant_high" ""))))]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
   "vmovl.<US><V_sz_elem> %q0, %f1"
   [(set_attr "neon_type" "neon_shift_1")]
 )
@@ -5259,7 +5277,7 @@
 (define_expand "vec_unpack<US>_hi_<mode>"
   [(match_operand:<V_unpack> 0 "register_operand" "")
    (SE:<V_unpack> (match_operand:VU 1 "register_operand"))]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
   {
    rtvec v = rtvec_alloc (<V_mode_nunits>/2)  ;
    rtx t1;
@@ -5278,7 +5296,7 @@
 (define_expand "vec_unpack<US>_lo_<mode>"
   [(match_operand:<V_unpack> 0 "register_operand" "")
    (SE:<V_unpack> (match_operand:VU 1 "register_operand" ""))]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
   {
    rtvec v = rtvec_alloc (<V_mode_nunits>/2)  ;
    rtx t1;
@@ -5301,7 +5319,7 @@
  		        (SE:<V_unpack> (vec_select:<V_HALF>
                            (match_operand:VU 3 "register_operand" "w") 
                            (match_dup 2)))))]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
   "vmull.<US><V_sz_elem> %q0, %e1, %e3"
   [(set_attr "neon_type" "neon_shift_1")]
 )
@@ -5310,7 +5328,7 @@
   [(match_operand:<V_unpack> 0 "register_operand" "")
    (SE:<V_unpack> (match_operand:VU 1 "register_operand" ""))
    (SE:<V_unpack> (match_operand:VU 2 "register_operand" ""))]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
  {
    rtvec v = rtvec_alloc (<V_mode_nunits>/2)  ;
    rtx t1;
@@ -5335,7 +5353,7 @@
 		       (SE:<V_unpack> (vec_select:<V_HALF>
 			    (match_operand:VU 3 "register_operand" "w") 
 			    (match_dup 2)))))]
-  "TARGET_NEON"
+  "TARGET_NEON && !BYTES_BIG_ENDIAN"
   "vmull.<US><V_sz_elem> %q0, %f1, %f3"
   [(set_attr "neon_type" "neon_shift_1")]
 )
@@ -5344,7 +5362,7 @@
   [(match_operand:<V_unpack> 0 "register_operand" "")
    (SE:<V_unpack> (match_operand:VU 1 "register_operand" ""))
    (SE:<V_unpack> (match_operand:VU 2 "register_operand" ""))]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
  {
    rtvec v = rtvec_alloc (<V_mode_nunits>/2)  ;
    rtx t1;
@@ -5438,6 +5456,10 @@
  }
 )
 
+; FIXME: These instruction patterns can't be used safely in big-endian mode
+; because the ordering of vector elements in Q registers is different from what
+; the semantics of the instructions require.
+
 ;; The case when using all quad registers.
 (define_insn "vec_pack_trunc_<mode>"
  [(set (match_operand:<V_narrow_pack> 0 "register_operand" "=&w")
@@ -5446,7 +5468,7 @@
 			(match_operand:VN 1 "register_operand" "w"))
 		(truncate:<V_narrow>
 			(match_operand:VN 2 "register_operand" "w"))))]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
  "vmovn.i<V_sz_elem>\t%e0, %q1\;vmovn.i<V_sz_elem>\t%f0, %q2"
  [(set_attr "neon_type" "neon_shift_1")
   (set_attr "length" "8")]
@@ -5456,7 +5478,7 @@
 (define_insn "neon_vec_pack_trunc_<mode>"
  [(set (match_operand:<V_narrow> 0 "register_operand" "=w")
        (truncate:<V_narrow> (match_operand:VN 1 "register_operand" "w")))]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
  "vmovn.i<V_sz_elem>\t%P0, %q1"
  [(set_attr "neon_type" "neon_shift_1")]
 )
@@ -5465,7 +5487,7 @@
  [(match_operand:<V_narrow_pack> 0 "register_operand" "")
   (match_operand:VSHFT 1 "register_operand" "")
   (match_operand:VSHFT 2 "register_operand")]
- "TARGET_NEON"
+ "TARGET_NEON && !BYTES_BIG_ENDIAN"
 {
   rtx tempreg = gen_reg_rtx (<V_DOUBLE>mode);
   
diff -ru ./gcc/config/arm/neon-testgen.ml /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/neon-testgen.ml
--- ./gcc/config/arm/neon-testgen.ml	2014-06-06 11:50:15.391598595 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/neon-testgen.ml	2012-03-29 18:03:11.000000000 +1000
@@ -257,7 +257,7 @@
      intrinsic expands to.  Watch out for any writeback character and
      comments after the instruction.  *)
   let regexps = List.map (fun regexp -> insn_regexp ^ "\\[ \t\\]+" ^ regexp ^
-			  "!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n")
+			  "!?\\(\\[ \t\\]+@.*\\)?\\n")
                          (analyze_all_shapes features shape analyze_shape)
   in
     (* Emit file and function prologues.  *)
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: nocrt0.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: nucleus.h
diff -ru ./gcc/config/arm/predicates.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/predicates.md
--- ./gcc/config/arm/predicates.md	2014-06-06 11:50:15.407598596 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/predicates.md	2012-03-29 18:03:11.000000000 +1000
@@ -132,7 +132,8 @@
 (define_predicate "shift_amount_operand"
   (ior (and (match_test "TARGET_ARM")
 	    (match_operand 0 "s_register_operand"))
-       (match_operand 0 "const_int_operand")))
+       (and (match_code "const_int")
+	    (match_test "((unsigned HOST_WIDE_INT) INTVAL (op)) < 32"))))
 
 (define_predicate "arm_add_operand"
   (ior (match_operand 0 "arm_rhs_operand")
@@ -227,6 +228,13 @@
 	    (match_code "ashift,ashiftrt,lshiftrt,rotatert"))
        (match_test "mode == GET_MODE (op)")))
 
+;; True for shift operators which can be used with saturation instructions.
+(define_special_predicate "sat_shift_operator"
+  (and (match_code "ashift,ashiftrt")
+       (match_test "GET_CODE (XEXP (op, 1)) == CONST_INT
+		    && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op, 1)) <= 32)")
+       (match_test "mode == GET_MODE (op)")))
+
 ;; True for MULT, to identify which variant of shift_operator is in use.
 (define_special_predicate "mult_operator"
   (match_code "mult"))
@@ -241,11 +249,15 @@
 
 ;; True for integer comparisons and, if FP is active, for comparisons
 ;; other than LTGT or UNEQ.
+(define_special_predicate "expandable_comparison_operator"
+  (match_code "eq,ne,le,lt,ge,gt,geu,gtu,leu,ltu,
+	       unordered,ordered,unlt,unle,unge,ungt"))
+
+;; Likewise, but only accept comparisons that are directly supported
+;; by ARM condition codes.
 (define_special_predicate "arm_comparison_operator"
-  (ior (match_code "eq,ne,le,lt,ge,gt,geu,gtu,leu,ltu")
-       (and (match_test "TARGET_32BIT && TARGET_HARD_FLOAT
-			 && (TARGET_FPA || TARGET_VFP)")
-            (match_code "unordered,ordered,unlt,unle,unge,ungt"))))
+  (and (match_operand 0 "expandable_comparison_operator")
+       (match_test "maybe_get_arm_condition_code (op) != ARM_NV")))
 
 (define_special_predicate "lt_ge_comparison_operator"
   (match_code "lt,ge"))
@@ -289,8 +301,11 @@
 
 (define_special_predicate "arm_extendqisi_mem_op"
   (and (match_operand 0 "memory_operand")
-       (match_test "arm_legitimate_address_outer_p (mode, XEXP (op, 0),
-						    SIGN_EXTEND, 0)")))
+       (match_test "TARGET_ARM ? arm_legitimate_address_outer_p (mode,
+                                                                 XEXP (op, 0),
+						                 SIGN_EXTEND,
+								 0)
+                               : memory_address_p (QImode, XEXP (op, 0))")))
 
 (define_special_predicate "arm_reg_or_extendqisi_mem_op"
   (ior (match_operand 0 "arm_extendqisi_mem_op")
@@ -338,12 +353,6 @@
        (and (match_code "reg,subreg,mem")
 	    (match_operand 0 "nonimmediate_soft_df_operand"))))
 
-(define_predicate "const_shift_operand"
-  (and (match_code "const_int")
-       (ior (match_operand 0 "power_of_two_operand")
-	    (match_test "((unsigned HOST_WIDE_INT) INTVAL (op)) < 32"))))
-
-
 (define_special_predicate "load_multiple_operation"
   (match_code "parallel")
 {
diff -ru ./gcc/config/arm/sfp-machine.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/sfp-machine.h
--- ./gcc/config/arm/sfp-machine.h	2014-06-06 11:50:15.415598596 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/sfp-machine.h	2012-03-29 18:03:11.000000000 +1000
@@ -99,7 +99,7 @@
 #define __fixdfdi	__aeabi_d2lz
 #define __fixunsdfdi	__aeabi_d2ulz
 #define __floatdidf	__aeabi_l2d
-#define __extendhfsf2	__gnu_h2f_ieee
-#define __truncsfhf2	__gnu_f2h_ieee
+#define __extendhfsf2	__aeabi_h2f
+#define __truncsfhf2	__aeabi_f2h
 
 #endif /* __ARM_EABI__ */
diff -ru ./gcc/config/arm/symbian.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/symbian.h
--- ./gcc/config/arm/symbian.h	2014-06-06 11:50:15.415598596 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/symbian.h	2012-03-29 18:03:11.000000000 +1000
@@ -71,11 +71,6 @@
 #define SUBTARGET_ASM_FLOAT_SPEC \
   "%{!mfpu=*:-mfpu=vfp} %{!mcpu=*:%{!march=*:-march=armv5t}}"
   
-/* SymbianOS provides the BPABI routines in a separate library.
-   Therefore, we do not need to define any of them in libgcc.  */
-#undef RENAME_LIBRARY
-#define RENAME_LIBRARY(GCC_NAME, AEABI_NAME) /* empty */
-
 /* Define the __symbian__ macro.  */
 #undef TARGET_OS_CPP_BUILTINS
 #define TARGET_OS_CPP_BUILTINS()				\
diff -ru ./gcc/config/arm/t-arm /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-arm
--- ./gcc/config/arm/t-arm	2014-06-06 11:50:15.423598596 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-arm	2012-03-29 18:03:11.000000000 +1000
@@ -37,7 +37,8 @@
 		$(srcdir)/config/arm/iwmmxt.md \
 		$(srcdir)/config/arm/vfp.md \
 		$(srcdir)/config/arm/neon.md \
-		$(srcdir)/config/arm/thumb2.md
+		$(srcdir)/config/arm/thumb2.md \
+		$(srcdir)/config/arm/arm-fixed.md
 
 LIB1ASMSRC = arm/lib1funcs.asm
 LIB1ASMFUNCS = _thumb1_case_sqi _thumb1_case_uqi _thumb1_case_shi \
diff -ru ./gcc/config/arm/t-arm-elf /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-arm-elf
--- ./gcc/config/arm/t-arm-elf	2014-06-06 11:50:15.423598596 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-arm-elf	2012-03-29 18:03:11.000000000 +1000
@@ -46,6 +46,7 @@
 #MULTILIB_MATCHES      += march?armv7=march?armv7-a
 #MULTILIB_MATCHES      += march?armv7=march?armv7-r
 #MULTILIB_MATCHES      += march?armv7=march?armv7-m
+#MULTILIB_MATCHES      += march?armv7=march?armv7e-m
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-a8
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-r4
 #MULTILIB_MATCHES      += march?armv7=mcpu?cortex-m3
diff -ru ./gcc/config/arm/t-arm-softfp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-arm-softfp
--- ./gcc/config/arm/t-arm-softfp	2014-06-06 11:50:15.423598596 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-arm-softfp	2012-03-29 18:03:11.000000000 +1000
@@ -22,7 +22,7 @@
 softfp_truncations := dfsf
 softfp_machine_header := arm/sfp-machine.h
 softfp_exclude_libgcc2 := y
-softfp_wrap_start := '\#ifdef __ARM_ARCH_6M__'
+softfp_wrap_start := '\#if defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_6SM__)'
 softfp_wrap_end := '\#endif'
 
 # softfp seems to be missing a whole bunch of prototypes.
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-brewmp-eabi
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-cs-eabi
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-cs-eabi-lite
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-cs-linux
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-cs-linux-lite
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-cs-nucleuseabi
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-cs-uclinux-eabi
diff -ru ./gcc/config/arm/thumb2.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/thumb2.md
--- ./gcc/config/arm/thumb2.md	2014-06-06 11:50:15.431598597 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/thumb2.md	2012-03-29 18:03:11.000000000 +1000
@@ -635,16 +635,15 @@
 
 ;; Note: this is not predicable, to avoid issues with linker-generated
 ;; interworking stubs.
-(define_insn "*thumb2_return"
-  [(return)]
-  "TARGET_THUMB2 && USE_RETURN_INSN (FALSE)"
-  "*
-  {
-    return output_return_instruction (const_true_rtx, TRUE, FALSE);
-  }"
+(define_insn "*thumb2_<return_str>return"
+  [(returns)]
+  "TARGET_THUMB2<return_cond>"
+{
+  return output_return_instruction (const_true_rtx, true, false,
+				    <return_simple_p>);
+}
   [(set_attr "type" "load1")
-   (set_attr "length" "12")]
-)
+   (set_attr "length" "12")])
 
 (define_insn_and_split "thumb2_eh_return"
   [(unspec_volatile [(match_operand:SI 0 "s_register_operand" "r")]
@@ -780,26 +779,6 @@
    (set_attr "length" "2")]
 )
 
-(define_insn "divsi3"
-  [(set (match_operand:SI	  0 "s_register_operand" "=r")
-	(div:SI (match_operand:SI 1 "s_register_operand"  "r")
-		(match_operand:SI 2 "s_register_operand"  "r")))]
-  "TARGET_THUMB2 && arm_arch_hwdiv"
-  "sdiv%?\t%0, %1, %2"
-  [(set_attr "predicable" "yes")
-   (set_attr "insn" "sdiv")]
-)
-
-(define_insn "udivsi3"
-  [(set (match_operand:SI	   0 "s_register_operand" "=r")
-	(udiv:SI (match_operand:SI 1 "s_register_operand"  "r")
-		 (match_operand:SI 2 "s_register_operand"  "r")))]
-  "TARGET_THUMB2 && arm_arch_hwdiv"
-  "udiv%?\t%0, %1, %2"
-  [(set_attr "predicable" "yes")
-   (set_attr "insn" "udiv")]
-)
-
 (define_insn "*thumb2_subsi_short"
   [(set (match_operand:SI 0 "low_register_operand" "=l")
 	(minus:SI (match_operand:SI 1 "low_register_operand" "l")
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm: t-nucleus
diff -ru ./gcc/config/arm/t-symbian /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-symbian
--- ./gcc/config/arm/t-symbian	2014-06-06 11:50:15.427598597 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/t-symbian	2012-03-29 18:03:11.000000000 +1000
@@ -16,28 +16,6 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-LIB1ASMFUNCS += _bb_init_func _call_via_rX _interwork_call_via_rX _clzsi2 _clzdi2
-
-# These functions have __aeabi equivalents and will never be called by GCC.  
-# By putting them in LIB1ASMFUNCS, we avoid the standard libgcc2.c code being
-# used -- and we make sure that definitions are not available in lib1funcs.asm,
-# either, so they end up undefined.
-LIB1ASMFUNCS += \
-	_ashldi3 _ashrdi3 _divdi3 _floatdidf _udivmoddi4 _umoddi3 \
-	_udivdi3 _lshrdi3 _moddi3 _muldi3 _negdi2 _cmpdi2 \
-	_fixdfdi _fixsfdi _fixunsdfdi _fixunssfdi _floatdisf \
-	_negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi _fixunsdfsi \
-	_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2 \
-	_fixsfsi _fixunssfsi
-
-# Include the gcc personality routine
-UNWIND_H = $(srcdir)/config/arm/unwind-arm.h
-LIB2ADDEH = $(srcdir)/unwind-c.c $(srcdir)/config/arm/pr-support.c
-LIB2ADDEHDEP = $(UNWIND_H)
-
-# Include half-float helpers.
-LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/arm/fp16.c
-
 # Create a multilib for processors with VFP floating-point, and a
 # multilib for those without -- using the soft-float ABI in both
 # cases.  Symbian OS object should be compiled with interworking
@@ -45,6 +23,9 @@
 MULTILIB_OPTIONS     = mfloat-abi=softfp
 MULTILIB_DIRNAMES    = softfp
 
+LIB2FUNCS_EXTRA += $(srcdir)/config/arm/eabi-memcpy.c \
+  $(srcdir)/config/arm/eabi-memset.c
+
 # There is no C library to link against on Symbian OS -- at least when 
 # building GCC.
 SHLIB_LC = 
diff -ru ./gcc/config/arm/uclinux-eabi.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/uclinux-eabi.h
--- ./gcc/config/arm/uclinux-eabi.h	2014-06-06 11:50:15.431598597 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/uclinux-eabi.h	2012-03-29 18:03:11.000000000 +1000
@@ -50,6 +50,10 @@
 #undef ARM_DEFAULT_ABI
 #define ARM_DEFAULT_ABI ARM_ABI_AAPCS_LINUX
 
+#undef LINK_GCC_C_SEQUENCE_SPEC
+#define LINK_GCC_C_SEQUENCE_SPEC \
+  "--start-group %G %L --end-group"
+
 /* Clear the instruction cache from `beg' to `end'.  This makes an
    inline system call to SYS_cacheflush.  */
 #undef CLEAR_INSN_CACHE
diff -ru ./gcc/config/arm/unwind-arm.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/unwind-arm.c
--- ./gcc/config/arm/unwind-arm.c	2014-06-06 11:50:15.431598597 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/unwind-arm.c	2012-03-29 18:03:11.000000000 +1000
@@ -32,13 +32,18 @@
 typedef unsigned char bool;
 
 typedef struct _ZSt9type_info type_info; /* This names C++ type_info type */
+enum __cxa_type_match_result
+  {
+    ctm_failed = 0,
+    ctm_succeeded = 1,
+    ctm_succeeded_with_ptr_to_base = 2
+  };
 
 void __attribute__((weak)) __cxa_call_unexpected(_Unwind_Control_Block *ucbp);
 bool __attribute__((weak)) __cxa_begin_cleanup(_Unwind_Control_Block *ucbp);
-bool __attribute__((weak)) __cxa_type_match(_Unwind_Control_Block *ucbp,
-					    const type_info *rttip,
-					    bool is_reference,
-					    void **matched_object);
+enum __cxa_type_match_result __attribute__((weak)) __cxa_type_match
+  (_Unwind_Control_Block *ucbp, const type_info *rttip,
+   bool is_reference, void **matched_object);
 
 _Unwind_Ptr __attribute__((weak))
 __gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);
@@ -1107,6 +1112,7 @@
 		      _uw rtti;
 		      bool is_reference = (data[0] & uint32_highbit) != 0;
 		      void *matched;
+		      enum __cxa_type_match_result match_type;
 
 		      /* Check for no-throw areas.  */
 		      if (data[1] == (_uw) -2)
@@ -1118,17 +1124,31 @@
 			{
 			  /* Match a catch specification.  */
 			  rtti = _Unwind_decode_target2 ((_uw) &data[1]);
-			  if (!__cxa_type_match (ucbp, (type_info *) rtti,
-						 is_reference,
-						 &matched))
-			    matched = (void *)0;
+			  match_type = __cxa_type_match (ucbp,
+							 (type_info *) rtti,
+							 is_reference,
+							 &matched);
 			}
+		      else
+			match_type = ctm_succeeded;
 
-		      if (matched)
+		      if (match_type)
 			{
 			  ucbp->barrier_cache.sp =
 			    _Unwind_GetGR (context, R_SP);
-			  ucbp->barrier_cache.bitpattern[0] = (_uw) matched;
+			  // ctm_succeeded_with_ptr_to_base really
+			  // means _c_t_m indirected the pointer
+			  // object.  We have to reconstruct the
+			  // additional pointer layer by using a temporary.
+			  if (match_type == ctm_succeeded_with_ptr_to_base)
+			    {
+			      ucbp->barrier_cache.bitpattern[2]
+				= (_uw) matched;
+			      ucbp->barrier_cache.bitpattern[0]
+				= (_uw) &ucbp->barrier_cache.bitpattern[2];
+			    }
+			  else
+			    ucbp->barrier_cache.bitpattern[0] = (_uw) matched;
 			  ucbp->barrier_cache.bitpattern[1] = (_uw) data;
 			  return _URC_HANDLER_FOUND;
 			}
@@ -1196,8 +1216,6 @@
 		  ucbp->barrier_cache.bitpattern[4] = (_uw) &data[1];
 
 		  if (data[0] & uint32_highbit)
-		    phase2_call_unexpected_after_unwind = 1;
-		  else
 		    {
 		      data += rtti_count + 1;
 		      /* Setup for entry to the handler.  */
@@ -1207,6 +1225,8 @@
 		      _Unwind_SetGR (context, 0, (_uw) ucbp);
 		      return _URC_INSTALL_CONTEXT;
 		    }
+		  else
+		    phase2_call_unexpected_after_unwind = 1;
 		}
 	      if (data[0] & uint32_highbit)
 		data++;
diff -ru ./gcc/config/arm/unwind-arm.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/unwind-arm.h
--- ./gcc/config/arm/unwind-arm.h	2014-06-06 11:50:15.435598597 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/unwind-arm.h	2012-03-29 18:03:11.000000000 +1000
@@ -228,7 +228,8 @@
       if (!tmp)
 	return 0;
 
-#if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__)
+#if (defined(linux) && !defined(__uClinux__)) || defined(__NetBSD__) \
+    || (defined (__nucleus__) && defined (__shared__))
       /* Pc-relative indirect.  */
       tmp += ptr;
       tmp = *(_Unwind_Word *) tmp;
diff -ru ./gcc/config/arm/vfp.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/vfp.md
--- ./gcc/config/arm/vfp.md	2014-06-06 11:50:15.435598597 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/arm/vfp.md	2012-03-29 18:03:11.000000000 +1000
@@ -83,6 +83,7 @@
   "
   [(set_attr "predicable" "yes")
    (set_attr "type" "*,*,*,*,load1,store1,r_2_f,f_2_r,fcpys,f_loads,f_stores")
+   (set_attr "neon_type" "*,*,*,*,*,*,neon_mcr,neon_mrc,neon_vmov,neon_ldr,neon_str")
    (set_attr "insn" "mov,mov,mvn,mov,*,*,*,*,*,*,*")
    (set_attr "pool_range"     "*,*,*,*,4096,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,*,*,*,4084,*,*,*,*,1008,*")]
@@ -125,6 +126,7 @@
   "
   [(set_attr "predicable" "yes")
    (set_attr "type" "*,*,*,*,load1,load1,store1,store1,r_2_f,f_2_r,fcpys,f_loads,f_stores")
+   (set_attr "neon_type" "*,*,*,*,*,*,*,*,neon_mcr,neon_mrc,neon_vmov,*,*")
    (set_attr "insn" "mov,mov,mvn,mov,*,*,*,*,*,*,*,*,*")
    (set_attr "pool_range"     "*,*,*,*,1020,4096,*,*,*,*,*,1020,*")
    (set_attr "neg_pool_range" "*,*,*,*,   0,   0,*,*,*,*,*,1008,*")]
@@ -134,9 +136,51 @@
 ;; DImode moves
 
 (define_insn "*arm_movdi_vfp"
-  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r,m,w,r,w,w, Uv")
+  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r, m,w,r,w,w, Uv")
 	(match_operand:DI 1 "di_operand"              "rIK,mi,r,r,w,w,Uvi,w"))]
-  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP
+  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune != cortexa8
+   && (   register_operand (operands[0], DImode)
+       || register_operand (operands[1], DImode))"
+  "*
+  switch (which_alternative)
+    {
+    case 0: 
+      return \"#\";
+    case 1:
+    case 2:
+      return output_move_double (operands);
+    case 3:
+      return \"fmdrr%?\\t%P0, %Q1, %R1\\t%@ int\";
+    case 4:
+      return \"fmrrd%?\\t%Q0, %R0, %P1\\t%@ int\";
+    case 5:
+      if (TARGET_VFP_SINGLE)
+	return \"fcpys%?\\t%0, %1\\t%@ int\;fcpys%?\\t%p0, %p1\\t%@ int\";
+      else
+	return \"fcpyd%?\\t%P0, %P1\\t%@ int\";
+    case 6: case 7:
+      return output_move_vfp (operands);
+    default:
+      gcc_unreachable ();
+    }
+  "
+  [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
+			       (eq_attr "alternative" "5")
+				(if_then_else
+				 (eq (symbol_ref "TARGET_VFP_SINGLE") (const_int 1))
+				 (const_int 8)
+				 (const_int 4))]
+			      (const_int 4)))
+   (set_attr "pool_range"     "*,1020,*,*,*,*,1020,*")
+   (set_attr "neg_pool_range" "*,1008,*,*,*,*,1008,*")]
+)
+
+(define_insn "*arm_movdi_vfp_cortexa8"
+  [(set (match_operand:DI 0 "nonimmediate_di_operand" "=r, r,m,w,!r,w,w, Uv")
+	(match_operand:DI 1 "di_operand"              "rIK,mi,r,r,w,w,Uvi,w"))]
+  "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP && arm_tune == cortexa8
    && (   register_operand (operands[0], DImode)
        || register_operand (operands[1], DImode))"
   "*
@@ -163,6 +207,7 @@
     }
   "
   [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
    (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
 			       (eq_attr "alternative" "5")
 				(if_then_else
@@ -201,6 +246,7 @@
     }
   "
   [(set_attr "type" "*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored")
+   (set_attr "neon_type" "*,*,*,neon_mcr_2_mcrr,neon_mrrc,neon_vmov,*,*")
    (set (attr "length") (cond [(eq_attr "alternative" "0,1,2") (const_int 8)
 			       (eq_attr "alternative" "5")
 				(if_then_else
@@ -355,6 +401,7 @@
   [(set_attr "predicable" "yes")
    (set_attr "type"
      "r_2_f,f_2_r,fconsts,f_loads,f_stores,load1,store1,fcpys,*")
+   (set_attr "neon_type" "neon_mcr,neon_mrc,*,*,*,*,*,neon_vmov,*")
    (set_attr "insn" "*,*,*,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,1020,*,4096,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,4080,*,*,*")]
@@ -392,6 +439,7 @@
   [(set_attr "predicable" "yes")
    (set_attr "type"
      "r_2_f,f_2_r,fconsts,f_loads,f_stores,load1,store1,fcpys,*")
+   (set_attr "neon_type" "neon_mcr,neon_mrc,*,*,*,*,*,neon_vmov,*")
    (set_attr "insn" "*,*,*,*,*,*,*,*,mov")
    (set_attr "pool_range" "*,*,*,1020,*,4092,*,*,*")
    (set_attr "neg_pool_range" "*,*,*,1008,*,0,*,*,*")]
@@ -401,8 +449,8 @@
 ;; DFmode moves
 
 (define_insn "*movdf_vfp"
-  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,r, m,w  ,Uv,w,r")
-	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,mF,r,UvF,w, w,r"))]
+  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,w, r, m,w  ,Uv,w,r")
+	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,D0,mF,r,UvF,w, w,r"))]
   "TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP
    && (   register_operand (operands[0], DFmode)
        || register_operand (operands[1], DFmode))"
@@ -417,16 +465,18 @@
       case 2:
 	gcc_assert (TARGET_VFP_DOUBLE);
         return \"fconstd%?\\t%P0, #%G1\";
-      case 3: case 4:
+      case 3:
+	return \"vmov.i32\\t%P0, #0\";
+      case 4: case 5:
 	return output_move_double (operands);
-      case 5: case 6:
+      case 6: case 7:
 	return output_move_vfp (operands);
-      case 7:
+      case 8:
 	if (TARGET_VFP_SINGLE)
 	  return \"fcpys%?\\t%0, %1\;fcpys%?\\t%p0, %p1\";
 	else
 	  return \"fcpyd%?\\t%P0, %P1\";
-      case 8:
+      case 9:
         return \"#\";
       default:
 	gcc_unreachable ();
@@ -434,9 +484,10 @@
     }
   "
   [(set_attr "type"
-     "r_2_f,f_2_r,fconstd,f_loadd,f_stored,load2,store2,ffarithd,*")
-   (set (attr "length") (cond [(eq_attr "alternative" "3,4,8") (const_int 8)
-			       (eq_attr "alternative" "7")
+     "r_2_f,f_2_r,fconstd,*,f_loadd,f_stored,load2,store2,ffarithd,*")
+   (set_attr "neon_type" "neon_mcr_2_mcrr,neon_mrrc,*,neon_vmov,*,*,*,*,neon_vmov,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "4,5,9") (const_int 8)
+			       (eq_attr "alternative" "8")
 				(if_then_else
 				 (eq (symbol_ref "TARGET_VFP_SINGLE")
 				     (const_int 1))
@@ -444,14 +495,16 @@
 				 (const_int 4))]
 			      (const_int 4)))
    (set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,*,*,1020,*,1020,*,*,*")
-   (set_attr "neg_pool_range" "*,*,*,1008,*,1008,*,*,*")]
+   (set_attr "pool_range" "*,*,*,*,1020,*,1020,*,*,*")
+   (set_attr "neg_pool_range" "*,*,*,*,1008,*,1008,*,*,*")]
 )
 
 (define_insn "*thumb2_movdf_vfp"
-  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,r, m,w  ,Uv,w,r")
-	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,mF,r,UvF,w, w,r"))]
-  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP"
+  [(set (match_operand:DF 0 "nonimmediate_soft_df_operand" "=w,?r,w ,w,r, m,w  ,Uv,w,r")
+	(match_operand:DF 1 "soft_df_operand"		   " ?r,w,Dy,D0,mF,r,UvF,w, w,r"))]
+  "TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP
+   && (   register_operand (operands[0], DFmode)
+       || register_operand (operands[1], DFmode))"
   "*
   {
     switch (which_alternative)
@@ -463,11 +516,13 @@
       case 2:
 	gcc_assert (TARGET_VFP_DOUBLE);
 	return \"fconstd%?\\t%P0, #%G1\";
-      case 3: case 4: case 8:
+      case 3:
+	return \"vmov.i32\\t%P0, #0\";
+      case 4: case 5: case 9:
 	return output_move_double (operands);
-      case 5: case 6:
+      case 6: case 7:
 	return output_move_vfp (operands);
-      case 7:
+      case 8:
 	if (TARGET_VFP_SINGLE)
 	  return \"fcpys%?\\t%0, %1\;fcpys%?\\t%p0, %p1\";
 	else
@@ -478,17 +533,18 @@
     }
   "
   [(set_attr "type"
-     "r_2_f,f_2_r,fconstd,load2,store2,f_loadd,f_stored,ffarithd,*")
-   (set (attr "length") (cond [(eq_attr "alternative" "3,4,8") (const_int 8)
-			       (eq_attr "alternative" "7")
+     "r_2_f,f_2_r,fconstd,*,load2,store2,f_loadd,f_stored,ffarithd,*")
+   (set_attr "neon_type" "neon_mcr_2_mcrr,neon_mrrc,*,neon_vmov,*,*,*,*,neon_vmov,*")
+   (set (attr "length") (cond [(eq_attr "alternative" "4,5,9") (const_int 8)
+			       (eq_attr "alternative" "8")
 				(if_then_else
 				 (eq (symbol_ref "TARGET_VFP_SINGLE")
 				     (const_int 1))
 				 (const_int 8)
 				 (const_int 4))]
 			      (const_int 4)))
-   (set_attr "pool_range" "*,*,*,4096,*,1020,*,*,*")
-   (set_attr "neg_pool_range" "*,*,*,0,*,1008,*,*,*")]
+   (set_attr "pool_range" "*,*,*,*,4096,*,1020,*,*,*")
+   (set_attr "neg_pool_range" "*,*,*,*,0,*,1008,*,*,*")]
 )
 
 
@@ -514,7 +570,8 @@
    fmrs%D3\\t%0, %2\;fmrs%d3\\t%0, %1"
    [(set_attr "conds" "use")
     (set_attr "length" "4,4,8,4,4,8,4,4,8")
-    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr,neon_mcr,neon_mcr,neon_mrc,neon_mrc,neon_mrc")]
 )
 
 (define_insn "*thumb2_movsfcc_vfp"
@@ -537,7 +594,8 @@
    ite\\t%D3\;fmrs%D3\\t%0, %2\;fmrs%d3\\t%0, %1"
    [(set_attr "conds" "use")
     (set_attr "length" "6,6,10,6,6,10,6,6,10")
-    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "fcpys,fcpys,fcpys,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr,neon_mcr,neon_mcr,neon_mrc,neon_mrc,neon_mrc")]
 )
 
 (define_insn "*movdfcc_vfp"
@@ -560,7 +618,8 @@
    fmrrd%D3\\t%Q0, %R0, %P2\;fmrrd%d3\\t%Q0, %R0, %P1"
    [(set_attr "conds" "use")
     (set_attr "length" "4,4,8,4,4,8,4,4,8")
-    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mrrc,neon_mrrc,neon_mrrc")]
 )
 
 (define_insn "*thumb2_movdfcc_vfp"
@@ -583,7 +642,8 @@
    ite\\t%D3\;fmrrd%D3\\t%Q0, %R0, %P2\;fmrrd%d3\\t%Q0, %R0, %P1"
    [(set_attr "conds" "use")
     (set_attr "length" "6,6,10,6,6,10,6,6,10")
-    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")]
+    (set_attr "type" "ffarithd,ffarithd,ffarithd,r_2_f,r_2_f,r_2_f,f_2_r,f_2_r,f_2_r")
+    (set_attr "neon_type" "neon_vmov,neon_vmov,neon_vmov,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mcr_2_mcrr,neon_mrrc,neon_mrrc,neon_mrrc")]
 )
 
 
@@ -712,23 +772,25 @@
 ;; Division insns
 
 (define_insn "*divsf3_vfp"
-  [(set (match_operand:SF	  0 "s_register_operand" "+t")
-	(div:SF (match_operand:SF 1 "s_register_operand" "t")
-		(match_operand:SF 2 "s_register_operand" "t")))]
+  [(set (match_operand:SF	  0 "s_register_operand" "+t,&t")
+	(div:SF (match_operand:SF 1 "s_register_operand" "t,t")
+		(match_operand:SF 2 "s_register_operand" "t,t")))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
   "fdivs%?\\t%0, %1, %2"
   [(set_attr "predicable" "yes")
-   (set_attr "type" "fdivs")]
+   (set_attr "type" "fdivs")
+   (set_attr "arch" "notvfp9,vfp9")]
 )
 
 (define_insn "*divdf3_vfp"
-  [(set (match_operand:DF	  0 "s_register_operand" "+w")
-	(div:DF (match_operand:DF 1 "s_register_operand" "w")
-		(match_operand:DF 2 "s_register_operand" "w")))]
+  [(set (match_operand:DF	  0 "s_register_operand" "+w,&w")
+	(div:DF (match_operand:DF 1 "s_register_operand" "w,w")
+		(match_operand:DF 2 "s_register_operand" "w,w")))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fdivd%?\\t%P0, %P1, %P2"
   [(set_attr "predicable" "yes")
-   (set_attr "type" "fdivd")]
+   (set_attr "type" "fdivd")
+   (set_attr "arch" "notvfp9,vfp9")]
 )
 
 
@@ -991,21 +1053,23 @@
 ;; Sqrt insns.
 
 (define_insn "*sqrtsf2_vfp"
-  [(set (match_operand:SF	   0 "s_register_operand" "=t")
-	(sqrt:SF (match_operand:SF 1 "s_register_operand" "t")))]
+  [(set (match_operand:SF	   0 "s_register_operand" "=t,&t")
+	(sqrt:SF (match_operand:SF 1 "s_register_operand" "t,t")))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP"
   "fsqrts%?\\t%0, %1"
   [(set_attr "predicable" "yes")
-   (set_attr "type" "fdivs")]
+   (set_attr "type" "fdivs")
+   (set_attr "arch" "notvfp9,vfp9")]
 )
 
 (define_insn "*sqrtdf2_vfp"
-  [(set (match_operand:DF	   0 "s_register_operand" "=w")
-	(sqrt:DF (match_operand:DF 1 "s_register_operand" "w")))]
+  [(set (match_operand:DF	   0 "s_register_operand" "=w,&w")
+	(sqrt:DF (match_operand:DF 1 "s_register_operand" "w,w")))]
   "TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE"
   "fsqrtd%?\\t%P0, %P1"
   [(set_attr "predicable" "yes")
-   (set_attr "type" "fdivd")]
+   (set_attr "type" "fdivd")
+   (set_attr "arch" "notvfp9,vfp9")]
 )
 
 
diff -ru ./gcc/config/bfin/bfin.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/bfin/bfin.c
--- ./gcc/config/bfin/bfin.c	2014-06-06 11:50:15.487598599 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/bfin/bfin.c	2012-03-29 18:03:17.000000000 +1000
@@ -2332,7 +2332,7 @@
     XVECEXP (pat, 0, n++) = gen_rtx_USE (VOIDmode, picreg);
   XVECEXP (pat, 0, n++) = gen_rtx_USE (VOIDmode, cookie);
   if (sibcall)
-    XVECEXP (pat, 0, n++) = gen_rtx_RETURN (VOIDmode);
+    XVECEXP (pat, 0, n++) = ret_rtx;
   else
     XVECEXP (pat, 0, n++) = gen_rtx_CLOBBER (VOIDmode, retsreg);
   call = emit_call_insn (pat);
diff -ru ./gcc/config/cris/cris.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/cris/cris.c
--- ./gcc/config/cris/cris.c	2014-06-06 11:50:15.515598600 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/cris/cris.c	2012-03-29 18:03:00.000000000 +1000
@@ -1788,7 +1788,7 @@
      we do that until they're fixed.  Currently, all return insns in a
      function must be the same (not really a limiting factor) so we need
      to check that it doesn't change half-way through.  */
-  emit_jump_insn (gen_rtx_RETURN (VOIDmode));
+  emit_jump_insn (ret_rtx);
 
   CRIS_ASSERT (cfun->machine->return_type != CRIS_RETINSN_RET || !on_stack);
   CRIS_ASSERT (cfun->machine->return_type != CRIS_RETINSN_JUMP || on_stack);
diff -ru ./gcc/config/fixed-bit.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/fixed-bit.h
--- ./gcc/config/fixed-bit.h	2014-06-06 11:50:15.571598602 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/fixed-bit.h	2012-03-29 18:03:17.000000000 +1000
@@ -25,6 +25,10 @@
 #ifndef _FIXED_BIT_H
 #define _FIXED_BIT_H
 
+#ifdef LIBGCC2_GNU_PREFIX
+#define LIBGCC2_FIXEDBIT_GNU_PREFIX
+#endif
+
 /* To use this file we need to define one of the following:
    QQ_MODE, UQQ_MODE, HQ_MODE, UHQ_MODE, SQ_MODE, USQ_MODE, DQ_MODE, UDQ_MODE,
    TQ_MODE, UTQ_MODE, HA_MODE, UHA_MODE, SA_MODE, USA_MODE, DA_MODE, UDA_MODE,
@@ -445,35 +449,39 @@
 #define IBITS		IBITS2(MODE_NAME)
 #define I_F_BITS	(FBITS + IBITS)
 
-#define FIXED_OP(OP,MODE,NUM)	OP ## MODE ## NUM
+#ifdef LIBGCC2_FIXEDBIT_GNU_PREFIX
+#define FIXED_OP(OP,MODE,NUM)	__gnu_ ## OP ## MODE ## NUM
+#else
+#define FIXED_OP(OP,MODE,NUM)	__ ## OP ## MODE ## NUM
+#endif
 
-#define FIXED_SATURATE1_TEMP(NAME)	FIXED_OP(__saturate1,NAME,)
-#define FIXED_SATURATE2_TEMP(NAME)	FIXED_OP(__saturate2,NAME,)
-#define FIXED_MULHELPER_TEMP(NAME)	FIXED_OP(__mulhelper,NAME,)
-#define FIXED_DIVHELPER_TEMP(NAME)	FIXED_OP(__divhelper,NAME,)
-#define FIXED_ASHLHELPER_TEMP(NAME)	FIXED_OP(__ashlhelper,NAME,)
-#define FIXED_ADD_TEMP(NAME)	FIXED_OP(__add,NAME,3)
-#define FIXED_SSADD_TEMP(NAME)	FIXED_OP(__ssadd,NAME,3)
-#define FIXED_USADD_TEMP(NAME)	FIXED_OP(__usadd,NAME,3)
-#define FIXED_SUB_TEMP(NAME)	FIXED_OP(__sub,NAME,3)
-#define FIXED_SSSUB_TEMP(NAME)	FIXED_OP(__sssub,NAME,3)
-#define FIXED_USSUB_TEMP(NAME)	FIXED_OP(__ussub,NAME,3)
-#define FIXED_MUL_TEMP(NAME)	FIXED_OP(__mul,NAME,3)
-#define FIXED_SSMUL_TEMP(NAME)	FIXED_OP(__ssmul,NAME,3)
-#define FIXED_USMUL_TEMP(NAME)	FIXED_OP(__usmul,NAME,3)
-#define FIXED_DIV_TEMP(NAME)	FIXED_OP(__div,NAME,3)
-#define FIXED_UDIV_TEMP(NAME)	FIXED_OP(__udiv,NAME,3)
-#define FIXED_SSDIV_TEMP(NAME)	FIXED_OP(__ssdiv,NAME,3)
-#define FIXED_USDIV_TEMP(NAME)	FIXED_OP(__usdiv,NAME,3)
-#define FIXED_NEG_TEMP(NAME)	FIXED_OP(__neg,NAME,2)
-#define FIXED_SSNEG_TEMP(NAME)	FIXED_OP(__ssneg,NAME,2)
-#define FIXED_USNEG_TEMP(NAME)	FIXED_OP(__usneg,NAME,2)
-#define FIXED_ASHL_TEMP(NAME)	FIXED_OP(__ashl,NAME,3)
-#define FIXED_ASHR_TEMP(NAME)	FIXED_OP(__ashr,NAME,3)
-#define FIXED_LSHR_TEMP(NAME)	FIXED_OP(__lshr,NAME,3)
-#define FIXED_SSASHL_TEMP(NAME)	FIXED_OP(__ssashl,NAME,3)
-#define FIXED_USASHL_TEMP(NAME)	FIXED_OP(__usashl,NAME,3)
-#define FIXED_CMP_TEMP(NAME)	FIXED_OP(__cmp,NAME,2)
+#define FIXED_SATURATE1_TEMP(NAME)	FIXED_OP(saturate1,NAME,)
+#define FIXED_SATURATE2_TEMP(NAME)	FIXED_OP(saturate2,NAME,)
+#define FIXED_MULHELPER_TEMP(NAME)	FIXED_OP(mulhelper,NAME,)
+#define FIXED_DIVHELPER_TEMP(NAME)	FIXED_OP(divhelper,NAME,)
+#define FIXED_ASHLHELPER_TEMP(NAME)	FIXED_OP(ashlhelper,NAME,)
+#define FIXED_ADD_TEMP(NAME)	FIXED_OP(add,NAME,3)
+#define FIXED_SSADD_TEMP(NAME)	FIXED_OP(ssadd,NAME,3)
+#define FIXED_USADD_TEMP(NAME)	FIXED_OP(usadd,NAME,3)
+#define FIXED_SUB_TEMP(NAME)	FIXED_OP(sub,NAME,3)
+#define FIXED_SSSUB_TEMP(NAME)	FIXED_OP(sssub,NAME,3)
+#define FIXED_USSUB_TEMP(NAME)	FIXED_OP(ussub,NAME,3)
+#define FIXED_MUL_TEMP(NAME)	FIXED_OP(mul,NAME,3)
+#define FIXED_SSMUL_TEMP(NAME)	FIXED_OP(ssmul,NAME,3)
+#define FIXED_USMUL_TEMP(NAME)	FIXED_OP(usmul,NAME,3)
+#define FIXED_DIV_TEMP(NAME)	FIXED_OP(div,NAME,3)
+#define FIXED_UDIV_TEMP(NAME)	FIXED_OP(udiv,NAME,3)
+#define FIXED_SSDIV_TEMP(NAME)	FIXED_OP(ssdiv,NAME,3)
+#define FIXED_USDIV_TEMP(NAME)	FIXED_OP(usdiv,NAME,3)
+#define FIXED_NEG_TEMP(NAME)	FIXED_OP(neg,NAME,2)
+#define FIXED_SSNEG_TEMP(NAME)	FIXED_OP(ssneg,NAME,2)
+#define FIXED_USNEG_TEMP(NAME)	FIXED_OP(usneg,NAME,2)
+#define FIXED_ASHL_TEMP(NAME)	FIXED_OP(ashl,NAME,3)
+#define FIXED_ASHR_TEMP(NAME)	FIXED_OP(ashr,NAME,3)
+#define FIXED_LSHR_TEMP(NAME)	FIXED_OP(lshr,NAME,3)
+#define FIXED_SSASHL_TEMP(NAME)	FIXED_OP(ssashl,NAME,3)
+#define FIXED_USASHL_TEMP(NAME)	FIXED_OP(usashl,NAME,3)
+#define FIXED_CMP_TEMP(NAME)	FIXED_OP(cmp,NAME,2)
 
 #if defined (MODE_NAME)
 #if defined (DINT_C_TYPE)
@@ -1146,14 +1154,19 @@
 #define TO_HAVE_PADDING_BITS	(TO_PADDING_BITS > 0)
 #endif /* TO_TYPE == 4  */
 
-#define FIXED_CONVERT_OP(OP,FROM,TO)	OP ## FROM ## TO
-#define FIXED_CONVERT_OP2(OP,FROM,TO)	OP ## FROM ## TO ## 2
-#define FRACT_TEMP(N1,N2)		FIXED_CONVERT_OP(__fract,N1,N2)
-#define FRACT2_TEMP(N1,N2)		FIXED_CONVERT_OP2(__fract,N1,N2)
-#define SATFRACT_TEMP(N1,N2)		FIXED_CONVERT_OP(__satfract,N1,N2)
-#define SATFRACT2_TEMP(N1,N2)		FIXED_CONVERT_OP2(__satfract,N1,N2)
-#define FRACTUNS_TEMP(N1,N2)		FIXED_CONVERT_OP(__fractuns,N1,N2)
-#define SATFRACTUNS_TEMP(N1,N2)		FIXED_CONVERT_OP(__satfractuns,N1,N2)
+#ifdef LIBGCC2_FIXEDBIT_GNU_PREFIX
+#define FIXED_CONVERT_OP(OP,FROM,TO)	__gnu_ ## OP ## FROM ## TO
+#define FIXED_CONVERT_OP2(OP,FROM,TO)	__gnu_ ## OP ## FROM ## TO ## 2
+#else
+#define FIXED_CONVERT_OP(OP,FROM,TO)	__ ## OP ## FROM ## TO
+#define FIXED_CONVERT_OP2(OP,FROM,TO)	__ ## OP ## FROM ## TO ## 2
+#endif
+#define FRACT_TEMP(N1,N2)		FIXED_CONVERT_OP(fract,N1,N2)
+#define FRACT2_TEMP(N1,N2)		FIXED_CONVERT_OP2(fract,N1,N2)
+#define SATFRACT_TEMP(N1,N2)		FIXED_CONVERT_OP(satfract,N1,N2)
+#define SATFRACT2_TEMP(N1,N2)		FIXED_CONVERT_OP2(satfract,N1,N2)
+#define FRACTUNS_TEMP(N1,N2)		FIXED_CONVERT_OP(fractuns,N1,N2)
+#define SATFRACTUNS_TEMP(N1,N2)		FIXED_CONVERT_OP(satfractuns,N1,N2)
 
 /* Define conversions from fixed-point to fixed-point.  */
 #if FROM_TYPE == 4 && TO_TYPE == 4
diff -ru ./gcc/config/frv/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/frv/t-linux
--- ./gcc/config/frv/t-linux	2014-06-06 11:50:15.639598605 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/frv/t-linux	2012-03-29 18:02:45.000000000 +1000
@@ -29,5 +29,5 @@
 CRTSTUFF_T_CFLAGS = -fPIC
 TARGET_LIBGCC2_CFLAGS = -fPIC
 
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver \
 		 $(srcdir)/config/frv/libgcc-frv.ver
diff -ru ./gcc/config/h8300/h8300.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/h8300/h8300.c
--- ./gcc/config/h8300/h8300.c	2014-06-06 14:25:27.278150544 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/h8300/h8300.c	2012-03-29 18:03:16.000000000 +1000
@@ -416,7 +416,7 @@
     }
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 }
 
@@ -702,7 +702,7 @@
   /* Add the return instruction.  */
   if (return_p)
     {
-      RTVEC_ELT (vec, i) = gen_rtx_RETURN (VOIDmode);
+      RTVEC_ELT (vec, i) = ret_rtx;
       i++;
     }
 
@@ -986,7 +986,7 @@
     }
 
   if (!returned_p)
-    emit_jump_insn (gen_rtx_RETURN (VOIDmode));
+    emit_jump_insn (ret_rtx);
 }
 
 /* Return nonzero if the current function is an interrupt
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386: cs-linux.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386: cs-linux-lite.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386: cs-linux.opt
diff -ru ./gcc/config/i386/i386.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/i386.c
--- ./gcc/config/i386/i386.c	2014-06-06 14:25:27.302150545 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/i386.c	2012-03-29 18:02:55.000000000 +1000
@@ -11279,13 +11279,13 @@
 
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
 				     popc, -1, true);
-	  emit_jump_insn (gen_return_indirect_internal (ecx));
+	  emit_jump_insn (gen_simple_return_indirect_internal (ecx));
 	}
       else
-	emit_jump_insn (gen_return_pop_internal (popc));
+	emit_jump_insn (gen_simple_return_pop_internal (popc));
     }
   else
-    emit_jump_insn (gen_return_internal ());
+    emit_jump_insn (gen_simple_return_internal ());
 
   /* Restore the state back to the state from the prologue,
      so that it's correct for the next epilogue.  */
@@ -30183,7 +30183,7 @@
       rtx prev;
       bool replace = false;
 
-      if (!JUMP_P (ret) || GET_CODE (PATTERN (ret)) != RETURN
+      if (!JUMP_P (ret) || !ANY_RETURN_P (PATTERN (ret))
 	  || optimize_bb_for_size_p (bb))
 	continue;
       for (prev = PREV_INSN (ret); prev; prev = PREV_INSN (prev))
@@ -30213,7 +30213,10 @@
 	}
       if (replace)
 	{
-	  emit_jump_insn_before (gen_return_internal_long (), ret);
+	  if (PATTERN (ret) == ret_rtx)
+	    emit_jump_insn_before (gen_return_internal_long (), ret);
+	  else
+	    emit_jump_insn_before (gen_simple_return_internal_long (), ret);
 	  delete_insn (ret);
 	}
     }
@@ -30234,7 +30237,7 @@
     {
       /* Only happen in exit blocks.  */
       if (JUMP_P (insn)
-	  && GET_CODE (PATTERN (insn)) == RETURN)
+	  && ANY_RETURN_P (PATTERN (insn)))
 	break;
 
       if (NONDEBUG_INSN_P (insn)
@@ -30307,7 +30310,7 @@
   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)
     {
       rtx ret = BB_END (e->src);
-      if (JUMP_P (ret) && GET_CODE (PATTERN (ret)) == RETURN)
+      if (JUMP_P (ret) && ANY_RETURN_P (PATTERN (ret)))
 	{
 	  int insn_count = ix86_count_insn (e->src);
 
diff -ru ./gcc/config/i386/i386elf.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/i386elf.h
--- ./gcc/config/i386/i386elf.h	2014-06-06 11:50:15.835598612 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/i386elf.h	2012-03-29 18:02:55.000000000 +1000
@@ -20,10 +20,6 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-/* Use stabs instead of DWARF debug format.  */
-#undef  PREFERRED_DEBUGGING_TYPE
-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
-
 #define TARGET_VERSION fprintf (stderr, " (i386 bare ELF target)");
 
 /* The ELF ABI for the i386 says that records and unions are returned
@@ -36,12 +32,9 @@
 #undef CPP_SPEC
 #define CPP_SPEC ""
 
-#define ENDFILE_SPEC "crtend.o%s"
+#define ENDFILE_SPEC "crtend.o%s crtn.o%s"
 
-#define STARTFILE_SPEC "%{!shared: \
-			 %{!symbolic: \
-			  %{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}\
-			crtbegin.o%s"
+#define STARTFILE_SPEC "crtbegin.o%s crti.o%s"
 
 #undef DBX_REGISTER_NUMBER
 #define DBX_REGISTER_NUMBER(n) \
diff -ru ./gcc/config/i386/i386.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/i386.md
--- ./gcc/config/i386/i386.md	2014-06-06 14:25:27.314150546 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/i386.md	2012-03-29 18:02:55.000000000 +1000
@@ -11711,24 +11711,29 @@
   ""
   [(set_attr "length" "0")])
 
+(define_code_iterator returns [return simple_return])
+(define_code_attr return_str [(return "") (simple_return "simple_")])
+(define_code_attr return_cond [(return "ix86_can_use_return_insn_p ()")
+			       (simple_return "")])
+
 ;; Insn emitted into the body of a function to return from a function.
 ;; This is only done if the function's epilogue is known to be simple.
 ;; See comments for ix86_can_use_return_insn_p in i386.c.
 
-(define_expand "return"
-  [(return)]
-  "ix86_can_use_return_insn_p ()"
+(define_expand "<return_str>return"
+  [(returns)]
+  "<return_cond>"
 {
   if (crtl->args.pops_args)
     {
       rtx popc = GEN_INT (crtl->args.pops_args);
-      emit_jump_insn (gen_return_pop_internal (popc));
+      emit_jump_insn (gen_<return_str>return_pop_internal (popc));
       DONE;
     }
 })
 
-(define_insn "return_internal"
-  [(return)]
+(define_insn "<return_str>return_internal"
+  [(returns)]
   "reload_completed"
   "ret"
   [(set_attr "length" "1")
@@ -11739,8 +11744,8 @@
 ;; Used by x86_machine_dependent_reorg to avoid penalty on single byte RET
 ;; instruction Athlon and K8 have.
 
-(define_insn "return_internal_long"
-  [(return)
+(define_insn "<return_str>return_internal_long"
+  [(returns)
    (unspec [(const_int 0)] UNSPEC_REP)]
   "reload_completed"
   "rep\;ret"
@@ -11750,8 +11755,8 @@
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
 
-(define_insn "return_pop_internal"
-  [(return)
+(define_insn "<return_str>return_pop_internal"
+  [(returns)
    (use (match_operand:SI 0 "const_int_operand" ""))]
   "reload_completed"
   "ret\t%0"
@@ -11760,8 +11765,8 @@
    (set_attr "length_immediate" "2")
    (set_attr "modrm" "0")])
 
-(define_insn "return_indirect_internal"
-  [(return)
+(define_insn "<return_str>return_indirect_internal"
+  [(returns)
    (use (match_operand:SI 0 "register_operand" "r"))]
   "reload_completed"
   "jmp\t%A0"
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386: t-cs-linux
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386: t-cs-linux-lite
diff -ru ./gcc/config/i386/t-cygming /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/t-cygming
--- ./gcc/config/i386/t-cygming	2014-06-06 11:50:15.907598615 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/t-cygming	2012-03-29 18:02:55.000000000 +1000
@@ -106,4 +106,4 @@
 # We'd like to use SHLIB_SONAME here too, but shlib_base_name
 # does not get substituted before mkmap-flat.awk is run.
 SHLIB_MKMAP_OPTS = -v pe_dll=libgcc_s_$(EH_MODEL)-$(SHLIB_SOVERSION)$(SHLIB_EXT)
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver
diff -ru ./gcc/config/i386/t-i386elf /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/t-i386elf
--- ./gcc/config/i386/t-i386elf	2014-06-06 11:50:15.911598615 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/t-i386elf	2012-03-29 18:02:55.000000000 +1000
@@ -1,4 +1,17 @@
 # For svr4 we build crtbegin.o and crtend.o which serve to add begin and
 # end labels to the .ctors and .dtors section when we link using gcc.
 
-EXTRA_PARTS=crtbegin.o crtend.o
+EXTRA_PARTS=crtbegin.o crtend.o crti.o crtn.o
+
+#
+# Also build crti.o and ctrn.o to provide _init/_fini.
+# The x68 Solaris implementation works here.
+#
+
+$(T)crti.o: $(srcdir)/config/i386/sol2-ci.asm $(GCC_PASSES)
+	sed -e '/^!/d' <$(srcdir)/config/i386/sol2-ci.asm >crti.s
+	$(GCC_FOR_TARGET) -c -o $(T)crti.o crti.s
+$(T)crtn.o: $(srcdir)/config/i386/sol2-cn.asm $(GCC_PASSES)
+	sed -e '/^!/d' <$(srcdir)/config/i386/sol2-cn.asm >crtn.s
+	$(GCC_FOR_TARGET) -c -o $(T)crtn.o crtn.s
+
diff -ru ./gcc/config/i386/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/t-linux
--- ./gcc/config/i386/t-linux	2014-06-06 14:25:27.318150546 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/i386/t-linux	2012-03-29 18:02:55.000000000 +1000
@@ -1,5 +1,5 @@
 # On 64bit we do not need any exports for glibc for 64-bit libgcc_s.
 # Need to support TImode for x86.  Override the settings from
 # t-slibgcc-elf-ver and t-linux
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver \
 		 $(srcdir)/config/i386/libgcc-glibc.ver
diff -ru ./gcc/config/m32c/m32c.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m32c/m32c.c
--- ./gcc/config/m32c/m32c.c	2014-06-06 14:25:27.322150546 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m32c/m32c.c	2012-03-29 18:02:47.000000000 +1000
@@ -447,7 +447,7 @@
     flag_ivopts = 0;
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   /* r8c/m16c have no 16-bit indirect call, so thunks are involved.
diff -ru ./gcc/config/m68k/m68k.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k.c
--- ./gcc/config/m68k/m68k.c	2014-06-06 11:50:16.091598622 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k.c	2012-03-29 18:03:03.000000000 +1000
@@ -1397,7 +1397,7 @@
 			   EH_RETURN_STACKADJ_RTX));
 
   if (!sibcall_p)
-    emit_jump_insn (gen_rtx_RETURN (VOIDmode));
+    emit_jump_insn (ret_rtx);
 }
 
 /* Return true if X is a valid comparison operator for the dbcc 
@@ -1917,15 +1917,16 @@
    whether we need strict checking.  */
 
 bool
-m68k_legitimate_index_reg_p (rtx x, bool strict_p)
+m68k_legitimate_index_reg_p (enum machine_mode mode, rtx x, bool strict_p)
 {
   if (!strict_p && GET_CODE (x) == SUBREG)
     x = SUBREG_REG (x);
 
   return (REG_P (x)
 	  && (strict_p
-	      ? REGNO_OK_FOR_INDEX_P (REGNO (x))
-	      : REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (x))));
+	      ? REGNO_MODE_OK_FOR_INDEX_P (REGNO (x), mode)
+	      : (MODE_OK_FOR_INDEX_P (mode)
+		 && REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (x)))));
 }
 
 /* Return true if X is a legitimate index expression for a (d8,An,Xn) or
@@ -1933,7 +1934,8 @@
    ADDRESS if so.  STRICT_P says whether we need strict checking.  */
 
 static bool
-m68k_decompose_index (rtx x, bool strict_p, struct m68k_address *address)
+m68k_decompose_index (enum machine_mode mode, rtx x, bool strict_p,
+		      struct m68k_address *address)
 {
   int scale;
 
@@ -1957,7 +1959,7 @@
       && GET_MODE (XEXP (x, 0)) == HImode)
     x = XEXP (x, 0);
 
-  if (m68k_legitimate_index_reg_p (x, strict_p))
+  if (m68k_legitimate_index_reg_p (mode, x, strict_p))
     {
       address->scale = scale;
       address->index = x;
@@ -2111,7 +2113,7 @@
      accesses to unplaced labels in other cases.  */
   if (GET_CODE (x) == PLUS
       && m68k_jump_table_ref_p (XEXP (x, 1))
-      && m68k_decompose_index (XEXP (x, 0), strict_p, address))
+      && m68k_decompose_index (mode, XEXP (x, 0), strict_p, address))
     {
       address->offset = XEXP (x, 1);
       return true;
@@ -2143,7 +2145,7 @@
 	 worse code.  */
       if (address->offset
 	  && symbolic_operand (address->offset, VOIDmode)
-	  && m68k_decompose_index (x, strict_p, address))
+	  && m68k_decompose_index (mode, x, strict_p, address))
 	return true;
     }
   else
@@ -2162,14 +2164,14 @@
   if (GET_CODE (x) == PLUS)
     {
       if (m68k_legitimate_base_reg_p (XEXP (x, 0), strict_p)
-	  && m68k_decompose_index (XEXP (x, 1), strict_p, address))
+	  && m68k_decompose_index (mode, XEXP (x, 1), strict_p, address))
 	{
 	  address->base = XEXP (x, 0);
 	  return true;
 	}
 
       if (m68k_legitimate_base_reg_p (XEXP (x, 1), strict_p)
-	  && m68k_decompose_index (XEXP (x, 0), strict_p, address))
+	  && m68k_decompose_index (mode, XEXP (x, 0), strict_p, address))
 	{
 	  address->base = XEXP (x, 1);
 	  return true;
@@ -4302,7 +4304,8 @@
       && GET_MODE_CLASS (GET_MODE (XEXP (cc_status.value2, 0))) == MODE_FLOAT)
     {
       cc_status.flags = CC_IN_68881;
-      if (!FP_REG_P (XEXP (cc_status.value2, 0)))
+      if (!FP_REG_P (XEXP (cc_status.value2, 0))
+	  && FP_REG_P (XEXP (cc_status.value2, 1)))
 	cc_status.flags |= CC_REVERSED;
     }
 }
@@ -6175,7 +6178,14 @@
 	  gcc_unreachable ();
 	}
 
-      gcc_assert (insn_size <= sched_ib.filled);
+      if (insn_size > sched_ib.filled)
+	/* Scheduling for register pressure does not always take DFA into
+	   account.  Workaround instruction buffer not being filled enough.  */
+	{
+	  gcc_assert (sched_pressure_p);
+	  insn_size = sched_ib.filled;
+	}
+
       --can_issue_more;
     }
   else if (GET_CODE (PATTERN (insn)) == ASM_INPUT
@@ -6341,6 +6351,8 @@
     /* haifa-sched.c: schedule_block () calls advance_cycle () just before
        the first cycle.  Workaround that.  */
     sched_ib.filled = -2;
+  /* Undo attempts by sched-rgn to save states across block boundaries.  */
+  state_reset (curr_state);
 }
 
 /* Implementation of targetm.sched.dfa_pre_advance_cycle () hook.
diff -ru ./gcc/config/m68k/m68k-devices.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k-devices.def
--- ./gcc/config/m68k/m68k-devices.def	2014-06-06 11:50:16.079598621 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k-devices.def	2012-03-29 18:03:03.000000000 +1000
@@ -84,10 +84,16 @@
 /* For historical reasons, the 51 multilib is named 51qe.  */
 M68K_DEVICE ("51",    mcf51,    "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
 M68K_DEVICE ("51ac",  mcf51ac,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51ag",  mcf51ag,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
 M68K_DEVICE ("51cn",  mcf51cn,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
 M68K_DEVICE ("51em",  mcf51em,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_MAC)
+M68K_DEVICE ("51je",  mcf51je,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_MAC)
+M68K_DEVICE ("51jf",  mcf51jf,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_EMAC)
+M68K_DEVICE ("51jg",  mcf51jg,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_EMAC)
 M68K_DEVICE ("51jm",  mcf51jm,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51mm",  mcf51mm,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_MAC)
 M68K_DEVICE ("51qe",  mcf51qe,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP)
+M68K_DEVICE ("51qm",  mcf51qm,  "51",    "51qe",  cfv1,     isa_c,     FL_CF_USP | FL_CF_EMAC)
 
 /* ColdFire CFV2 processors.  */
 M68K_DEVICE ("5202",  mcf5202,  "5206",  "5206",  cfv2,     isa_a,     0)
diff -ru ./gcc/config/m68k/m68k.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k.h
--- ./gcc/config/m68k/m68k.h	2014-06-06 11:50:16.099598622 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k.h	2012-03-29 18:03:03.000000000 +1000
@@ -480,7 +480,8 @@
 
 extern enum reg_class regno_reg_class[];
 #define REGNO_REG_CLASS(REGNO) (regno_reg_class[(REGNO)])
-#define INDEX_REG_CLASS GENERAL_REGS
+#define MODE_INDEX_REG_CLASS(MODE) \
+  (MODE_OK_FOR_INDEX_P (MODE) ? GENERAL_REGS : NO_REGS)
 #define BASE_REG_CLASS ADDR_REGS
 
 #define PREFERRED_RELOAD_CLASS(X,CLASS) \
@@ -614,6 +615,10 @@
 #define HAVE_POST_INCREMENT 1
 #define HAVE_PRE_DECREMENT 1
 
+/* Return true if addresses of mode MODE can have an index register.  */
+#define MODE_OK_FOR_INDEX_P(MODE) \
+  (!TARGET_COLDFIRE_FPU || GET_MODE_CLASS (MODE) != MODE_FLOAT)
+
 /* Macros to check register numbers against specific register classes.  */
 
 /* True for data registers, D0 through D7.  */
@@ -628,9 +633,10 @@
 /* True for floating point registers, FP0 through FP7.  */
 #define FP_REGNO_P(REGNO)	IN_RANGE (REGNO, 16, 23)
 
-#define REGNO_OK_FOR_INDEX_P(REGNO)			\
-  (INT_REGNO_P (REGNO)					\
-   || INT_REGNO_P (reg_renumber[REGNO]))
+#define REGNO_MODE_OK_FOR_INDEX_P(REGNO, MODE)		\
+  (MODE_OK_FOR_INDEX_P (MODE)				\
+   && (INT_REGNO_P (REGNO)				\
+       || INT_REGNO_P (reg_renumber[REGNO])))
 
 #define REGNO_OK_FOR_BASE_P(REGNO)			\
   (ADDRESS_REGNO_P (REGNO)				\
@@ -696,8 +702,8 @@
 #define REG_OK_FOR_BASE_P(X) \
   m68k_legitimate_base_reg_p (X, REG_STRICT_P)
 
-#define REG_OK_FOR_INDEX_P(X) \
-  m68k_legitimate_index_reg_p (X, REG_STRICT_P)
+#define REG_MODE_OK_FOR_INDEX_P(X, MODE)	\
+  m68k_legitimate_index_reg_p (MODE, X, REG_STRICT_P)
 
 
 /* This address is OK as it stands.  */
diff -ru ./gcc/config/m68k/m68k.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k.md
--- ./gcc/config/m68k/m68k.md	2014-06-06 11:50:16.111598623 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k.md	2012-03-29 18:03:03.000000000 +1000
@@ -387,7 +387,7 @@
 
 (define_insn "tst<mode>_cf"
   [(set (cc0)
-	(compare (match_operand:FP 0 "general_operand" "f<FP:dreg><Q>U")
+	(compare (match_operand:FP 0 "general_operand" "f<FP:dreg>m")
 		 (match_operand:FP 1 "const0_operand" "H")))]
   "TARGET_COLDFIRE_FPU"
 {
@@ -637,8 +637,8 @@
 
 (define_insn "*cmp<mode>_cf"
   [(set (cc0)
-	(compare (match_operand:FP 0 "fp_src_operand" "f,f,<FP:dreg><Q>U")
-		 (match_operand:FP 1 "fp_src_operand" "f,<FP:dreg><Q>U,f")))]
+	(compare (match_operand:FP 0 "fp_src_operand" "f,f,<FP:dreg>m")
+		 (match_operand:FP 1 "fp_src_operand" "f,<FP:dreg>m,f")))]
   "TARGET_COLDFIRE_FPU
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
@@ -1195,10 +1195,8 @@
 ;; SFmode MEMs are restricted to modes 2-4 if TARGET_COLDFIRE_FPU.
 ;; The move instructions can handle all combinations.
 (define_insn "movsf_cf_hard"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=r<Q>U, f,    f,mr,f,r<Q>,f
-,m")
-        (match_operand:SF 1 "general_operand"      " f,     r<Q>U,f,rm,F,F,   m
-,f"))]
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=rm,f, f,rm,f,r<Q>,f,m")
+        (match_operand:SF 1 "general_operand"      " f, rm,f,rm,F,F,   m,f"))]
   "TARGET_COLDFIRE_FPU"
 {
   if (which_alternative == 4 || which_alternative == 5) {
@@ -1340,8 +1338,8 @@
 })
 
 (define_insn "movdf_cf_hard"
-  [(set (match_operand:DF 0 "nonimmediate_operand" "=f,    <Q>U,r,f,r,r,m,f")
-        (match_operand:DF 1 "general_operand"      " f<Q>U,f,   f,r,r,m,r,E"))]
+  [(set (match_operand:DF 0 "nonimmediate_operand" "=f, m,r,f,r,r,m,f")
+        (match_operand:DF 1 "general_operand"      " fm,f,f,r,r,m,r,E"))]
   "TARGET_COLDFIRE_FPU"
 {
   rtx xoperands[3];
@@ -1982,7 +1980,7 @@
 (define_insn "extendsfdf2_cf"
   [(set (match_operand:DF 0 "nonimmediate_operand" "=f,f")
 	(float_extend:DF
-	 (match_operand:SF 1 "general_operand" "f,<Q>U")))]
+	 (match_operand:SF 1 "general_operand" "f,m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[0]) && FP_REG_P (operands[1]))
@@ -2022,9 +2020,9 @@
 })
 
 (define_insn "truncdfsf2_cf"
-  [(set (match_operand:SF 0 "nonimmediate_operand" "=f,d<Q>U")
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=f,dm")
 	(float_truncate:SF
-	  (match_operand:DF 1 "general_operand" "<Q>U,f")))]
+	  (match_operand:DF 1 "general_operand" "m,f")))]
   "TARGET_COLDFIRE_FPU"
   "@
   fsmove%.d %1,%0
@@ -2170,7 +2168,7 @@
 
 (define_insn "ftrunc<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
-        (fix:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U")))]
+        (fix:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[1]))
@@ -2791,7 +2789,7 @@
 (define_insn "add<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(plus:FP (match_operand:FP 1 "general_operand" "%0")
-		 (match_operand:FP 2 "general_operand" "f<FP:dreg><Q>U")))]
+		 (match_operand:FP 2 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3014,7 +3012,7 @@
 (define_insn "sub<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
         (minus:FP (match_operand:FP 1 "general_operand" "0")
-                  (match_operand:FP 2 "general_operand" "f<FP:dreg><Q>U")))]
+                  (match_operand:FP 2 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3370,7 +3368,7 @@
 (define_insn "fmul<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(mult:FP (match_operand:FP 1 "general_operand" "%0")
-		 (match_operand:FP 2 "general_operand" "f<Q>U<FP:dreg>")))]
+		 (match_operand:FP 2 "general_operand" "fm<FP:dreg>")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -3440,7 +3438,7 @@
 (define_insn "div<mode>3_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
 	(div:FP (match_operand:FP 1 "general_operand" "0")
-		(match_operand:FP 2 "general_operand" "f<Q>U<FP:dreg>")))]
+		(match_operand:FP 2 "general_operand" "fm<FP:dreg>")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[2]))
@@ -4288,7 +4286,7 @@
 
 (define_insn "neg<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f,d")
-	(neg:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U,0")))]
+	(neg:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m,0")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (DATA_REG_P (operands[0]))
@@ -4322,7 +4320,7 @@
 
 (define_insn "sqrt<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f")
-	(sqrt:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U")))]
+	(sqrt:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (FP_REG_P (operands[1]))
@@ -4441,7 +4439,7 @@
 
 (define_insn "abs<mode>2_cf"
   [(set (match_operand:FP 0 "nonimmediate_operand" "=f,d")
-	(abs:FP (match_operand:FP 1 "general_operand" "f<FP:dreg><Q>U,0")))]
+	(abs:FP (match_operand:FP 1 "general_operand" "f<FP:dreg>m,0")))]
   "TARGET_COLDFIRE_FPU"
 {
   if (DATA_REG_P (operands[0]))
diff -ru ./gcc/config/m68k/m68k-protos.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k-protos.h
--- ./gcc/config/m68k/m68k-protos.h	2014-06-06 11:50:16.079598621 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/m68k-protos.h	2012-03-29 18:03:03.000000000 +1000
@@ -54,7 +54,7 @@
 extern bool m68k_output_addr_const_extra (FILE *, rtx);
 extern void notice_update_cc (rtx, rtx);
 extern bool m68k_legitimate_base_reg_p (rtx, bool);
-extern bool m68k_legitimate_index_reg_p (rtx, bool);
+extern bool m68k_legitimate_index_reg_p (enum machine_mode, rtx, bool);
 extern bool m68k_illegitimate_symbolic_constant_p (rtx);
 extern bool m68k_matches_q_p (rtx);
 extern bool m68k_matches_u_p (rtx);
diff -ru ./gcc/config/m68k/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/t-linux
--- ./gcc/config/m68k/t-linux	2014-06-06 14:25:27.322150546 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/m68k/t-linux	2012-03-29 18:03:03.000000000 +1000
@@ -18,8 +18,8 @@
 
 EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
 
-# Only include multilibs for 680x0 CPUs with an MMU.
-M68K_MLIB_CPU += && (CPU ~ "^m680") && (FLAGS ~ "FL_MMU")
+# Only include multilibs for 680x0 and ColdFire CPUs with an MMU.
+M68K_MLIB_CPU += && ((CPU ~ "^m680") || (CPU ~ "^mcf")) && (FLAGS ~ "FL_MMU")
 
 # This rule uses MULTILIB_MATCHES to generate a definition of
 # SYSROOT_SUFFIX_SPEC.
diff -ru ./gcc/config/mips/74k.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/74k.md
--- ./gcc/config/mips/74k.md	2014-06-06 11:50:16.151598624 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/74k.md	2012-03-29 18:03:15.000000000 +1000
@@ -118,8 +118,7 @@
 ;; stores
 (define_insn_reservation "r74k_int_store" 1
   (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
-       (and (eq_attr "type" "store")
-            (eq_attr "mode" "!unknown")))
+       (eq_attr "type" "store"))
   "r74k_agen")
 
 
@@ -145,33 +144,123 @@
 ;; load->load base:  4 cycles
 ;; load->store base: 4 cycles
 (define_bypass 4 "r74k_int_load" "r74k_int_load")
-(define_bypass 4 "r74k_int_load" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 4 "r74k_int_load" "r74k_int_store" "!mips_store_data_bypass_p")
 
 ;; logical/move/slt/signext->next use :  1 cycles (Default)
 ;; logical/move/slt/signext->load base:  2 cycles
 ;; logical/move/slt/signext->store base: 2 cycles
 (define_bypass 2 "r74k_int_logical" "r74k_int_load")
-(define_bypass 2 "r74k_int_logical" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 2 "r74k_int_logical" "r74k_int_store"
+  "!mips_store_data_bypass_p")
 
 ;; arith->next use :  2 cycles (Default)
 ;; arith->load base:  3 cycles
 ;; arith->store base: 3 cycles
 (define_bypass 3 "r74k_int_arith" "r74k_int_load")
-(define_bypass 3 "r74k_int_arith" "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 3 "r74k_int_arith" "r74k_int_store" "!mips_store_data_bypass_p")
 
 ;; cmove->next use :  4 cycles (Default)
 ;; cmove->load base:  5 cycles
 ;; cmove->store base: 5 cycles
 (define_bypass 5 "r74k_int_cmove"  "r74k_int_load")
-(define_bypass 5 "r74k_int_cmove"  "r74k_int_store" "!store_data_bypass_p")
+(define_bypass 5 "r74k_int_cmove"  "r74k_int_store"
+  "!mips_store_data_bypass_p")
 
 ;; mult/madd/msub->int_mfhilo  : 4 cycles (default)
 ;; mult->madd/msub             : 1 cycles
 ;; madd/msub->madd/msub        : 1 cycles
-(define_bypass 1 "r74k_int_mult,r74k_int_mul3" "r74k_int_madd"
-  "mips_linked_madd_p")
-(define_bypass 1 "r74k_int_madd" "r74k_int_madd"
-  "mips_linked_madd_p")
+(define_bypass 1 "r74k_int_mult" "r74k_int_madd")
+(define_bypass 1 "r74k_int_madd" "r74k_int_madd")
+
+(define_bypass 1 "r74k_int_mul3" "r74k_int_madd"
+  "mips_mult_madd_chain_bypass_p")
+
+
+;; --------------------------------------------------------------
+;; DSP instructins
+;; --------------------------------------------------------------
+
+;; Non-saturating insn have the same latency as normal ALU operations,
+(define_insn_reservation "r74k_dsp_alu" 2
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspalu"))
+  "r74k_alu")
+
+;; Saturating insn takes an extra cycle.
+(define_insn_reservation "r74k_dsp_alu_sat" 3
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspalusat"))
+  "r74k_alu")
+
+;; dpaq_s, dpau, dpsq_s, dpsu, maq_s, mulsaq
+;; - delivers result to hi/lo in 6 cycle (bypass at M4)
+(define_insn_reservation "r74k_dsp_mac" 6
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspmac"))
+  "r74k_alu+r74k_mul")
+
+;; dpaq_sa, dpsq_sa, maq_sa
+;; - delivers result to hi/lo in 7 cycle (bypass at WB)
+(define_insn_reservation "r74k_dsp_mac_sat" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "dspmacsat"))
+  "r74k_alu+r74k_mul")
+
+;; extp, extpdp, extpdpv, extpv, extr, extrv
+;; - same latency as "mul"
+(define_insn_reservation "r74k_dsp_acc_ext" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "accext"))
+  "r74k_alu+r74k_mul")
+
+;; mthlip, shilo, shilov
+;; - same latency as "mul"
+(define_insn_reservation "r74k_dsp_acc_mod" 7
+  (and (eq_attr "cpu" "74kc,74kf2_1,74kf1_1,74kf3_2")
+       (eq_attr "type" "accmod"))
+  "r74k_alu+r74k_mul")
+
+;; dspalu   ->load/store base
+;; dspalusat->load/store base
+;; - we should never see these in real life.
+
+;; dsp_mac->dsp_mac     : 1 cycles (repeat rate of 1)
+;; dsp_mac->dsp_mac_sat : 1 cycles (repeat rate of 1)
+(define_bypass 1 "r74k_dsp_mac" "r74k_dsp_mac")
+(define_bypass 1 "r74k_dsp_mac" "r74k_dsp_mac_sat")
+
+;; dsp_mac_sat->dsp_mac_sat : 2 cycles (repeat rate of 2)
+;; dsp_mac_sat->dsp_mac     : 2 cycles (repeat rate of 2)
+(define_bypass 2 "r74k_dsp_mac_sat" "r74k_dsp_mac_sat")
+(define_bypass 2 "r74k_dsp_mac_sat" "r74k_dsp_mac")
+
+(define_bypass 1 "r74k_int_mult" "r74k_dsp_mac")
+(define_bypass 1 "r74k_int_mult" "r74k_dsp_mac_sat")
+
+;; Before reload, all multiplier is registered as imul3 (which has a long
+;;  latency).  We temporary jig the latency such that the macc groups
+;;  are scheduled closely together during the first scheduler pass.
+(define_bypass 1 "r74k_int_mul3" "r74k_dsp_mac"
+  "mips_mult_madd_chain_bypass_p")
+(define_bypass 1 "r74k_int_mul3" "r74k_dsp_mac_sat"
+  "mips_mult_madd_chain_bypass_p")
+
+;; Assuming the following is true (bypass at M4)
+;;  AP AF AM MB M1 M2 M3 M4 WB GR GC
+;;              AP AF AM MB M1 M2 M3 M4 WB GR GC
+;; dsp_mac->dsp_acc_ext : 4 cycles
+;; dsp_mac->dsp_acc_mod : 4 cycles
+(define_bypass 4 "r74k_dsp_mac" "r74k_dsp_acc_ext")
+(define_bypass 4 "r74k_dsp_mac" "r74k_dsp_acc_mod")
+
+;; Assuming the following is true (bypass at WB)
+;;  AP AF AM MB M1 M2 M3 M4 WB GR GC
+;;                 AP AF AM MB M1 M2 M3 M4 WB GR GC
+;; dsp_mac_sat->dsp_acc_ext : 5 cycles
+;; dsp_mac_sat->dsp_acc_mod : 5 cycles
+(define_bypass 5 "r74k_dsp_mac_sat" "r74k_dsp_acc_ext")
+(define_bypass 5 "r74k_dsp_mac_sat" "r74k_dsp_acc_mod")
+
 
 ;; --------------------------------------------------------------
 ;; Floating Point Instructions
diff -ru ./gcc/config/mips/constraints.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/constraints.md
--- ./gcc/config/mips/constraints.md	2014-06-06 11:50:16.155598624 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/constraints.md	2012-03-29 18:03:15.000000000 +1000
@@ -162,7 +162,7 @@
 (define_memory_constraint "R"
   "An address that can be used in a non-macro load or store."
   (and (match_code "mem")
-       (match_test "mips_address_insns (XEXP (op, 0), mode, false) == 1")))
+       (match_test "mips_address_insns (XEXP (op, 0), mode, false, false) == 1")))
 
 (define_constraint "S"
   "@internal
@@ -216,6 +216,16 @@
   (and (match_code "const_int")
        (match_test "IMM10_OPERAND (ival)")))
 
+(define_memory_constraint "YC"
+  "For MIPS, it is the same as the constraint R.  For microMIPS, it matches an address within a 12-bit offset that can be used in ll, sc, etc."
+  (and (match_code "mem")
+       (match_test "mips_address_insns (XEXP (op, 0), mode, false, true) == 1")))
+
+(define_address_constraint "YD"
+  "@internal
+   For MIPS, it is the same as the constraint p.  For microMIPS, it matches a 12-bit offset address."
+  (match_test "mips_address_insns (op, mode, false, true) == 1"))
+
 (define_constraint "Yb"
    "@internal"
    (match_operand 0 "qi_mask_operand"))
@@ -231,3 +241,8 @@
 (define_constraint "Yx"
    "@internal"
    (match_operand 0 "low_bitmask_operand"))
+
+(define_memory_constraint "YE"
+  "A single reg memory operand."
+  (and (match_code "mem")
+       (match_test "REG_P (XEXP (op, 0))")))
diff -ru ./gcc/config/mips/crtfastmath.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/crtfastmath.c
--- ./gcc/config/mips/crtfastmath.c	2014-06-06 11:50:16.155598624 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/crtfastmath.c	2012-03-29 18:03:15.000000000 +1000
@@ -39,7 +39,7 @@
 #define _FPU_GETCW(cw) __asm__ ("cfc1 %0,$31" : "=r" (cw))
 #define _FPU_SETCW(cw) __asm__ ("ctc1 %0,$31" : : "r" (cw))
 
-static void __attribute__((constructor))
+static void __attribute__ ((constructor,nomips16))
 set_fast_math (void)
 {
   unsigned int fcr;
diff -ru ./gcc/config/mips/crtn.asm /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/crtn.asm
--- ./gcc/config/mips/crtn.asm	2014-06-06 11:50:16.155598624 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/crtn.asm	2012-03-29 18:03:15.000000000 +1000
@@ -31,6 +31,7 @@
 #endif
 
 	.section .init,"ax",@progbits
+init:	
 #ifdef __mips64
 	ld      RA,40($sp)
 	daddu	$sp,$sp,48
@@ -41,6 +42,7 @@
 	j	RA
 
 	.section .fini,"ax",@progbits
+fini:	
 #ifdef	__mips64
 	ld	RA,40($sp)
 	daddu	$sp,$sp,48
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: cs-sgxx-linux.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: cs-sgxxlite-linux.h
diff -ru ./gcc/config/mips/elf.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/elf.h
--- ./gcc/config/mips/elf.h	2014-06-06 11:50:16.155598624 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/elf.h	2012-03-29 18:03:15.000000000 +1000
@@ -49,3 +49,6 @@
 #define ENDFILE_SPEC "crtend%O%s crtn%O%s"
 
 #define NO_IMPLICIT_EXTERN_C 1
+
+#define MD_HAVE_COMPACT_EH 1
+#define MD_UNWIND_SUPPORT "config/mips/mips-unwind.h"
diff -ru ./gcc/config/mips/linux64.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/linux64.h
--- ./gcc/config/mips/linux64.h	2014-06-06 11:50:16.167598625 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/linux64.h	2012-03-29 18:03:15.000000000 +1000
@@ -57,7 +57,7 @@
       %{mabi=32: -dynamic-linker " LINUX_DYNAMIC_LINKER32 "}} \
     %{static:-static}} \
 %{mabi=n32:-melf32%{EB:b}%{EL:l}tsmipn32} \
-%{mabi=64:-melf64%{EB:b}%{EL:l}tsmip} \
+%{mabi=64:-melf64%{EB:b}%{EL:l}tsmip%{msym32:_sym32}} \
 %{mabi=32:-melf32%{EB:b}%{EL:l}tsmip}"
 
 #undef LOCAL_LABEL_PREFIX
diff -ru ./gcc/config/mips/linux.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/linux.h
--- ./gcc/config/mips/linux.h	2014-06-06 11:50:16.167598625 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/linux.h	2012-03-29 18:03:15.000000000 +1000
@@ -106,6 +106,7 @@
 %{!shared: \
   %{profile:-lc_p} %{!profile:-lc}}"
 
+#define MD_HAVE_COMPACT_EH 1
 #define MD_UNWIND_SUPPORT "config/mips/linux-unwind.h"
 
 #ifdef HAVE_AS_NO_SHARED
@@ -149,3 +150,13 @@
 #define ENDFILE_SPEC \
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
    %{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef SUBTARGET_OVERRIDE_OPTIONS
+#define SUBTARGET_OVERRIDE_OPTIONS                              \
+do {                                                            \
+  /* microMIPS PLT entries are non-microMIPS.  */		\
+  TARGET_INTERLINK_MIPS16 = 1;					\
+  /* __thread_support is not supported by uClibc.  */           \
+  if (OPTION_UCLIBC)                                             \
+    targetm.have_tls = 0;                                       \
+} while (0)
diff -ru ./gcc/config/mips/linux-unwind.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/linux-unwind.h
--- ./gcc/config/mips/linux-unwind.h	2014-06-06 14:25:27.322150546 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/linux-unwind.h	2012-03-29 18:03:15.000000000 +1000
@@ -26,6 +26,8 @@
 /* Do code reading to identify a signal frame, and set the frame
    state data appropriately.  See unwind-dw2.c for the structs.  */
 
+#include "mips-unwind.h"
+
 #include <signal.h>
 #include <asm/unistd.h>
 
@@ -51,6 +53,11 @@
   _Unwind_Ptr new_cfa, reg_offset;
   int i;
 
+  /* microMIPS frame; the kernel does not have microMIPS signal
+     frames.  */
+  if ((_Unwind_Ptr) pc & 3)
+    return _URC_END_OF_STACK;
+
   /* 24021061 li v0, 0x1061 (rt_sigreturn)*/
   /* 0000000c syscall    */
   /*    or */
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: micromips.md
diff -ru ./gcc/config/mips/mips16.S /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips16.S
--- ./gcc/config/mips/mips16.S	2014-06-06 11:50:16.231598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips16.S	2012-03-29 18:03:15.000000000 +1000
@@ -22,6 +22,10 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
+#ifdef __mips_micromips
+  /* DO NOTHING */
+#else
+
 /* This file contains mips16 floating point support functions.  These
    functions are called by mips16 code to handle floating point when
    -msoft-float is not used.  They accept the arguments and return
@@ -30,6 +34,7 @@
 
 #if defined _MIPS_SIM && (_MIPS_SIM == _ABIO32 || _MIPS_SIM == _ABIO64)
 
+
 /* This file contains 32-bit assembly code.  */
 	.set nomips16
 
@@ -86,8 +91,13 @@
 	OPCODE, OP2;				\
 	.set	reorder
 
+#if __mips >= 4
+/* Coprocessor moves are interlocked from the MIPS IV ISA up.  */
+#define DELAYf(T, OPCODE, OP2) DELAYt (T, OPCODE, OP2)
+#else
 /* Use "OPCODE. OP2" and jump to T.  */
 #define DELAYf(T, OPCODE, OP2) OPCODE, OP2; jr T
+#endif
 
 /* MOVE_SF_BYTE0(D)
 	Move the first single-precision floating-point argument between
@@ -472,10 +482,25 @@
 #endif /* !__mips_single_float */
 
 /* Define a function NAME that moves a return value of mode MODE from
-   FPRs to GPRs.  */
+   FPRs to GPRs.
+
+   We hide these functions because they use $2 and $3 as arguments
+   diverging from the standard SysV ABI and as such would require
+   severe pessimisation of MIPS16 PLT entries just for this single
+   special case.  By making them hidden they become local to the
+   module using them and consequently PLT entries are never made for
+   them.
+
+   Four functions are actually generated, taking 2, 3, 3, and 5
+   instructions respectively (16, 16, 16, and 32 bytes respectively
+   after rounding up to a multiple of 16 bytes), which essentially
+   defeats any benefit from dynamic linking as a PLT entry itself
+   takes 16 bytes, and then the extra GOT entries and overhead of
+   indirect calls further add to it.  */
 
 #define RET_FUNCTION(NAME, MODE)	\
 STARTFN (NAME);				\
+	.hidden NAME;			\
 	MOVE_##MODE##_RET (t, $31);	\
 	ENDFN (NAME)
 
@@ -709,4 +734,19 @@
 CALL_STUB_RET (__mips16_call_stub_dc_10, 10, DC)
 #endif
 #endif /* !__mips_single_float */
+
+#ifdef L_m16rdhwr
+STARTFN (__mips16_rdhwr)
+	/* Forced always hidden, to avoid exporting from shared libgcc.  */
+	.hidden	__mips16_rdhwr
+	.set	push
+	.set	mips32r2
+	.set	noreorder
+	rdhwr	$3,$29
+	.set	pop
+	j	$31
+	ENDFN (__mips16_rdhwr)
+#endif
+
 #endif
+#endif /* __mips_micromips */
diff -ru ./gcc/config/mips/mips.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.c
--- ./gcc/config/mips/mips.c	2014-06-06 14:25:27.326150546 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.c	2012-04-28 17:58:33.000000000 +1000
@@ -80,6 +80,10 @@
    preserve the maximum stack alignment.  We therefore use a value
    of 0x7ff0 in this case.
 
+   microMIPS LWM and SWM support 12-bit offsets (from -2048 to 2047) and
+   to preserve the maximum stack alignment, so 0x7f0 is used when
+   TARGET_MICROMIPS.
+
    MIPS16e SAVE and RESTORE instructions can adjust the stack pointer by
    up to 0x7f8 bytes and can usually save or restore all the registers
    that we need to save or restore.  (Note that we can only use these
@@ -90,7 +94,8 @@
    to save and restore registers, and to allocate and deallocate the top
    part of the frame.  */
 #define MIPS_MAX_FIRST_STACK_STEP					\
-  (!TARGET_MIPS16 ? 0x7ff0						\
+  ((!TARGET_MIPS16 && !TARGET_MICROMIPS) ? 0x7ff0			\
+   : TARGET_MICROMIPS ? 0x7f0						\
    : GENERATE_MIPS16E_SAVE_RESTORE ? 0x7f8				\
    : TARGET_64BIT ? 0x100 : 0x400)
 
@@ -122,6 +127,12 @@
        (SUBINSN) != NEXT_INSN (SEQ_END (INSN));				\
        (SUBINSN) = NEXT_INSN (SUBINSN))
 
+/* Walk the instruction chain either backwards or forwards.  */
+#define WALK_INSNS(START_INSN, INSN, WALK_FUNCTION) 			\
+  for ((INSN) = (WALK_FUNCTION) (START_INSN);				\
+       (INSN) != 0;							\
+       (INSN) = (WALK_FUNCTION) (INSN))
+
 /* True if bit BIT is set in VALUE.  */
 #define BITSET_P(VALUE, BIT) (((VALUE) & (1 << (BIT))) != 0)
 
@@ -189,6 +200,7 @@
 };
 
 /* Macros to create an enumeration identifier for a function prototype.  */
+#define MIPS_FTYPE_NAME0(A) MIPS_##A##_FTYPE_VOID
 #define MIPS_FTYPE_NAME1(A, B) MIPS_##A##_FTYPE_##B
 #define MIPS_FTYPE_NAME2(A, B, C) MIPS_##A##_FTYPE_##B##_##C
 #define MIPS_FTYPE_NAME3(A, B, C, D) MIPS_##A##_FTYPE_##B##_##C##_##D
@@ -239,7 +251,13 @@
   MIPS_BUILTIN_CMP_SINGLE,
 
   /* For generating bposge32 branch instructions in MIPS32 DSP ASE.  */
-  MIPS_BUILTIN_BPOSGE32
+  MIPS_BUILTIN_BPOSGE32,
+
+  /* For generating atomic built-ins.  */
+  MIPS_BUILTIN_ATOMIC,
+
+  /* For generating accesses to the TLS thread pointer.  */
+  MIPS_BUILTIN_THREAD_POINTER
 };
 
 /* Invoke MACRO (COND) for each C.cond.fmt condition.  */
@@ -326,6 +344,9 @@
 
   /* The offset of hard_frame_pointer_rtx from the bottom of the frame.  */
   HOST_WIDE_INT hard_frame_pointer_offset;
+
+  /* Skip stack frame allocation if possible.  */
+  bool skip_stack_frame_allocation_p;
 };
 
 struct GTY(())  machine_function {
@@ -386,6 +407,15 @@
   /* True if this is an interrupt handler that should use DERET
      instead of ERET.  */
   bool use_debug_exception_return_p;
+
+  /* True if some of the callees uses its frame header.  */
+  bool callees_use_frame_header_p;
+
+  /* True if current function uses its frame header.  */
+  bool uses_frame_header_p;
+
+  /* Frame size before updated by optimizations.  */
+  HOST_WIDE_INT initial_total_size;
 };
 
 /* Information about a single argument.  */
@@ -486,8 +516,18 @@
   unsigned short memory_latency;
 };
 
+/* Stores frame header usage information for all seen functions.  */
+struct GTY (()) mips_frame_header_usage
+{
+  tree fndecl;              /* Function declaration.  */
+  bool frame_header_unused; /* Incoming frame header is unused.  */
+};
+
 /* Global variables for machine-dependent things.  */
 
+/* Frame header usage information for all seen functions.  */
+static GTY ((param_is (struct mips_frame_header_usage))) htab_t frame_header_usage_htab;
+
 /* The -G setting, or the configuration's default small-data limit if
    no -G option is given.  */
 static unsigned int mips_small_data_threshold;
@@ -542,6 +582,9 @@
 /* True if MIPS16 is the default mode.  */
 bool mips_base_mips16;
 
+/* True if microMIPS is the default mode.  */
+bool mips_base_micromips;
+
 /* The ambient values of other global variables.  */
 static int mips_base_schedule_insns; /* flag_schedule_insns */
 static int mips_base_reorder_blocks_and_partition; /* flag_reorder... */
@@ -588,6 +631,8 @@
    and returned from mips_sched_reorder2.  */
 static int cached_can_issue_more;
 
+static bool done_cfi_sections;
+
 /* Index R is the smallest register class that contains register R.  */
 const enum reg_class mips_regno_to_class[FIRST_PSEUDO_REGISTER] = {
   LEA_REGS,	LEA_REGS,	M16_REGS,	V1_REG,
@@ -651,6 +696,8 @@
      code generation but don't carry other semantics.  */
   { "mips16", 	   0, 0, true,  false, false, NULL },
   { "nomips16",    0, 0, true,  false, false, NULL },
+  { "micromips",   0, 0, true,  false, false, NULL },
+  { "nomicromips", 0, 0, true,  false, false, NULL },
   /* Allow functions to be specified as interrupt handlers */
   { "interrupt",   0, 0, false, true,  true, NULL },
   { "use_shadow_register_set",	0, 0, false, true,  true, NULL },
@@ -727,6 +774,10 @@
 
   /* MIPS32 Release 2 processors.  */
   { "m4k", PROCESSOR_M4K, 33, 0 },
+  { "m14kc", PROCESSOR_M4K, 33, 0 },
+  { "m14k", PROCESSOR_M4K, 33, 0 },
+  { "m14kec", PROCESSOR_M4K, 33, 0 },
+  { "m14ke", PROCESSOR_M4K, 33, 0 },
   { "4kec", PROCESSOR_4KC, 33, 0 },
   { "4kem", PROCESSOR_4KC, 33, 0 },
   { "4kep", PROCESSOR_4KP, 33, 0 },
@@ -751,6 +802,7 @@
   { "34kf", PROCESSOR_24KF2_1, 33, 0 },
   { "34kf1_1", PROCESSOR_24KF1_1, 33, 0 },
   { "34kfx", PROCESSOR_24KF1_1, 33, 0 },
+  { "34kn", PROCESSOR_24KC, 33, 0 },  /* 34K without MT/DSP.  */
   { "34kx", PROCESSOR_24KF1_1, 33, 0 },
 
   { "74kc", PROCESSOR_74KC, 33, 0 }, /* 74K with DSPr2.  */
@@ -773,11 +825,12 @@
   { "sb1", PROCESSOR_SB1, 64, PTF_AVOID_BRANCHLIKELY },
   { "sb1a", PROCESSOR_SB1A, 64, PTF_AVOID_BRANCHLIKELY },
   { "sr71000", PROCESSOR_SR71000, 64, PTF_AVOID_BRANCHLIKELY },
-  { "xlr", PROCESSOR_XLR, 64, 0 },
+  { "xlr", PROCESSOR_XLR, 64, PTF_AVOID_BRANCHLIKELY },
   { "loongson3a", PROCESSOR_LOONGSON_3A, 64, PTF_AVOID_BRANCHLIKELY },
 
   /* MIPS64 Release 2 processors.  */
-  { "octeon", PROCESSOR_OCTEON, 65, PTF_AVOID_BRANCHLIKELY }
+  { "octeon", PROCESSOR_OCTEON, 65, PTF_AVOID_BRANCHLIKELY },
+  { "xlp", PROCESSOR_XLP, 65, PTF_AVOID_BRANCHLIKELY }
 };
 
 /* Default costs.  If these are used for a processor we should look
@@ -1183,9 +1236,23 @@
     COSTS_N_INSNS (72),           /* int_div_di */
 		     1,           /* branch_cost */
 		     4            /* memory_latency */
+  },
+  { /* NLM XLP */
+    COSTS_N_INSNS (4),            /* fp_add */
+    COSTS_N_INSNS (4),            /* fp_mult_sf */
+    COSTS_N_INSNS (4),            /* fp_mult_df */
+    COSTS_N_INSNS (24),           /* fp_div_sf */
+    COSTS_N_INSNS (32),           /* fp_div_df */
+    COSTS_N_INSNS (4),            /* int_mult_si */
+    COSTS_N_INSNS (5),            /* int_mult_di */
+    COSTS_N_INSNS (36),           /* int_div_si */
+    COSTS_N_INSNS (68),           /* int_div_di */
+		     1,           /* branch_cost */
+		     4            /* memory_latency */
   }
 };
 
+static void mips_rest_of_frame_header_opt (void);
 static rtx mips_find_pic_call_symbol (rtx, rtx, bool);
 static int mips_register_move_cost (enum machine_mode, reg_class_t,
 				    reg_class_t);
@@ -1340,6 +1407,41 @@
   return mips_base_mips16;
 }
 
+/* Similar predicates for "micromips"/"nomicromips" function attributes.  */
+
+static bool
+mips_micromips_decl_p (const_tree decl)
+{
+  return lookup_attribute ("micromips", DECL_ATTRIBUTES (decl)) != NULL;
+}
+
+static bool
+mips_nomicromips_decl_p (const_tree decl)
+{
+  return lookup_attribute ("nomicromips", DECL_ATTRIBUTES (decl)) != NULL;
+}
+
+/* Return true if function DECL is a microMIPS function.  Return the ambient
+   setting if DECL is null.  */
+
+static bool
+mips_use_micromips_mode_p (tree decl)
+{
+  if (decl)
+    {
+      /* Nested functions must use the same frame pointer as their
+	 parent and must therefore use the same ISA mode.  */
+      tree parent = decl_function_context (decl);
+      if (parent)
+	decl = parent;
+      if (mips_micromips_decl_p (decl))
+	return true;
+      if (mips_nomicromips_decl_p (decl))
+	return false;
+    }
+  return mips_base_micromips;
+}
+
 /* Implement TARGET_COMP_TYPE_ATTRIBUTES.  */
 
 static int
@@ -1360,16 +1462,23 @@
 {
   const char *name;
   bool mips16_p, nomips16_p;
+  bool micromips_p, nomicromips_p;
 
   /* Check for "mips16" and "nomips16" attributes.  */
   mips16_p = lookup_attribute ("mips16", *attributes) != NULL;
   nomips16_p = lookup_attribute ("nomips16", *attributes) != NULL;
+  micromips_p = lookup_attribute ("micromips", *attributes) != NULL;
+  nomicromips_p = lookup_attribute ("nomicromips", *attributes) != NULL;
   if (TREE_CODE (decl) != FUNCTION_DECL)
     {
       if (mips16_p)
 	error ("%qs attribute only applies to functions", "mips16");
       if (nomips16_p)
 	error ("%qs attribute only applies to functions", "nomips16");
+      if (micromips_p)
+	error ("%qs attribute only applies to functions", "micromips");
+      if (nomicromips_p)
+	error ("%qs attribute only applies to functions", "nomicromips");
     }
   else
     {
@@ -1391,6 +1500,21 @@
 	  name = mflip_mips16_use_mips16_p (decl) ? "mips16" : "nomips16";
 	  *attributes = tree_cons (get_identifier (name), NULL, *attributes);
 	}
+
+      micromips_p |= mips_micromips_decl_p (decl);
+      nomicromips_p |= mips_nomicromips_decl_p (decl);
+      if (micromips_p || nomicromips_p)
+	{
+	  /* DECL cannot be simultaneously "micromips" and "nomicromips".  */
+	  if (micromips_p && nomicromips_p)
+	    error ("%qs cannot have both %<micromips%> and "
+		   "%<nomicromips%> attributes",
+		   IDENTIFIER_POINTER (DECL_NAME (decl)));
+	}
+
+      if (mips16_p && micromips_p)
+	error ("%qs cannot have both %<mips16%> and %<micromips%> attributes",
+	       IDENTIFIER_POINTER (DECL_NAME (decl)));
     }
 }
 
@@ -1592,6 +1716,8 @@
   return (GET_CODE (x) == SYMBOL_REF
 	  && SYMBOL_REF_LOCAL_P (x)
 	  && !SYMBOL_REF_EXTERNAL_P (x)
+	  && !SYMBOL_REF_WEAK (x)
+	  && !DECL_ONE_ONLY (SYMBOL_REF_DECL (x))
 	  && mips_use_mips16_mode_p (SYMBOL_REF_DECL (x)));
 }
 
@@ -1856,6 +1982,8 @@
     case SYMBOL_GOTTPREL:
     case SYMBOL_TLS:
     case SYMBOL_HALF:
+    case SYMBOL_TPREL_HI:
+    case SYMBOL_DTPREL_HI:
       return false;
     }
   gcc_unreachable ();
@@ -1950,8 +2078,10 @@
     case SYMBOL_TLSGD:
     case SYMBOL_TLSLDM:
     case SYMBOL_DTPREL:
+    case SYMBOL_DTPREL_HI:
     case SYMBOL_GOTTPREL:
     case SYMBOL_TPREL:
+    case SYMBOL_TPREL_HI:
     case SYMBOL_HALF:
       /* A 16-bit constant formed by a single relocation, or a 32-bit
 	 constant formed from a high 16-bit relocation and a low 16-bit
@@ -2021,14 +2151,23 @@
   if (mips_symbolic_constant_p (base, SYMBOL_CONTEXT_LEA, &type)
       && type != SYMBOL_FORCE_TO_MEM)
     {
+      if (TARGET_MIPS16_PCREL_LOADS)
+	{
+	  /* Under MIPS16, TLS DTP/TP-relative offsets are loaded from the
+	     constant pool, as this saves some code size compared to hi/lo
+	     constructing.  */
+	  if (type == SYMBOL_DTPREL || type == SYMBOL_TPREL)
+	    return false;
+
+	  /* If MIPS16 constant pools live in the text section, they should
+	     not refer to anything that might need run-time relocation.  */
+	  if (mips_got_symbol_type_p (type))
+	    return true;
+	}
+
       /* The same optimization as for CONST_INT.  */
       if (SMALL_INT (offset) && mips_symbol_insns (type, MAX_MACHINE_MODE) > 0)
 	return true;
-
-      /* If MIPS16 constant pools live in the text section, they should
-	 not refer to anything that might need run-time relocation.  */
-      if (TARGET_MIPS16_PCREL_LOADS && mips_got_symbol_type_p (type))
-	return true;
     }
 
   /* TLS symbols must be computed by mips_legitimize_move.  */
@@ -2266,7 +2405,7 @@
 mips16_unextended_reference_p (enum machine_mode mode, rtx base,
 			       unsigned HOST_WIDE_INT offset)
 {
-  if (offset % GET_MODE_SIZE (mode) == 0)
+  if (mode != BLKmode && offset % GET_MODE_SIZE (mode) == 0)
     {
       if (GET_MODE_SIZE (mode) == 4 && base == stack_pointer_rtx)
 	return offset < 256U * GET_MODE_SIZE (mode);
@@ -2281,10 +2420,14 @@
    if MIGHT_SPLIT_P, otherwise assume that a single load or store is
    enough.
 
+   If CHECK_MICROMIPS_12BIT_P, we check if the address is within a 12-bit
+   offset for microMIPS.
+
    For MIPS16 code, count extended instructions as two instructions.  */
 
 int
-mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)
+mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p,
+		    bool check_micromips_12bit_p)
 {
   struct mips_address_info addr;
   int factor;
@@ -2302,6 +2445,12 @@
     switch (addr.type)
       {
       case ADDRESS_REG:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p
+	    && (!CONST_INT_P (addr.offset)
+		|| INTVAL (addr.offset) < -2048
+		|| INTVAL (addr.offset) > 2047))
+	      return 0;
+
 	if (TARGET_MIPS16
 	    && !mips16_unextended_reference_p (mode, addr.reg,
 					       UINTVAL (addr.offset)))
@@ -2309,12 +2458,21 @@
 	return factor;
 
       case ADDRESS_LO_SUM:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p)
+	  return 0;
+
 	return TARGET_MIPS16 ? factor * 2 : factor;
 
       case ADDRESS_CONST_INT:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p)
+	  return 0;
+
 	return factor;
 
       case ADDRESS_SYMBOLIC:
+	if (TARGET_MICROMIPS && check_micromips_12bit_p)
+	  return 0;
+
 	return factor * mips_symbol_insns (addr.symbol_type, mode);
       }
   return 0;
@@ -2439,7 +2597,7 @@
 	might_split_p = false;
     }
 
-  return mips_address_insns (XEXP (mem, 0), mode, might_split_p);
+  return mips_address_insns (XEXP (mem, 0), mode, might_split_p, false);
 }
 
 /* Return the number of instructions needed for an integer division.  */
@@ -2894,11 +3052,20 @@
 /* Return a pseudo register that contains the current thread pointer.  */
 
 static rtx
-mips_get_tp (void)
+mips_get_tp (rtx target)
 {
-  rtx tp;
+  rtx tp = (target != NULL_RTX && REG_P (target)
+	    ? target : gen_reg_rtx (Pmode));
+
+  if (TARGET_MIPS16)
+    {
+      if (Pmode == DImode)
+	emit_insn (gen_tls_get_tp_di_mips16 (tp));
+      else
+	emit_insn (gen_tls_get_tp_si_mips16 (tp));
+      return tp;
+    }
 
-  tp = gen_reg_rtx (Pmode);
   if (Pmode == DImode)
     emit_insn (gen_tls_get_tp_di (tp));
   else
@@ -2916,12 +3083,6 @@
   rtx dest, insn, v0, tp, tmp1, tmp2, eqv;
   enum tls_model model;
 
-  if (TARGET_MIPS16)
-    {
-      sorry ("MIPS16 TLS");
-      return gen_reg_rtx (Pmode);
-    }
-
   model = SYMBOL_REF_TLS_MODEL (loc);
   /* Only TARGET_ABICALLS code can have more than one module; other
      code must be be static and should not use a GOT.  All TLS models
@@ -2949,13 +3110,23 @@
 			    UNSPEC_TLS_LDM);
       emit_libcall_block (insn, tmp1, v0, eqv);
 
-      tmp2 = mips_unspec_offset_high (NULL, tmp1, loc, SYMBOL_DTPREL);
-      dest = gen_rtx_LO_SUM (Pmode, tmp2,
-			     mips_unspec_address (loc, SYMBOL_DTPREL));
+      if (TARGET_MIPS16_PCREL_LOADS)
+	{
+	  tmp2 = mips_force_temporary (NULL,
+				       mips_unspec_address (loc,
+							    SYMBOL_DTPREL));
+	  dest = gen_rtx_PLUS (Pmode, tmp1, tmp2);
+	}
+      else
+	{
+	  tmp2 = mips_unspec_offset_high (NULL, tmp1, loc, SYMBOL_DTPREL);
+	  dest = gen_rtx_LO_SUM (Pmode, tmp2,
+				 mips_unspec_address (loc, SYMBOL_DTPREL));
+	}
       break;
 
     case TLS_MODEL_INITIAL_EXEC:
-      tp = mips_get_tp ();
+      tp = mips_get_tp (NULL_RTX);
       tmp1 = gen_reg_rtx (Pmode);
       tmp2 = mips_unspec_address (loc, SYMBOL_GOTTPREL);
       if (Pmode == DImode)
@@ -2967,10 +3138,20 @@
       break;
 
     case TLS_MODEL_LOCAL_EXEC:
-      tp = mips_get_tp ();
-      tmp1 = mips_unspec_offset_high (NULL, tp, loc, SYMBOL_TPREL);
-      dest = gen_rtx_LO_SUM (Pmode, tmp1,
-			     mips_unspec_address (loc, SYMBOL_TPREL));
+      tp = mips_get_tp (NULL_RTX);
+      if (TARGET_MIPS16_PCREL_LOADS)
+	{
+	  tmp1 = mips_force_temporary (NULL,
+				       mips_unspec_address (loc,
+							    SYMBOL_TPREL));
+	  dest = gen_rtx_PLUS (Pmode, tp, tmp1);
+	}
+      else
+	{
+	  tmp1 = mips_unspec_offset_high (NULL, tp, loc, SYMBOL_TPREL);
+	  dest = gen_rtx_LO_SUM (Pmode, tmp1,
+				 mips_unspec_address (loc, SYMBOL_TPREL));
+	}
       break;
 
     default:
@@ -2999,7 +3180,7 @@
 			 enum machine_mode mode)
 {
   rtx base, addr;
-  HOST_WIDE_INT offset;
+  HOST_WIDE_INT intval, high, offset;
 
   if (mips_tls_symbol_p (x))
     return mips_legitimize_tls_address (x);
@@ -3018,6 +3199,31 @@
       return mips_force_address (addr, mode);
     }
 
+ /* Handle references to constant addresses by loading the high part
+    into a register and using an offset for the low part.  */
+ if (GET_CODE (base) == CONST_INT)
+   {
+     intval = INTVAL (base);
+     high = trunc_int_for_mode (CONST_HIGH_PART (intval), Pmode);
+     offset = CONST_LOW_PART (intval);
+     /* Ignore cases in which a positive address would be accessed by a
+	negative offset from a negative address.  The required wraparound
+	does not occur for 32-bit addresses on 64-bit targets, and it is
+	very unlikely that such an access would occur in real code anyway.
+
+	If the low offset is not legitimate for MODE, prefer to load
+	the constant normally, instead of using mips_force_address on
+	the legitimized address.  The latter option would cause us to
+	use (D)ADDIU unconditionally, but LUI/ORI is more efficient
+	than LUI/ADDIU on some targets.  */
+     if ((intval < 0 || high > 0)
+	  && mips_valid_offset_p (GEN_INT (offset), mode))
+	{
+	  base = mips_force_temporary (NULL, GEN_INT (high));
+	  return plus_constant (base, offset);
+	}
+   }
+
   return x;
 }
 
@@ -3636,7 +3842,7 @@
       /* If the address is legitimate, return the number of
 	 instructions it needs.  */
       addr = XEXP (x, 0);
-      cost = mips_address_insns (addr, mode, true);
+      cost = mips_address_insns (addr, mode, true, false);
       if (cost > 0)
 	{
 	  *total = COSTS_N_INSNS (cost + 1);
@@ -3732,7 +3938,7 @@
 
     case MINUS:
       if (float_mode_p
-	  && (ISA_HAS_NMADD4_NMSUB4 (mode) || ISA_HAS_NMADD3_NMSUB3 (mode))
+	  && (ISA_HAS_NMADD4_NMSUB4 || ISA_HAS_NMADD3_NMSUB3)
 	  && TARGET_FUSED_MADD
 	  && !HONOR_NANS (mode)
 	  && !HONOR_SIGNED_ZEROS (mode))
@@ -3784,7 +3990,7 @@
 
     case NEG:
       if (float_mode_p
-	  && (ISA_HAS_NMADD4_NMSUB4 (mode) || ISA_HAS_NMADD3_NMSUB3 (mode))
+	  && (ISA_HAS_NMADD4_NMSUB4 || ISA_HAS_NMADD3_NMSUB3)
 	  && TARGET_FUSED_MADD
 	  && !HONOR_NANS (mode)
 	  && HONOR_SIGNED_ZEROS (mode))
@@ -3904,7 +4110,7 @@
 static int
 mips_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)
 {
-  return mips_address_insns (addr, SImode, false);
+  return mips_address_insns (addr, SImode, false, false);
 }
 
 /* Information about a single instruction in a multi-instruction
@@ -5738,6 +5944,39 @@
   return addr;
 }
 
+/* The LTO frontend only enables exceptions when it sees a function that
+   uses it.  This changes the return value of dwarf2out_do_frame, so we
+   have to check before every function.  */
+
+void
+mips_fixup_cfi_sections (void)
+{
+#ifdef MD_HAVE_COMPACT_EH
+  if (done_cfi_sections)
+    return;
+
+  if (!TARGET_COMPACT_EH)
+    return;
+
+  /* Output a .cfi_sections directive.  */
+  if (dwarf2out_do_frame ())
+    {
+      if (flag_unwind_tables || flag_exceptions)
+	{
+	  if (write_symbols == DWARF2_DEBUG
+	      || write_symbols == VMS_AND_DWARF2_DEBUG)
+	    fprintf (asm_out_file,
+		     "\t.cfi_sections .debug_frame, .eh_frame_entry\n");
+	  else
+	    fprintf (asm_out_file, "\t.cfi_sections .eh_frame_entry\n");
+	}
+      else
+	fprintf (asm_out_file, "\t.cfi_sections .debug_frame\n");
+      done_cfi_sections = true;
+    }
+#endif
+}
+
 /* Start a definition of function NAME.  MIPS16_P indicates whether the
    function contains MIPS16 code.  */
 
@@ -5749,6 +5988,11 @@
   else
     fprintf (asm_out_file, "\t.set\tnomips16\n");
 
+  if (TARGET_MICROMIPS)
+    fprintf (asm_out_file, "\t.set\tmicromips\n");
+  else
+    fprintf (asm_out_file, "\t.set\tnomicromips\n");
+
   if (!flag_inhibit_size_directive)
     {
       fputs ("\t.ent\t", asm_out_file);
@@ -5872,7 +6116,8 @@
 	 __fn_local_* is based on the __fn_stub_* names that we've
 	 traditionally used for the non-MIPS16 stub.  */
       func_name = targetm.strip_name_encoding (XSTR (func, 0));
-      local_name = ACONCAT (("__fn_local_", func_name, NULL));
+      local_name = ACONCAT ((LOCAL_LABEL_PREFIX, "__fn_local_", func_name,
+			     NULL));
       local = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (local_name));
       SYMBOL_REF_FLAGS (local) = SYMBOL_REF_FLAGS (func) | SYMBOL_FLAG_LOCAL;
 
@@ -6011,20 +6256,15 @@
    into the general registers and then jumps to the MIPS16 code.  */
 
 static void
-mips16_build_function_stub (void)
+mips16_build_function_stub (rtx symbol, const char *fnname, 
+			    rtx alias)
 {
-  const char *fnname, *alias_name, *separator;
+  const char *separator;
   char *secname, *stubname;
   tree stubdecl;
   unsigned int f;
-  rtx symbol, alias;
 
-  /* Create the name of the stub, and its unique section.  */
-  symbol = XEXP (DECL_RTL (current_function_decl), 0);
-  alias = mips16_local_alias (symbol);
-
-  fnname = targetm.strip_name_encoding (XSTR (symbol, 0));
-  alias_name = targetm.strip_name_encoding (XSTR (alias, 0));
+  /* Create the name of the unique section for the stub.  */
   secname = ACONCAT ((".mips16.fn.", fnname, NULL));
   stubname = ACONCAT (("__fn_stub_", fnname, NULL));
 
@@ -6036,6 +6276,12 @@
   DECL_RESULT (stubdecl) = build_decl (BUILTINS_LOCATION,
 				       RESULT_DECL, NULL_TREE, void_type_node);
 
+  /* If the original function should occur only once in the final
+     binary (e.g. it's in a COMDAT group), the same should be true of
+     the stub.  */
+  if (DECL_ONE_ONLY (current_function_decl))
+    make_decl_one_only (stubdecl, DECL_ASSEMBLER_NAME (current_function_decl));
+
   /* Output a comment.  */
   fprintf (asm_out_file, "\t# Stub function for %s (",
 	   current_function_name ());
@@ -6086,6 +6332,25 @@
 
   mips_end_function_definition (stubname);
 
+  switch_to_section (function_section (current_function_decl));
+}
+
+static void
+mips16_build_function_stub_and_local_alias (bool need_stub)
+{
+  const char *fnname, *alias_name;
+  rtx symbol, alias;
+
+  /* Determine the name of the alias.  */
+  symbol = XEXP (DECL_RTL (current_function_decl), 0);
+  alias = mips16_local_alias (symbol);
+  fnname = targetm.strip_name_encoding (XSTR (symbol, 0));
+  alias_name = targetm.strip_name_encoding (XSTR (alias, 0));
+
+  /* Build the stub, if necessary.  */
+  if (need_stub)
+    mips16_build_function_stub (symbol, fnname, alias);
+
   /* If the linker needs to create a dynamic symbol for the target
      function, it will associate the symbol with the stub (which,
      unlike the target function, follows the proper calling conventions).
@@ -6094,8 +6359,6 @@
      this symbol can also be used for indirect MIPS16 references from
      within this file.  */
   ASM_OUTPUT_DEF (asm_out_file, alias_name, fnname);
-
-  switch_to_section (function_section (current_function_decl));
 }
 
 /* The current function is a MIPS16 function that returns a value in an FPR.
@@ -6202,8 +6465,11 @@
       bool lazy_p;
 
       /* If this is a locally-defined and locally-binding function,
-	 avoid the stub by calling the local alias directly.  */
-      if (mips16_local_function_p (fn))
+	 avoid the stub by calling the local alias directly.
+	 Functions that return floating-point values but do not take
+	 floating-point arguments do not have a local alias, so we
+	 cannot take this short-cut in that case.  */
+      if (fp_code && mips16_local_function_p (fn))
 	{
 	  *fn_ptr = mips16_local_alias (fn);
 	  return NULL_RTX;
@@ -6259,7 +6525,7 @@
     {
       const char *separator;
       char *secname, *stubname;
-      tree stubid, stubdecl;
+      tree stubid, stubdecl, targetdecl;
       unsigned int f;
 
       /* If the function does not return in FPRs, the special stub
@@ -6283,6 +6549,14 @@
 					   RESULT_DECL, NULL_TREE,
 					   void_type_node);
 
+      targetdecl = SYMBOL_REF_DECL (fn);
+
+      /* If the called function should occur only once in the final binary
+	 (e.g. it's in a COMDAT group), the same should be true of the
+	 stub.  */
+      if (targetdecl && DECL_ONE_ONLY (targetdecl))
+	make_decl_one_only (stubdecl, DECL_ASSEMBLER_NAME (targetdecl));
+
       /* Output a comment.  */
       fprintf (asm_out_file, "\t# Stub function to call %s%s (",
 	       (fp_ret_p
@@ -6537,12 +6811,35 @@
   if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))
     return false;
 
+  if (TARGET_MICROMIPS)
+    {
+      /* We can't do a sibcall if the called function is a MIPS32 function.  */
+      if (decl
+	  && !mips_use_micromips_mode_p (decl)
+	  && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
+	return false;
+
+      /* When -minterlink-mips16 is in effect, assume that non-locally-binding
+	 functions could be MIPS32 ones unless an attribute explicitly tells
+	 us otherwise.  */
+      if (TARGET_INTERLINK_MIPS16
+	  && decl
+	  && (DECL_EXTERNAL (decl) || !targetm.binds_local_p (decl))
+	  && !mips_micromips_decl_p (decl)
+	  && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
+	return false;
+
+      /* Otherwise OK.  */
+      return true;
+    }
+
   /* We can't do a sibcall if the called function is a MIPS16 function
      because there is no direct "jx" instruction equivalent to "jalx" to
      switch the ISA mode.  We only care about cases where the sibling
      and normal calls would both be direct.  */
   if (decl
-      && mips_use_mips16_mode_p (decl)
+      && (mips_use_mips16_mode_p (decl)
+	  || mips_use_micromips_mode_p (decl))
       && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
     return false;
 
@@ -6553,6 +6850,7 @@
       && decl
       && (DECL_EXTERNAL (decl) || !targetm.binds_local_p (decl))
       && !mips_nomips16_decl_p (decl)
+      && !mips_nomicromips_decl_p (decl)
       && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))
     return false;
 
@@ -6982,6 +7280,15 @@
   if (!mips_get_unaligned_mem (&src, width, bitpos, &left, &right))
     return false;
 
+  if (ISA_HAS_UL_US)
+    {
+      if (GET_MODE (dest) == DImode)
+	emit_insn (gen_mov_uld (dest, src, left));
+      else
+	emit_insn (gen_mov_ulw (dest, src, left));
+      return true;
+    }
+
   temp = gen_reg_rtx (GET_MODE (dest));
   if (GET_MODE (dest) == DImode)
     {
@@ -7016,6 +7323,16 @@
 
   mode = mode_for_size (width, MODE_INT, 0);
   src = gen_lowpart (mode, src);
+
+  if (ISA_HAS_UL_US)
+    {
+      if (GET_MODE (src) == DImode)
+        emit_insn (gen_mov_usd (dest, src, left));
+      else
+        emit_insn (gen_mov_usw (dest, src, left));
+      return true;
+    }
+
   if (mode == DImode)
     {
       emit_insn (gen_mov_sdl (dest, src, left));
@@ -7239,16 +7556,24 @@
   mips_lo_relocs[SYMBOL_TLSGD] = "%tlsgd(";
   mips_lo_relocs[SYMBOL_TLSLDM] = "%tlsldm(";
 
-  mips_split_p[SYMBOL_DTPREL] = true;
-  mips_hi_relocs[SYMBOL_DTPREL] = "%dtprel_hi(";
-  mips_lo_relocs[SYMBOL_DTPREL] = "%dtprel_lo(";
-
-  mips_lo_relocs[SYMBOL_GOTTPREL] = "%gottprel(";
+  if (! TARGET_MIPS16_PCREL_LOADS)
+    {
+      mips_split_p[SYMBOL_DTPREL] = true;
+      mips_hi_relocs[SYMBOL_DTPREL] = "%dtprel_hi(";
+      mips_lo_relocs[SYMBOL_DTPREL] = "%dtprel_lo(";
+
+      mips_split_p[SYMBOL_TPREL] = true;
+      mips_hi_relocs[SYMBOL_TPREL] = "%tprel_hi(";
+      mips_lo_relocs[SYMBOL_TPREL] = "%tprel_lo(";
 
-  mips_split_p[SYMBOL_TPREL] = true;
-  mips_hi_relocs[SYMBOL_TPREL] = "%tprel_hi(";
-  mips_lo_relocs[SYMBOL_TPREL] = "%tprel_lo(";
+      if (TARGET_MIPS16)
+	{
+	  mips_lo_relocs[SYMBOL_TPREL_HI] = "%tprel_hi(";
+	  mips_lo_relocs[SYMBOL_DTPREL_HI] = "%dtprel_hi(";
+	}
+    }
 
+  mips_lo_relocs[SYMBOL_GOTTPREL] = "%gottprel(";
   mips_lo_relocs[SYMBOL_HALF] = "%half(";
 }
 
@@ -7330,6 +7655,9 @@
    '^'	Print the name of the pic call-through register (t9 or $25).
    '+'	Print the name of the gp register (usually gp or $28).
    '$'	Print the name of the stack pointer register (sp or $29).
+   ':'  Print "c" to use the compact version if the delay slot is a nop.
+   '!'  Print "s" to use the short version if the delay slot contains a
+	16-bit instruction.
 
    See also mips_init_print_operand_pucnt.  */
 
@@ -7413,6 +7741,386 @@
       fputs (reg_names[STACK_POINTER_REGNUM], file);
       break;
 
+    case ':':
+      /* When reorder or noreorder with final_squence 0, the delay slot will
+	 be a nop, so we just use the compact version for microMIPS.  */
+      if (mips_noreorder.nesting_level == 0 || final_sequence == 0)
+	putc ('c', file);
+      break;
+
+    case '!':
+      /* When reorder or noreorder with final_squence 0, the delay slot will
+	 be a nop, so we just use the compact version for microMIPS.  */
+      if (mips_noreorder.nesting_level == 0 || final_sequence == 0)
+	putc ('s', file);
+      else
+	{
+	  /* Try to find out if the delay slot instruction is 16-bit.  */
+
+	  struct recog_data old_recog_data = recog_data;
+	  rtx insn = XVECEXP (final_sequence, 0, 1);
+	  enum attr_mode mode = get_attr_mode (insn);
+	  enum attr_micromips_type micromips_type
+	    = get_attr_micromips_type (insn);
+
+	  recog_memoized (insn);
+	  cleanup_subreg_operands (insn);
+
+	  if (0
+
+	      /* move16 rd, rs.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && (REG_P (XEXP (PATTERN (insn), 1))
+		      || GET_CODE (XEXP (PATTERN (insn), 1)) == CONST_DOUBLE)
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && ((REG_P (recog_data.operand[1])
+		       && GP_REG_P (REGNO (recog_data.operand[1])))
+		      || (recog_data.operand[1] == CONST0_RTX (SFmode))))
+
+	      /* move16 rd, $0.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && GET_CODE (XEXP (PATTERN (insn), 1)) == CONST_INT
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && CONST_INT_P (recog_data.operand[1])
+		  && INTVAL (recog_data.operand[1]) == 0)
+
+	      /* li16 rd, imm.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && GET_CODE (XEXP (PATTERN (insn), 1)) == CONST_INT
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && CONST_INT_P (recog_data.operand[1])
+		  && INTVAL (recog_data.operand[1]) >= -1
+		  && INTVAL (recog_data.operand[1]) <= 126)
+
+	      /* lw16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && MEM_P (XEXP (PATTERN (insn), 1))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[1]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[1]) == SFmode))
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[1], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 60)))
+
+	      /* lwsp rt, offset($29).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && MEM_P (XEXP (PATTERN (insn), 1))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[1]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[1]) == SFmode))
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && (REGNO (XEXP (recog_data.operand[1], 0))) == 29)
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)) == 29
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 124)))
+
+	      /* lhu16 rt, offset(base).  */
+	      || (micromips_type == MICROMIPS_TYPE_ZERO_EXTEND
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && GET_MODE (recog_data.operand[1]) == HImode
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[1], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) & 1) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 30)))
+
+	      /* lbu16 rt, offset(base).  */
+	      || (micromips_type == MICROMIPS_TYPE_ZERO_EXTEND
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && MEM_P (recog_data.operand[1])
+		  && GET_MODE (recog_data.operand[1]) == QImode
+		  && ((REG_P (XEXP (recog_data.operand[1], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[1], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[1], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[1], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[1], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[1], 0), 1))
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) >= -1
+			  && INTVAL (XEXP (XEXP (recog_data.operand[1], 0), 1)) <= 14)))
+
+	      /* sw16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && REG_P (XEXP (PATTERN (insn), 1))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[0]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[0]) == SFmode))
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && M16STORE_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[0], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 60)))
+
+	      /* swsp rt, offset($29).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && REG_P (XEXP (PATTERN (insn), 1))
+		  && ((mode == MODE_SI
+		       && GET_MODE (recog_data.operand[0]) == SImode)
+		      || (mode == MODE_SF
+			  && GET_MODE (recog_data.operand[0]) == SFmode))
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && GP_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && (REGNO (XEXP (recog_data.operand[0], 0))) == 29)
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)) == 29)
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) & 3) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 124)))
+
+	      /* sh16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && REG_P (XEXP (PATTERN (insn), 1))
+		  && mode == MODE_HI
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && M16STORE_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && GET_MODE (recog_data.operand[0]) == HImode
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[0], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && (INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) & 1) == 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 30)))
+
+	      /* sb16 rt, offset(base).  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && MEM_P (XEXP (PATTERN (insn), 0))
+		  && REG_P (XEXP (PATTERN (insn), 1))
+		  && mode == MODE_QI
+		  && ((CONST_INT_P (recog_data.operand[1])
+		       && INTVAL (recog_data.operand[1]) == 0)
+		      || (REG_P (recog_data.operand[1])
+			  && M16STORE_REG_P (REGNO (recog_data.operand[1]))))
+		  && MEM_P (recog_data.operand[0])
+		  && GET_MODE (recog_data.operand[0]) == QImode
+		  && ((REG_P (XEXP (recog_data.operand[0], 0))
+		       && M16_REG_P (REGNO (XEXP (recog_data.operand[0], 0))))
+		      || (GET_CODE (XEXP (recog_data.operand[0], 0)) == PLUS
+			  && REG_P (XEXP (XEXP (recog_data.operand[0], 0), 0))
+			  && M16_REG_P (REGNO (XEXP (XEXP (recog_data.operand[0], 0), 0)))
+			  && CONST_INT_P (XEXP (XEXP (recog_data.operand[0], 0), 1))
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) >= 0
+			  && INTVAL (XEXP (XEXP (recog_data.operand[0], 0), 1)) <= 15)))
+
+	      /* addu16 rd, rs, rt.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && REG_P (recog_data.operand[2])
+		  && M16_REG_P (REGNO (recog_data.operand[2])))
+
+	      /* addius5 rd, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && REG_P (recog_data.operand[1])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && (REGNO (recog_data.operand[0])
+		      == REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && INTVAL (recog_data.operand[2]) >= -8
+		  && INTVAL (recog_data.operand[2]) <= 7)
+
+	      /* addiusp $29, $29, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && REGNO (recog_data.operand[0]) == 29
+		  && REG_P (recog_data.operand[1])
+		  && REGNO (recog_data.operand[1]) == 29
+		  && CONST_INT_P (recog_data.operand[2])
+		  && ((INTVAL (recog_data.operand[2]) >= 2
+		       && INTVAL (recog_data.operand[2]) <= 257)
+		      || (INTVAL (recog_data.operand[2]) >= -258
+			  && INTVAL (recog_data.operand[2]) <= -3)))
+
+	      /* addiur1sp rd, $29, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && REGNO (recog_data.operand[1]) == 29
+		  && CONST_INT_P (recog_data.operand[2])
+		  && (INTVAL (recog_data.operand[2]) & 3) == 0
+		  && INTVAL (recog_data.operand[2]) >= 0
+		  && INTVAL (recog_data.operand[2]) <= 252)
+
+	      /* addiur2 rd, rs, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ADD
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && (INTVAL (recog_data.operand[2]) == 1
+		      || INTVAL (recog_data.operand[2]) == 4
+		      || INTVAL (recog_data.operand[2]) == 8
+		      || INTVAL (recog_data.operand[2]) == 12
+		      || INTVAL (recog_data.operand[2]) == 16
+		      || INTVAL (recog_data.operand[2]) == 20
+		      || INTVAL (recog_data.operand[2]) == 24
+		      || INTVAL (recog_data.operand[2]) == -1))
+
+	      /* subu16 rd, rs, rt.  */
+	      || (micromips_type == MICROMIPS_TYPE_SUB
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && REG_P (recog_data.operand[2])
+		  && M16_REG_P (REGNO (recog_data.operand[2])))
+
+	      /* sll16/srl16 rd, rt, sa.  */
+	      || (micromips_type == MICROMIPS_TYPE_SHIFT
+		  && mode != MODE_DI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && INTVAL (recog_data.operand[2]) >= 1
+		  && INTVAL (recog_data.operand[2]) <= 8)
+
+	      /* andi16 rd, rs, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_LOGICAL_AND
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && CONST_INT_P (recog_data.operand[2])
+		  && (INTVAL (recog_data.operand[2]) == 128
+		      || INTVAL (recog_data.operand[2]) == 1
+		      || INTVAL (recog_data.operand[2]) == 2
+		      || INTVAL (recog_data.operand[2]) == 3
+		      || INTVAL (recog_data.operand[2]) == 4
+		      || INTVAL (recog_data.operand[2]) == 7
+		      || INTVAL (recog_data.operand[2]) == 8
+		      || INTVAL (recog_data.operand[2]) == 15
+		      || INTVAL (recog_data.operand[2]) == 16
+		      || INTVAL (recog_data.operand[2]) == 31
+		      || INTVAL (recog_data.operand[2]) == 32
+		      || INTVAL (recog_data.operand[2]) == 63
+		      || INTVAL (recog_data.operand[2]) == 64
+		      || INTVAL (recog_data.operand[2]) == 255
+		      || INTVAL (recog_data.operand[2]) == 32768
+		      || INTVAL (recog_data.operand[2]) == 65535))
+
+	      /* andi16 rd, rs, imm.  */
+	      || (micromips_type == MICROMIPS_TYPE_ZERO_EXTEND
+		  && mode == MODE_SI
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1])))
+
+	      /* and16/xor16/or16 rd, rs, rt.  */
+	      || ((micromips_type == MICROMIPS_TYPE_LOGICAL_AND
+		   || micromips_type == MICROMIPS_TYPE_LOGICAL_XOR
+		   || micromips_type == MICROMIPS_TYPE_LOGICAL_OR)
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1]))
+		  && REG_P (recog_data.operand[2])
+		  && M16_REG_P (REGNO (recog_data.operand[2]))
+		  && (REGNO (recog_data.operand[0])
+			== REGNO (recog_data.operand[1])
+		      || REGNO (recog_data.operand[0])
+			   == REGNO (recog_data.operand[2])))
+
+	      /* mfhi rd.  */
+	      || (micromips_type == MICROMIPS_TYPE_MFHI
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0])))
+
+	      /* mflo rd.  */
+	      || (GET_CODE (PATTERN (insn)) == SET
+		  && REG_P (XEXP (PATTERN (insn), 0))
+		  && REG_P (XEXP (PATTERN (insn), 1))
+		  && REG_P (recog_data.operand[0])
+		  && GP_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && REGNO (recog_data.operand[1]) == LO_REGNUM)
+
+	      /* not rt, rs.  */
+	      || (micromips_type == MICROMIPS_TYPE_LOGICAL_NOT
+		  && REG_P (recog_data.operand[0])
+		  && M16_REG_P (REGNO (recog_data.operand[0]))
+		  && REG_P (recog_data.operand[1])
+		  && M16_REG_P (REGNO (recog_data.operand[1])))
+
+	      || 0)
+
+	    putc ('s', file);
+
+	  recog_data = old_recog_data;
+	}
+      break;
     default:
       gcc_unreachable ();
       break;
@@ -7426,7 +8134,7 @@
 {
   const char *p;
 
-  for (p = "()[]<>*#/?~.@^+$"; *p; p++)
+  for (p = "()[]<>*#/?~.@^+$:!"; *p; p++)
     mips_print_operand_punct[(unsigned char) *p] = true;
 }
 
@@ -7511,7 +8219,8 @@
    'D'	Print the second part of a double-word register or memory operand.
    'L'	Print the low-order register in a double-word register operand.
    'M'	Print high-order register in a double-word register operand.
-   'z'	Print $0 if OP is zero, otherwise print OP normally.  */
+   'z'	Print $0 if OP is zero, otherwise print OP normally.
+   'b'	Print the address of a memory operand, without offset.  */
 
 static void
 mips_print_operand (FILE *file, rtx op, int letter)
@@ -7640,6 +8349,11 @@
 	case MEM:
 	  if (letter == 'D')
 	    output_address (plus_constant (XEXP (op, 0), 4));
+	  else if (letter == 'b')
+	    {
+	      gcc_assert (REG_P (XEXP (op, 0)));
+	      mips_print_operand (file, XEXP (op, 0), 0);
+	    }
 	  else if (letter && letter != 'z')
 	    output_operand_lossage ("invalid use of '%%%c'", letter);
 	  else
@@ -7761,6 +8475,19 @@
   return data_section;
 }
 
+/* Implement TARGET_ASM_INIT_SECTIONS.  */
+
+static void
+mips_asm_init_sections (void)
+{
+  if (TARGET_COMPACT_EH)
+    {
+      /* Let the assembler decide where to put the LSDA.  */
+      exception_section = get_unnamed_section (0, output_section_asm_op,
+					       "\t.cfi_inline_lsda 2");
+    }
+}
+
 /* Implement TARGET_IN_SMALL_DATA_P.  */
 
 static bool
@@ -7990,6 +8717,38 @@
   return NULL_RTX;
 }
 
+/* DSP ALU can bypass data with no delays for the following pairs. */
+enum insn_code dspalu_bypass_table[][2] =
+{
+  {CODE_FOR_mips_addsc, CODE_FOR_mips_addwc},
+  {CODE_FOR_mips_cmpu_eq_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmpu_lt_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmpu_le_qb, CODE_FOR_mips_pick_qb},
+  {CODE_FOR_mips_cmp_eq_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_cmp_lt_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_cmp_le_ph, CODE_FOR_mips_pick_ph},
+  {CODE_FOR_mips_wrdsp, CODE_FOR_mips_insv}
+};
+
+int
+mips_dspalu_bypass_p (rtx out_insn, rtx in_insn)
+{
+  int i;
+  int num_bypass = (sizeof (dspalu_bypass_table)
+		    / (2 * sizeof (enum insn_code)));
+  enum insn_code out_icode = INSN_CODE (out_insn);
+  enum insn_code in_icode = INSN_CODE (in_insn);
+
+  for (i = 0; i < num_bypass; i++)
+    {
+      if (out_icode == dspalu_bypass_table[i][0]
+	  && in_icode == dspalu_bypass_table[i][1])
+       return true;
+    }
+#if 0
+#endif
+  return false;
+}
 /* Implement ASM_OUTPUT_ASCII.  */
 
 void
@@ -8192,6 +8951,8 @@
 {
   default_file_start ();
 
+  done_cfi_sections = false;
+
   /* Generate a special section to describe the ABI switches used to
      produce the resultant binary.  This is unnecessary on IRIX and
      causes unwanted warnings from the native linker.  */
@@ -9148,69 +9909,207 @@
   return false;
 }
 
-/* Populate the current function's mips_frame_info structure.
+/* Hash table callbacks for frame_header_usage_htab.  */
 
-   MIPS stack frames look like:
+static hashval_t
+frame_header_usage_htab_hash (const void *p)
+{
+  /* Function declaration pointer is used as a hash index.  */
+  const struct mips_frame_header_usage *entry =
+    (const struct mips_frame_header_usage *) p;
+  return (hashval_t) (uintptr_t) entry->fndecl;
+}
 
-	+-------------------------------+
-	|                               |
-	|  incoming stack arguments     |
-	|                               |
-	+-------------------------------+
-	|                               |
-	|  caller-allocated save area   |
-      A |  for register arguments       |
-	|                               |
-	+-------------------------------+ <-- incoming stack pointer
-	|                               |
-	|  callee-allocated save area   |
-      B |  for arguments that are       |
-	|  split between registers and  |
-	|  the stack                    |
-	|                               |
-	+-------------------------------+ <-- arg_pointer_rtx
-	|                               |
-      C |  callee-allocated save area   |
-	|  for register varargs         |
-	|                               |
-	+-------------------------------+ <-- frame_pointer_rtx
-	|                               |       + cop0_sp_offset
-	|  COP0 reg save area           |	+ UNITS_PER_WORD
-	|                               |
-	+-------------------------------+ <-- frame_pointer_rtx + acc_sp_offset
-	|                               |       + UNITS_PER_WORD
-	|  accumulator save area        |
-	|                               |
-	+-------------------------------+ <-- stack_pointer_rtx + fp_sp_offset
-	|                               |       + UNITS_PER_HWFPVALUE
-	|  FPR save area                |
-	|                               |
-	+-------------------------------+ <-- stack_pointer_rtx + gp_sp_offset
-	|                               |       + UNITS_PER_WORD
-	|  GPR save area                |
-	|                               |
-	+-------------------------------+ <-- frame_pointer_rtx with
-	|                               | \     -fstack-protector
-	|  local variables              |  | var_size
-	|                               | /
-	+-------------------------------+
-	|                               | \
-	|  $gp save area                |  | cprestore_size
-	|                               | /
-      P +-------------------------------+ <-- hard_frame_pointer_rtx for
-	|                               | \     MIPS16 code
-	|  outgoing stack arguments     |  |
-	|                               |  |
-	+-------------------------------+  | args_size
-	|                               |  |
-	|  caller-allocated save area   |  |
-	|  for register arguments       |  |
-	|                               | /
-	+-------------------------------+ <-- stack_pointer_rtx
-					      frame_pointer_rtx without
-					        -fstack-protector
-					      hard_frame_pointer_rtx for
-						non-MIPS16 code.
+static int
+frame_header_usage_htab_eq (const void *p1, const void *p2)
+{
+  const struct mips_frame_header_usage *entry1 =
+    (const struct mips_frame_header_usage *) p1;
+  const struct mips_frame_header_usage *entry2 =
+    (const struct mips_frame_header_usage *) p2;
+  return entry1->fndecl == entry2->fndecl;
+}
+
+/* Try to find if function may use its incoming frame header.  */
+
+static bool
+mips_find_if_frame_header_is_used (tree fndecl)
+{
+  void **slot = NULL;
+  struct mips_frame_header_usage tmp_element;
+  tmp_element.fndecl = fndecl;
+
+  if (frame_header_usage_htab)
+    slot = htab_find_slot (frame_header_usage_htab, &tmp_element, NO_INSERT);
+  if (slot && *slot)
+    {
+      struct mips_frame_header_usage *element =
+        (struct mips_frame_header_usage *) *slot;
+      if (element->frame_header_unused)
+        return false;
+    }
+  return true;
+}
+
+/* Return true if the instruction is a call and the called function may use its
+   incoming frame header.  */
+
+static bool
+mips_callee_use_frame_header (rtx insn)
+{
+  rtx call_insn;
+  tree fndecl;
+
+  if (insn == NULL_RTX || !USEFUL_INSN_P (insn))
+    return false;
+
+  /* Handle sequence of instructions.  */
+  if (GET_CODE (PATTERN (insn)) == SEQUENCE)
+    {
+      rtx subinsn;
+      FOR_EACH_SUBINSN (subinsn, insn)
+	if (INSN_P (subinsn) && mips_callee_use_frame_header (subinsn))
+	  return true;
+    }
+
+  if (GET_CODE (insn) != CALL_INSN)
+    return false;
+
+  if (GET_CODE (PATTERN (insn)) != PARALLEL
+      || GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) != SET)
+    return true;
+
+  call_insn = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));
+
+  if (GET_CODE (call_insn) != CALL
+      || GET_CODE (XEXP (call_insn, 0)) != MEM
+      || GET_CODE (XEXP (XEXP (call_insn, 0), 0)) != SYMBOL_REF)
+    return true;
+
+  fndecl = SYMBOL_REF_DECL (XEXP (XEXP (call_insn, 0), 0));
+
+  if (fndecl == current_function_decl)
+    return true;
+
+  return mips_find_if_frame_header_is_used (fndecl);
+}
+
+/* Return true if any of the callee functions may use its incoming frame
+   header.  */
+
+static bool
+mips_callees_use_frame_header_p (void)
+{
+  rtx insn;
+
+  /* Iterate through all instructions in the current function and check whether
+     only already seen functions may be called.  Assume that any unseen function
+     may use its incoming frame header.  */
+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))
+    if (mips_callee_use_frame_header (insn))
+      return true;
+
+  return false;
+}
+
+/* Return true if the current function may use its incoming frame header.
+   If destination of memory store in format sp + offset and offset is greater
+   or equal than frame->total_size than this function returns true.
+   */
+
+static bool
+mips_cfun_use_frame_header_p (void)
+{
+  rtx insn;
+  struct mips_frame_info *frame;
+
+  frame = &cfun->machine->frame;
+
+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))
+    {
+      if (insn != NULL_RTX && INSN_P (insn)
+	  && GET_CODE (PATTERN (insn)) == SET
+	  && MEM_P (XEXP (PATTERN (insn), 0)))
+	{
+	  rtx mem_dst = XEXP (XEXP (PATTERN (insn), 0), 0);
+	  if (GET_CODE (mem_dst) == PLUS
+	      && CONST_INT_P (XEXP (mem_dst, 1))
+	      && REG_P (XEXP (mem_dst, 0))
+	      && REGNO (XEXP (mem_dst, 0)) == STACK_POINTER_REGNUM)
+	    {
+	      int offset = INTVAL (XEXP (mem_dst, 1));
+	      if (offset >= cfun->machine->initial_total_size)
+		return true;
+	    }
+	}
+    }
+
+  return false;
+}
+
+/* Populate the current function's mips_frame_info structure.
+
+   MIPS stack frames look like:
+
+	+-------------------------------+
+	|                               |
+	|  incoming stack arguments     |
+	|                               |
+	+-------------------------------+
+	|                               |
+	|  caller-allocated save area   |
+      A |  for register arguments       |
+	|                               |
+	+-------------------------------+ <-- incoming stack pointer
+	|                               |
+	|  callee-allocated save area   |
+      B |  for arguments that are       |
+	|  split between registers and  |
+	|  the stack                    |
+	|                               |
+	+-------------------------------+ <-- arg_pointer_rtx
+	|                               |
+      C |  callee-allocated save area   |
+	|  for register varargs         |
+	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx
+	|                               |       + cop0_sp_offset
+	|  COP0 reg save area           |	+ UNITS_PER_WORD
+	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx + acc_sp_offset
+	|                               |       + UNITS_PER_WORD
+	|  accumulator save area        |
+	|                               |
+	+-------------------------------+ <-- stack_pointer_rtx + fp_sp_offset
+	|                               |       + UNITS_PER_HWFPVALUE
+	|  FPR save area                |
+	|                               |
+	+-------------------------------+ <-- stack_pointer_rtx + gp_sp_offset
+	|                               |       + UNITS_PER_WORD
+	|  GPR save area                |
+	|                               |
+	+-------------------------------+ <-- frame_pointer_rtx with
+	|                               | \     -fstack-protector
+	|  local variables              |  | var_size
+	|                               | /
+	+-------------------------------+
+	|                               | \
+	|  $gp save area                |  | cprestore_size
+	|                               | /
+      P +-------------------------------+ <-- hard_frame_pointer_rtx for
+	|                               | \     MIPS16 code
+	|  outgoing stack arguments     |  |
+	|                               |  |
+	+-------------------------------+  | args_size
+	|                               |  |
+	|  caller-allocated save area   |  |
+	|  for register arguments       |  |
+	|                               | /
+	+-------------------------------+ <-- stack_pointer_rtx
+					      frame_pointer_rtx without
+					        -fstack-protector
+					      hard_frame_pointer_rtx for
+						non-MIPS16 code.
 
    At least two of A, B and C will be empty.
 
@@ -9219,9 +10118,8 @@
    hard_frame_pointer_rtx unchanged.  */
 
 static void
-mips_compute_frame_info (void)
+mips_compute_frame_info (bool recalculate, struct mips_frame_info *frame)
 {
-  struct mips_frame_info *frame;
   HOST_WIDE_INT offset, size;
   unsigned int regno, i;
 
@@ -9247,11 +10145,11 @@
 	}
     }
 
-  frame = &cfun->machine->frame;
   memset (frame, 0, sizeof (*frame));
   size = get_frame_size ();
 
   cfun->machine->global_pointer = mips_global_pointer ();
+  frame->cprestore_size = 0;
 
   /* The first two blocks contain the outgoing argument area and the $gp save
      slot.  This area isn't needed in leaf functions, but if the
@@ -9267,12 +10165,18 @@
 	frame->args_size = REG_PARM_STACK_SPACE (cfun->decl);
       else
 	frame->args_size = 0;
-      frame->cprestore_size = 0;
     }
   else
     {
-      frame->args_size = crtl->outgoing_args_size;
-      frame->cprestore_size = MIPS_GP_SAVE_AREA_SIZE;
+      /* If recalculate do not take args_size into account.  */
+      if (recalculate)
+	frame->args_size = 0;
+      else
+	frame->args_size = crtl->outgoing_args_size;
+
+      /* Check if space allocated on stack for gp will be used.  */
+      if (!recalculate || mips_must_initialize_gp_p ())
+	frame->cprestore_size = MIPS_GP_SAVE_AREA_SIZE;
     }
   offset = frame->args_size + frame->cprestore_size;
 
@@ -9432,7 +10336,7 @@
      without using a second temporary register.  */
   if (TARGET_MIPS16)
     {
-      mips_compute_frame_info ();
+      mips_compute_frame_info (false, &cfun->machine->frame);
       if (!SMALL_OPERAND (cfun->machine->frame.total_size))
 	return true;
     }
@@ -9458,7 +10362,7 @@
 {
   HOST_WIDE_INT offset;
 
-  mips_compute_frame_info ();
+  mips_compute_frame_info (false, &cfun->machine->frame);
 
   /* Set OFFSET to the offset from the end-of-prologue stack pointer.  */
   switch (from)
@@ -9700,6 +10604,125 @@
       }
 }
 
+static void mips_save_reg (rtx reg, rtx mem);
+
+/* Build microMIPS save or restore.  FN is save or restore function.
+   OFFSET is the current stack offset.
+   Return true if we succeed creating save or restore.  */
+
+static bool
+micromips_build_save_restore (mips_save_restore_fn fn,
+			      HOST_WIDE_INT offset)
+{
+  int i, num_of_reg;
+  unsigned int j;
+  rtx pattern, set, reg, mem;
+  HOST_WIDE_INT this_offset;
+  rtx this_base;
+  unsigned int type[19] = {0x00010000, 0x00030000, 0x00070000, 0x000f0000,
+			   0x001f0000, 0x003f0000, 0x007f0000, 0x00ff0000,
+			   0x40ff0000, 0x80000000, 0x80010000, 0x80030000,
+			   0x80070000, 0x800f0000, 0x801f0000, 0x803f0000,
+			   0x807f0000, 0x80ff0000, 0xc0ff0000};
+  unsigned int encode[19] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 17, 18, 19,
+			     20, 21, 22, 23, 24, 25};
+
+  /* LWM/SWM can only support offsets from -2048 to 2047.  */
+  if (offset < -2048 || offset > 2047)
+    return false;
+
+  /* Try matching $16 to $31 (s0 to ra).  */
+  for (i = 0; i < 19; i++)
+    if ((cfun->machine->frame.mask & 0xffff0000) == type[i])
+      break;
+
+  if (i == 19)
+    {
+      /* Try matching $16 to $23 (s0 to s7) only.  */
+      for (i = 0; i < 8; i ++)
+	if ((cfun->machine->frame.mask & 0x00ff0000) == type[i])
+	  break;
+
+      if (i == 8)
+	return false;
+    }
+
+  /* For only one register, we use normal sw/lw for speed.  */
+  if (i == 0 || i == 9)
+    return false;
+
+  /* For $31 to $24.  */
+  if (i < 8 && (cfun->machine->frame.mask & 0xff000000))
+    {
+      int regno;
+      for (regno = GP_REG_LAST; regno > GP_REG_LAST - 8; regno--)
+	if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
+	  {
+	    mips_save_restore_reg (word_mode, regno, offset, fn);
+	    offset -= UNITS_PER_WORD;
+	  }
+    }
+
+  /* Adjust offset for output.  */
+  num_of_reg = (encode[i] & 0xf) + (encode[i] >> 4);
+  offset -= (UNITS_PER_WORD * (num_of_reg - 1));
+
+  /* Create the final PARALLEL.  */
+  pattern = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_of_reg));
+
+  this_base = stack_pointer_rtx;
+  this_offset = offset;
+
+  /* For $16-$23, $30.  */
+  for (j = 0; j < (encode[i] & 0xf); j++)
+    {
+      unsigned int regno;
+      mem = gen_frame_mem (SImode, plus_constant (this_base,
+			   this_offset + j * UNITS_PER_WORD));
+      regno = (j != 8) ? 16 + j : 30;
+      reg = gen_rtx_REG (SImode, regno);
+      if (fn == mips_save_reg)
+	set = mips_frame_set (mem, reg);
+      else
+	set = gen_rtx_SET (VOIDmode, reg, mem);
+      XVECEXP (pattern, 0, j) = set;
+    }
+
+  /* For $31.  */
+  if (encode[i] >> 4)
+    {
+      mem = gen_frame_mem (SImode, plus_constant (this_base,
+			   this_offset + j * UNITS_PER_WORD));
+      reg = gen_rtx_REG (SImode, 31);
+      if (fn == mips_save_reg)
+	set = mips_frame_set (mem, reg);
+      else
+	set = gen_rtx_SET (VOIDmode, reg, mem);
+      XVECEXP (pattern, 0, j) = set;
+    }
+
+  pattern = emit_insn (pattern);
+  if (fn == mips_save_reg)
+    RTX_FRAME_RELATED_P(pattern) = 1;  
+
+  /* Adjust the last offset.  */
+  offset -= UNITS_PER_WORD;
+
+  /* For $15 to $0.  */
+  if (cfun->machine->frame.mask & 0xffff)
+    {
+      int regno;
+      for (regno = GP_REG_FIRST + 15; regno >= GP_REG_FIRST; regno--)
+	if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
+	  {
+	    mips_save_restore_reg (word_mode, regno, offset, fn);
+	    offset -= UNITS_PER_WORD;
+	  }
+    }
+
+  return true;
+}
+
 /* Call FN for each register that is saved by the current function.
    SP_OFFSET is the offset of the current stack pointer from the start
    of the frame.  */
@@ -9717,6 +10740,13 @@
      need a nop in the epilogue if at least one register is reloaded in
      addition to return address.  */
   offset = cfun->machine->frame.gp_sp_offset - sp_offset;
+
+  if (TARGET_MICROMIPS)
+    {
+      if (micromips_build_save_restore (fn, offset))
+	goto save_restore_fp_reg;
+    }
+
   for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)
     if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
       {
@@ -9727,6 +10757,8 @@
 	offset -= UNITS_PER_WORD;
       }
 
+  save_restore_fp_reg:
+
   /* This loop must iterate over the same space as its companion in
      mips_compute_frame_info.  */
   offset = cfun->machine->frame.fp_sp_offset - sp_offset;
@@ -9851,10 +10883,15 @@
 
   /* In MIPS16 mode, we may need to generate a non-MIPS16 stub to handle
      floating-point arguments.  */
-  if (TARGET_MIPS16
-      && TARGET_HARD_FLOAT_ABI
-      && crtl->args.info.fp_code != 0)
-    mips16_build_function_stub ();
+  if (TARGET_MIPS16 && TARGET_HARD_FLOAT_ABI)
+    {
+      bool fp_args = crtl->args.info.fp_code != 0;
+      rtx return_rtx = crtl->return_rtx;
+      bool fp_ret= (return_rtx 
+		    && mips_return_mode_in_fpr_p (GET_MODE (return_rtx)));
+      if (fp_args || fp_ret)
+	mips16_build_function_stub_and_local_alias (fp_args);
+    }
 
   /* Get the function name the same way that toplev.c does before calling
      assemble_start_function.  This is needed so that the name used here
@@ -10060,11 +11097,14 @@
 void
 mips_expand_prologue (void)
 {
-  const struct mips_frame_info *frame;
+  struct mips_frame_info *frame;
   HOST_WIDE_INT size;
   unsigned int nargs;
   rtx insn;
 
+  frame = &cfun->machine->frame;
+  mips_compute_frame_info (false, frame);
+
   if (cfun->machine->global_pointer != INVALID_REGNUM)
     {
       /* Check whether an insn uses pic_offset_table_rtx, either explicitly
@@ -10080,7 +11120,6 @@
       SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);
     }
 
-  frame = &cfun->machine->frame;
   size = frame->total_size;
 
   if (flag_stack_usage)
@@ -10319,6 +11358,7 @@
      the call to mcount.  */
   if (crtl->profile)
     emit_insn (gen_blockage ());
+  cfun->machine->initial_total_size = frame->total_size;
 }
 
 /* Emit instructions to restore register REG from slot MEM.  */
@@ -10361,6 +11401,7 @@
   const struct mips_frame_info *frame;
   HOST_WIDE_INT step1, step2;
   rtx base, target, insn;
+  bool use_jraddiusp_p = false;
 
   if (!sibcall_p && mips_can_use_return_insn ())
     {
@@ -10460,6 +11501,14 @@
       mips_for_each_saved_gpr_and_fpr (frame->total_size - step2,
 				       mips_restore_reg);
 
+      /* Check if we can use jraddiusp.  */
+      use_jraddiusp_p = (TARGET_MICROMIPS
+			 && !crtl->calls_eh_return
+			 && !sibcall_p
+			 && step2 > 0
+			 && (step2 & 3) == 0
+			 && step2 <= (31 << 2));
+
       if (cfun->machine->interrupt_handler_p)
 	{
 	  HOST_WIDE_INT offset;
@@ -10498,7 +11547,7 @@
       else
 	{
 	  /* Deallocate the final bit of the frame.  */
-	  if (step2 > 0)
+	  if (step2 > 0 && !use_jraddiusp_p)
 	    emit_insn (gen_add3_insn (stack_pointer_rtx,
 				      stack_pointer_rtx,
 				      GEN_INT (step2)));
@@ -10547,7 +11596,11 @@
 	    regno = GP_REG_FIRST + 7;
 	  else
 	    regno = RETURN_ADDR_REGNUM;
-	  emit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode, regno)));
+	  if (use_jraddiusp_p)
+	    emit_jump_insn (gen_mips_jraddiusp (GEN_INT (step2)));
+	  else
+	    emit_jump_insn (gen_simple_return_internal (gen_rtx_REG (Pmode,
+								     regno)));
 	}
     }
 
@@ -11535,6 +12588,8 @@
       return is_64bit_p ? "daddiu\t%0,%1,%2" : "addiu\t%0,%1,%2";
     case SYNC_INSN1_SUBU:
       return is_64bit_p ? "dsubu\t%0,%1,%z2" : "subu\t%0,%1,%z2";
+    case SYNC_INSN1_NEG:
+      return is_64bit_p ? "dsubu\t%0,%.,%z2" : "subu\t%0,%.,%z2";
     case SYNC_INSN1_AND:
       return "and\t%0,%1,%z2";
     case SYNC_INSN1_ANDI:
@@ -11590,7 +12645,7 @@
 mips_process_sync_loop (rtx insn, rtx *operands)
 {
   rtx at, mem, oldval, newval, inclusive_mask, exclusive_mask;
-  rtx required_oldval, insn1_op2, tmp1, tmp2, tmp3;
+  rtx required_oldval, insn1_op2, tmp1, tmp2, tmp3, cmp;
   unsigned int tmp3_insn;
   enum attr_sync_insn1 insn1;
   enum attr_sync_insn2 insn2;
@@ -11611,6 +12666,7 @@
   /* Read the other attributes.  */
   at = gen_rtx_REG (GET_MODE (mem), AT_REGNUM);
   READ_OPERAND (oldval, at);
+  READ_OPERAND (cmp, 0);
   READ_OPERAND (newval, at);
   READ_OPERAND (inclusive_mask, 0);
   READ_OPERAND (exclusive_mask, 0);
@@ -11622,7 +12678,8 @@
   mips_multi_start ();
 
   /* Output the release side of the memory barrier.  */
-  if (get_attr_sync_release_barrier (insn) == SYNC_RELEASE_BARRIER_YES)
+  if (get_attr_sync_release_barrier (insn) == SYNC_RELEASE_BARRIER_YES
+      && !TARGET_XLP)
     {
       if (required_oldval == 0 && TARGET_OCTEON)
 	{
@@ -11660,6 +12717,10 @@
 	  tmp1 = at;
 	}
       mips_multi_add_insn ("bne\t%0,%z1,2f", tmp1, required_oldval, NULL);
+
+      /* CMP  = 0 [delay slot].  */
+      if (cmp)
+        mips_multi_add_insn ("li\t%0,0", cmp, NULL);      
     }
 
   /* $TMP1 = OLDVAL & EXCLUSIVE_MASK.  */
@@ -11726,8 +12787,13 @@
   else
     mips_multi_add_insn ("nop", NULL);
 
+  /* CMP  = 1.  */
+  if (required_oldval && cmp)
+    mips_multi_add_insn ("li\t%0,1", cmp, NULL);      
+
   /* Output the acquire side of the memory barrier.  */
-  if (TARGET_SYNC_AFTER_SC)
+  if (get_attr_sync_acquire_barrier (insn) == SYNC_ACQUIRE_BARRIER_YES 
+      && !TARGET_XLP && TARGET_SYNC_AFTER_SC)
     mips_multi_add_insn ("sync", NULL);
 
   /* Output the exit label, if needed.  */
@@ -11764,13 +12830,108 @@
   return "";
 }
 
+/* INSN is an atomic operation with operands OPERANDS.  Build up a multi-insn
+   sequence for it.  */
+
+static void
+mips_process_atomic (rtx insn, rtx *operands)
+{
+  rtx at, mem, oldval;
+  rtx insn1_op2;
+  enum attr_sync_insn1 insn1;
+  bool is_64bit_p;
+  rtx dummy;
+
+  /* Read an operand from the sync_WHAT attribute and store it in
+     variable WHAT.  DEFAULT is the default value if no attribute
+     is specified.  */
+#define READ_OPERAND(WHAT, DEFAULT) \
+  WHAT = mips_get_sync_operand (operands, (int) get_attr_sync_##WHAT (insn), \
+                                DEFAULT)
+
+  /* Read the memory.  */
+  READ_OPERAND (mem, 0);
+  gcc_assert (mem);
+  is_64bit_p = (GET_MODE_BITSIZE (GET_MODE (mem)) == 64);
+
+  /* Read the other attributes.  */
+  at = gen_rtx_REG (GET_MODE (mem), AT_REGNUM);
+  dummy = at;
+  READ_OPERAND (oldval, at);
+  READ_OPERAND (insn1_op2, 0);
+  insn1 = get_attr_sync_insn1 (insn);
+
+  mips_multi_start ();
+
+  /* Output the release side of the memory barrier.  */
+  if (get_attr_sync_release_barrier (insn) == SYNC_RELEASE_BARRIER_YES
+      && !TARGET_XLP)
+    mips_multi_add_insn ("sync", NULL);
+
+  /* Move operand to proper reg. */
+  mips_multi_add_insn (mips_sync_insn1_template (insn1, is_64bit_p),
+                       oldval, dummy, insn1_op2, NULL);
+
+  /* Do atomic operation.  */
+  switch (get_attr_sync_atomic_insn (insn))
+    {
+    case SYNC_ATOMIC_INSN_LDADD:
+      mips_multi_add_insn (is_64bit_p ? "ldaddd\t%0,%b1" : "ldaddw\t%0,%b1",
+                           oldval, mem, NULL);
+      break;
+    case SYNC_ATOMIC_INSN_SWAP:
+      mips_multi_add_insn (is_64bit_p ? "swapd\t%0,%b1" : "swapw\t%0,%b1",
+                           oldval, mem, NULL);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  /* Output the acquire side of the memory barrier.  */
+  if (get_attr_sync_acquire_barrier (insn) == SYNC_ACQUIRE_BARRIER_YES 
+      && !TARGET_XLP)
+    mips_multi_add_insn ("sync", NULL);
+
+#undef READ_OPERAND
+}
+
+/* Output and/or return the asm template for atomic INSN, which has
+   the operands given by OPERANDS.  */
+
+const char *
+mips_output_atomic (rtx insn, rtx *operands)
+{
+  mips_process_atomic (insn, operands);
+
+  mips_push_asm_switch (&mips_noreorder);
+  mips_push_asm_switch (&mips_nomacro);
+  mips_push_asm_switch (&mips_noat);
+
+  if (!TARGET_XLP)
+    mips_start_ll_sc_sync_block ();
+
+  mips_multi_write ();
+
+  if (!TARGET_XLP)
+    mips_end_ll_sc_sync_block ();
+
+  mips_pop_asm_switch (&mips_noat);
+  mips_pop_asm_switch (&mips_nomacro);
+  mips_pop_asm_switch (&mips_noreorder);
+
+  return "";
+}
+
 /* Return the number of individual instructions in sync loop INSN,
    which has the operands given by OPERANDS.  */
 
 unsigned int
 mips_sync_loop_insns (rtx insn, rtx *operands)
 {
-  mips_process_sync_loop (insn, operands);
+  if (get_attr_sync_atomic_insn (insn) != SYNC_ATOMIC_INSN_NONE)
+    mips_process_atomic (insn, operands);
+  else
+    mips_process_sync_loop (insn, operands);
   return mips_multi_num_insns;
 }
 
@@ -12039,6 +13200,9 @@
     case PROCESSOR_LOONGSON_3A:
       return 4;
 
+    case PROCESSOR_XLP:
+      return (reload_completed ? 4 : 2);
+
     default:
       return 1;
     }
@@ -12169,6 +13333,9 @@
   if (TUNE_OCTEON)
     return 2;
 
+  if (TUNE_XLP)
+    return 4;
+
   return 0;
 }
 
@@ -12205,7 +13372,17 @@
       ready[pos2] = temp;
     }
 }
-
+
+int
+mips_mult_madd_chain_bypass_p (rtx out_insn ATTRIBUTE_UNUSED,
+			       rtx in_insn ATTRIBUTE_UNUSED)
+{
+  if (reload_completed)
+    return false;
+  else
+    return true;
+}
+
 /* Used by TUNE_MACC_CHAINS to record the last scheduled instruction
    that may clobber hi or lo.  */
 static rtx mips_macc_chains_last_hilo;
@@ -12592,7 +13769,8 @@
   /* The function's prototype.  */
   enum mips_function_type function_type;
 
-  /* Whether the function is available.  */
+  /* Whether the function is available.  A NULL pointer value here
+     means the builtin is always available.  */
   unsigned int (*avail) (void);
 };
 
@@ -12605,6 +13783,11 @@
 AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)
 AVAIL_NON_MIPS16 (loongson, TARGET_LOONGSON_VECTORS)
 AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)
+AVAIL_NON_MIPS16 (swap, GENERATE_SWAP || GENERATE_LL_SC)
+AVAIL_NON_MIPS16 (swapd, (GENERATE_SWAP || GENERATE_LL_SC) && TARGET_64BIT)
+AVAIL_NON_MIPS16 (ll_sc, GENERATE_LL_SC)
+AVAIL_NON_MIPS16 (lld_scd, GENERATE_LL_SC && TARGET_64BIT)
+
 
 /* Construct a mips_builtin_description from the given arguments.
 
@@ -12633,6 +13816,11 @@
 #define DIRECT_BUILTIN(INSN, FUNCTION_TYPE, AVAIL)			\
   MIPS_BUILTIN (INSN, f, #INSN, MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, AVAIL)
 
+/* Define __builtin_mips_<INSN>. Like DIRECT_BUILTIN, but expanded using
+   mips_expand_builtin_atomic.  */
+#define ATOMIC_BUILTIN(INSN, FUNCTION_TYPE, AVAIL)			\
+  MIPS_BUILTIN (INSN, f, #INSN, MIPS_BUILTIN_ATOMIC, FUNCTION_TYPE, AVAIL)
+
 /* Define __builtin_mips_<INSN>_<COND>_{s,d} functions, both of which
    are subject to mips_builtin_avail_<AVAIL>.  */
 #define CMP_SCALAR_BUILTINS(INSN, COND, AVAIL)				\
@@ -12767,6 +13955,13 @@
 #define CODE_FOR_loongson_punpcklhw CODE_FOR_vec_interleave_lowv4hi
 #define CODE_FOR_loongson_punpcklwd CODE_FOR_vec_interleave_lowv2si
 
+/* Define a MIPS_BUILTIN_THREAD_POINTER builtin.  The parameters are
+   mostly fixed, but we allow both __builtin* and __builtin_mips*
+   prefixes below.  */
+#define THREAD_POINTER_BUILTIN(NAME)					\
+  { CODE_FOR_nothing, MIPS_FP_COND_f, #NAME,				\
+    MIPS_BUILTIN_THREAD_POINTER, MIPS_POINTER_FTYPE_VOID, NULL }
+
 static const struct mips_builtin_description mips_builtins[] = {
   DIRECT_BUILTIN (pll_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),
   DIRECT_BUILTIN (pul_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),
@@ -13046,8 +14241,36 @@
   LOONGSON_BUILTIN_SUFFIX (punpcklhw, s, MIPS_V4HI_FTYPE_V4HI_V4HI),
   LOONGSON_BUILTIN_SUFFIX (punpcklwd, s, MIPS_V2SI_FTYPE_V2SI_V2SI),
 
+  /* Atomic builtins.  */
+  ATOMIC_BUILTIN (swap_acq, MIPS_SI_FTYPE_VPOINTER_SI, swap),
+  ATOMIC_BUILTIN (swap_rel, MIPS_SI_FTYPE_VPOINTER_SI, swap),
+  ATOMIC_BUILTIN (swapd_acq, MIPS_DI_FTYPE_VPOINTER_DI, swapd),
+  ATOMIC_BUILTIN (swapd_rel, MIPS_DI_FTYPE_VPOINTER_DI, swapd),
+
+  ATOMIC_BUILTIN (val_compare_and_swap_acq, MIPS_SI_FTYPE_VPOINTER_SI_SI,
+                  ll_sc),
+  ATOMIC_BUILTIN (val_compare_and_swap_rel, MIPS_SI_FTYPE_VPOINTER_SI_SI,
+                  ll_sc),
+  ATOMIC_BUILTIN (val_compare_and_swapd_acq, MIPS_DI_FTYPE_VPOINTER_DI_DI,
+                  lld_scd),
+  ATOMIC_BUILTIN (val_compare_and_swapd_rel, MIPS_DI_FTYPE_VPOINTER_DI_DI,
+                  lld_scd),
+
+  ATOMIC_BUILTIN (bool_compare_and_swap_acq, MIPS_SI_FTYPE_VPOINTER_SI_SI,
+                  ll_sc),
+  ATOMIC_BUILTIN (bool_compare_and_swap_rel, MIPS_SI_FTYPE_VPOINTER_SI_SI,
+                  ll_sc),
+  ATOMIC_BUILTIN (bool_compare_and_swapd_acq, MIPS_DI_FTYPE_VPOINTER_DI_DI,
+                  lld_scd),
+  ATOMIC_BUILTIN (bool_compare_and_swapd_rel, MIPS_DI_FTYPE_VPOINTER_DI_DI,
+                  lld_scd),
+
   /* Sundry other built-in functions.  */
-  DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache)
+  DIRECT_NO_TARGET_BUILTIN (cache, MIPS_VOID_FTYPE_SI_CVPOINTER, cache),
+
+  /* TLS thread pointer built-in functions.  */
+  THREAD_POINTER_BUILTIN (__builtin_mips_thread_pointer),
+  THREAD_POINTER_BUILTIN (__builtin_thread_pointer)
 };
 
 /* Index I is the function declaration for mips_builtins[I], or null if the
@@ -13087,11 +14310,26 @@
   return cache;
 }
 
+/* Return a type for 'volatile void *'.  */
+
+static tree
+mips_build_vpointer_type (void)
+{
+  static tree cache;
+
+  if (cache == NULL_TREE)
+    cache = build_pointer_type (build_qualified_type
+				(void_type_node,
+				 TYPE_QUAL_VOLATILE));
+  return cache;
+}
+
 /* Source-level argument types.  */
 #define MIPS_ATYPE_VOID void_type_node
 #define MIPS_ATYPE_INT integer_type_node
 #define MIPS_ATYPE_POINTER ptr_type_node
 #define MIPS_ATYPE_CVPOINTER mips_build_cvpointer_type ()
+#define MIPS_ATYPE_VPOINTER mips_build_vpointer_type ()
 
 /* Standard mode-based argument types.  */
 #define MIPS_ATYPE_UQI unsigned_intQI_type_node
@@ -13118,6 +14356,8 @@
 
 /* MIPS_FTYPE_ATYPESN takes N MIPS_FTYPES-like type codes and lists
    their associated MIPS_ATYPEs.  */
+#define MIPS_FTYPE_ATYPES0(A) MIPS_ATYPE_##A
+
 #define MIPS_FTYPE_ATYPES1(A, B) \
   MIPS_ATYPE_##A, MIPS_ATYPE_##B
 
@@ -13156,6 +14396,7 @@
   return types[(int) type];
 }
 
+
 /* Implement TARGET_INIT_BUILTINS.  */
 
 static void
@@ -13169,14 +14410,20 @@
   for (i = 0; i < ARRAY_SIZE (mips_builtins); i++)
     {
       d = &mips_builtins[i];
-      if (d->avail ())
-	mips_builtin_decls[i]
+      if (d->avail && !d->avail())
+	continue;
+      mips_builtin_decls[i]
 	  = add_builtin_function (d->name,
 				  mips_build_function_type (d->function_type),
 				  i, BUILT_IN_MD, NULL, NULL);
+      if (d->builtin_type == MIPS_BUILTIN_THREAD_POINTER)
+	{
+	  TREE_NOTHROW (mips_builtin_decls[i]) = 1;
+	  TREE_READONLY (mips_builtin_decls[i]) = 1;
+	}
+
     }
 }
-
 /* Implement TARGET_BUILTIN_DECL.  */
 
 static tree
@@ -13439,6 +14686,49 @@
 				       const1_rtx, const0_rtx);
 }
 
+/* Expand an atomic built-in function.  */
+
+static rtx
+mips_expand_builtin_atomic (enum insn_code icode, rtx target, tree exp)
+{
+  rtx ops2, ops3;
+  int n = call_expr_nargs (exp);
+  rtx addr, mem;
+  tree loc;
+  enum machine_mode mode;
+
+  target = mips_prepare_builtin_target (icode, 0, target);
+
+  /* inlined static builtins.c:get_builtin_sync_mem.  */
+  loc = CALL_EXPR_ARG (exp, 0);
+  mode = GET_MODE (target);
+  addr = expand_expr (loc, NULL_RTX, Pmode, EXPAND_SUM);
+  mem = validize_mem (gen_rtx_MEM (mode, addr));
+  set_mem_align (mem, get_pointer_alignment (loc, BIGGEST_ALIGNMENT));
+  set_mem_alias_set (mem, ALIAS_SET_MEMORY_BARRIER);
+  MEM_VOLATILE_P (mem) = 1;
+
+  ops2 = mips_prepare_builtin_arg (icode, 2, exp, 1);
+
+  if (n == 3)
+    ops3 = mips_prepare_builtin_arg (icode, 3, exp, 2);
+
+  switch (n)
+    {
+    case 2:
+      emit_insn (GEN_FCN (icode) (target, mem, ops2));
+      break;
+
+    case 3:
+      emit_insn (GEN_FCN (icode) (target, mem, ops2, ops3));
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+  return target;
+}
+
 /* Implement TARGET_EXPAND_BUILTIN.  */
 
 static rtx
@@ -13446,20 +14736,21 @@
 		     enum machine_mode mode, int ignore)
 {
   tree fndecl;
-  unsigned int fcode, avail;
+  unsigned int fcode;
   const struct mips_builtin_description *d;
 
   fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
   fcode = DECL_FUNCTION_CODE (fndecl);
   gcc_assert (fcode < ARRAY_SIZE (mips_builtins));
   d = &mips_builtins[fcode];
-  avail = d->avail ();
-  gcc_assert (avail != 0);
-  if (TARGET_MIPS16)
+  if (d->avail && !d->avail ())
     {
-      error ("built-in function %qE not supported for MIPS16",
-	     DECL_NAME (fndecl));
-      return ignore ? const0_rtx : CONST0_RTX (mode);
+      if (TARGET_MIPS16)
+	{
+	  error ("built-in function %qE not supported for MIPS16",
+		 DECL_NAME (fndecl));
+	  return ignore ? const0_rtx : CONST0_RTX (mode);
+	}
     }
   switch (d->builtin_type)
     {
@@ -13484,6 +14775,12 @@
 
     case MIPS_BUILTIN_BPOSGE32:
       return mips_expand_builtin_bposge (d->builtin_type, target);
+
+    case MIPS_BUILTIN_ATOMIC:
+      return mips_expand_builtin_atomic (d->icode, target, exp);
+
+    case MIPS_BUILTIN_THREAD_POINTER:
+      return mips_get_tp (target);
     }
   gcc_unreachable ();
 }
@@ -13673,7 +14970,7 @@
   struct mips16_rewrite_pool_refs_info *info =
     (struct mips16_rewrite_pool_refs_info *) data;
 
-  if (force_to_mem_operand (*x, Pmode))
+  if (force_to_mem_operand (*x, Pmode) || tls_reloc_operand (*x, Pmode))
     {
       rtx mem = force_const_mem (GET_MODE (*x), *x);
       validate_change (info->insn, x, mem, false);
@@ -13685,6 +14982,11 @@
       return -1;
     }
 
+  if (GET_CODE (*x) == UNSPEC
+      && XINT (*x, 1) == UNSPEC_TLS_GET_TP
+      && GET_CODE (XVECEXP (*x, 0, 0)) == SYMBOL_REF)
+    return -1;
+
   if (TARGET_MIPS16_TEXT_LOADS)
     mips16_rewrite_pool_constant (info->pool, x);
 
@@ -14705,6 +16007,15 @@
     }
   dfa_finish ();
 }
+
+/* MIPS insns are 4-byte aligned.  Return 4 log 2.  */
+
+static int
+mips_align_insns (void)
+{
+  return 2;
+}
+
 
 /* This structure records that the current function has a LO_SUM
    involving SYMBOL_REF or LABEL_REF BASE and that MAX_OFFSET is
@@ -14778,6 +16089,213 @@
     }
   return INTVAL (offset) <= entry->offset;
 }
+#define OK_FOR_MIPS16_BRANCH(OFFSET) ((OFFSET) >= -65000 && (OFFSET) <= 65000)
+
+static int
+mips16_count_matching_branches (rtx jump_insn)
+{
+  rtx insn;
+  int label_uid, jump_uid;
+  int matches = 0;
+  
+  jump_uid = INSN_UID (jump_insn);
+  label_uid = INSN_UID (JUMP_LABEL (jump_insn));
+
+  /* Count the number of branches to the same label.  */
+  for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))
+    {
+      if (simplejump_p (insn))
+	{
+	  int insn_uid = INSN_UID (JUMP_LABEL (insn));
+	  if (insn_uid != jump_uid && label_uid == insn_uid)
+	    matches++;
+	}
+    }
+
+  return matches;
+}
+
+static rtx
+walk_insns_forward (rtx insn)
+{
+  return NEXT_INSN (insn);
+}
+
+static rtx
+walk_insns_reverse (rtx insn)
+{
+  return PREV_INSN (insn);
+}
+
+static void
+mips16_update_branch_info (mips16_branch_info_t *previous,
+			   mips16_branch_info_t *current,
+			   int insn_uid)
+{
+  /* Move current to previous.  */
+  previous->uid = current->uid;
+  previous->address = current->address;
+  previous->distance_to_dest = current->distance_to_dest;
+  previous->distance_from_src = current->distance_from_src;
+
+  /* Update current.  */
+  current->uid = insn_uid;
+  current->address = INSN_ADDRESSES (insn_uid);
+}
+
+static void
+mips16_zero_branch_info (mips16_branch_info_t *branch_info)
+{
+  branch_info->uid = 0;
+  branch_info->address = 0;
+  branch_info->distance_to_dest = 0;
+  branch_info->distance_from_src = 0;
+}
+
+static void
+mips16_check_branches (rtx jump_insn)
+{
+  int label1_uid, label2_uid, jump_uid, insn_uid;
+  int offset;
+  rtx label1;
+  rtx insn, new_label, new_label_insn, new_jump, new_jump_label;
+
+  rtx (*walk_function) (rtx);
+
+  mips16_branch_info_t first_branch, current, previous;
+  
+  mips16_zero_branch_info (&first_branch);
+  mips16_zero_branch_info (&current);
+  mips16_zero_branch_info (&previous);
+
+  jump_uid = INSN_UID (jump_insn);
+  first_branch.uid = jump_uid;
+  first_branch.address = INSN_ADDRESSES (jump_uid);
+
+  /* Don't reprocess branches that were introduced by mips16_check_branches.
+     The branches are known to be within range.  We'll update INSN_ADDRESSES
+     for all of the new branches when we finish here.  */
+  if (first_branch.address == -1)
+    return;
+
+  label1 = JUMP_LABEL (jump_insn);
+  label1_uid = INSN_UID (label1);
+
+  offset = INSN_ADDRESSES (label1_uid) - INSN_ADDRESSES (jump_uid);
+  first_branch.distance_to_dest = offset;
+
+  /* The branch offset is in range, nothing to do.  */
+  if (OK_FOR_MIPS16_BRANCH (offset))
+    return;
+
+  if (offset > 0)
+    walk_function = &walk_insns_forward;
+  else
+    walk_function = &walk_insns_reverse;
+
+  /* The branch offset is too large.  First figure out if there are
+     other branches to the same destination.  If other branches to 
+     the same destination are available, we'll branch there instead.  */
+
+  if (mips16_count_matching_branches (jump_insn))
+    {
+      /* If branches to the same label are available and in range,
+	 then use those first.  */
+      WALK_INSNS (jump_insn, insn, walk_function)
+	{
+	  if (JUMP_P (insn))
+	    {
+	      insn_uid = INSN_UID (insn);
+	      label2_uid = INSN_UID (JUMP_LABEL (insn));
+
+	      if (label2_uid != label1_uid)
+		continue;
+
+	      mips16_update_branch_info (&previous, &current, insn_uid);
+	      offset = INSN_ADDRESSES (insn_uid) - INSN_ADDRESSES (jump_uid);
+	      current.distance_from_src = offset;
+	      if (!OK_FOR_MIPS16_BRANCH (offset))
+		{
+		  /* If the previous candidate was in range, use it.  */
+		  if (previous.address != 0
+		      && OK_FOR_MIPS16_BRANCH (previous.distance_from_src))
+		    {
+		      new_label = gen_label_rtx ();
+		      emit_label_before (new_label, insn);
+		      redirect_jump (jump_insn, new_label, 0);
+		      return;
+		    }
+		  continue;
+		}
+
+	      offset = INSN_ADDRESSES (label2_uid) - INSN_ADDRESSES (insn_uid);
+	      current.distance_to_dest = offset;
+	      if (!OK_FOR_MIPS16_BRANCH (offset))
+		continue; 
+        
+	      /* The offset is in range.  The new destination will
+		 be this branch.  */
+	      new_label = gen_label_rtx ();
+	      emit_label_before (new_label, insn);
+	      redirect_jump (jump_insn, new_label, 0);
+	      return;
+	    }
+	}
+    }
+
+  /* Reset current and previous branch information.  */
+  mips16_zero_branch_info (&current);
+  mips16_zero_branch_info (&previous);
+
+  /* Search for a barrier instruction/insert a label and a jump.  */
+  WALK_INSNS (jump_insn, insn, walk_function)
+    {
+      int barrier_off, label_off;
+
+      if (GET_CODE (insn) == BARRIER)
+	{
+	  insn_uid = INSN_UID (insn);
+	  mips16_update_branch_info (&previous, &current, insn_uid);
+
+	  barrier_off = INSN_ADDRESSES (insn_uid) - INSN_ADDRESSES (jump_uid);
+	  label_off = INSN_ADDRESSES (label1_uid) - INSN_ADDRESSES (insn_uid);
+	  current.distance_from_src = barrier_off;
+	  current.distance_to_dest = label_off;
+
+	  if (!OK_FOR_MIPS16_BRANCH (barrier_off))
+	    {
+	      /* If the previous candidate was in range, use that instead.  */
+	      if (previous.address != 0
+		  && OK_FOR_MIPS16_BRANCH (previous.distance_from_src))
+		{
+		  new_label = gen_label_rtx ();
+		  new_label_insn = emit_label_before (new_label, insn);
+		  redirect_jump (jump_insn, new_label, 0);
+		  new_jump_label = gen_jump (label1);
+		  new_jump = emit_jump_insn_after (new_jump_label,
+						   new_label_insn);
+		  INSN_ADDRESSES_NEW (new_jump, -1);
+		  JUMP_LABEL (new_jump) = label1;
+		  return;
+		}
+	      continue;
+	    }
+
+	  /* If the offset is too large, search for another candidate.  */
+	  if (!OK_FOR_MIPS16_BRANCH (label_off))
+	    continue;
+
+	  new_label = gen_label_rtx ();
+	  new_label_insn = emit_label_before (new_label, insn);
+	  redirect_jump (jump_insn, new_label, 0);
+	  new_jump_label = gen_jump (label1);
+	  new_jump = emit_jump_insn_after (new_jump_label, new_label_insn);
+	  INSN_ADDRESSES_NEW (new_jump, -1);
+	  JUMP_LABEL (new_jump) = label1;
+	  return;
+	}
+    }
+}
 
 /* A for_each_rtx callback for which DATA is a mips_lo_sum_offset hash table.
    Record every LO_SUM in *LOC.  */
@@ -14928,9 +16446,9 @@
   if (crtl->profile)
     cfun->machine->all_noreorder_p = false;
 
-  /* Code compiled with -mfix-vr4120 can't be all noreorder because
-     we rely on the assembler to work around some errata.  */
-  if (TARGET_FIX_VR4120)
+  /* Code compiled with -mfix-vr4120 or -mfix-24k can't be all noreorder
+     because we rely on the assembler to work around some errata.  */
+  if (TARGET_FIX_VR4120 || TARGET_FIX_24K)
     cfun->machine->all_noreorder_p = false;
 
   /* The same is true for -mfix-vr4130 if we might generate MFLO or
@@ -14943,6 +16461,17 @@
   htab = htab_create (37, mips_lo_sum_offset_hash,
 		      mips_lo_sum_offset_eq, free);
 
+  /* Ensure that MIPS16 branches are within range.  */
+  if (TARGET_MIPS16)
+    {
+      for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))
+        {
+	  if (simplejump_p (insn) || any_condjump_p (insn))
+	    mips16_check_branches (insn);
+	}
+      shorten_branches (get_insns ());
+    }
+
   /* Make a first pass over the instructions, recording all the LO_SUMs.  */
   for (insn = get_insns (); insn != 0; insn = NEXT_INSN (insn))
     FOR_EACH_SUBINSN (subinsn, insn)
@@ -15006,12 +16535,8 @@
   htab_delete (htab);
 }
 
-/* If we are using a GOT, but have not decided to use a global pointer yet,
-   see whether we need one to implement long branches.  Convert the ghost
-   global-pointer instructions into real ones if so.  */
-
 static bool
-mips_expand_ghost_gp_insns (void)
+mips_gp_expand_needed_p (void)
 {
   rtx insn;
   int normal_length;
@@ -15040,12 +16565,28 @@
     return false;
 
   /* We've now established that we need $gp.  */
-  cfun->machine->must_initialize_gp_p = true;
-  split_all_insns_noflow ();
-
   return true;
 }
 
+
+/* If we are using a GOT, but have not decided to use a global pointer yet,
+   see whether we need one to implement long branches.  Convert the ghost
+   global-pointer instructions into real ones if so.  */
+
+static bool
+mips_expand_ghost_gp_insns (void)
+{
+
+  if (mips_gp_expand_needed_p ())
+    {
+      /* We've now established that we need $gp.  */
+      cfun->machine->must_initialize_gp_p = true;
+      split_all_insns_noflow ();
+      return true;
+    }
+  return false;
+}
+
 /* Subroutine of mips_reorg to manage passes that require DF.  */
 
 static void
@@ -15082,6 +16623,9 @@
       free_bb_for_insn ();
     }
 
+  if (flag_frame_header_optimization)
+    mips_rest_of_frame_header_opt ();
+
   if (optimize > 0 && flag_delayed_branch)
     dbr_schedule (get_insns ());
   mips_reorg_process_insns ();
@@ -15225,24 +16769,20 @@
   reload_completed = 0;
 }
 
-/* The last argument passed to mips_set_mips16_mode, or negative if the
-   function hasn't been called yet.
+/* The last argument passed to mips_set_mips16_micromips_mode, or negative if the
+   function hasn't been called yet. */
 
-   There are two copies of this information.  One is saved and restored
-   by the PCH process while the other is specific to this compiler
-   invocation.  The information calculated by mips_set_mips16_mode
-   is invalid unless the two variables are the same.  */
 static int was_mips16_p = -1;
-static GTY(()) int was_mips16_pch_p = -1;
+static int was_micromips_p = -1;
 
 /* Set up the target-dependent global state so that it matches the
    current function's ISA mode.  */
 
 static void
-mips_set_mips16_mode (int mips16_p)
+mips_set_mips16_micromips_mode (int mips16_p, int micromips_p)
 {
   if (mips16_p == was_mips16_p
-      && mips16_p == was_mips16_pch_p)
+      && micromips_p == was_micromips_p)
     return;
 
   /* Restore base settings of various flags.  */
@@ -15303,6 +16843,18 @@
       /* Switch to normal (non-MIPS16) mode.  */
       target_flags &= ~MASK_MIPS16;
 
+      if (micromips_p)
+	{
+	  /* Switch to microMIPS mode.  */
+	  target_flags |= MASK_MICROMIPS;
+
+	  /* Avoid branch likely.  */
+	  target_flags &= ~MASK_BRANCHLIKELY;
+	}
+      else
+	/* Switch to normal (non-microMIPS) mode.  */
+	target_flags &= ~MASK_MICROMIPS;
+
       /* Provide default values for align_* for 64-bit targets.  */
       if (TARGET_64BIT)
 	{
@@ -15323,7 +16875,7 @@
   /* (Re)initialize MIPS target internals for new ISA.  */
   mips_init_relocs ();
 
-  if (mips16_p)
+  if (was_mips16_p >= 0)
     {
       if (!mips16_globals)
 	mips16_globals = save_target_globals ();
@@ -15333,8 +16885,8 @@
   else
     restore_target_globals (&default_target_globals);
 
+  was_micromips_p = micromips_p;
   was_mips16_p = mips16_p;
-  was_mips16_pch_p = mips16_p;
 }
 
 /* Implement TARGET_SET_CURRENT_FUNCTION.  Decide whether the current
@@ -15343,7 +16895,8 @@
 static void
 mips_set_current_function (tree fndecl)
 {
-  mips_set_mips16_mode (mips_use_mips16_mode_p (fndecl));
+  mips_set_mips16_micromips_mode (mips_use_mips16_mode_p (fndecl),
+				  mips_use_micromips_mode_p (fndecl));
 }
 
 /* Allocate a chunk of memory for per-function machine-dependent data.  */
@@ -15550,13 +17103,24 @@
 {
   int i, start, regno, mode;
 
+#ifdef SUBTARGET_OVERRIDE_OPTIONS
+  SUBTARGET_OVERRIDE_OPTIONS;
+#endif
+
+#if !(defined(MD_HAVE_COMPACT_EH) && defined(HAVE_GAS_EH_FRAME_ENTRY))
+  TARGET_COMPACT_EH = 0;
+#endif
+
+  /* MIPS16 and microMIPS cannot coexist  */
+  if (TARGET_MICROMIPS && TARGET_MIPS16)
+    error ("unsupported combination: %s", "-mips16 -mmicromips");
+
   /* Process flags as though we were generating non-MIPS16 code.  */
   mips_base_mips16 = TARGET_MIPS16;
   target_flags &= ~MASK_MIPS16;
 
-#ifdef SUBTARGET_OVERRIDE_OPTIONS
-  SUBTARGET_OVERRIDE_OPTIONS;
-#endif
+  mips_base_micromips = TARGET_MICROMIPS;
+  target_flags &= ~MASK_MICROMIPS;
 
   /* -mno-float overrides -mhard-float and -msoft-float.  */
   if (TARGET_NO_FLOAT)
@@ -15721,6 +17285,14 @@
        long as any indirect jumps use $25.  */
     flag_pic = 1;
 
+  /* For SDE, switch on ABICALLS mode if -fpic or -fpie were used, and the
+     user hasn't explicitly disabled these modes.  */
+  if (TARGET_MIPS_SDE
+      && (flag_pic || flag_pie) && !TARGET_ABICALLS
+      && !((target_flags_explicit & MASK_ABICALLS))
+      && mips_abi != ABI_EABI)
+    target_flags |= MASK_ABICALLS;
+
   /* -mvr4130-align is a "speed over size" optimization: it usually produces
      faster code, but at the expense of more nops.  Enable it at -O3 and
      above.  */
@@ -15915,9 +17487,15 @@
 
   /* Now select the ISA mode.
 
-     Do all CPP-sensitive stuff in non-MIPS16 mode; we'll switch to
-     MIPS16 mode afterwards if need be.  */
-  mips_set_mips16_mode (false);
+     Do all CPP-sensitive stuff in non-MIPS16/non-microMIPS mode;
+     We'll switch modes later if required.  */
+  mips_set_mips16_micromips_mode (false, false);
+
+  /* Do not do frame header optimizations when exception handling is generated
+     because of unwinding problems.  This should be a temporary solution, since
+     it's a goal of gcc to generate equivalent code for '-Ox' and '-Ox -g'.  */
+  if (flag_exceptions || flag_unwind_tables)
+    flag_frame_header_optimization = false;
 }
 
 /* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
@@ -16055,28 +17633,6 @@
   emit_move_insn (target, mem);
 }
 
-/* When generating MIPS16 code, we want to allocate $24 (T_REG) before
-   other registers for instructions for which it is possible.  This
-   encourages the compiler to use CMP in cases where an XOR would
-   require some register shuffling.  */
-
-void
-mips_order_regs_for_local_alloc (void)
-{
-  int i;
-
-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-    reg_alloc_order[i] = i;
-
-  if (TARGET_MIPS16)
-    {
-      /* It really doesn't matter where we put register 0, since it is
-         a fixed register anyhow.  */
-      reg_alloc_order[0] = 24;
-      reg_alloc_order[24] = 0;
-    }
-}
-
 /* Implement EH_USES.  */
 
 bool
@@ -16199,6 +17755,287 @@
       return signed_p ? gen_mulsidi3_32bit : gen_umulsidi3_32bit;
     }
 }
+
+/* Return true if PATTERN matches the kind of instruction generated by
+   micromips_build_save_restore.  SAVE_P is true for store.  */
+
+bool
+micromips_save_restore_pattern_p (bool save_p, rtx pattern)
+{
+  int n;
+  HOST_WIDE_INT first_offset = 0;
+  rtx first_base = 0;
+  unsigned int first_regno = 0;
+
+  for (n = 0; n < XVECLEN (pattern, 0); n++)
+    {
+      rtx set, reg, mem, this_base;
+      HOST_WIDE_INT this_offset;
+      unsigned int this_regno;
+
+      /* Check that we have a SET.  */
+      set = XVECEXP (pattern, 0, n);
+      if (GET_CODE (set) != SET)
+	return false;
+
+      /* Check that the SET is a load (if restoring) or a store
+	 (if saving).  */
+      mem = save_p ? SET_DEST (set) : SET_SRC (set);
+      if (!MEM_P (mem))
+	return false;
+
+      /* Check that the address is the sum of base and a
+	 possibly-zero constant offset.  */
+      mips_split_plus (XEXP (mem, 0), &this_base, &this_offset);
+      if (!REG_P (this_base))
+	return false;
+
+      if (n == 0)
+	{
+	  first_base = this_base;
+	  first_offset = this_offset;
+	}
+      else
+	{
+	  /* Check if this_base is the same as first_base.  */
+	  if (REGNO (this_base) != REGNO (first_base))
+	    return false;
+
+	  /* Check if this_offset is first_offset + UNITS_PER_WORD * n.  */
+	  if (this_offset != first_offset + UNITS_PER_WORD * n)
+	    return false;
+	}
+
+      /* Check that SET's other operand is a register.  */
+      reg = save_p ? SET_SRC (set) : SET_DEST (set);
+      if (!REG_P (reg))
+	return false;
+
+      /* Make sure the order of regno is "$16-$23, $30, $31", "$16-$23, $30",
+	 or "$31".  */
+      this_regno = REGNO (reg);
+      if (n == 0)
+	{
+	  if (this_regno != 16 && this_regno != 31)
+	    return false;
+	  first_regno = this_regno;
+	}
+      else if (n == 8) /* For s8.  */
+	{
+	  if (n == XVECLEN (pattern, 0) - 1)
+	    {
+	      if (this_regno != 30 && this_regno != 31)
+		return false;
+	    }
+	  else
+	    {
+	      if (this_regno != 30)
+		return false;
+	    }
+	}
+      else if (n != XVECLEN (pattern, 0) - 1)
+	{
+	  if (this_regno != first_regno + n)
+	    return false;
+	}
+      else /* The last item.  */
+	{
+	  if ((this_regno != first_regno + n) && this_regno != 31)
+	    return false;
+	}
+
+      /* If any item in the list is volatile then disallow.  This is a
+         safeguard only as this is a path unlikely to be exercised since 
+         typical code only generates the instructions for stack accesses.  */
+      if (MEM_VOLATILE_P (mem))
+        return false;
+    }
+
+  return true;
+}
+
+/* Return the assembly instruction for microMIPS lwm or swm.
+   SAVE_P and PATTERN are as for micromips_save_restore_pattern_p.  */
+
+const char *
+micromips_output_save_restore (bool save_p, rtx pattern)
+{
+  static char buffer[300];
+  char *s;
+  int n;
+  HOST_WIDE_INT offset;
+  rtx base, mem, set, reg, last_set, last_reg;
+
+  /* Parse the pattern.  */
+  if (!micromips_save_restore_pattern_p (save_p, pattern))
+    gcc_unreachable ();
+
+  s = strcpy (buffer, save_p ? "swm\t" : "lwm\t");
+  s += strlen (s);
+  n = XVECLEN (pattern, 0);
+
+  set = XVECEXP (pattern, 0, 0);
+  reg = save_p ? SET_SRC (set) : SET_DEST (set);
+  mem = save_p ? SET_DEST (set) : SET_SRC (set);
+  mips_split_plus (XEXP (mem, 0), &base, &offset);
+
+  last_set = XVECEXP (pattern, 0, n - 1);
+  last_reg = save_p ? SET_SRC (last_set) : SET_DEST (last_set);
+
+  if (REGNO (last_reg) == 31)
+    n--;
+
+  if (n == 0)
+    ;
+  else if (n == 1)
+    s += sprintf (s, "%s,", reg_names[16]);
+  else if (n < 9)
+    s += sprintf (s, "%s-%s,", reg_names[16], reg_names[15 + n]);
+  else if (n == 9)
+    s += sprintf (s, "%s-%s,%s,", reg_names[16], reg_names[23],
+		  reg_names[30]);
+  else
+    gcc_unreachable ();
+
+  if (REGNO (last_reg) == 31)
+    s += sprintf (s, "%s,", reg_names[31]);
+
+  s += sprintf (s, "%d(%s)", (int)offset, reg_names[REGNO (base)]);
+  return buffer;
+}
+
+/* Return true if MEM1 and MEM2 use the same base register, and the
+   offset of MEM2 equals the offset of MEM1 plus 4.  FIRST_REG is the
+   register into (from) which the contents of MEM1 will be loaded
+   (stored), depending on the value of LOAD_P.
+   SWAP_P is true when the 1st and 2nd instructions are swapped.  */
+
+bool
+micromips_load_store_pair_p (bool load_p, bool swap_p, rtx first_reg, rtx mem1, rtx mem2)
+{
+  rtx base1, base2, mem1_temp, mem2_temp;
+  HOST_WIDE_INT offset1, offset2;
+
+  if (!MEM_P (mem1) || !MEM_P (mem2))
+    return false;
+
+  mem1_temp = XEXP (mem1, 0);
+  mem2_temp = XEXP (mem2, 0);
+
+  /* Make sure memory is base plus offset.  */
+  if (GET_CODE (mem1_temp) != PLUS
+      || GET_CODE (mem2_temp) != PLUS
+      || GET_CODE (XEXP (mem1_temp, 1)) != CONST_INT
+      || GET_CODE (XEXP (mem2_temp, 1)) != CONST_INT)
+    return false;
+
+  mips_split_plus (mem1_temp, &base1, &offset1);
+  mips_split_plus (mem2_temp, &base2, &offset2);
+
+  if (!REG_P (base1) || !REG_P (base2))
+    return false;
+
+  if (REGNO (base1) != REGNO (base2))
+    return false;
+
+  /* Avoid invalid load pair instructions.  */
+  if (load_p && REGNO (first_reg) == REGNO (base1))
+    return false;
+
+  /* We must avoid this case for anti-dependence.
+     Ex:  lw $3, 4($3)
+          lw $2, 0($3)
+     first_reg is $2, but the base is $3.  */
+  if (load_p && swap_p && (REGNO (first_reg) + 1) == REGNO (base1))
+    return false;
+
+  if (offset1 + 4 != offset2)
+    return false;
+
+  if (offset1 < -2048 || offset1 > 2047)
+    return false;
+
+  return true;
+}
+
+/* Return the assembly instruction for microMIPS lwp or swp.
+   LOAD_P is true for load.  */
+
+const char *
+micromips_output_load_store_pair (bool load_p, rtx reg, rtx mem)
+{
+  static char buffer[300];
+  HOST_WIDE_INT offset;
+  rtx base;
+
+  if (!REG_P (reg) || !MEM_P (mem))
+    gcc_unreachable ();
+
+  mips_split_plus (XEXP (mem, 0), &base, &offset);
+  if (!REG_P (base))
+    gcc_unreachable ();
+
+  sprintf (buffer, "%s\t%s,%d(%s)", load_p ? "lwp" : "swp",
+	   reg_names [REGNO (reg)], (int) offset, reg_names [REGNO (base)]);
+  return buffer;
+}
+
+/* Return true if reg1 and reg2 can be target of movep.  */
+
+bool
+micromips_movep_target_p (rtx reg1, rtx reg2)
+{
+  int regno1, regno2, pair, i;
+  int match[8] = {0x00000060,	/* 5, 6 */
+		  0x000000a0,	/* 5, 7 */
+		  0x000000c0,	/* 6, 7 */
+		  0x00200010,	/* 4, 21 */
+		  0x00400010,	/* 4, 22 */
+		  0x00000030,	/* 4, 5 */
+		  0x00000050,	/* 4, 6 */
+		  0x00000090};	/* 4, 7 */
+
+  if (!REG_P (reg1) || !REG_P (reg2))
+    return false;
+
+  regno1 = REGNO (reg1);
+  regno2 = REGNO (reg2);
+
+  if (!GP_REG_P (regno1)  || !GP_REG_P (regno2))
+    return false;
+
+  pair = (1 << regno1) | (1 << regno2);
+
+  for (i = 0; i < 8; i++)
+    {
+      if (pair == match[i])
+	return true;
+    }
+
+  return false;
+}
+
+/* Output a DTP/TP-relative relocation, used in MIPS16 TLS.  */
+
+void
+mips_output_tls_reloc_directive (rtx x, rtx size)
+{
+  const char *dir = NULL;
+  if (GET_CODE (x) == CONST)
+    x = XEXP (x, 0);
+  switch (UNSPEC_ADDRESS_TYPE (x))
+    {
+    case SYMBOL_DTPREL:
+      dir = INTVAL (size) == 4 ? ".dtprelword" : ".dtpreldword";
+      break;
+    case SYMBOL_TPREL:
+      dir = INTVAL (size) == 4 ? ".tprelword" : ".tpreldword";
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  fprintf (asm_out_file, "\t%s\t%s\n", dir, XSTR (UNSPEC_ADDRESS (x), 0));
+}
 
 /* Return the size in bytes of the trampoline code, padded to
    TRAMPOLINE_ALIGNMENT bits.  The static chain pointer and target
@@ -16428,6 +18265,225 @@
   return GET_MODE_BITSIZE (mode) - 1;
 }
 
+/* Implement TARGET_PREPARE_PCH_SAVE.  */
+
+static void
+mips_prepare_pch_save (void)
+{
+  /* We are called in a context where the current MIPS16 vs. non-MIPS16
+     setting should be irrelevant.  The question then is: which setting
+     makes most sense at load time?
+
+     The PCH is loaded before the first token is read.  We should never
+     have switched into MIPS16 mode by that point, and thus should not
+     have populated mips16_globals.  Nor can we load the entire contents
+     of mips16_globals from the PCH file, because mips16_globals contains
+     a combination of GGC and non-GGC data.
+
+     There is therefore no point in trying save the GGC part of
+     mips16_globals to the PCH file, or to preserve MIPS16ness across
+     the PCH save and load.  The loading compiler would not have access
+     to the non-GGC parts of mips16_globals (either from the PCH file,
+     or from a copy that the loading compiler generated itself) and would
+     have to call target_reinit anyway.
+
+     It therefore seems best to switch back to non-MIPS16 mode at
+     save time, and to ensure that mips16_globals remains null after
+     a PCH load.  */
+  mips_set_mips16_micromips_mode (false, false);
+  mips16_globals = 0;
+}
+
+/* Implement TARGET_UNSPEC_MAY_TRAP .  */
+
+static int
+mips_unspec_may_trap_p (const_rtx x, unsigned flags)
+{
+  if (GET_CODE (x) == UNSPEC_VOLATILE)
+    {
+      switch (XINT (x, 1))
+	{
+	case UNSPEC_SET_GOT_VERSION:
+	  return false;
+	}
+    }
+
+  return default_unspec_may_trap_p (x, flags);
+}
+
+/* Return new offset for stack load/store operations.  */
+
+static int
+mips_get_updated_offset (int old_offset)
+{
+  struct mips_frame_info *frame = &cfun->machine->frame;
+  int res = old_offset;
+  int initial_total_size = cfun->machine->initial_total_size;
+
+  if (old_offset > 0 && old_offset <= frame->gp_sp_offset)
+    /* It should be only gp.  */
+    res = old_offset - (initial_total_size
+			- REG_PARM_STACK_SPACE (cfun->decl));
+  else if (old_offset >= frame->gp_sp_offset
+	   && old_offset <= initial_total_size)
+    /* gp registers, accumulators.  */
+    res = old_offset - (initial_total_size
+			- REG_PARM_STACK_SPACE (cfun->decl));
+  else if (old_offset > initial_total_size)
+    /* Incoming args.  */
+    res = old_offset - initial_total_size;
+
+  return res;
+}
+
+/* Test whether to skip frame header allocation.  TODO: Try to do stack
+   frame allocation removal even if local variables are used.  */
+
+static bool
+mips_skip_stack_frame_alloc (void)
+{
+  struct mips_frame_info *frame = &cfun->machine->frame;
+  struct mips_frame_info opt_frame;
+
+  if (!flag_frame_header_optimization)
+    return false;
+
+  if (cfun->calls_setjmp != 0
+      || cfun->calls_alloca != 0
+      || cfun->stdarg != 0
+      || frame->var_size != 0
+      || frame->args_size > REG_PARM_STACK_SPACE (cfun->decl)
+      || mips_abi != ABI_32 || ((target_flags & MASK_MIPS16) != 0)
+      || frame_pointer_needed != 0 || mips_gp_expand_needed_p ())
+    return false;
+
+  if (mips_callees_use_frame_header_p ())
+    return false;
+
+  mips_compute_frame_info (true, &opt_frame);
+
+  if (opt_frame.total_size > REG_PARM_STACK_SPACE (cfun->decl)
+      || cfun->machine->uses_frame_header_p)
+    return false;
+
+  return true;
+}
+
+/* Update stack related instructions.  */
+
+static void
+mips_frame_header_update_insn (rtx insn, bool inside_seq)
+{
+  rtx set_insn, src, dst;
+
+  if (insn == NULL_RTX || !USEFUL_INSN_P (insn))
+    return;
+
+  set_insn = single_set (insn);
+  if (set_insn == NULL_RTX)
+    return;
+
+  src = SET_SRC (set_insn);
+  dst = SET_DEST (set_insn);
+
+  if (GET_CODE (src) == REG && GET_CODE (dst) == MEM
+      && GET_CODE (XEXP (dst, 0)) == PLUS
+      && GET_CODE (XEXP (XEXP (dst, 0), 0)) == REG
+      && CONST_INT_P (XEXP (XEXP (dst, 0), 1))
+      && (REGNO (XEXP (XEXP (dst, 0), 0))
+          == STACK_POINTER_REGNUM))
+    {
+      /* It is a store through sp - update offset.  */
+      XEXP (XEXP (dst, 0), 1)
+        = GEN_INT (mips_get_updated_offset (INTVAL (XEXP (XEXP (dst, 0), 1))));
+      return;
+    }
+
+  if (GET_CODE (src) == MEM && GET_CODE (dst) == REG
+      && GET_CODE (XEXP (src, 0)) == PLUS
+      && GET_CODE (XEXP (XEXP (src, 0), 0)) == REG
+      && CONST_INT_P (XEXP (XEXP (src, 0), 1))
+      && (REGNO (XEXP (XEXP (src, 0), 0))
+          == STACK_POINTER_REGNUM))
+    {
+      /* It is a load through sp - update offset.  */
+      XEXP (XEXP (src, 0), 1)
+        = GEN_INT (mips_get_updated_offset (INTVAL (XEXP (XEXP (src, 0), 1))));
+      return;
+    }
+
+  if (GET_CODE (src) == PLUS
+      && GET_CODE (XEXP (src, 0)) == REG
+      && CONST_INT_P (XEXP (src, 1))
+      && REGNO (XEXP (src, 0)) == STACK_POINTER_REGNUM
+      && REGNO (SET_DEST (set_insn)) == STACK_POINTER_REGNUM)
+    {
+      /* It is a stack update instruction which can be removed.  */
+      if (inside_seq)
+        {
+          PATTERN (insn) = gen_nop ();
+          INSN_CODE (insn) = CODE_FOR_nop;
+        }
+      else
+        delete_insn (insn);
+    }
+}
+
+/* Entry function for the frame header optimization.  */
+
+static void
+mips_rest_of_frame_header_opt (void)
+{
+  rtx insn;
+  bool skip_stack_frame_alloc;
+  struct mips_frame_info *frame = &cfun->machine->frame;
+
+  cfun->machine->uses_frame_header_p = mips_cfun_use_frame_header_p ();
+  skip_stack_frame_alloc = mips_skip_stack_frame_alloc ();
+
+  /* Check if it is needed to recalculate stack frame info.  */
+  if (skip_stack_frame_alloc)
+    mips_compute_frame_info (true, frame);
+
+  if ((skip_stack_frame_alloc && frame->total_size == 0)
+      || (!skip_stack_frame_alloc && !cfun->machine->uses_frame_header_p
+	  && !cfun->stdarg))
+    {
+      /* Function does not use its incoming frame header.  */
+
+      struct mips_frame_header_usage tmp_element;
+      struct mips_frame_header_usage *element;
+      void **slot;
+
+      if (!frame_header_usage_htab)
+	frame_header_usage_htab
+	  = htab_create_ggc (128, frame_header_usage_htab_hash,
+			     frame_header_usage_htab_eq, NULL);
+
+      tmp_element.fndecl = current_function_decl;
+      slot = htab_find_slot (frame_header_usage_htab, &tmp_element, INSERT);
+      if (*slot == HTAB_EMPTY_ENTRY)
+	{
+	  element = ggc_alloc_mips_frame_header_usage ();
+	  memset (element, 0, sizeof (struct mips_frame_header_usage));
+	  element->fndecl = current_function_decl;
+	  element->frame_header_unused = true;
+	  *slot = element;
+	}
+    }
+
+  if (skip_stack_frame_alloc)
+    {
+      if (dump_file && cfun->machine->initial_total_size > frame->total_size)
+	fprintf (dump_file, "Frame size reduced by frame header optimization"
+		 " from %lld to %lld.\n", cfun->machine->initial_total_size,
+		 frame->total_size);
+
+      /* Update instructions.  */
+      for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))
+	mips_frame_header_update_insn (insn, false);
+    }
+}
 
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
@@ -16453,6 +18509,8 @@
 #define TARGET_ASM_SELECT_RTX_SECTION mips_select_rtx_section
 #undef TARGET_ASM_FUNCTION_RODATA_SECTION
 #define TARGET_ASM_FUNCTION_RODATA_SECTION mips_function_rodata_section
+#undef TARGET_ASM_INIT_SECTIONS
+#define TARGET_ASM_INIT_SECTIONS mips_asm_init_sections
 
 #undef TARGET_SCHED_INIT
 #define TARGET_SCHED_INIT mips_sched_init
@@ -16612,6 +18670,9 @@
 #undef TARGET_EXTRA_LIVE_ON_ENTRY
 #define TARGET_EXTRA_LIVE_ON_ENTRY mips_extra_live_on_entry
 
+#undef TARGET_ALIGN_INSNS
+#define TARGET_ALIGN_INSNS mips_align_insns
+
 #undef TARGET_USE_BLOCKS_FOR_CONSTANT_P
 #define TARGET_USE_BLOCKS_FOR_CONSTANT_P mips_use_blocks_for_constant_p
 #undef TARGET_USE_ANCHORS_FOR_SYMBOL_P
@@ -16654,6 +18715,12 @@
 #undef TARGET_SHIFT_TRUNCATION_MASK
 #define TARGET_SHIFT_TRUNCATION_MASK mips_shift_truncation_mask
 
+#undef TARGET_PREPARE_PCH_SAVE
+#define TARGET_PREPARE_PCH_SAVE mips_prepare_pch_save
+
+#undef TARGET_UNSPEC_MAY_TRAP_P
+#define TARGET_UNSPEC_MAY_TRAP_P mips_unspec_may_trap_p
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-mips.h"
diff -ru ./gcc/config/mips/mips-dsp.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-dsp.md
--- ./gcc/config/mips/mips-dsp.md	2014-06-06 11:50:16.167598625 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-dsp.md	2012-03-29 18:03:15.000000000 +1000
@@ -134,7 +134,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ))])]
   "ISA_HAS_DSP"
   "add<DSPV:dspfmt1>.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_add<DSP:dspfmt1>_s_<DSP:dspfmt2>"
@@ -147,7 +147,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ_S))])]
   "ISA_HAS_DSP"
   "add<DSP:dspfmt1>_s.<DSP:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; SUBQ*
@@ -160,7 +160,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ))])]
   "ISA_HAS_DSP"
   "sub<DSPV:dspfmt1>.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_sub<DSP:dspfmt1>_s_<DSP:dspfmt2>"
@@ -173,7 +173,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ_S))])]
   "ISA_HAS_DSP"
   "sub<DSP:dspfmt1>_s.<DSP:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; ADDSC
@@ -187,7 +187,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDSC))])]
   "ISA_HAS_DSP"
   "addsc\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; ADDWC
@@ -202,7 +202,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDWC))])]
   "ISA_HAS_DSP"
   "addwc\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; MODSUB
@@ -213,7 +213,7 @@
 		   UNSPEC_MODSUB))]
   "ISA_HAS_DSP"
   "modsub\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; RADDU*
@@ -223,7 +223,7 @@
 		   UNSPEC_RADDU_W_QB))]
   "ISA_HAS_DSP"
   "raddu.w.qb\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; ABSQ*
@@ -236,7 +236,7 @@
 	  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S))])]
   "ISA_HAS_DSP"
   "absq_s.<DSPQ:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; PRECRQ*
@@ -247,7 +247,7 @@
 		     UNSPEC_PRECRQ_QB_PH))]
   "ISA_HAS_DSP"
   "precrq.qb.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precrq_ph_w"
@@ -257,7 +257,7 @@
 		     UNSPEC_PRECRQ_PH_W))]
   "ISA_HAS_DSP"
   "precrq.ph.w\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precrq_rs_ph_w"
@@ -271,7 +271,7 @@
 			UNSPEC_PRECRQ_RS_PH_W))])]
   "ISA_HAS_DSP"
   "precrq_rs.ph.w\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECRQU*
@@ -286,7 +286,7 @@
 			UNSPEC_PRECRQU_S_QB_PH))])]
   "ISA_HAS_DSP"
   "precrqu_s.qb.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; PRECEQ*
@@ -296,7 +296,7 @@
 		   UNSPEC_PRECEQ_W_PHL))]
   "ISA_HAS_DSP"
   "preceq.w.phl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceq_w_phr"
@@ -305,7 +305,7 @@
 		   UNSPEC_PRECEQ_W_PHR))]
   "ISA_HAS_DSP"
   "preceq.w.phr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECEQU*
@@ -315,7 +315,7 @@
 		     UNSPEC_PRECEQU_PH_QBL))]
   "ISA_HAS_DSP"
   "precequ.ph.qbl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbr"
@@ -324,7 +324,7 @@
 		     UNSPEC_PRECEQU_PH_QBR))]
   "ISA_HAS_DSP"
   "precequ.ph.qbr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbla"
@@ -333,7 +333,7 @@
 		     UNSPEC_PRECEQU_PH_QBLA))]
   "ISA_HAS_DSP"
   "precequ.ph.qbla\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precequ_ph_qbra"
@@ -342,7 +342,7 @@
 		     UNSPEC_PRECEQU_PH_QBRA))]
   "ISA_HAS_DSP"
   "precequ.ph.qbra\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PRECEU*
@@ -352,7 +352,7 @@
 		     UNSPEC_PRECEU_PH_QBL))]
   "ISA_HAS_DSP"
   "preceu.ph.qbl\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbr"
@@ -361,7 +361,7 @@
 		     UNSPEC_PRECEU_PH_QBR))]
   "ISA_HAS_DSP"
   "preceu.ph.qbr\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbla"
@@ -370,7 +370,7 @@
 		     UNSPEC_PRECEU_PH_QBLA))]
   "ISA_HAS_DSP"
   "preceu.ph.qbla\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_preceu_ph_qbra"
@@ -379,7 +379,7 @@
 		     UNSPEC_PRECEU_PH_QBRA))]
   "ISA_HAS_DSP"
   "preceu.ph.qbra\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-2. MIPS DSP ASE Instructions: Shift
@@ -403,7 +403,7 @@
     }
   return "shllv.<DSPV:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shll_s_<DSPQ:dspfmt2>"
@@ -425,7 +425,7 @@
     }
   return "shllv_s.<DSPQ:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 ;; SHRL*
@@ -444,7 +444,7 @@
     }
   return "shrlv.qb\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; SHRA*
@@ -463,7 +463,7 @@
     }
   return "shrav.ph\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shra_r_<DSPQ:dspfmt2>"
@@ -482,7 +482,7 @@
     }
   return "shrav_r.<DSPQ:dspfmt2>\t%0,%1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-3. MIPS DSP ASE Instructions: Multiply
@@ -568,7 +568,7 @@
 		   UNSPEC_DPAU_H_QBL))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpau.h.qbl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpau_h_qbr"
@@ -579,7 +579,7 @@
 		   UNSPEC_DPAU_H_QBR))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpau.h.qbr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPSU*
@@ -591,7 +591,7 @@
 		   UNSPEC_DPSU_H_QBL))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsu.h.qbl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsu_h_qbr"
@@ -602,7 +602,7 @@
 		   UNSPEC_DPSU_H_QBR))]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsu.h.qbr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPAQ*
@@ -618,7 +618,7 @@
 			UNSPEC_DPAQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpaq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPSQ*
@@ -634,7 +634,7 @@
 			UNSPEC_DPSQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; MULSAQ*
@@ -650,7 +650,7 @@
 			UNSPEC_MULSAQ_S_W_PH))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "mulsaq_s.w.ph\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; DPAQ*
@@ -666,7 +666,7 @@
 			UNSPEC_DPAQ_SA_L_W))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpaq_sa.l.w\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; DPSQ*
@@ -682,7 +682,7 @@
 			UNSPEC_DPSQ_SA_L_W))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "dpsq_sa.l.w\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; MAQ*
@@ -698,7 +698,7 @@
 			UNSPEC_MAQ_S_W_PHL))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_s.w.phl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_maq_s_w_phr"
@@ -713,7 +713,7 @@
 			UNSPEC_MAQ_S_W_PHR))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_s.w.phr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 ;; MAQ_SA*
@@ -729,7 +729,7 @@
 			UNSPEC_MAQ_SA_W_PHL))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_sa.w.phl\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_maq_sa_w_phr"
@@ -744,7 +744,7 @@
 			UNSPEC_MAQ_SA_W_PHR))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "maq_sa.w.phr\t%q0,%2,%3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-4. MIPS DSP ASE Instructions: General Bit/Manipulation
@@ -755,7 +755,7 @@
 		   UNSPEC_BITREV))]
   "ISA_HAS_DSP"
   "bitrev\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; INSV
@@ -768,7 +768,7 @@
 		   UNSPEC_INSV))]
   "ISA_HAS_DSP"
   "insv\t%0,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; REPL*
@@ -786,7 +786,7 @@
     }
   return "replv.qb\t%0,%1";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_repl_ph"
@@ -797,7 +797,7 @@
   "@
    repl.ph\t%0,%1
    replv.ph\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-5. MIPS DSP ASE Instructions: Compare-Pick
@@ -810,7 +810,7 @@
 		      UNSPEC_CMP_EQ))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.eq.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmp<DSPV:dspfmt1_1>_lt_<DSPV:dspfmt2>"
@@ -821,7 +821,7 @@
 		      UNSPEC_CMP_LT))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.lt.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmp<DSPV:dspfmt1_1>_le_<DSPV:dspfmt2>"
@@ -832,7 +832,7 @@
 		      UNSPEC_CMP_LE))]
   "ISA_HAS_DSP"
   "cmp<DSPV:dspfmt1_1>.le.<DSPV:dspfmt2>\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_eq_qb"
@@ -842,7 +842,7 @@
 		   UNSPEC_CMPGU_EQ_QB))]
   "ISA_HAS_DSP"
   "cmpgu.eq.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_lt_qb"
@@ -852,7 +852,7 @@
 		   UNSPEC_CMPGU_LT_QB))]
   "ISA_HAS_DSP"
   "cmpgu.lt.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgu_le_qb"
@@ -862,7 +862,7 @@
 		   UNSPEC_CMPGU_LE_QB))]
   "ISA_HAS_DSP"
   "cmpgu.le.qb\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PICK*
@@ -874,7 +874,7 @@
 		     UNSPEC_PICK))]
   "ISA_HAS_DSP"
   "pick.<DSPV:dspfmt2>\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; PACKRL*
@@ -885,7 +885,7 @@
 		     UNSPEC_PACKRL_PH))]
   "ISA_HAS_DSP"
   "packrl.ph\t%0,%1,%2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-6. MIPS DSP ASE Instructions: Accumulator and DSPControl Access
@@ -908,7 +908,7 @@
     }
   return "extrv.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extr_r_w"
@@ -929,7 +929,7 @@
     }
   return "extrv_r.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extr_rs_w"
@@ -950,7 +950,7 @@
     }
   return "extrv_rs.w\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; EXTR*_S.H
@@ -972,7 +972,7 @@
     }
   return "extrv_s.h\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; EXTP*
@@ -995,7 +995,7 @@
     }
   return "extpv\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_extpdp"
@@ -1020,7 +1020,7 @@
     }
   return "extpdpv\t%0,%q1,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accext")
    (set_attr "mode"	"SI")])
 
 ;; SHILO*
@@ -1039,7 +1039,7 @@
     }
   return "shilov\t%q0,%2";
 }
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accmod")
    (set_attr "mode"	"SI")])
 
 ;; MTHLIP*
@@ -1055,7 +1055,7 @@
 			 (reg:CCDSP CCDSP_PO_REGNUM)] UNSPEC_MTHLIP))])]
   "ISA_HAS_DSP && !TARGET_64BIT"
   "mthlip\t%2,%q0"
-  [(set_attr "type"	"mfhilo")
+  [(set_attr "type"	"accmod")
    (set_attr "mode"	"SI")])
 
 ;; WRDSP
@@ -1077,7 +1077,7 @@
 	  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))])]
   "ISA_HAS_DSP"
   "wrdsp\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; RDDSP
@@ -1093,7 +1093,7 @@
 		   UNSPEC_RDDSP))]
   "ISA_HAS_DSP"
   "rddsp\t%0,%1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 ;; Table 2-7. MIPS DSP ASE Instructions: Indexed-Load
diff -ru ./gcc/config/mips/mips-dspr2.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-dspr2.md
--- ./gcc/config/mips/mips-dspr2.md	2014-06-06 11:50:16.167598625 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-dspr2.md	2012-03-29 18:03:15.000000000 +1000
@@ -79,7 +79,7 @@
 	  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S_QB))])]
   "ISA_HAS_DSPR2"
   "absq_s.qb\t%0,%z1"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addu_ph"
@@ -91,7 +91,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDU_PH))])]
   "ISA_HAS_DSPR2"
   "addu.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addu_s_ph"
@@ -104,7 +104,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDU_S_PH))])]
   "ISA_HAS_DSPR2"
   "addu_s.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_adduh_qb"
@@ -114,7 +114,7 @@
 		     UNSPEC_ADDUH_QB))]
   "ISA_HAS_DSPR2"
   "adduh.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_adduh_r_qb"
@@ -124,7 +124,7 @@
 		     UNSPEC_ADDUH_R_QB))]
   "ISA_HAS_DSPR2"
   "adduh_r.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_append"
@@ -139,7 +139,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "append\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_balign"
@@ -154,7 +154,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 3);
   return "balign\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_eq_qb"
@@ -169,7 +169,7 @@
 			UNSPEC_CMPGDU_EQ_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.eq.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_lt_qb"
@@ -184,7 +184,7 @@
 			UNSPEC_CMPGDU_LT_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.lt.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_cmpgdu_le_qb"
@@ -199,7 +199,7 @@
 			UNSPEC_CMPGDU_LE_QB))])]
   "ISA_HAS_DSPR2"
   "cmpgdu.le.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpa_w_ph"
@@ -210,7 +210,7 @@
 		   UNSPEC_DPA_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dps_w_ph"
@@ -221,7 +221,7 @@
 		   UNSPEC_DPS_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dps.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mulv2hi3"
@@ -301,7 +301,7 @@
 		   UNSPEC_MULSA_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "mulsa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_qb_ph"
@@ -311,7 +311,7 @@
 		     UNSPEC_PRECR_QB_PH))]
   "ISA_HAS_DSPR2"
   "precr.qb.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_sra_ph_w"
@@ -326,7 +326,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "precr_sra.ph.w\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_precr_sra_r_ph_w"
@@ -341,7 +341,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "precr_sra_r.ph.w\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_prepend"
@@ -356,7 +356,7 @@
     operands[2] = GEN_INT (INTVAL (operands[2]) & 31);
   return "prepend\t%0,%z2,%3";
 }
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shra_qb"
@@ -374,7 +374,7 @@
     }
   return "shrav.qb\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 
@@ -393,7 +393,7 @@
     }
   return "shrav_r.qb\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_shrl_ph"
@@ -411,7 +411,7 @@
     }
   return "shrlv.ph\t%0,%z1,%2";
 }
-  [(set_attr "type"	"shift")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subu_ph"
@@ -424,7 +424,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBU_PH))])]
   "ISA_HAS_DSPR2"
   "subu.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subu_s_ph"
@@ -437,7 +437,7 @@
 	  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBU_S_PH))])]
   "ISA_HAS_DSPR2"
   "subu_s.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalusat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subuh_qb"
@@ -447,7 +447,7 @@
 		     UNSPEC_SUBUH_QB))]
   "ISA_HAS_DSPR2"
   "subuh.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subuh_r_qb"
@@ -457,7 +457,7 @@
 		     UNSPEC_SUBUH_R_QB))]
   "ISA_HAS_DSPR2"
   "subuh_r.qb\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_ph"
@@ -467,7 +467,7 @@
 		     UNSPEC_ADDQH_PH))]
   "ISA_HAS_DSPR2"
   "addqh.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_r_ph"
@@ -477,7 +477,7 @@
 		     UNSPEC_ADDQH_R_PH))]
   "ISA_HAS_DSPR2"
   "addqh_r.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_w"
@@ -487,7 +487,7 @@
 		   UNSPEC_ADDQH_W))]
   "ISA_HAS_DSPR2"
   "addqh.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_addqh_r_w"
@@ -497,7 +497,7 @@
 		   UNSPEC_ADDQH_R_W))]
   "ISA_HAS_DSPR2"
   "addqh_r.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_ph"
@@ -507,7 +507,7 @@
 		     UNSPEC_SUBQH_PH))]
   "ISA_HAS_DSPR2"
   "subqh.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_r_ph"
@@ -517,7 +517,7 @@
 		     UNSPEC_SUBQH_R_PH))]
   "ISA_HAS_DSPR2"
   "subqh_r.ph\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_w"
@@ -527,7 +527,7 @@
 		   UNSPEC_SUBQH_W))]
   "ISA_HAS_DSPR2"
   "subqh.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_subqh_r_w"
@@ -537,7 +537,7 @@
 		   UNSPEC_SUBQH_R_W))]
   "ISA_HAS_DSPR2"
   "subqh_r.w\t%0,%z1,%z2"
-  [(set_attr "type"	"arith")
+  [(set_attr "type"	"dspalu")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpax_w_ph"
@@ -548,7 +548,7 @@
 		   UNSPEC_DPAX_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpax.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsx_w_ph"
@@ -559,7 +559,7 @@
 		   UNSPEC_DPSX_W_PH))]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsx.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpaqx_s_w_ph"
@@ -574,7 +574,7 @@
 			UNSPEC_DPAQX_S_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpaqx_s.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpaqx_sa_w_ph"
@@ -589,7 +589,7 @@
 			UNSPEC_DPAQX_SA_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpaqx_sa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsqx_s_w_ph"
@@ -604,7 +604,7 @@
 			UNSPEC_DPSQX_S_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsqx_s.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmac")
    (set_attr "mode"	"SI")])
 
 (define_insn "mips_dpsqx_sa_w_ph"
@@ -619,5 +619,43 @@
 			UNSPEC_DPSQX_SA_W_PH))])]
   "ISA_HAS_DSPR2 && !TARGET_64BIT"
   "dpsqx_sa.w.ph\t%q0,%z2,%z3"
-  [(set_attr "type"	"imadd")
+  [(set_attr "type"	"dspmacsat")
+   (set_attr "mode"	"SI")])
+
+;; Convert  mtlo $ac[1-3],$0  =>  mult $ac[1-3],$0,$0
+;;          mthi $ac[1-3],$0
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(const_int 0))
+   (set (match_operand:SI 1 "register_operand" "")
+	(const_int 0))]
+  "ISA_HAS_DSPR2
+   && !TARGET_MIPS16
+   && !TARGET_64BIT
+   && (((true_regnum (operands[0]) == AC1LO_REGNUM
+		     && true_regnum (operands[1]) == AC1HI_REGNUM)
+	|| (true_regnum (operands[0]) == AC1HI_REGNUM
+			&& true_regnum (operands[1]) == AC1LO_REGNUM))
+       || ((true_regnum (operands[0]) == AC2LO_REGNUM
+			&& true_regnum (operands[1]) == AC2HI_REGNUM)
+	   || (true_regnum (operands[0]) == AC2HI_REGNUM
+			&& true_regnum (operands[1]) == AC2LO_REGNUM))
+       || ((true_regnum (operands[0]) == AC3LO_REGNUM
+		     && true_regnum (operands[1]) == AC3HI_REGNUM)
+	   || (true_regnum (operands[0]) == AC3HI_REGNUM
+			   && true_regnum (operands[1]) == AC3LO_REGNUM)))"
+  [(parallel [(set (match_dup 0) (const_int 0))
+	      (set (match_dup 1) (const_int 0))])]
+)
+
+(define_insn "*mips_acc_init"
+  [(parallel [(set (match_operand:SI 0 "register_operand" "=a")
+	      (const_int 0))
+	      (set (match_operand:SI 1 "register_operand" "=a")
+	      (const_int 0))])]
+  "ISA_HAS_DSPR2
+   && !TARGET_MIPS16
+   && !TARGET_64BIT"
+  "mult\t%q0,$0,$0\t\t# Clear ACC HI/LO"
+  [(set_attr "type"	"imul")
    (set_attr "mode"	"SI")])
diff -ru ./gcc/config/mips/mips-ftypes.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-ftypes.def
--- ./gcc/config/mips/mips-ftypes.def	2014-06-06 11:50:16.167598625 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-ftypes.def	2012-03-29 18:03:15.000000000 +1000
@@ -124,3 +124,10 @@
 DEF_MIPS_FTYPE (2, (VOID, SI, SI))
 DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))
 DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))
+
+DEF_MIPS_FTYPE (2, (SI, VPOINTER, SI))
+DEF_MIPS_FTYPE (2, (DI, VPOINTER, DI))
+DEF_MIPS_FTYPE (3, (SI, VPOINTER, SI, SI))
+DEF_MIPS_FTYPE (3, (DI, VPOINTER, DI, DI))
+
+DEF_MIPS_FTYPE (0, (POINTER))
diff -ru ./gcc/config/mips/mips.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.h
--- ./gcc/config/mips/mips.h	2014-06-06 11:50:16.215598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.h	2012-03-29 18:03:15.000000000 +1000
@@ -231,6 +231,8 @@
 #define TARGET_SB1                  (mips_arch == PROCESSOR_SB1		\
 				     || mips_arch == PROCESSOR_SB1A)
 #define TARGET_SR71K                (mips_arch == PROCESSOR_SR71000)
+#define TARGET_XLP                  (mips_arch == PROCESSOR_XLP)
+#define TARGET_XLR                  (mips_arch == PROCESSOR_XLR)
 
 /* Scheduling target defines.  */
 #define TUNE_20KC		    (mips_tune == PROCESSOR_20KC)
@@ -258,6 +260,7 @@
 #define TUNE_OCTEON		    (mips_tune == PROCESSOR_OCTEON)
 #define TUNE_SB1                    (mips_tune == PROCESSOR_SB1		\
 				     || mips_tune == PROCESSOR_SB1A)
+#define TUNE_XLP                    (mips_tune == PROCESSOR_XLP)
 
 /* Whether vector modes and intrinsics for ST Microelectronics
    Loongson-2E/2F processors should be enabled.  In o32 pairs of
@@ -323,6 +326,9 @@
 /* IRIX specific stuff.  */
 #define TARGET_IRIX6	   0
 
+/* SDE specific stuff.  */
+#define TARGET_MIPS_SDE    0
+
 /* Define preprocessor macros for the -march and -mtune options.
    PREFIX is either _MIPS_ARCH or _MIPS_TUNE, INFO is the selected
    processor.  If INFO's canonical name is "foo", define PREFIX to
@@ -397,6 +403,12 @@
       if (TARGET_SMARTMIPS)						\
 	builtin_define ("__mips_smartmips");				\
 									\
+      if (mips_base_micromips)						\
+	builtin_define ("__mips_micromips");				\
+									\
+      if (TARGET_MCU)							\
+	builtin_define ("__mips_mcu");					\
+									\
       if (TARGET_DSP)							\
 	{								\
 	  builtin_define ("__mips_dsp");				\
@@ -556,6 +568,9 @@
 									\
       if (TARGET_CACHE_BUILTIN)						\
 	builtin_define ("__GCC_HAVE_BUILTIN_MIPS_CACHE");		\
+									\
+      if (TARGET_COMPACT_EH)						\
+	builtin_define ("__GNU_COMPACT_EH__");				\
     }									\
   while (0)
 
@@ -717,10 +732,10 @@
        |march=r10000|march=r12000|march=r14000|march=r16000:-mips4} \
      %{march=mips32|march=4kc|march=4km|march=4kp|march=4ksc:-mips32} \
      %{march=mips32r2|march=m4k|march=4ke*|march=4ksd|march=24k* \
-       |march=34k*|march=74k*|march=1004k*: -mips32r2} \
+       |march=34k*|march=74k*|march=m14k*|march=1004k*: -mips32r2} \
      %{march=mips64|march=5k*|march=20k*|march=sb1*|march=sr71000 \
        |march=xlr|march=loongson3a: -mips64} \
-     %{march=mips64r2|march=octeon: -mips64r2} \
+     %{march=mips64r2|march=octeon|march=xlp: -mips64r2} \
      %{!march=*: -" MULTILIB_ISA_DEFAULT "}}"
 
 /* A spec that infers a -mhard-float or -msoft-float setting from an
@@ -730,8 +745,8 @@
 #define MIPS_ARCH_FLOAT_SPEC \
   "%{mhard-float|msoft-float|march=mips*:; \
      march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec \
-     |march=34kc|march=74kc|march=1004kc|march=5kc \
-     |march=octeon|march=xlr: -msoft-float;		  \
+     |march=34kc|march=34kn|march=74kc|march=1004kc|march=5kc \
+     |march=m14k*|march=octeon|march=xlr: -msoft-float;	\
      march=*: -mhard-float}"
 
 /* A spec condition that matches 32-bit options.  It only works if
@@ -778,8 +793,8 @@
 /* A spec that infers the -mdsp setting from an -march argument.  */
 #define BASE_DRIVER_SELF_SPECS \
   "%{!mno-dsp: \
-     %{march=24ke*|march=34k*|march=1004k*: -mdsp} \
-     %{march=74k*:%{!mno-dspr2: -mdspr2 -mdsp}}}"
+     %{march=24ke*|march=34kc*|march=34kf*|march=34kx*|march=1004k*: -mdsp} \
+     %{march=74k*|march=m14ke*: %{!mno-dspr2: -mdspr2 -mdsp}}}"
 
 #define DRIVER_SELF_SPECS BASE_DRIVER_SELF_SPECS
 
@@ -864,7 +879,7 @@
    FP madd and msub instructions, and the FP recip and recip sqrt
    instructions.  */
 #define ISA_HAS_FP4		((ISA_MIPS4				\
-				  || (ISA_MIPS32R2 && TARGET_FLOAT64)   \
+				  || ISA_MIPS32R2			\
 				  || ISA_MIPS64				\
 				  || ISA_MIPS64R2)			\
 				 && !TARGET_MIPS16)
@@ -894,18 +909,12 @@
 
 /* ISA has floating-point nmadd and nmsub instructions
    'd = -((a * b) [+-] c)'.  */
-#define ISA_HAS_NMADD4_NMSUB4(MODE)					\
-				((ISA_MIPS4				\
-				  || (ISA_MIPS32R2 && (MODE) == V2SFmode) \
-				  || ISA_MIPS64				\
-				  || ISA_MIPS64R2)			\
-				 && (!TARGET_MIPS5400 || TARGET_MAD)	\
-				 && !TARGET_MIPS16)
+#define ISA_HAS_NMADD4_NMSUB4	(ISA_HAS_FP4				\
+				 && (!TARGET_MIPS5400 || TARGET_MAD))
 
 /* ISA has floating-point nmadd and nmsub instructions
    'c = -((a * b) [+-] c)'.  */
-#define ISA_HAS_NMADD3_NMSUB3(MODE)					\
-                                TARGET_LOONGSON_2EF
+#define ISA_HAS_NMADD3_NMSUB3	TARGET_LOONGSON_2EF
 
 /* ISA has count leading zeroes/ones instruction (not implemented).  */
 #define ISA_HAS_CLZ_CLO		((ISA_MIPS32				\
@@ -998,7 +1007,8 @@
 				     || ISA_MIPS64R2))
 
 /* ISA has lwxs instruction (load w/scaled index address.  */
-#define ISA_HAS_LWXS		(TARGET_SMARTMIPS && !TARGET_MIPS16)
+#define ISA_HAS_LWXS		((TARGET_SMARTMIPS || TARGET_MICROMIPS) \
+				 && !TARGET_MIPS16)
 
 /* The DSP ASE is available.  */
 #define ISA_HAS_DSP		(TARGET_DSP && !TARGET_MIPS16)
@@ -1061,6 +1071,9 @@
    ? TARGET_LLSC && !TARGET_MIPS16	\
    : ISA_HAS_LL_SC)
 
+#define GENERATE_SWAP (TARGET_XLP || TARGET_XLR)
+#define GENERATE_LDADD (TARGET_XLP || TARGET_XLR)
+
 /* ISA includes the baddu instruction.  */
 #define ISA_HAS_BADDU		(TARGET_OCTEON && !TARGET_MIPS16)
 
@@ -1084,6 +1097,11 @@
 
 /* The CACHE instruction is available.  */
 #define ISA_HAS_CACHE (TARGET_CACHE_BUILTIN && !TARGET_MIPS16)
+ 
+/* ISA has single-instruction unaligned load/store support.  */
+#define ISA_HAS_UL_US           (TARGET_OCTEON \
+                                 && TARGET_OCTEON_UNALIGNED \
+                                 && !TARGET_MIPS16)
 
 /* Tell collect what flags to pass to nm.  */
 #ifndef NM_FLAGS
@@ -1127,6 +1145,8 @@
 %{G*} %(endian_spec) %{mips1} %{mips2} %{mips3} %{mips4} \
 %{mips32*} %{mips64*} \
 %{mips16} %{mno-mips16:-no-mips16} \
+%{mmicromips} %{mno-micromips} \
+%{mmcu} %{mno-mcu} \
 %{mips3d} %{mno-mips3d:-no-mips3d} \
 %{mdmx} %{mno-mdmx:-no-mdmx} \
 %{mdsp} %{mno-dsp} \
@@ -1134,6 +1154,7 @@
 %{msmartmips} %{mno-smartmips} \
 %{mmt} %{mno-mt} \
 %{mfix-vr4120} %{mfix-vr4130} \
+%{mfix-24k} \
 %(subtarget_asm_optimizing_spec) \
 %(subtarget_asm_debugging_spec) \
 %{mabi=*} %{!mabi=*: %(asm_abi_default_spec)} \
@@ -1142,6 +1163,7 @@
 %{mshared} %{mno-shared} \
 %{msym32} %{mno-sym32} \
 %{mtune=*} \
+%{mocteon-useun} %{mno-octeon-useun} \
 %(subtarget_asm_spec)"
 
 /* Extra switches sometimes passed to the linker.  */
@@ -1651,6 +1673,18 @@
 #define AT_REGNUM	(GP_REG_FIRST + 1)
 #define HI_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST : MD_REG_FIRST + 1)
 #define LO_REGNUM	(TARGET_BIG_ENDIAN ? MD_REG_FIRST + 1 : MD_REG_FIRST)
+#define AC1HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST : DSP_ACC_REG_FIRST + 1)
+#define AC1LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 1 : DSP_ACC_REG_FIRST)
+#define AC2HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 2 : DSP_ACC_REG_FIRST + 3)
+#define AC2LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 3 : DSP_ACC_REG_FIRST + 2)
+#define AC3HI_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 4 : DSP_ACC_REG_FIRST + 5)
+#define AC3LO_REGNUM	(TARGET_BIG_ENDIAN \
+			 ? DSP_ACC_REG_FIRST + 5 : DSP_ACC_REG_FIRST + 4)
 
 /* A few bitfield locations for the coprocessor registers.  */
 /* Request Interrupt Priority Level is from bit 10 to bit 15 of
@@ -1672,6 +1706,8 @@
   ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)
 #define M16_REG_P(REGNO) \
   (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 16 || (REGNO) == 17)
+#define M16STORE_REG_P(REGNO) \
+  (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 0 || (REGNO) == 17)
 #define FP_REG_P(REGNO)  \
   ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)
 #define MD_REG_P(REGNO) \
@@ -1982,13 +2018,6 @@
   182,183,184,185,186,187						\
 }
 
-/* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order
-   to be rearranged based on a particular function.  On the mips16, we
-   want to allocate $24 (T_REG) before other registers for
-   instructions for which it is possible.  */
-
-#define ADJUST_REG_ALLOC_ORDER mips_order_regs_for_local_alloc ()
-
 /* True if VALUE is an unsigned 6-bit number.  */
 
 #define UIMM6_OPERAND(VALUE) \
@@ -2377,13 +2406,18 @@
 /* True if we're generating a form of MIPS16 code in which jump tables
    are stored in the text section and encoded as 16-bit PC-relative
    offsets.  This is only possible when general text loads are allowed,
-   since the table access itself will be an "lh" instruction.  */
-/* ??? 16-bit offsets can overflow in large functions.  */
+   since the table access itself will be an "lh" instruction.  If the
+   PC-relative offsets grow too large, 32-bit offsets are used instead.  */
 #define TARGET_MIPS16_SHORT_JUMP_TABLES TARGET_MIPS16_TEXT_LOADS
 
 #define JUMP_TABLES_IN_TEXT_SECTION TARGET_MIPS16_SHORT_JUMP_TABLES
 
-#define CASE_VECTOR_MODE (TARGET_MIPS16_SHORT_JUMP_TABLES ? HImode : ptr_mode)
+#define CASE_VECTOR_MODE ptr_mode
+
+/* Only use short offsets if their range will not overflow.  */
+#define CASE_VECTOR_SHORTEN_MODE(MIN, MAX, BODY) \
+  (TARGET_MIPS16_SHORT_JUMP_TABLES && ((MIN) >= -32768 && (MAX) < 32768) \
+   ? HImode : ptr_mode)
 
 #define CASE_VECTOR_PC_RELATIVE TARGET_MIPS16_SHORT_JUMP_TABLES
 
@@ -2481,18 +2515,46 @@
    all calls should use assembly macros.  Otherwise, all indirect
    calls should use "jr" or "jalr"; we will arrange to restore $gp
    afterwards if necessary.  Finally, we can only generate direct
-   calls for -mabicalls by temporarily switching to non-PIC mode.  */
+   calls for -mabicalls by temporarily switching to non-PIC mode.
+
+   For microMIPS jal(r), we try to generate jal(r)s when a 16-bit
+   instruction is in the delay slot of jal(r).  */
 #define MIPS_CALL(INSN, OPERANDS, TARGET_OPNO, SIZE_OPNO)	\
+  (TARGET_MICROMIPS						\
+   ? (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS			\
+      ? "%*" INSN "\t%" #TARGET_OPNO "%/"			\
+      : (REG_P (OPERANDS[TARGET_OPNO])				\
+         && mips_get_pic_call_symbol (OPERANDS, SIZE_OPNO))	\
+      ? ("%*.reloc\t1f,R_MIPS_JALR,%" #SIZE_OPNO "\n"		\
+         "1:\t" INSN "r%!\t%" #TARGET_OPNO "%/")		\
+      : REG_P (OPERANDS[TARGET_OPNO])				\
+      ? "%*" INSN "r%!\t%" #TARGET_OPNO "%/"			\
+      : (TARGET_JALS						\
+	 ? MIPS_ABSOLUTE_JUMP ("%*" INSN "%!\t%" #TARGET_OPNO "%/") \
+	 : MIPS_ABSOLUTE_JUMP ("%*" INSN "\t%" #TARGET_OPNO "%/"))) \
+  : (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS			\
+     ? "%*" INSN "\t%" #TARGET_OPNO "%/"			\
+     : (REG_P (OPERANDS[TARGET_OPNO])				\
+        && mips_get_pic_call_symbol (OPERANDS, SIZE_OPNO))	\
+     ? ("%*.reloc\t1f,R_MIPS_JALR,%" #SIZE_OPNO "\n"		\
+        "1:\t" INSN "r\t%" #TARGET_OPNO "%/")			\
+     : REG_P (OPERANDS[TARGET_OPNO])				\
+     ? "%*" INSN "r\t%" #TARGET_OPNO "%/"			\
+     : MIPS_ABSOLUTE_JUMP ("%*" INSN "\t%" #TARGET_OPNO "%/")))
+
+/* Similar to MIPS_CALL, but this is for MICROMIPS "j" to generate
+   "jrc" when nop is in the delay slot of "jr".  */
+#define MICROMIPS_J(OPERANDS, OPNO)				\
   (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS			\
-   ? "%*" INSN "\t%" #TARGET_OPNO "%/"				\
-   : (REG_P (OPERANDS[TARGET_OPNO])				\
-      && mips_get_pic_call_symbol (OPERANDS, SIZE_OPNO))	\
-   ? ("%*.reloc\t1f,R_MIPS_JALR,%" #SIZE_OPNO "\n"		\
-      "1:\t" INSN "r\t%" #TARGET_OPNO "%/")			\
-   : REG_P (OPERANDS[TARGET_OPNO])				\
-   ? "%*" INSN "r\t%" #TARGET_OPNO "%/"				\
-   : MIPS_ABSOLUTE_JUMP ("%*" INSN "\t%" #TARGET_OPNO "%/"))
-
+   ? "%*j\t%" #OPNO "%/"					\
+   : REG_P (OPERANDS[OPNO])					\
+   ? "%*jr%:\t%" #OPNO						\
+   : TARGET_ABICALLS && flag_pic				\
+   ? (".option\tpic0\n\t"					\
+      "%*j\t%" #OPNO "%/\n\t"					\
+      ".option\tpic2")						\
+   : "%*j\t%" #OPNO "%/")
+
 /* Control the assembler format that we output.  */
 
 /* Output to assembler file text saying following lines
@@ -2643,11 +2705,12 @@
 /* This is how to declare a function name.  The actual work of
    emitting the label is moved to function_prologue, so that we can
    get the line number correctly emitted before the .ent directive,
-   and after any .file directives.  Define as empty so that the function
-   is not declared before the .ent directive elsewhere.  */
+   and after any .file directives.  Define as mostly empty so that the
+   function is not declared before the .ent directive elsewhere.  */
 
 #undef ASM_DECLARE_FUNCTION_NAME
-#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)
+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \
+  mips_fixup_cfi_sections ();
 
 /* This is how to store into the string LABEL
    the symbol_ref name of an internal numbered label where
@@ -2699,8 +2762,14 @@
 #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)		\
 do {									\
   if (TARGET_MIPS16_SHORT_JUMP_TABLES)					\
-    fprintf (STREAM, "\t.half\t%sL%d-%sL%d\n",				\
-	     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);	\
+    {									\
+      if (GET_MODE (BODY) == HImode)					\
+	fprintf (STREAM, "\t.half\t%sL%d-%sL%d\n",			\
+		 LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);	\
+      else								\
+	fprintf (STREAM, "\t.word\t%sL%d-%sL%d\n",			\
+		 LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);	\
+    }									\
   else if (TARGET_GPWORD)						\
     fprintf (STREAM, "\t%s\t%sL%d\n",					\
 	     ptr_mode == DImode ? ".gpdword" : ".gpword",		\
@@ -2909,8 +2978,32 @@
 	jal " USER_LABEL_PREFIX #FUNC "\n\
 	" TEXT_SECTION_ASM_OP);
 #endif
+
+#else
+#if (defined _ABIO32 && _MIPS_SIM == _ABIO32)
+#ifdef __PIC__
+/* For MIPS16 PIC, construct the GP-value in $2 using PC-relative insns.  */
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+   asm (SECTION_OP "\n\
+	li $2,%hi(_gp_disp)\n\
+	addiu $3,$pc,%lo(_gp_disp)\n\
+	sll $2,16\n\
+	addu $2,$3\n\
+	lw $2,%got(" USER_LABEL_PREFIX #FUNC ")($2)\n\
+	addiu $2,%lo(" USER_LABEL_PREFIX #FUNC ")\n\
+	move $25,$2\n\
+	jalr $2\n\
+	" TEXT_SECTION_ASM_OP);
+#else
+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)	\
+   asm (SECTION_OP "\n\
+	jal " USER_LABEL_PREFIX #FUNC "\n\
+	" TEXT_SECTION_ASM_OP);
+#endif
 #endif
 
+#endif /* __mips16 */
+
 #ifndef HAVE_AS_TLS
 #define HAVE_AS_TLS 0
 #endif
@@ -2943,6 +3036,7 @@
 extern const struct mips_cpu_info *mips_arch_info;
 extern const struct mips_cpu_info *mips_tune_info;
 extern bool mips_base_mips16;
+extern bool mips_base_micromips;
 extern enum mips_code_readable_setting mips_code_readable;
 extern GTY(()) struct target_globals *mips16_globals;
 #endif
@@ -2976,9 +3070,49 @@
    versions of the linker know how to do this for indirect pointers,
    and for personality data.  We must fall back on using writable
    .eh_frame sections for shared libraries if the linker does not
-   support this feature.  */
+   support this feature.
+   
+   For compact EH frames we have a special relocation we can use.  */
+
 #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) \
-  (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_absptr)
+  (TARGET_COMPACT_EH \
+   ? ((GLOBAL) ? MIPS_EH_ENCODING : (DW_EH_PE_pcrel | DW_EH_PE_sdata4)) \
+   : (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_absptr))
+
+/* TType references have assembler support via .ehword.  */
+
+#define ASM_CFI_SPECIAL_ENCODING(ENC) (TARGET_COMPACT_EH \
+   && (ENC) == MIPS_EH_ENCODING)
+
+/* Handle special EH pointer encodings.  */
+
+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(FILE, ENCODING, SIZE, ADDR, DONE) \
+  do {									\
+    if ((SIZE) == 4 && (ENCODING) == MIPS_EH_ENCODING)			\
+      {									\
+        fputs ("\t.ehword\t", FILE);					\
+        assemble_name (FILE, XSTR (ADDR, 0));				\
+        goto DONE;							\
+      }									\
+  } while (0)
+
+#define MIPS_EH_ENCODING \
+  (DW_EH_PE_datarel | DW_EH_PE_sdata4 | DW_EH_PE_indirect)
+
+#define CRT_GET_RFIB_DATA(BASE)			\
+  {						\
+    extern char _gp[];				\
+    BASE = &_gp[0];				\
+  }
+
+/* Track branch candidates for resolution of MIPS16 long branches.  */
+typedef struct mips16_branch_info_t
+{
+  int uid;
+  int address;
+  int distance_to_dest;
+  int distance_from_src;
+} mips16_branch_info_t;
 
 /* For switching between MIPS16 and non-MIPS16 modes.  */
 #define SWITCHABLE_TARGET 1
diff -ru ./gcc/config/mips/mips.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.md
--- ./gcc/config/mips/mips.md	2014-06-06 11:50:16.227598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.md	2012-03-29 18:03:15.000000000 +1000
@@ -63,6 +63,7 @@
   sb1a
   sr71000
   xlr
+  xlp
 ])
 
 (define_c_enum "unspec" [
@@ -113,6 +114,10 @@
   UNSPEC_RDHWR
   UNSPEC_SYNCI
   UNSPEC_SYNC
+  UNSPEC_COMPARE_AND_SWAP_ACQ
+  UNSPEC_COMPARE_AND_SWAP_REL
+  UNSPEC_SWAP_ACQ
+  UNSPEC_SWAP_REL
 
   ;; Cache manipulation.
   UNSPEC_MIPS_CACHE
@@ -126,13 +131,20 @@
   UNSPEC_RDPGPR
   UNSPEC_COP0
 
+  ;; Octeon unaligned access.
+  UNSPEC_UNALIGNED_LOAD
+  UNSPEC_UNALIGNED_STORE
+
   ;; Used in a call expression in place of args_size.  It's present for PIC
   ;; indirect calls where it contains args_size and the function symbol.
   UNSPEC_CALL_ATTR
 ])
 
 (define_constants
-  [(TLS_GET_TP_REGNUM		3)
+  [(V0_REGNUM			2)
+   (TLS_GET_TP_REGNUM		3)
+   (MIPS16_T_REGNUM		24)
+   (PIC_JUMP_REGNUM		25)
    (RETURN_ADDR_REGNUM		31)
    (CPRESTORE_SLOT_REGNUM	76)
    (GOT_VERSION_REGNUM		79)
@@ -267,15 +279,23 @@
 ;; frsqrt       floating point reciprocal square root
 ;; frsqrt1      floating point reciprocal square root step1
 ;; frsqrt2      floating point reciprocal square root step2
+;; dspmac       DSP MAC instructions not saturating the accumulator
+;; dspmacsat    DSP MAC instructions that saturate the accumulator
+;; accext       DSP accumulator extract instructions
+;; accmod       DSP accumulator modify instructions
+;; dspalu       DSP ALU instructions not saturating the result
+;; dspalusat    DSP ALU instructions that saturate the result
 ;; multi	multiword sequence (or user asm statements)
 ;; nop		no operation
 ;; ghost	an instruction that produces no real code
+;; multimem	microMIPS multiword load and store
 (define_attr "type"
   "unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,
    prefetch,prefetchx,condmove,mtc,mfc,mthilo,mfhilo,const,arith,logical,
    shift,slt,signext,clz,pop,trap,imul,imul3,imul3nc,imadd,idiv,idiv3,move,
    fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,
-   frsqrt,frsqrt1,frsqrt2,multi,nop,ghost"
+   frsqrt,frsqrt1,frsqrt2,dspmac,dspmacsat,accext,accmod,dspalu,dspalusat,
+   multi,nop,ghost,multimem"
   (cond [(eq_attr "jal" "!unset") (const_string "call")
 	 (eq_attr "got" "load") (const_string "load")
 
@@ -343,13 +363,15 @@
 ;;       if (RELEASE_BARRIER == YES) sync
 ;;    1: OLDVAL = *MEM
 ;;       if ((OLDVAL & INCLUSIVE_MASK) != REQUIRED_OLDVAL) goto 2
+;;         CMP  = 0 [delay slot]
 ;;       $TMP1 = OLDVAL & EXCLUSIVE_MASK
 ;;       $TMP2 = INSN1 (OLDVAL, INSN1_OP2)
 ;;       $TMP3 = INSN2 ($TMP2, INCLUSIVE_MASK)
 ;;       $AT |= $TMP1 | $TMP3
 ;;       if (!commit (*MEM = $AT)) goto 1.
 ;;         if (INSN1 != MOVE && INSN1 != LI) NEWVAL = $TMP3 [delay slot]
-;;       sync
+;;       CMP  = 1
+;;       if (ACQUIRE_BARRIER == YES) sync
 ;;    2:
 ;;
 ;; where "$" values are temporaries and where the other values are
@@ -358,6 +380,7 @@
 ;; specified, the following values are used instead:
 ;;
 ;;    - OLDVAL: $AT
+;;    - CMP: NONE
 ;;    - NEWVAL: $AT
 ;;    - INCLUSIVE_MASK: -1
 ;;    - REQUIRED_OLDVAL: OLDVAL & INCLUSIVE_MASK
@@ -369,17 +392,31 @@
 ;; but the gen* programs don't yet support that.
 (define_attr "sync_mem" "none,0,1,2,3,4,5" (const_string "none"))
 (define_attr "sync_oldval" "none,0,1,2,3,4,5" (const_string "none"))
+(define_attr "sync_cmp" "none,0,1,2,3,4,5" (const_string "none"))
 (define_attr "sync_newval" "none,0,1,2,3,4,5" (const_string "none"))
 (define_attr "sync_inclusive_mask" "none,0,1,2,3,4,5" (const_string "none"))
 (define_attr "sync_exclusive_mask" "none,0,1,2,3,4,5" (const_string "none"))
 (define_attr "sync_required_oldval" "none,0,1,2,3,4,5" (const_string "none"))
 (define_attr "sync_insn1_op2" "none,0,1,2,3,4,5" (const_string "none"))
-(define_attr "sync_insn1" "move,li,addu,addiu,subu,and,andi,or,ori,xor,xori"
+(define_attr "sync_insn1" "move,li,addu,addiu,subu,and,andi,or,ori,xor,xori,neg"
   (const_string "move"))
 (define_attr "sync_insn2" "nop,and,xor,not"
   (const_string "nop"))
 (define_attr "sync_release_barrier" "yes,no"
   (const_string "yes"))
+(define_attr "sync_acquire_barrier" "yes,no"
+  (const_string "yes"))
+
+;; Atribute used by mips_output_atomic/mips_process_atomic.
+;; Note that they also use most of the sync loop attributes.
+(define_attr "sync_atomic_insn" "none,ldadd,swap"
+  (const_string "none"))
+
+;; Types for 16-bit microMIPS instructions.
+(define_attr "micromips_type"
+  "none,mfhi,logical_not,logical_and,logical_or,logical_xor,zero_extend,
+   add,sub,shift"
+  (const_string "none"))
 
 ;; Length of instruction in bytes.
 (define_attr "length" ""
@@ -445,6 +482,9 @@
 	  (eq_attr "got" "xgot_high")
 	  (const_int 8)
 
+	  (eq_attr "type" "multimem")
+	  (const_int 4)
+
 	  ;; In general, constant-pool loads are extended instructions.
 	  (eq_attr "move_type" "loadpool")
 	  (const_int 8)
@@ -479,7 +519,9 @@
 	  (eq_attr "move_type" "load,fpload")
 	  (symbol_ref "mips_load_store_insns (operands[1], insn) * 4")
 	  (eq_attr "move_type" "store,fpstore")
-	  (symbol_ref "mips_load_store_insns (operands[0], insn) * 4")
+	  (cond [(eq (symbol_ref "TARGET_FIX_24K") (const_int 0))
+	         (symbol_ref "mips_load_store_insns (operands[0], insn) * 4")]
+	         (symbol_ref "mips_load_store_insns (operands[0], insn) * 4 + 4"))
 
 	  ;; In the worst case, a call macro will take 8 instructions:
 	  ;;
@@ -913,6 +955,7 @@
 (include "sb1.md")
 (include "sr71k.md")
 (include "xlr.md")
+(include "xlp.md")
 (include "generic.md")
 
 ;;
@@ -1214,6 +1257,7 @@
   ""
   "<d>subu\t%0,%1,%2"
   [(set_attr "alu_type" "sub")
+   (set_attr "micromips_type" "sub")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*subsi3_extended"
@@ -2130,7 +2174,7 @@
 		   (mult:ANYF (match_operand:ANYF 1 "register_operand" "f")
 			      (match_operand:ANYF 2 "register_operand" "f"))
 		   (match_operand:ANYF 3 "register_operand" "f"))))]
-  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
+  "ISA_HAS_NMADD4_NMSUB4
    && TARGET_FUSED_MADD
    && HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2144,7 +2188,7 @@
 		   (mult:ANYF (match_operand:ANYF 1 "register_operand" "f")
 			      (match_operand:ANYF 2 "register_operand" "f"))
 		   (match_operand:ANYF 3 "register_operand" "0"))))]
-  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
+  "ISA_HAS_NMADD3_NMSUB3
    && TARGET_FUSED_MADD
    && HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2158,7 +2202,7 @@
 	 (mult:ANYF (neg:ANYF (match_operand:ANYF 1 "register_operand" "f"))
 		    (match_operand:ANYF 2 "register_operand" "f"))
 	 (match_operand:ANYF 3 "register_operand" "f")))]
-  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
+  "ISA_HAS_NMADD4_NMSUB4
    && TARGET_FUSED_MADD
    && !HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2172,7 +2216,7 @@
 	 (mult:ANYF (neg:ANYF (match_operand:ANYF 1 "register_operand" "f"))
 		    (match_operand:ANYF 2 "register_operand" "f"))
 	 (match_operand:ANYF 3 "register_operand" "0")))]
-  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
+  "ISA_HAS_NMADD3_NMSUB3
    && TARGET_FUSED_MADD
    && !HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2186,7 +2230,7 @@
 		   (mult:ANYF (match_operand:ANYF 2 "register_operand" "f")
 			      (match_operand:ANYF 3 "register_operand" "f"))
 		   (match_operand:ANYF 1 "register_operand" "f"))))]
-  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
+  "ISA_HAS_NMADD4_NMSUB4
    && TARGET_FUSED_MADD
    && HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2200,7 +2244,7 @@
 		   (mult:ANYF (match_operand:ANYF 2 "register_operand" "f")
 			      (match_operand:ANYF 3 "register_operand" "f"))
 		   (match_operand:ANYF 1 "register_operand" "0"))))]
-  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
+  "ISA_HAS_NMADD3_NMSUB3
    && TARGET_FUSED_MADD
    && HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2214,7 +2258,7 @@
 	 (match_operand:ANYF 1 "register_operand" "f")
 	 (mult:ANYF (match_operand:ANYF 2 "register_operand" "f")
 		    (match_operand:ANYF 3 "register_operand" "f"))))]
-  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
+  "ISA_HAS_NMADD4_NMSUB4
    && TARGET_FUSED_MADD
    && !HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2228,7 +2272,7 @@
 	 (match_operand:ANYF 1 "register_operand" "f")
 	 (mult:ANYF (match_operand:ANYF 2 "register_operand" "f")
 		    (match_operand:ANYF 3 "register_operand" "0"))))]
-  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
+  "ISA_HAS_NMADD3_NMSUB3
    && TARGET_FUSED_MADD
    && !HONOR_SIGNED_ZEROS (<MODE>mode)
    && !HONOR_NANS (<MODE>mode)"
@@ -2548,6 +2592,7 @@
     return "nor\t%0,%.,%1";
 }
   [(set_attr "alu_type" "not")
+   (set_attr "micromips_type" "logical_not")
    (set_attr "mode" "<MODE>")])
 
 ;;
@@ -2621,6 +2666,7 @@
     }
 }
   [(set_attr "move_type" "load,load,load,andi,ext_ins,shift_shift,logical")
+   (set_attr "micromips_type" "logical_and")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*and<mode>3_mips16"
@@ -2670,6 +2716,7 @@
    or\t%0,%1,%2
    ori\t%0,%1,%x2"
   [(set_attr "alu_type" "or")
+   (set_attr "micromips_type" "logical_or")
    (set_attr "mode" "<MODE>")])
 
 (define_insn "*ior<mode>3_mips16"
@@ -2697,6 +2744,7 @@
    xor\t%0,%1,%2
    xori\t%0,%1,%x2"
   [(set_attr "alu_type" "xor")
+   (set_attr "micromips_type" "logical_xor")
    (set_attr "mode" "<MODE>")])
 
 (define_insn ""
@@ -2800,6 +2848,7 @@
   "ISA_HAS_EXTS && TARGET_64BIT && UINTVAL (operands[2]) < 32"
   "exts\t%0,%1,%2,31"
   [(set_attr "type" "arith")
+   (set_attr "micromips_type" "add")
    (set_attr "mode" "<MODE>")])
 
 ;;
@@ -2880,6 +2929,7 @@
    andi\t%0,%1,<SHORT:mask>
    l<SHORT:size>u\t%0,%1"
   [(set_attr "move_type" "andi,load")
+   (set_attr "micromips_type" "zero_extend")
    (set_attr "mode" "<GPR:MODE>")])
 
 (define_insn "*zero_extend<SHORT:mode><GPR:mode>2_mips16e"
@@ -3655,9 +3705,11 @@
 (define_insn "mov_<load>l"
   [(set (match_operand:GPR 0 "register_operand" "=d")
 	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
-		     (match_operand:QI 2 "memory_operand" "m")]
+		     (match_operand:QI 2 "memory_operand" "YC")]
 		    UNSPEC_LOAD_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>l\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -3665,10 +3717,12 @@
 (define_insn "mov_<load>r"
   [(set (match_operand:GPR 0 "register_operand" "=d")
 	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
-		     (match_operand:QI 2 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "YC")
 		     (match_operand:GPR 3 "register_operand" "0")]
 		    UNSPEC_LOAD_RIGHT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
   "<load>r\t%0,%2"
   [(set_attr "move_type" "load")
    (set_attr "mode" "<MODE>")])
@@ -3676,9 +3730,11 @@
 (define_insn "mov_<store>l"
   [(set (match_operand:BLK 0 "memory_operand" "=m")
 	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
-		     (match_operand:QI 2 "memory_operand" "m")]
+		     (match_operand:QI 2 "memory_operand" "YC")]
 		    UNSPEC_STORE_LEFT))]
-  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "!TARGET_MIPS16
+   && !ISA_HAS_UL_US
+   && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
   "<store>l\t%z1,%2"
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
@@ -3686,7 +3742,7 @@
 (define_insn "mov_<store>r"
   [(set (match_operand:BLK 0 "memory_operand" "+m")
 	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
-		     (match_operand:QI 2 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "YC")
 		     (match_dup 0)]
 		    UNSPEC_STORE_RIGHT))]
   "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
@@ -3694,6 +3750,28 @@
   [(set_attr "move_type" "store")
    (set_attr "mode" "<MODE>")])
 
+;; Unaligned load and store patterns.
+
+(define_insn "mov_u<load>"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(unspec:GPR [(match_operand:BLK 1 "memory_operand" "m")
+		     (match_operand:QI 2 "memory_operand" "m")]
+		    UNSPEC_UNALIGNED_LOAD))]
+  "ISA_HAS_UL_US && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
+  "u<load>\t%0,%2"
+  [(set_attr "type" "load")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "mov_u<store>"
+  [(set (match_operand:BLK 0 "memory_operand" "=m")
+	(unspec:BLK [(match_operand:GPR 1 "reg_or_0_operand" "dJ")
+		     (match_operand:QI 2 "memory_operand" "m")]
+		    UNSPEC_UNALIGNED_STORE))]
+  "ISA_HAS_UL_US && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
+  "u<store>\t%z1,%2"
+  [(set_attr "type" "store")
+   (set_attr "mode" "<MODE>")])
+
 ;; An instruction to calculate the high part of a 64-bit SYMBOL_ABSOLUTE.
 ;; The required value is:
 ;;
@@ -3749,6 +3827,19 @@
   operands[4] = mips_unspec_address (operands[2], SYMBOL_64_LOW);
 })
 
+;; Peephole to enable finding duplicates in delay slot filling.
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand")
+        (zero_extend:SI (match_operand:HI 1 "register_operand")))]
+  "!TARGET_MIPS16"
+  [(set (match_dup 0)
+	(and:SI (match_dup 2)
+                (const_int 65535)))
+  ]
+{
+  operands[2] = gen_rtx_REG (SImode, REGNO (operands[1]));
+})
+
 ;; On most targets, the expansion of (lo_sum (high X) X) for a 64-bit
 ;; SYMBOL_ABSOLUTE X will take 6 cycles.  This next pattern allows combine
 ;; to merge the HIGH and LO_SUM parts of a move if the HIGH part is only
@@ -3797,6 +3888,23 @@
   operands[2] = mips_unspec_address (operands[1], SYMBOL_32_HIGH);
 })
 
+;; MIPS16 %dtprel_hi,%tprel_hi split pattern. Similar transform
+;; as above, for supporting MIPS16 TLS.
+(define_split
+  [(set (match_operand:SI 0 "d_operand")
+	(high:SI (match_operand:SI 1 "tls_reloc_operand")))]
+  "TARGET_MIPS16 && reload_completed"
+  [(set (match_dup 0) (match_dup 2))
+   (set (match_dup 0) (ashift:SI (match_dup 0) (const_int 16)))]
+{
+  /* SYMBOL_DTPREL_HI/TPREL_HI are ordered immediately after
+     SYMBOL_DTPREL/TPREL respectively, so use unspec_type + 1.  */
+  rtx unspec = XEXP (operands[1], 0);
+  int unspec_type = XINT (unspec, 1);
+  operands[2] = mips_unspec_address (XVECEXP (unspec, 0, 0),
+				     unspec_type + 1 - UNSPEC_ADDRESS_FIRST);
+})
+
 ;; Insns to fetch a symbol from a big GOT.
 
 (define_insn_and_split "*xgot_hi<mode>"
@@ -4583,6 +4691,7 @@
   ""
   { return ISA_HAS_MACCHI ? "<GPR:d>macchi\t%0,%.,%." : "mfhi\t%0"; }
   [(set_attr "move_type" "mfhilo")
+   (set_attr "micromips_type" "mfhi")
    (set_attr "mode" "<GPR:MODE>")])
 
 ;; Set the high part of a HI/LO value, given that the low part has
@@ -4968,7 +5077,7 @@
   [(set (match_operand:GPR 0 "register_operand" "=d")
 	(any_shift:GPR (match_operand:GPR 1 "register_operand" "d")
 		       (match_operand:SI 2 "arith_operand" "dI")))]
-  "!TARGET_MIPS16"
+  "!TARGET_MIPS16 && !TARGET_MICROMIPS"
 {
   if (CONST_INT_P (operands[2]))
     operands[2] = GEN_INT (INTVAL (operands[2])
@@ -4979,6 +5088,53 @@
   [(set_attr "type" "shift")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*micromips_ashl<mode>3"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(ashift:GPR (match_operand:GPR 1 "register_operand" "d")
+		       (match_operand:SI 2 "arith_operand" "dI")))]
+  "TARGET_MICROMIPS"
+{
+  if (GET_CODE (operands[2]) == CONST_INT)
+    operands[2] = GEN_INT (INTVAL (operands[2])
+			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));
+
+  return "<d>sll\t%0,%1,%2";
+}
+  [(set_attr "type" "shift")
+   (set_attr "micromips_type" "shift")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*micromips_ashr<mode>3"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(ashiftrt:GPR (match_operand:GPR 1 "register_operand" "d")
+		       (match_operand:SI 2 "arith_operand" "dI")))]
+  "TARGET_MICROMIPS"
+{
+  if (GET_CODE (operands[2]) == CONST_INT)
+    operands[2] = GEN_INT (INTVAL (operands[2])
+			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));
+
+  return "<d>sra\t%0,%1,%2";
+}
+  [(set_attr "type" "shift")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*micromips_lshr<mode>3"
+  [(set (match_operand:GPR 0 "register_operand" "=d")
+	(lshiftrt:GPR (match_operand:GPR 1 "register_operand" "d")
+		       (match_operand:SI 2 "arith_operand" "dI")))]
+  "TARGET_MICROMIPS"
+{
+  if (GET_CODE (operands[2]) == CONST_INT)
+    operands[2] = GEN_INT (INTVAL (operands[2])
+			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));
+
+  return "<d>srl\t%0,%1,%2";
+}
+  [(set_attr "type" "shift")
+   (set_attr "micromips_type" "shift")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*<optab>si3_extend"
   [(set (match_operand:DI 0 "register_operand" "=d")
 	(sign_extend:DI
@@ -5202,12 +5358,38 @@
 			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
 	 (label_ref (match_operand 0 "" ""))
 	 (pc)))]
-  "!TARGET_MIPS16"
+  "!TARGET_MIPS16 && !TARGET_MICROMIPS"
 {
   return mips_output_conditional_branch (insn, operands,
 					 MIPS_BRANCH ("b%C1", "%2,%z3,%0"),
 					 MIPS_BRANCH ("b%N1", "%2,%z3,%0"));
 }
+  [(set_attr "type" "branch")
+   (set_attr "mode" "none")])
+
+(define_insn "*branch_equality<mode>_micromips"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 1 "equality_operator"
+			 [(match_operand:GPR 2 "register_operand" "d")
+			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
+	 (label_ref (match_operand 0 "" ""))
+	 (pc)))]
+  "TARGET_MICROMIPS"
+{
+  /* For a simple bnez or beqz microMIPS branch.  */
+  if (!TARGET_BRANCHLIKELY
+      && get_attr_length (insn) <= 8
+      && GET_CODE (operands[3]) == CONST_INT
+      && INTVAL (operands[3]) == 0)
+    return mips_output_conditional_branch (insn, operands,
+					   "%*b%C1z%:\t%2,%0",
+					   "%*b%N1z%:\t%2,%0");
+
+  return mips_output_conditional_branch (insn, operands,
+					 MIPS_BRANCH ("b%C1", "%2,%z3,%0"),
+					 MIPS_BRANCH ("b%N1", "%2,%z3,%0"));
+}
   [(set_attr "type" "branch")])
 
 (define_insn "*branch_equality<mode>_inverted"
@@ -5218,7 +5400,7 @@
 			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
 	 (pc)
 	 (label_ref (match_operand 0 "" ""))))]
-  "!TARGET_MIPS16"
+  "!TARGET_MIPS16 && !TARGET_MICROMIPS"
 {
   return mips_output_conditional_branch (insn, operands,
 					 MIPS_BRANCH ("b%N1", "%2,%z3,%0"),
@@ -5288,6 +5470,32 @@
 		      (label_ref (match_operand 1))
 		      (pc)))])
 
+(define_insn "*branch_equality<mode>_inverted_micromips"
+  [(set (pc)
+	(if_then_else
+	 (match_operator 0 "equality_operator"
+			 [(match_operand:GPR 2 "register_operand" "d")
+			  (match_operand:GPR 3 "reg_or_0_operand" "dJ")])
+	 (pc)
+	 (label_ref (match_operand 1 "" ""))))]
+  "TARGET_MICROMIPS"
+{
+  /* For a simple bnez or beqz microMIPS branch.  */
+  if (!TARGET_BRANCHLIKELY
+      && get_attr_length (insn) <= 8
+      && GET_CODE (operands[3]) == CONST_INT
+      && INTVAL (operands[3]) == 0)
+    return mips_output_conditional_branch (insn, operands,
+					   "%*b%N0z%:\t%2,%1",
+					   "%*b%C0z%:\t%2,%1");
+
+  return mips_output_conditional_branch (insn, operands,
+					 MIPS_BRANCH ("b%N0", "%2,%z3,%1"),
+					 MIPS_BRANCH ("b%C0", "%2,%z3,%1"));
+}
+  [(set_attr "type" "branch")
+   (set_attr "mode" "none")])
+
 ;; Branch if bit is set/clear.
 
 (define_insn "*branch_bit<bbv><mode>"
@@ -5522,7 +5730,14 @@
   [(set (pc)
 	(label_ref (match_operand 0)))]
   "!TARGET_MIPS16 && TARGET_ABSOLUTE_JUMPS"
-  { return MIPS_ABSOLUTE_JUMP ("%*j\t%l0%/"); }
+{
+  /* Use a branch for microMIPS.  The assembler will choose
+     a 16-bit branch, a 32-bit branch, or a 32-bit jump.  */
+  if (TARGET_MICROMIPS && !TARGET_ABICALLS_PIC2)
+    return "%*b\t%l0%/";
+  else
+    return MIPS_ABSOLUTE_JUMP ("%*j\t%l0%/");
+}
   [(set_attr "type" "jump")])
 
 (define_insn "*jump_pic"
@@ -5565,7 +5780,12 @@
 (define_insn "indirect_jump<mode>"
   [(set (pc) (match_operand:P 0 "register_operand" "d"))]
   ""
-  "%*j\t%0%/"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t%0";
+  else
+    return "%*j\t%0%/";
+}
   [(set_attr "type" "jump")
    (set_attr "mode" "none")])
 
@@ -5573,14 +5793,9 @@
   [(set (pc)
 	(match_operand 0 "register_operand"))
    (use (label_ref (match_operand 1 "")))]
-  ""
+  "!TARGET_MIPS16_SHORT_JUMP_TABLES"
 {
-  if (TARGET_MIPS16_SHORT_JUMP_TABLES)
-    operands[0] = expand_binop (Pmode, add_optab,
-				convert_to_mode (Pmode, operands[0], false),
-				gen_rtx_LABEL_REF (Pmode, operands[1]),
-				0, 0, OPTAB_WIDEN);
-  else if (TARGET_GPWORD)
+  if (TARGET_GPWORD)
     operands[0] = expand_binop (Pmode, add_optab, operands[0],
 				pic_offset_table_rtx, 0, 0, OPTAB_WIDEN);
   else if (TARGET_RTP_PIC)
@@ -5605,10 +5820,100 @@
 	(match_operand:P 0 "register_operand" "d"))
    (use (label_ref (match_operand 1 "" "")))]
   ""
-  "%*j\t%0%/"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t%0";
+  else
+    return "%*j\t%0%/";
+}
   [(set_attr "type" "jump")
    (set_attr "mode" "none")])
 
+;; For MIPS16, we don't know whether a given jump table will use short or
+;; word-sized offsets until late in compilation, when we are able to determine
+;; the sizes of the insns which comprise the containing function.  This
+;; necessitates the use of the casesi rather than the tablejump pattern, since
+;; the latter tries to calculate the index of the offset to jump through early
+;; in compilation, i.e. at expand time, when nothing is known about the
+;; eventual function layout.
+
+(define_expand "casesi"
+  [(match_operand:SI 0 "register_operand" "")	; index to jump on
+   (match_operand:SI 1 "const_int_operand" "")	; lower bound
+   (match_operand:SI 2 "const_int_operand" "")	; total range
+   (match_operand:SI 3 "" "")			; table label
+   (match_operand:SI 4 "" "")]			; out of range label
+  "TARGET_MIPS16_SHORT_JUMP_TABLES"
+{
+  if (operands[1] != const0_rtx)
+    {
+      rtx reg = gen_reg_rtx (SImode);
+      rtx offset = gen_int_mode (-INTVAL (operands[1]), SImode);
+      
+      if (!arith_operand (offset, SImode))
+        offset = force_reg (SImode, offset);
+      
+      emit_insn (gen_addsi3 (reg, operands[0], offset));
+      operands[0] = reg;
+    }
+
+  if (!arith_operand (operands[0], SImode))
+    operands[0] = force_reg (SImode, operands[0]);
+
+  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);
+
+  emit_jump_insn (gen_casesi_internal_mips16 (operands[0], operands[2],
+					      operands[3], operands[4]));
+
+  DONE;
+})
+
+(define_insn "casesi_internal_mips16"
+  [(set (pc)
+     (if_then_else
+       (leu (match_operand:SI 0 "register_operand" "d")
+	    (match_operand:SI 1 "arith_operand" "dI"))
+       (mem:SI (plus:SI (mult:SI (match_dup 0) (const_int 4))
+			(label_ref (match_operand 2 "" ""))))
+       (label_ref (match_operand 3 "" ""))))
+   (clobber (match_scratch:SI 4 "=&d"))
+   (clobber (match_scratch:SI 5 "=d"))
+   (clobber (reg:SI MIPS16_T_REGNUM))
+   (use (label_ref (match_dup 2)))]
+  "TARGET_MIPS16_SHORT_JUMP_TABLES"
+{
+  rtx diff_vec = PATTERN (next_real_insn (operands[2]));
+
+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);
+  
+  output_asm_insn ("sltu\t%0, %1", operands);
+  output_asm_insn ("bteqz\t%3", operands);
+  output_asm_insn ("la\t%4, %2", operands);
+  
+  switch (GET_MODE (diff_vec))
+    {
+    case HImode:
+      output_asm_insn ("sll\t%5, %0, 1", operands);
+      output_asm_insn ("addu\t%5, %4, %5", operands);
+      output_asm_insn ("lh\t%5, 0(%5)", operands);
+      break;
+    
+    case SImode:
+      output_asm_insn ("sll\t%5, %0, 2", operands);
+      output_asm_insn ("addu\t%5, %4, %5", operands);
+      output_asm_insn ("lw\t%5, 0(%5)", operands);
+      break;
+
+    default:
+      gcc_unreachable ();
+    }
+  
+  output_asm_insn ("addu\t%4, %4, %5", operands);
+  
+  return "j\t%4";
+}
+  [(set_attr "length" "32")])
+
 ;; For TARGET_USE_GOT, we save the gp in the jmp_buf as well.
 ;; While it is possible to either pull it off the stack (in the
 ;; o32 case) or recalculate it given t9 and our target label,
@@ -5712,6 +6017,23 @@
 (define_insn "*return"
   [(return)]
   "mips_can_use_return_insn ()"
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t$31";
+  else
+    return "%*j\t$31%/";
+}
+  [(set_attr "type"	"jump")
+   (set_attr "mode"	"none")])
+
+(define_expand "simple_return"
+  [(simple_return)]
+  "!mips_can_use_return_insn ()"
+  { mips_expand_before_return (); })
+
+(define_insn "*simple_return"
+  [(simple_return)]
+  "!mips_can_use_return_insn ()"
   "%*j\t$31%/"
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")])
@@ -5722,6 +6044,19 @@
   [(return)
    (use (match_operand 0 "pmode_register_operand" ""))]
   ""
+{
+  if (TARGET_MICROMIPS)
+    return "%*jr%:\t%0";
+  else
+    return "%*j\t%0%/";
+}
+  [(set_attr "type"	"jump")
+   (set_attr "mode"	"none")])
+
+(define_insn "simple_return_internal"
+  [(simple_return)
+   (use (match_operand 0 "pmode_register_operand" ""))]
+  ""
   "%*j\t%0%/"
   [(set_attr "type"	"jump")
    (set_attr "mode"	"none")])
@@ -5976,7 +6311,12 @@
   [(call (mem:SI (match_operand 0 "call_insn_operand" "j,S"))
 	 (match_operand 1 "" ""))]
   "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
-  { return MIPS_CALL ("j", operands, 0, 1); }
+  {
+    if (TARGET_MICROMIPS)
+      return MICROMIPS_J (operands, 0);
+    else
+      return MIPS_CALL ("j", operands, 0, 1);
+  }
   [(set_attr "type" "call")])
 
 (define_expand "sibcall_value"
@@ -5996,7 +6336,12 @@
         (call (mem:SI (match_operand 1 "call_insn_operand" "j,S"))
               (match_operand 2 "" "")))]
   "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
-  { return MIPS_CALL ("j", operands, 1, 2); }
+  {
+    if (TARGET_MICROMIPS)
+      return MICROMIPS_J (operands, 1);
+    else
+      return MIPS_CALL ("j", operands, 1, 2);
+  }
   [(set_attr "type" "call")])
 
 (define_insn "sibcall_value_multiple_internal"
@@ -6007,7 +6352,12 @@
 	(call (mem:SI (match_dup 1))
 	      (match_dup 2)))]
   "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
-  { return MIPS_CALL ("j", operands, 1, 2); }
+  {
+    if (TARGET_MICROMIPS)
+      return MICROMIPS_J (operands, 1);
+    else
+      return MIPS_CALL ("j", operands, 1, 2);
+  }
   [(set_attr "type" "call")])
 
 (define_expand "call"
@@ -6247,7 +6597,7 @@
 
 
 (define_insn "prefetch"
-  [(prefetch (match_operand:QI 0 "address_operand" "p")
+  [(prefetch (match_operand:QI 0 "address_operand" "YD")
 	     (match_operand 1 "const_int_operand" "n")
 	     (match_operand 2 "const_int_operand" "n"))]
   "ISA_HAS_PREFETCH && TARGET_EXPLICIT_RELOCS"
@@ -6357,6 +6707,17 @@
 ;;  ....................
 ;;
 
+(define_insn "consttable_tls_reloc"
+  [(unspec_volatile [(match_operand 0 "tls_reloc_operand" "")
+		     (match_operand 1 "const_int_operand" "")]
+		    UNSPEC_CONSTTABLE_INT)]
+  "TARGET_MIPS16_PCREL_LOADS"
+{
+  mips_output_tls_reloc_directive (operands[0], operands[1]);
+  return "";
+}
+  [(set (attr "length") (symbol_ref "INTVAL (operands[1])"))])
+
 (define_insn "consttable_int"
   [(unspec_volatile [(match_operand 0 "consttable_operand" "")
 		     (match_operand 1 "const_int_operand" "")]
@@ -6458,6 +6819,60 @@
    ; See tls_get_tp_<mode>
    (set_attr "can_delay" "no")
    (set_attr "mode" "<MODE>")])
+
+;; In MIPS16 mode, the TLS base pointer is accessed by a
+;; libgcc helper function __mips16_rdhwr(), as 'rdhwr' is not
+;; accessible in MIPS16.
+;;
+;; This is not represented as a call insn, to avoid the
+;; unnecesarry clobbering of caller-save registers by a
+;; function consisting only of: "rdhwr $3,$29; j $31; nop;
+;;
+;; A $25 clobber is added to cater for a $25 load stub added by the
+;; linker to __mips16_rdhwr when the call is made from non-PIC code.
+
+(define_insn_and_split "tls_get_tp_<mode>_mips16"
+  [(set (match_operand:P 0 "register_operand" "=d")
+	(unspec:P [(const_int 0)] UNSPEC_TLS_GET_TP))
+   (clobber (reg:P TLS_GET_TP_REGNUM))
+   (clobber (reg:P PIC_JUMP_REGNUM))
+   (clobber (reg:P RETURN_ADDR_REGNUM))]
+  "HAVE_AS_TLS && TARGET_MIPS16"
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (reg:P TLS_GET_TP_REGNUM)
+  	      (unspec:P [(match_dup 1)] UNSPEC_TLS_GET_TP))
+	      (clobber (reg:P PIC_JUMP_REGNUM))
+	      (clobber (reg:P RETURN_ADDR_REGNUM))])
+   (set (match_dup 0) (reg:P TLS_GET_TP_REGNUM)) ]
+  {
+    /* UNSPEC operand decides on direct/indirect pattern below.  */
+    rtx sym = gen_rtx_SYMBOL_REF (Pmode, "__mips16_rdhwr");
+    if (TARGET_ABSOLUTE_JUMPS)
+      operands[1] = sym;
+    else
+      {
+	operands[1] = gen_rtx_REG (Pmode, TLS_GET_TP_REGNUM);
+	mips_emit_move (operands[1], sym);
+      }
+  }
+  [(set_attr "type" "unknown")
+   (set_attr "can_delay" "no")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "*tls_get_tp_<mode>_mips16_rdhwr"
+  [(set (reg:P TLS_GET_TP_REGNUM)
+	(unspec:P [(match_operand:P 0 "")] UNSPEC_TLS_GET_TP))
+	(clobber (reg:P PIC_JUMP_REGNUM))
+	(clobber (reg:P RETURN_ADDR_REGNUM))]
+  "HAVE_AS_TLS && TARGET_MIPS16"
+  {
+    return MIPS_CALL ("jal", operands, 0, -1);
+  }
+  [(set_attr "type" "call")
+   (set_attr "can_delay" "no")
+   (set_attr "mode" "<MODE>")])
+
 
 ;; Synchronization instructions.
 
@@ -6478,9 +6893,66 @@
 ; MIPS fixed-point instructions.
 (include "mips-fixed.md")
 
+; microMIPS patterns.
+(include "micromips.md")
+
 ; ST-Microelectronics Loongson-2E/2F-specific patterns.
 (include "loongson.md")
 
 (define_c_enum "unspec" [
   UNSPEC_ADDRESS_FIRST
 ])
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand")
+	(zero_extend:SI (match_operand:QI 1)))
+   (set (match_operand:SI 2 "register_operand")
+	(plus:SI (match_dup 0)
+		 (match_operand:SI 3 "const_int_operand")))
+   (set (match_operand:SI 4 "register_operand")
+	(zero_extend:SI (match_operand:QI 5)))
+   (set (match_operand:SI 6 "register_operand")
+	(leu:SI (match_dup 4)
+		(match_operand:SI 7 "const_int_operand")))]
+  "REGNO (operands[5]) == REGNO (operands[2]) && INTVAL (operands[3]) < 0
+   && INTVAL (operands[7]) > 0
+   && (INTVAL (operands[7]) + -INTVAL (operands[3])) <= 256
+   && (/* op4 killed by last insn.  */
+       rtx_equal_p (operands[4], operands[6])
+	  /* op4 dead after use in last insn.  */
+       || peep2_reg_dead_p (4, operands[4]))"
+  [(set (match_dup 0)
+	(zero_extend:SI (match_dup 1)))
+   (set (match_dup 2)
+	(plus:SI (match_dup 0) (match_dup 3)))
+   (set (match_dup 6)
+	(leu:SI (match_dup 2)
+		(match_dup 7)))]
+)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand")
+	(zero_extend:SI (match_operand:HI 1)))
+   (set (match_operand:SI 2 "register_operand")
+	(plus:SI (match_dup 0)
+		 (match_operand:SI 3 "const_int_operand")))
+   (set (match_operand:SI 4 "register_operand")
+	(and:SI (match_dup 2) (const_int 65535)))
+   (set (match_operand:SI 5 "register_operand")
+	(leu:SI (match_dup 4)
+		(match_operand:SI 6 "const_int_operand")))]
+  "INTVAL (operands[3]) < 0
+   && INTVAL (operands[6]) > 0
+   && (INTVAL (operands[6]) + -INTVAL (operands[3])) <= 65536
+   && (/* op4 killed by last insn.  */
+       rtx_equal_p (operands[4], operands[5])
+	  /* op4 dead after use in last insn.  */
+       || peep2_reg_dead_p (4, operands[4]))"
+  [(set (match_dup 0)
+	(zero_extend:SI (match_dup 1)))
+   (set (match_dup 2)
+	(plus:SI (match_dup 0) (match_dup 3)))
+   (set (match_dup 5)
+	(leu:SI (match_dup 2)
+		(match_dup 6)))]
+)
diff -ru ./gcc/config/mips/mips.opt /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.opt
--- ./gcc/config/mips/mips.opt	2014-06-06 11:50:16.227598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips.opt	2012-03-29 18:03:15.000000000 +1000
@@ -60,6 +60,10 @@
 Target RejectNegative Joined
 -mcode-readable=SETTING	Specify when instructions are allowed to access code
 
+mcompact-eh
+Target Var(TARGET_COMPACT_EH) Init(1)
+Use compact exception unwinding tables.
+
 mdivide-breaks
 Target Report RejectNegative Mask(DIVIDE_BREAKS)
 Use branch-and-break sequences to check for integer divide by zero
@@ -110,6 +114,10 @@
 Target Report Var(TARGET_EXTERN_SDATA) Init(1)
 Use -G for data that is not defined by the current object
 
+mfix-24k
+Target Report Var(TARGET_FIX_24K)
+Work around certain 24K errata
+
 mfix-r4000
 Target Report Mask(FIX_R4000)
 Work around certain R4000 errata
@@ -182,6 +190,10 @@
 Target Report Var(TARGET_INTERLINK_MIPS16) Init(0)
 Generate code that can be safely linked with MIPS16 code.
 
+mjals
+Target Report Var(TARGET_JALS) Init(1)
+Generate jals for microMIPS by recognizing that the branch delay slot instruction can be 16 bits.  This implies that the function call cannot switch the current mode during the linking stage, because we don't have jalxs that supports 16-bit branch delay slot instructions.
+
 mips
 Target RejectNegative Joined
 -mipsN	Generate code for ISA level N
@@ -190,6 +202,10 @@
 Target Report RejectNegative Mask(MIPS16)
 Generate MIPS16 code
 
+mips16e
+Target Report RejectNegative Mask(MIPS16) MaskExists
+Deprecated; alias for -mips16
+
 mips3d
 Target Report RejectNegative Mask(MIPS3D)
 Use MIPS-3D instructions
@@ -222,6 +238,10 @@
 Target Report Mask(MEMCPY)
 Don't optimize block moves
 
+mmicromips
+Target Report Mask(MICROMIPS)
+Use microMIPS instructions
+
 mmips-tfile
 Target
 Use the mips-tfile postpass
@@ -234,6 +254,10 @@
 Target Report RejectNegative Var(TARGET_NO_FLOAT) Condition(TARGET_SUPPORTS_NO_FLOAT)
 Prevent the use of all floating-point operations
 
+mmcu
+Target Report Mask(MCU)
+Use MCU instructions
+
 mno-flush-func
 Target RejectNegative
 Do not use a cache-flushing function before calling stack trampolines
@@ -250,6 +274,10 @@
 Target Report RejectNegative InverseMask(MIPS3D)
 Do not use MIPS-3D instructions
 
+mocteon-useun
+Target Report Mask(OCTEON_UNALIGNED)
+Use Octeon-specific unaligned loads/stores for 32/64-bit data
+
 mpaired-single
 Target Report Mask(PAIRED_SINGLE_FLOAT)
 Use paired-single floating-point instructions
@@ -306,5 +334,9 @@
 Target Report Var(TARGET_XGOT)
 Lift restrictions on GOT size
 
+mframe-header-opt
+Target Report Var(flag_frame_header_optimization) Optimization
+Optimize frame header
+
 noasmopt
 Driver
diff -ru ./gcc/config/mips/mips-protos.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-protos.h
--- ./gcc/config/mips/mips-protos.h	2014-06-06 11:50:16.167598625 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/mips-protos.h	2012-03-29 18:03:15.000000000 +1000
@@ -89,8 +89,10 @@
    SYMBOL_TLSGD
    SYMBOL_TLSLDM
    SYMBOL_DTPREL
+   SYMBOL_DTPREL_HI
    SYMBOL_GOTTPREL
    SYMBOL_TPREL
+   SYMBOL_TPREL_HI
        UNSPEC wrappers around SYMBOL_TLS, corresponding to the
        thread-local storage relocation operators.
 
@@ -127,8 +129,10 @@
   SYMBOL_TLSGD,
   SYMBOL_TLSLDM,
   SYMBOL_DTPREL,
+  SYMBOL_DTPREL_HI,
   SYMBOL_GOTTPREL,
   SYMBOL_TPREL,
+  SYMBOL_TPREL_HI,
   SYMBOL_32_HIGH,
   SYMBOL_64_HIGH,
   SYMBOL_64_MID,
@@ -185,7 +189,7 @@
 				      enum mips_symbol_type *);
 extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);
 extern bool mips_stack_address_p (rtx, enum machine_mode);
-extern int mips_address_insns (rtx, enum machine_mode, bool);
+extern int mips_address_insns (rtx, enum machine_mode, bool, bool);
 extern int mips_const_insns (rtx);
 extern int mips_split_const_insns (rtx);
 extern int mips_load_store_insns (rtx, rtx);
@@ -296,11 +300,14 @@
 extern const char *mips_output_sync (void);
 extern const char *mips_output_sync_loop (rtx, rtx *);
 extern unsigned int mips_sync_loop_insns (rtx, rtx *);
+extern const char *mips_output_atomic (rtx, rtx *);
 extern const char *mips_output_division (const char *, rtx *);
 extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);
 extern bool mips_linked_madd_p (rtx, rtx);
 extern bool mips_store_data_bypass_p (rtx, rtx);
 extern rtx mips_prefetch_cookie (rtx, rtx);
+extern int mips_mult_madd_chain_bypass_p (rtx, rtx);
+extern int mips_dspalu_bypass_p (rtx, rtx);
 
 extern void irix_asm_output_align (FILE *, unsigned);
 extern const char *current_section_name (void);
@@ -326,12 +333,19 @@
 				     rtx, rtx, rtx, rtx);
 
 extern void mips_expand_vector_init (rtx, rtx);
+extern const char *micromips_output_save_restore (bool, rtx);
+extern bool micromips_save_restore_pattern_p (bool, rtx);
+extern bool micromips_load_store_pair_p (bool, bool, rtx, rtx, rtx);
+extern const char *micromips_output_load_store_pair (bool, rtx, rtx);
+extern bool micromips_movep_target_p (rtx, rtx);
 
 extern bool mips_eh_uses (unsigned int);
 extern bool mips_epilogue_uses (unsigned int);
 extern void mips_final_prescan_insn (rtx, rtx *, int);
 extern int mips_trampoline_code_size (void);
 extern void mips_function_profiler (FILE *);
+extern void mips_output_tls_reloc_directive (rtx, rtx);
+extern void mips_fixup_cfi_sections (void);
 
 typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);
 #ifdef RTX_CODE
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: mips-unwind.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: netlogic.h
diff -ru ./gcc/config/mips/predicates.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/predicates.md
--- ./gcc/config/mips/predicates.md	2014-06-06 11:50:16.231598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/predicates.md	2012-04-28 17:58:33.000000000 +1000
@@ -298,6 +298,14 @@
 	  && type == SYMBOL_GOT_PAGE_OFST);
 })
 
+(define_predicate "tls_reloc_operand"
+  (match_code "const,symbol_ref,label_ref")
+{
+  enum mips_symbol_type type;
+  return (mips_symbolic_constant_p (op, SYMBOL_CONTEXT_LEA, &type)
+	  && (type == SYMBOL_DTPREL || type == SYMBOL_TPREL));
+})
+
 (define_predicate "symbol_ref_operand"
   (match_code "symbol_ref"))
 
@@ -340,3 +348,17 @@
 (define_predicate "small_data_pattern"
   (and (match_code "set,parallel,unspec,unspec_volatile,prefetch")
        (match_test "mips_small_data_pattern_p (op)")))
+
+;; Return 1 if the operand is in non-volatile memory.  Note that during the
+;; RTL generation phase, memory_operand does not return TRUE for volatile
+;; memory references.  So this function allows us to recognize volatile
+;; references where it's safe.
+(define_predicate "non_volatile_mem_operand"
+  (not (and (and (match_code "mem")
+	    (match_test "MEM_VOLATILE_P (op)"))
+       (if_then_else (match_test "reload_completed")
+         (match_operand 0 "memory_operand")
+         (if_then_else (match_test "reload_in_progress")
+	   (match_test "strict_memory_address_p (mode, XEXP (op, 0))")
+	   (match_test "memory_address_p (mode, XEXP (op, 0))"))))))
+
diff -ru ./gcc/config/mips/sde.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/sde.h
--- ./gcc/config/mips/sde.h	2014-06-06 11:50:16.231598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/sde.h	2012-03-29 18:03:15.000000000 +1000
@@ -19,6 +19,17 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
+#undef TARGET_MIPS_SDE
+#define TARGET_MIPS_SDE 1
+
+#ifdef HAVE_GAS_EH_FRAME_ENTRY
+#undef MIPS_EH_ENCODING
+#define MIPS_EH_ENCODING (DW_EH_PE_pcrel | DW_EH_PE_sdata4)
+#define LINK_EH_SPEC "--pcrel-eh-reloc "
+#else
+#define LINK_EH_SPEC ""
+#endif
+
 #undef DRIVER_SELF_SPECS
 #define DRIVER_SELF_SPECS						\
   /* Make sure a -mips option is present.  This helps us to pick	\
@@ -56,7 +67,7 @@
 %{mips16:-no-mips16}"
 
 #undef LINK_SPEC
-#define LINK_SPEC "\
+#define LINK_SPEC LINK_EH_SPEC "\
 %(endian_spec) \
 %{G*} %{mips1} %{mips2} %{mips3} %{mips4} %{mips32*} %{mips64*} \
 %{shared} \
diff -ru ./gcc/config/mips/sdemtk.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/sdemtk.h
--- ./gcc/config/mips/sdemtk.h	2014-06-06 11:50:16.231598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/sdemtk.h	2012-03-29 18:03:15.000000000 +1000
@@ -99,5 +99,14 @@
 #undef MIPS_SAVE_REG_FOR_PROFILING_P
 #define MIPS_SAVE_REG_FOR_PROFILING_P(REGNO) ((REGNO) == RETURN_ADDR_REGNUM)
 
+/* From mips.h, with mno-float option added.  */
+
+#undef MIPS_ARCH_FLOAT_SPEC
+#define MIPS_ARCH_FLOAT_SPEC \
+  "%{mhard-float|msoft-float|mno-float|march=mips*:; \
+     march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec|march=m14k* \
+     |march=34kc|march=34kn|march=74kc|march=1004kc|march=5kc|march=octeon|march=xlr: -msoft-float; \
+     march=*: -mhard-float}"
+
 /* Compile in support for the -mno-float option.  */
 #define TARGET_SUPPORTS_NO_FLOAT 1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: sfp-machine.h
diff -ru ./gcc/config/mips/sync.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/sync.md
--- ./gcc/config/mips/sync.md	2014-06-06 11:50:16.239598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/sync.md	2012-03-29 18:03:15.000000000 +1000
@@ -56,7 +56,7 @@
 
 (define_insn "sync_compare_and_swap<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "dJ,dJ")
 			      (match_operand:GPR 3 "arith_operand" "I,d")]
@@ -69,6 +69,74 @@
    (set_attr "sync_required_oldval" "2")
    (set_attr "sync_insn1_op2" "3")])
 
+(define_insn "mips_val_compare_and_swap<d>_acq"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "dJ,dJ")
+			      (match_operand:GPR 3 "arith_operand" "I,d")]
+	 UNSPEC_COMPARE_AND_SWAP_ACQ))]
+  "GENERATE_LL_SC"
+  { return mips_output_sync_loop (insn, operands); }
+  [(set_attr "sync_release_barrier" "no")
+   (set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_required_oldval" "2")
+   (set_attr "sync_insn1_op2" "3")])
+
+(define_insn "mips_val_compare_and_swap<d>_rel"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+	(match_operand:GPR 1 "memory_operand" "+R,R"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "reg_or_0_operand" "dJ,dJ")
+			      (match_operand:GPR 3 "arith_operand" "I,d")]
+	 UNSPEC_COMPARE_AND_SWAP_REL))]
+  "GENERATE_LL_SC"
+  { return mips_output_sync_loop (insn, operands); }
+  [(set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_required_oldval" "2")
+   (set_attr "sync_insn1_op2" "3")
+   (set_attr "sync_acquire_barrier" "no")])
+
+(define_insn "mips_bool_compare_and_swap<d>_acq"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+        (eq:GPR (match_operand:GPR 1 "memory_operand" "+YE,YE")
+                (match_operand:GPR 2 "reg_or_0_operand" "dJ,dJ")))
+   (set (match_dup 1)
+        (unspec_volatile:GPR [(match_dup 2)
+                              (match_operand:GPR 3 "arith_operand" "I,d")]
+         UNSPEC_COMPARE_AND_SWAP_ACQ))]
+  "GENERATE_LL_SC"
+  { return mips_output_sync_loop (insn, operands); }
+  [(set_attr "sync_release_barrier" "no")
+   (set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_cmp" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_required_oldval" "2")
+   (set_attr "sync_insn1_op2" "3")])
+
+(define_insn "mips_bool_compare_and_swap<d>_rel"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+        (eq:GPR (match_operand:GPR 1 "memory_operand" "+R,R")
+                (match_operand:GPR 2 "reg_or_0_operand" "dJ,dJ")))
+   (set (match_dup 1)
+        (unspec_volatile:GPR [(match_dup 2)
+                              (match_operand:GPR 3 "arith_operand" "I,d")]
+         UNSPEC_COMPARE_AND_SWAP_REL))]
+  "GENERATE_LL_SC"
+  { return mips_output_sync_loop (insn, operands); }
+  [(set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_cmp" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_required_oldval" "2")
+   (set_attr "sync_insn1_op2" "3")
+   (set_attr "sync_acquire_barrier" "no")])
+
 (define_expand "sync_compare_and_swap<mode>"
   [(match_operand:SHORT 0 "register_operand")
    (match_operand:SHORT 1 "memory_operand")
@@ -86,7 +154,7 @@
 ;; Helper insn for mips_expand_atomic_qihi.
 (define_insn "compare_and_swap_12"
   [(set (match_operand:SI 0 "register_operand" "=&d,&d")
-	(match_operand:SI 1 "memory_operand" "+R,R"))
+	(match_operand:SI 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:SI [(match_operand:SI 2 "register_operand" "d,d")
 			     (match_operand:SI 3 "register_operand" "d,d")
@@ -102,13 +170,38 @@
    (set_attr "sync_required_oldval" "4")
    (set_attr "sync_insn1_op2" "5")])
 
-(define_insn "sync_add<mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R,R")
+(define_expand "sync_add<mode>"
+  [(match_operand:GPR 0 "memory_operand")
+   (match_operand:GPR 1 "arith_operand")]
+  "GENERATE_LL_SC || GENERATE_LDADD"
+{
+  if (GENERATE_LDADD)
+    emit_insn (gen_sync_add_ldadd<mode> (operands[0], operands[1]));
+  else
+    emit_insn (gen_sync_add_ll_sc<mode> (operands[0], operands[1]));
+  DONE;
+})
+
+(define_insn "sync_add_ldadd<mode>"
+  [(set (match_operand:GPR 0 "memory_operand" "+YE,YE")
 	(unspec_volatile:GPR
           [(plus:GPR (match_dup 0)
 		     (match_operand:GPR 1 "arith_operand" "I,d"))]
 	  UNSPEC_SYNC_OLD_OP))]
-  "GENERATE_LL_SC"
+  "GENERATE_LDADD"
+  { return mips_output_atomic (insn, operands); }
+  [(set_attr "sync_insn1" "li,move")
+   (set_attr "sync_mem" "0")
+   (set_attr "sync_insn1_op2" "1")
+   (set_attr "sync_atomic_insn" "ldadd")])
+
+(define_insn "sync_add_ll_sc<mode>"
+  [(set (match_operand:GPR 0 "memory_operand" "+YE,YE")
+	(unspec_volatile:GPR
+          [(plus:GPR (match_dup 0)
+		     (match_operand:GPR 1 "arith_operand" "I,d"))]
+	  UNSPEC_SYNC_OLD_OP))]
+  "GENERATE_LL_SC && !GENERATE_LDADD"
   { return mips_output_sync_loop (insn, operands); }
   [(set_attr "sync_insn1" "addiu,addu")
    (set_attr "sync_mem" "0")
@@ -131,7 +224,7 @@
 
 ;; Helper insn for sync_<optab><mode>
 (define_insn "sync_<optab>_12"
-  [(set (match_operand:SI 0 "memory_operand" "+R")
+  [(set (match_operand:SI 0 "memory_operand" "+YE")
 	(unspec_volatile:SI
           [(match_operand:SI 1 "register_operand" "d")
 	   (match_operand:SI 2 "register_operand" "d")
@@ -171,7 +264,7 @@
 ;; Helper insn for sync_old_<optab><mode>
 (define_insn "sync_old_<optab>_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
-	(match_operand:SI 1 "memory_operand" "+R"))
+	(match_operand:SI 1 "memory_operand" "+YE"))
    (set (match_dup 1)
 	(unspec_volatile:SI
           [(match_operand:SI 2 "register_operand" "d")
@@ -214,7 +307,7 @@
 (define_insn "sync_new_<optab>_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
 	(unspec_volatile:SI
-          [(match_operand:SI 1 "memory_operand" "+R")
+          [(match_operand:SI 1 "memory_operand" "+YE")
 	   (match_operand:SI 2 "register_operand" "d")
 	   (match_operand:SI 3 "register_operand" "d")
 	   (atomic_hiqi_op:SI (match_dup 0)
@@ -254,7 +347,7 @@
 
 ;; Helper insn for sync_nand<mode>
 (define_insn "sync_nand_12"
-  [(set (match_operand:SI 0 "memory_operand" "+R")
+  [(set (match_operand:SI 0 "memory_operand" "+YE")
 	(unspec_volatile:SI
           [(match_operand:SI 1 "register_operand" "d")
 	   (match_operand:SI 2 "register_operand" "d")
@@ -293,7 +386,7 @@
 ;; Helper insn for sync_old_nand<mode>
 (define_insn "sync_old_nand_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
-	(match_operand:SI 1 "memory_operand" "+R"))
+	(match_operand:SI 1 "memory_operand" "+YE"))
    (set (match_dup 1)
 	(unspec_volatile:SI
           [(match_operand:SI 2 "register_operand" "d")
@@ -334,7 +427,7 @@
 (define_insn "sync_new_nand_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
 	(unspec_volatile:SI
-          [(match_operand:SI 1 "memory_operand" "+R")
+          [(match_operand:SI 1 "memory_operand" "+YE")
 	   (match_operand:SI 2 "register_operand" "d")
 	   (match_operand:SI 3 "register_operand" "d")
 	   (match_operand:SI 4 "register_operand" "dJ")]
@@ -356,57 +449,162 @@
    (set_attr "sync_exclusive_mask" "3")
    (set_attr "sync_insn1_op2" "4")])
 
-(define_insn "sync_sub<mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R")
+(define_expand "sync_sub<mode>"
+  [(match_operand:GPR 0 "memory_operand")
+   (match_operand:GPR 1 "register_operand")]
+  "GENERATE_LL_SC || GENERATE_LDADD"
+{
+  if (GENERATE_LDADD)
+    emit_insn (gen_sync_sub_ldadd<mode> (operands[0], operands[1]));
+  else
+    emit_insn (gen_sync_sub_ll_sc<mode> (operands[0], operands[1]));
+  DONE;
+})
+
+(define_insn "sync_sub_ldadd<mode>"
+  [(set (match_operand:GPR 0 "memory_operand" "+YE")
 	(unspec_volatile:GPR
           [(minus:GPR (match_dup 0)
 		      (match_operand:GPR 1 "register_operand" "d"))]
 	 UNSPEC_SYNC_OLD_OP))]
-  "GENERATE_LL_SC"
+  "GENERATE_LDADD"
+  { return mips_output_atomic (insn, operands); }
+  [(set_attr "sync_insn1" "neg")
+   (set_attr "sync_mem" "0")
+   (set_attr "sync_insn1_op2" "1")
+   (set_attr "sync_atomic_insn" "ldadd")])
+
+(define_insn "sync_sub_ll_sc<mode>"
+  [(set (match_operand:GPR 0 "memory_operand" "+YE")
+	(unspec_volatile:GPR
+          [(minus:GPR (match_dup 0)
+		      (match_operand:GPR 1 "register_operand" "d"))]
+	 UNSPEC_SYNC_OLD_OP))]
+  "GENERATE_LL_SC && !GENERATE_LDADD"
   { return mips_output_sync_loop (insn, operands); }
   [(set_attr "sync_insn1" "subu")
    (set_attr "sync_mem" "0")
    (set_attr "sync_insn1_op2" "1")])
 
-(define_insn "sync_old_add<mode>"
+(define_expand "sync_old_add<mode>"
+  [(match_operand:GPR 0 "register_operand")
+   (match_operand:GPR 1 "memory_operand")
+   (match_operand:GPR 2 "arith_operand")]
+  "GENERATE_LL_SC || GENERATE_LDADD"
+{
+  rtx gen;
+  if (GENERATE_LDADD)
+    gen = gen_sync_old_add_ldadd<mode> (operands[0], operands[1], operands[2]);
+  else
+    gen = gen_sync_old_add_ll_sc<mode> (operands[0], operands[1], operands[2]);
+  emit_insn (gen);
+  DONE;
+})
+
+(define_insn "sync_old_add_ldadd<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(plus:GPR (match_dup 1)
 		     (match_operand:GPR 2 "arith_operand" "I,d"))]
 	 UNSPEC_SYNC_OLD_OP))]
-  "GENERATE_LL_SC"
+  "GENERATE_LDADD"
+  { return mips_output_atomic (insn, operands); }
+  [(set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_insn1_op2" "2")
+   (set_attr "sync_atomic_insn" "ldadd")])
+
+(define_insn "sync_old_add_ll_sc<mode>"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR
+          [(plus:GPR (match_dup 1)
+		     (match_operand:GPR 2 "arith_operand" "I,d"))]
+	 UNSPEC_SYNC_OLD_OP))]
+  "GENERATE_LL_SC && !GENERATE_LDADD"
   { return mips_output_sync_loop (insn, operands); }
   [(set_attr "sync_insn1" "addiu,addu")
    (set_attr "sync_oldval" "0")
    (set_attr "sync_mem" "1")
    (set_attr "sync_insn1_op2" "2")])
 
-(define_insn "sync_old_sub<mode>"
+(define_expand "sync_old_sub<mode>"
+  [(match_operand:GPR 0 "register_operand")
+   (match_operand:GPR 1 "memory_operand")
+   (match_operand:GPR 2 "register_operand")]
+  "GENERATE_LL_SC || GENERATE_LDADD"
+{
+  rtx gen;
+  if (GENERATE_LDADD)
+    gen = gen_sync_old_sub_ldadd<mode> (operands[0], operands[1], operands[2]);
+  else
+    gen = gen_sync_old_sub_ll_sc<mode> (operands[0], operands[1], operands[2]);
+  emit_insn (gen);
+  DONE;
+})
+
+(define_insn "sync_old_sub_ldadd<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d")
-	(match_operand:GPR 1 "memory_operand" "+R"))
+	(match_operand:GPR 1 "memory_operand" "+YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(minus:GPR (match_dup 1)
 		      (match_operand:GPR 2 "register_operand" "d"))]
 	 UNSPEC_SYNC_OLD_OP))]
-  "GENERATE_LL_SC"
+  "GENERATE_LDADD"
+  { return mips_output_atomic (insn, operands); }
+  [(set_attr "sync_insn1" "neg")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_insn1_op2" "2")
+   (set_attr "sync_atomic_insn" "ldadd")])
+
+(define_insn "sync_old_sub_ll_sc<mode>"
+  [(set (match_operand:GPR 0 "register_operand" "=&d")
+	(match_operand:GPR 1 "memory_operand" "+YE"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR
+          [(minus:GPR (match_dup 1)
+		      (match_operand:GPR 2 "register_operand" "d"))]
+	 UNSPEC_SYNC_OLD_OP))]
+  "GENERATE_LL_SC && !GENERATE_LDADD"
   { return mips_output_sync_loop (insn, operands); }
   [(set_attr "sync_insn1" "subu")
    (set_attr "sync_oldval" "0")
    (set_attr "sync_mem" "1")
    (set_attr "sync_insn1_op2" "2")])
 
-(define_insn "sync_new_add<mode>"
+(define_expand "sync_new_add<mode>"
+  [(match_operand:GPR 0 "register_operand")
+   (match_operand:GPR 1 "memory_operand")
+   (match_operand:GPR 2 "arith_operand")]
+  "GENERATE_LL_SC || GENERATE_LDADD"
+{
+  if (GENERATE_LDADD)
+    {
+      emit_insn (gen_sync_old_add_ldadd<mode> (operands[0], operands[1],
+                                               operands[2]));
+      emit_insn (gen_add<mode>3 (operands[0], operands[0], operands[2]));
+    }
+  else
+    emit_insn (gen_sync_new_add_ll_sc<mode> (operands[0], operands[1],
+                                             operands[2]));
+  DONE;
+})
+
+(define_insn "sync_new_add_ll_sc<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-        (plus:GPR (match_operand:GPR 1 "memory_operand" "+R,R")
+        (plus:GPR (match_operand:GPR 1 "memory_operand" "+YE,YE")
 		  (match_operand:GPR 2 "arith_operand" "I,d")))
    (set (match_dup 1)
 	(unspec_volatile:GPR
 	  [(plus:GPR (match_dup 1) (match_dup 2))]
 	 UNSPEC_SYNC_NEW_OP))]
-  "GENERATE_LL_SC"
+  "GENERATE_LL_SC && !GENERATE_LDADD"
   { return mips_output_sync_loop (insn, operands); }
   [(set_attr "sync_insn1" "addiu,addu")
    (set_attr "sync_oldval" "0")
@@ -414,9 +612,27 @@
    (set_attr "sync_mem" "1")
    (set_attr "sync_insn1_op2" "2")])
 
-(define_insn "sync_new_sub<mode>"
+(define_expand "sync_new_sub<mode>"
+   [(match_operand:GPR 0 "register_operand")
+    (match_operand:GPR 1 "memory_operand")
+    (match_operand:GPR 2 "register_operand")]
+  "GENERATE_LL_SC || GENERATE_LDADD"
+{
+  if (GENERATE_LDADD)
+    {
+      emit_insn (gen_sync_old_sub<mode> (operands[0], operands[1],
+                                         operands[2]));
+      emit_insn (gen_sub<mode>3 (operands[0], operands[0], operands[2]));
+    }
+  else
+    emit_insn (gen_sync_new_sub_ll_sc<mode> (operands[0], operands[1],
+                                             operands[2]));
+  DONE;
+})
+
+(define_insn "sync_new_sub_ll_sc<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d")
-        (minus:GPR (match_operand:GPR 1 "memory_operand" "+R")
+        (minus:GPR (match_operand:GPR 1 "memory_operand" "+YE")
 		   (match_operand:GPR 2 "register_operand" "d")))
    (set (match_dup 1)
 	(unspec_volatile:GPR
@@ -431,7 +647,7 @@
    (set_attr "sync_insn1_op2" "2")])
 
 (define_insn "sync_<optab><mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R,R")
+  [(set (match_operand:GPR 0 "memory_operand" "+YE,YE")
 	(unspec_volatile:GPR
           [(fetchop_bit:GPR (match_operand:GPR 1 "uns_arith_operand" "K,d")
 			      (match_dup 0))]
@@ -444,7 +660,7 @@
 
 (define_insn "sync_old_<optab><mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(fetchop_bit:GPR (match_operand:GPR 2 "uns_arith_operand" "K,d")
@@ -459,7 +675,7 @@
 
 (define_insn "sync_new_<optab><mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR
           [(fetchop_bit:GPR (match_operand:GPR 2 "uns_arith_operand" "K,d")
@@ -474,7 +690,7 @@
    (set_attr "sync_insn1_op2" "2")])
 
 (define_insn "sync_nand<mode>"
-  [(set (match_operand:GPR 0 "memory_operand" "+R,R")
+  [(set (match_operand:GPR 0 "memory_operand" "+YE,YE")
 	(unspec_volatile:GPR [(match_operand:GPR 1 "uns_arith_operand" "K,d")]
 	 UNSPEC_SYNC_OLD_OP))]
   "GENERATE_LL_SC"
@@ -486,7 +702,7 @@
 
 (define_insn "sync_old_nand<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
         (unspec_volatile:GPR [(match_operand:GPR 2 "uns_arith_operand" "K,d")]
 	 UNSPEC_SYNC_OLD_OP))]
@@ -500,7 +716,7 @@
 
 (define_insn "sync_new_nand<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR [(match_operand:GPR 2 "uns_arith_operand" "K,d")]
 	 UNSPEC_SYNC_NEW_OP))]
@@ -513,13 +729,28 @@
    (set_attr "sync_mem" "1")
    (set_attr "sync_insn1_op2" "2")])
 
-(define_insn "sync_lock_test_and_set<mode>"
+(define_expand "sync_lock_test_and_set<mode>"
+  [(match_operand:GPR 0 "register_operand")
+   (match_operand:GPR 1 "memory_operand")
+   (match_operand:GPR 2 "arith_operand")]
+  "GENERATE_LL_SC || GENERATE_SWAP"
+{
+  rtx gen;
+  if (GENERATE_SWAP)
+    gen = gen_mips_swap<d>_acq (operands[0], operands[1], operands[2]);
+  else
+    gen = gen_mips_swap<d>_ll_sc_acq (operands[0], operands[1], operands[2]);
+  emit_insn (gen);
+  DONE;
+})
+
+(define_insn "mips_swap<d>_ll_sc_acq"
   [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
-	(match_operand:GPR 1 "memory_operand" "+R,R"))
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
    (set (match_dup 1)
 	(unspec_volatile:GPR [(match_operand:GPR 2 "arith_operand" "I,d")]
-	 UNSPEC_SYNC_EXCHANGE))]
-  "GENERATE_LL_SC"
+	 UNSPEC_SWAP_ACQ))]
+  "GENERATE_LL_SC && !GENERATE_SWAP"
   { return mips_output_sync_loop (insn, operands); }
   [(set_attr "sync_release_barrier" "no")
    (set_attr "sync_insn1" "li,move")
@@ -527,6 +758,50 @@
    (set_attr "sync_mem" "1")
    (set_attr "sync_insn1_op2" "2")])
 
+(define_insn "mips_swap<d>_ll_sc_rel"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "arith_operand" "I,d")]
+	 UNSPEC_SWAP_REL))]
+  "GENERATE_LL_SC && !GENERATE_SWAP"
+  { return mips_output_sync_loop (insn, operands); }
+  [(set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_insn1_op2" "2")
+   (set_attr "sync_acquire_barrier" "no")])
+
+(define_insn "mips_swap<d>_acq"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "arith_operand" "I,d")]
+	 UNSPEC_SWAP_ACQ))]
+  "GENERATE_SWAP"
+  { return mips_output_atomic (insn, operands); }
+  [(set_attr "sync_release_barrier" "no")
+   (set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_insn1_op2" "2")
+   (set_attr "sync_atomic_insn" "swap")])
+
+(define_insn "mips_swap<d>_rel"
+  [(set (match_operand:GPR 0 "register_operand" "=&d,&d")
+	(match_operand:GPR 1 "memory_operand" "+YE,YE"))
+   (set (match_dup 1)
+	(unspec_volatile:GPR [(match_operand:GPR 2 "arith_operand" "I,d")]
+	 UNSPEC_SWAP_REL))]
+  "GENERATE_SWAP"
+  { return mips_output_atomic (insn, operands); }
+  [(set_attr "sync_insn1" "li,move")
+   (set_attr "sync_oldval" "0")
+   (set_attr "sync_mem" "1")
+   (set_attr "sync_insn1_op2" "2")
+   (set_attr "sync_atomic_insn" "swap")
+   (set_attr "sync_acquire_barrier" "no")])
+
 (define_expand "sync_lock_test_and_set<mode>"
   [(match_operand:SHORT 0 "register_operand")
    (match_operand:SHORT 1 "memory_operand")
@@ -542,7 +817,7 @@
 
 (define_insn "test_and_set_12"
   [(set (match_operand:SI 0 "register_operand" "=&d")
-	(match_operand:SI 1 "memory_operand" "+R"))
+	(match_operand:SI 1 "memory_operand" "+YE"))
    (set (match_dup 1)
 	(unspec_volatile:SI [(match_operand:SI 2 "register_operand" "d")
 			     (match_operand:SI 3 "register_operand" "d")
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: t-fprules-softfp
diff -ru ./gcc/config/mips/t-libgcc-mips16 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/t-libgcc-mips16
--- ./gcc/config/mips/t-libgcc-mips16	2014-06-06 11:50:16.239598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/t-libgcc-mips16	2012-03-29 18:03:15.000000000 +1000
@@ -36,7 +36,8 @@
 	_m16stubsc0 _m16stubsc1 _m16stubsc2 _m16stubsc5 _m16stubsc6 \
 	_m16stubsc9 _m16stubsc10 \
 	_m16stubdc0 _m16stubdc1 _m16stubdc2 _m16stubdc5 _m16stubdc6 \
-	_m16stubdc9 _m16stubdc10
+	_m16stubdc9 _m16stubdc10 \
+	_m16rdhwr
 
 LIBGCC_SYNC = yes
 LIBGCC_SYNC_CFLAGS = -mno-mips16
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: t-netlogic
diff -ru ./gcc/config/mips/t-sde /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/t-sde
--- ./gcc/config/mips/t-sde	2014-06-06 11:50:16.239598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/t-sde	2012-03-29 18:03:15.000000000 +1000
@@ -28,8 +28,8 @@
 	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
 	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mips/crtn.asm
 
-MULTILIB_OPTIONS = EL/EB mips32/mips32r2/mips64/mips64r2 mips16 msoft-float/mfp64 mcode-readable=no
-MULTILIB_DIRNAMES = el eb mips32 mips32r2 mips64 mips64r2 mips16 sof f64 spram
+MULTILIB_OPTIONS = EL/EB mips32/mips32r2/mips64/mips64r2 mips16/micromips msoft-float/mfp64 mcode-readable=no
+MULTILIB_DIRNAMES = el eb mips32 mips32r2 mips64 mips64r2 mips16 micromips sof f64 spram
 MULTILIB_MATCHES = EL=mel EB=meb
 
 # The -mfp64 option is only valid in conjunction with -mips32r2.
@@ -46,6 +46,9 @@
 MULTILIB_EXCLUSIONS += mips64/mips16 mips64r2/mips16
 endif
 
+# The -mcode-readable=no is only in conjunction with -mips16.
+MULTILIB_EXCLUSIONS += mcode-readable=no/!mips16
+
 EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
 
 # Build the multilibs.
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: t-sgxx-linux
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: t-sgxxlite-linux
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: t-sgxx-sde
diff -ru ./gcc/config/mips/t-slibgcc-irix /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/t-slibgcc-irix
--- ./gcc/config/mips/t-slibgcc-irix	2014-06-06 11:50:16.239598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/t-slibgcc-irix	2012-03-29 18:03:15.000000000 +1000
@@ -49,4 +49,4 @@
 	$(LN_S) $(SHLIB_SONAME) \
 	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK)
 SHLIB_MKMAP = $(srcdir)/mkmap-flat.awk
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips: xlp.md
diff -ru ./gcc/config/mips/xlr.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/xlr.md
--- ./gcc/config/mips/xlr.md	2014-06-06 11:50:16.239598627 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/mips/xlr.md	2012-03-29 18:03:15.000000000 +1000
@@ -28,10 +28,15 @@
        (eq_attr "type" "slt"))
   "xlr_main_pipe")
 
+(define_insn_reservation "ir_xlr_alu_clz" 2
+  (and (eq_attr "cpu" "xlr") 
+       (eq_attr "type" "clz"))
+  "xlr_main_pipe")
+
 ;; Integer arithmetic instructions.
 (define_insn_reservation "ir_xlr_alu" 1
   (and (eq_attr "cpu" "xlr") 
-       (eq_attr "type" "move,arith,shift,clz,logical,signext,const,unknown,multi,nop,trap"))
+       (eq_attr "type" "move,arith,shift,logical,signext,const,unknown,multi,nop,trap"))
   "xlr_main_pipe")
 
 ;; Integer arithmetic instructions.
diff -ru ./gcc/config/picochip/picochip.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/picochip/picochip.c
--- ./gcc/config/picochip/picochip.c	2014-06-06 11:50:16.355598632 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/picochip/picochip.c	2012-03-29 18:03:08.000000000 +1000
@@ -2264,7 +2264,7 @@
     rtvec p;
     p = rtvec_alloc (2);
 
-    RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);
+    RTVEC_ELT (p, 0) = ret_rtx;
     RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode,
 				    gen_rtx_REG (Pmode, LINK_REGNUM));
     emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));
diff -ru ./gcc/config/print-sysroot-suffix.sh /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/print-sysroot-suffix.sh
--- ./gcc/config/print-sysroot-suffix.sh	2014-06-06 11:50:16.355598632 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/print-sysroot-suffix.sh	2012-03-29 18:03:17.000000000 +1000
@@ -1,6 +1,7 @@
 #! /bin/sh
 # Script to generate SYSROOT_SUFFIX_SPEC equivalent to MULTILIB_OSDIRNAMES
-# Arguments are MULTILIB_OSDIRNAMES, MULTILIB_OPTIONS and MULTILIB_MATCHES.
+# Arguments are MULTILIB_OSDIRNAMES, MULTILIB_OPTIONS, MULTILIB_MATCHES
+# and MULTILIB_ALIASES.
 
 # Copyright (C) 2009 Free Software Foundation, Inc.
 
@@ -54,6 +55,7 @@
 dirnames="$1"
 options="$2"
 matches="$3"
+aliases="$4"
 
 cat > print-sysroot-suffix3.sh <<\EOF
 #! /bin/sh
@@ -80,7 +82,14 @@
 n="\" \\
 $padding\""
 if [ $# = 0 ]; then
+  case $optstring in
 EOF
+for x in $aliases; do
+  l=`echo $x | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $x | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "/$r/) optstring=\"/$l/\" ;;" >> print-sysroot-suffix2.sh
+done
+echo "  esac" >> print-sysroot-suffix2.sh
 
 pat=
 for x in $dirnames; do
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: 476.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: 476.opt
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: apm-linux.h
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: cs-linux.h
diff -ru ./gcc/config/rs6000/driver-rs6000.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/driver-rs6000.c
--- ./gcc/config/rs6000/driver-rs6000.c	2014-06-06 11:50:16.371598632 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/driver-rs6000.c	2012-03-29 18:03:07.000000000 +1000
@@ -29,6 +29,7 @@
 
 #ifdef __linux__
 # include <link.h>
+# include <asm/cputable.h>
 #endif
 
 #if defined (__APPLE__) || (__FreeBSD__)
@@ -156,13 +157,21 @@
 
 #ifdef __linux__
 
+
+static const char *platform = 0;
+static bool hard_float = false;
+static bool auxv_read = false;
+
 /* Returns AT_PLATFORM if present, otherwise generic PowerPC.  */
 
-static const char *
-elf_platform (void)
+static void
+elf_auxv (void)
 {
   int fd;
 
+  if (auxv_read)
+    return;
+  
   fd = open ("/proc/self/auxv", O_RDONLY);
 
   if (fd != -1)
@@ -179,15 +188,49 @@
 	  for (av = (ElfW(auxv_t) *) buf; av->a_type != AT_NULL; ++av)
 	    switch (av->a_type)
 	      {
+	      case AT_HWCAP:
+		if (av->a_un.a_val & PPC_FEATURE_HAS_FPU)
+		  hard_float = true;
+		break;
+
 	      case AT_PLATFORM:
-		return (const char *) av->a_un.a_val;
+		{
+		  const char *name = (const char *)av->a_un.a_val;
+
+		  if (name)
+		    {
+		      /* Strip leading 'ppc' */
+		      if (!memcmp (name, "ppc", 3))
+			{
+			  name += 3;
+			  if (!name[0])
+			    name = NULL;
+			}
+		    }
+		  platform = name;
+		  break;
+		}
 
 	      default:
 		break;
 	      }
 	}
     }
-  return NULL;
+  auxv_read = true;
+}
+
+static const char *
+elf_platform (void)
+{
+  elf_auxv ();
+  return platform;
+}
+
+static bool
+elf_float (void)
+{
+  elf_auxv ();
+  return hard_float;
 }
 
 /* Returns AT_PLATFORM if present, otherwise generic 32.  */
@@ -520,6 +563,14 @@
   return concat (cache, "-m", argv[0], "=", cpu, " ", options, NULL);
 }
 
+const char *
+host_detect_local_float (int argc ATTRIBUTE_UNUSED,
+			 const char **argv ATTRIBUTE_UNUSED)
+{
+  return elf_float () ? "-mhard-float" : "-msoft-float";
+}
+
+
 #else /* GCC_VERSION */
 
 /* If we aren't compiling with GCC we just provide a minimal
@@ -543,5 +594,12 @@
   return concat ("-m", argv[0], "=", cpu, NULL);
 }
 
+const char *
+host_detect_local_float (int argc ATTRIBUTE_UNUSED,
+			 const char **argv ATTRIBUTE_UNUSED)
+{
+  return NULL;
+}
+
 #endif /* GCC_VERSION */
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: e500mc.h
diff -ru ./gcc/config/rs6000/eabi-ci.asm /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/eabi-ci.asm
--- ./gcc/config/rs6000/eabi-ci.asm	2014-06-06 11:50:16.371598632 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/eabi-ci.asm	2012-03-29 18:03:07.000000000 +1000
@@ -98,6 +98,7 @@
 /* Head of __init function used for static constructors.  */
 	.section ".init","ax"
 	.align 2
+FUNC_START(_init)
 FUNC_START(__init)
 	stwu 1,-16(1)
 	mflr 0
@@ -106,6 +107,7 @@
 /* Head of __fini function used for static destructors.  */
 	.section ".fini","ax"
 	.align 2
+FUNC_START(_fini)
 FUNC_START(__fini)
 	stwu 1,-16(1)
 	mflr 0
diff -ru ./gcc/config/rs6000/eabi.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/eabi.h
--- ./gcc/config/rs6000/eabi.h	2014-06-06 11:50:16.371598632 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/eabi.h	2012-03-29 18:03:07.000000000 +1000
@@ -23,10 +23,6 @@
 #undef TARGET_DEFAULT
 #define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_EABI)
 
-/* Invoke an initializer function to set up the GOT.  */
-#define NAME__MAIN "__eabi"
-#define INVOKE__main
-
 #undef TARGET_VERSION
 #define TARGET_VERSION fprintf (stderr, " (PowerPC Embedded)");
 
@@ -42,3 +38,20 @@
       TARGET_OS_SYSV_CPP_BUILTINS ();     \
     }                                     \
   while (0)
+
+/* Add -te500v1 and -te500v2 options for convenience in generating
+   multilibs.  */
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC \
+  "%{te500v1: -mcpu=8540 -mfloat-gprs=single -mspe=yes -mabi=spe} " \
+  "%{te500v2: -mcpu=8548 -mfloat-gprs=double -mspe=yes -mabi=spe} " \
+  "%{te600: -mcpu=7400 -maltivec -mabi=altivec}"		    \
+  "%{te500mc: -mcpu=e500mc -maix-struct-return}"
+
+#undef ASM_DEFAULT_SPEC
+#define ASM_DEFAULT_SPEC			\
+  "%{te500v1:-mppc -mspe -me500 ;		\
+     te500v2:-mppc -mspe -me500 ;		\
+     te600:-mppc -maltivec ;			\
+     te500mc:-mppc -me500mc ;			\
+     :-mppc%{m64:64}}"
diff -ru ./gcc/config/rs6000/option-defaults.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/option-defaults.h
--- ./gcc/config/rs6000/option-defaults.h	2014-06-06 11:50:16.375598633 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/option-defaults.h	2012-03-29 18:03:07.000000000 +1000
@@ -58,7 +58,7 @@
   {"tune", "%{!mtune=*:%{!mcpu=*:-mtune=%(VALUE)}}" }, \
   {"tune_32", "%{" OPT_ARCH32 ":%{!mtune=*:%{!mcpu=*:-mtune=%(VALUE)}}}" }, \
   {"tune_64", "%{" OPT_ARCH64 ":%{!mtune=*:%{!mcpu=*:-mtune=%(VALUE)}}}" }, \
-  {"cpu", "%{!mcpu=*:-mcpu=%(VALUE)}" }, \
-  {"cpu_32", "%{" OPT_ARCH32 ":%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
-  {"cpu_64", "%{" OPT_ARCH64 ":%{!mcpu=*:-mcpu=%(VALUE)}}" }, \
+  {"cpu", "%{mcpu=*|te500mc|te500v1|te500v2|te600:;:-mcpu=%(VALUE)}" }, \
+  {"cpu_32", "%{" OPT_ARCH32 ":%{mcpu=*|te500mc|te500v1|te500v2|te600:;:-mcpu=%(VALUE)}}" }, \
+  {"cpu_64", "%{" OPT_ARCH64 ":%{mcpu=*|te500mc|te500v1|te500v2|te600:;:-mcpu=%(VALUE)}}" }, \
   {"float", "%{!msoft-float:%{!mhard-float:-m%(VALUE)-float}}" }
diff -ru ./gcc/config/rs6000/rs6000-builtin.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000-builtin.def
--- ./gcc/config/rs6000/rs6000-builtin.def	2014-06-06 11:50:16.375598633 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000-builtin.def	2012-03-29 18:03:07.000000000 +1000
@@ -1018,3 +1018,68 @@
 
 /* Darwin CfString builtin.  */
 RS6000_BUILTIN(RS6000_BUILTIN_CFSTRING,			RS6000_BTC_MISC)
+
+/* ISEL builtins.  */
+/* Generic versions that get resolved to specific builtins.  */
+RS6000_BUILTIN(RS6000_BUILTIN_ISELEQ,			RS6000_BTC_PURE)
+RS6000_BUILTIN_EQUATE(ISEL_BUILTIN_OVERLOADED_FIRST,
+		      RS6000_BUILTIN_ISELEQ)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELGT,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELLT,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELGTU,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELLTU,			RS6000_BTC_PURE)
+/* Same deal, but for 64-bit comparisons.  */
+RS6000_BUILTIN(RS6000_BUILTIN_ISELEQD,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELGTD,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELLTD,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELGTDU,			RS6000_BTC_PURE)
+RS6000_BUILTIN(RS6000_BUILTIN_ISELLTDU,			RS6000_BTC_PURE)
+RS6000_BUILTIN_EQUATE(ISEL_BUILTIN_OVERLOADED_LAST,
+		      RS6000_BUILTIN_ISELLTDU)
+
+/* Each set of arguments is polymorphic in selected arguments and return
+   value.  */
+#undef RS6000_ISEL_BASE
+#define RS6000_ISEL_BASE(ARG, PRED, CMP)					\
+  RS6000_BUILTIN(RS6000_BUILTIN_ISEL_##PRED##CMP##_##ARG##_SS, RS6000_BTC_PURE) \
+  RS6000_BUILTIN(RS6000_BUILTIN_ISEL_##PRED##CMP##_##ARG##_PP, RS6000_BTC_PURE) \
+  RS6000_BUILTIN(RS6000_BUILTIN_ISEL_##PRED##CMP##_##ARG##_UU, RS6000_BTC_PURE)
+#undef RS6000_ISEL_PTR_ARG
+#define RS6000_ISEL_PTR_ARG(PRED, CMP) RS6000_ISEL_BASE(PP, PRED, CMP)
+#undef RS6000_ISEL_SIGNED_ARG
+#define RS6000_ISEL_SIGNED_ARG(PRED, CMP) RS6000_ISEL_BASE(SS, PRED, CMP)
+#undef RS6000_ISEL_UNSIGNED_ARG
+#define RS6000_ISEL_UNSIGNED_ARG(PRED, CMP) RS6000_ISEL_BASE(UU, PRED, CMP)
+
+#undef RS6000_ISEL_EQ
+#define RS6000_ISEL_EQ(CMP)			\
+  RS6000_ISEL_PTR_ARG(EQ, CMP)			\
+  RS6000_ISEL_SIGNED_ARG(EQ, CMP)		\
+  RS6000_ISEL_UNSIGNED_ARG(EQ, CMP)
+
+#undef RS6000_ISEL_LT
+#define RS6000_ISEL_LT(CMP) RS6000_ISEL_SIGNED_ARG(LT, CMP)
+
+#undef RS6000_ISEL_GT
+#define RS6000_ISEL_GT(CMP) RS6000_ISEL_SIGNED_ARG(GT, CMP)
+
+#undef RS6000_ISEL_LTU
+#define RS6000_ISEL_LTU(CMP)			\
+  RS6000_ISEL_PTR_ARG(LTU, CMP)			\
+  RS6000_ISEL_UNSIGNED_ARG(LTU, CMP)
+
+#undef RS6000_ISEL_GTU
+#define RS6000_ISEL_GTU(CMP)			\
+  RS6000_ISEL_PTR_ARG(GTU, CMP)			\
+  RS6000_ISEL_UNSIGNED_ARG(GTU, CMP)
+
+RS6000_ISEL_EQ(CMPW)
+RS6000_ISEL_LT(CMPW)
+RS6000_ISEL_GT(CMPW)
+RS6000_ISEL_LTU(CMPW)
+RS6000_ISEL_GTU(CMPW)
+RS6000_ISEL_EQ(CMPD)
+RS6000_ISEL_LT(CMPD)
+RS6000_ISEL_GT(CMPD)
+RS6000_ISEL_LTU(CMPD)
+RS6000_ISEL_GTU(CMPD)
diff -ru ./gcc/config/rs6000/rs6000.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000.c
--- ./gcc/config/rs6000/rs6000.c	2014-06-06 14:25:27.342150547 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000.c	2012-04-03 17:46:44.000000000 +1000
@@ -1213,6 +1213,7 @@
 static void rs6000_conditional_register_usage (void);
 static void rs6000_trampoline_init (rtx, tree, rtx);
 static bool rs6000_cannot_force_const_mem (rtx);
+static void rs6000_code_end (void) ATTRIBUTE_UNUSED;
 
 /* Hash table stuff for keeping track of TOC entries.  */
 
@@ -1667,7 +1668,6 @@
 #undef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION rs6000_set_current_function
 
-struct gcc_target targetm = TARGET_INITIALIZER;
 
 
 /* Simplifications for entries below.  */
@@ -1785,6 +1785,10 @@
    | MASK_ISEL},
   {"e500mc64", PROCESSOR_PPCE500MC64, POWERPC_BASE_MASK | MASK_POWERPC64
    | MASK_PPC_GFXOPT | MASK_ISEL},
+  /* Freescale changed the name of the e500mc64 right before
+     release.  */
+  {"e5500", PROCESSOR_PPCE500MC64, POWERPC_BASE_MASK | MASK_POWERPC64
+   | MASK_PPC_GFXOPT | MASK_ISEL},
   {"860", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},
   {"970", PROCESSOR_POWER4,
    POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},
@@ -2705,6 +2709,9 @@
   set_masks &= ~target_flags_explicit;
 
   /* Identify the processor type.  */
+  if (default_cpu && !strcmp (default_cpu, "native"))
+    default_cpu = 0;
+  
   if (!default_cpu)
     {
       if (TARGET_POWERPC64)
@@ -3387,6 +3394,11 @@
     target_option_default_node = target_option_current_node
       = build_target_option_node ();
 
+  /* If not explicitly specified via option, decide whether to generate the
+     extra blr's required to preserve the link stack on some cpus (eg, 476).  */
+  if (TARGET_LINK_STACK == -1)
+    SET_TARGET_LINK_STACK (rs6000_cpu == PROCESSOR_PPC476 && flag_pic);
+
   return ret;
 }
 
@@ -4663,6 +4675,8 @@
   if ((TARGET_DEFAULT ^ target_flags) & MASK_64BIT)
     default_cpu = 0;
 #endif
+  if (default_cpu && !strcmp (default_cpu, "native"))
+    default_cpu = 0;
 
   if (flag_verbose_asm)
     {
@@ -6536,6 +6550,8 @@
 		  lab = gen_label_rtx ();
 		  emit_insn (gen_load_toc_v4_PIC_1b (gsym, lab));
 		  emit_move_insn (tmp1, gen_rtx_REG (Pmode, LR_REGNO));
+		  if (TARGET_LINK_STACK)
+		    emit_insn (gen_addsi3 (tmp1, tmp1, GEN_INT (4)));
 		  emit_move_insn (tmp2, mem);
 		  last = emit_insn (gen_addsi3 (got, tmp1, tmp2));
 		  set_unique_reg_note (last, REG_EQUAL, gsym);
@@ -7234,16 +7250,19 @@
   if (TARGET_ALTIVEC || TARGET_VSX)
     global_regs[VSCR_REGNO] = 1;
 
-  if (TARGET_ALTIVEC_ABI)
-    {
-      for (i = FIRST_ALTIVEC_REGNO; i < FIRST_ALTIVEC_REGNO + 20; ++i)
-	call_used_regs[i] = call_really_used_regs[i] = 1;
+  /* If we are not using the AltiVec ABI, pretend that the normally
+     call-saved registers are also call-used.  We could use them
+     normally if we saved and restored them in the prologue; that
+     would require using the alignment padding around the register
+     save area, and some care with unwinding information.  */
+  if (! TARGET_ALTIVEC_ABI)
+    for (i = FIRST_ALTIVEC_REGNO + 20; i <= LAST_ALTIVEC_REGNO; ++i)
+      call_used_regs[i] = call_really_used_regs[i] = 1;
 
-      /* AIX reserves VR20:31 in non-extended ABI mode.  */
-      if (TARGET_XCOFF)
-	for (i = FIRST_ALTIVEC_REGNO + 20; i < FIRST_ALTIVEC_REGNO + 32; ++i)
-	  fixed_regs[i] = call_used_regs[i] = call_really_used_regs[i] = 1;
-    }
+  if (TARGET_ALTIVEC_ABI && TARGET_XCOFF)
+    /* AIX reserves VR20:31 in non-extended ABI mode.  */
+    for (i = FIRST_ALTIVEC_REGNO + 20; i < FIRST_ALTIVEC_REGNO + 32; ++i)
+      fixed_regs[i] = call_used_regs[i] = call_really_used_regs[i] = 1;
 }
 
 /* Try to output insns to set TARGET equal to the constant C if it can
@@ -12418,6 +12437,289 @@
   return target;
 }
 
+/* isel builtins are a bit funny, because we want the user to be able to do:
+
+   char *p, *q, *r;
+   int x, y, z;
+   unsigned int a, b, c;
+   ...
+   p = __builtin_iseleq (i, j, q, r);
+   x = __builtin_iseleq (i, j, y, z);
+   a = __builtin_iseleq (i, j, b, c);
+
+   and, of course, i and j may be of several different types depending on the
+   condition.
+
+   We handle this by having generic builtins that
+   TARGET_RESOLVE_OVERLOADED_BUILTIN takes and turns into calls to our
+   specific builtins.  */
+
+/* Macros to help constructing the isel_builtin_desc arrays.
+   These closely mirror the macros in rs6000-builtins.def.  */
+/* HACK: Use VOIDmode here as a constant approximation to Pmode and fix
+   at runtime.  We can't use Pmode because in biarch its definition is
+   not constant.  */
+#define ISEL_Pmode VOIDmode
+#define ISEL_BASE(FLAGS, ARG, RESULT, PRED, CMP, MODE, RMODE)		\
+  { NULL, FLAGS, RS6000_BUILTIN_ISEL_##PRED##CMP##_##ARG##_##RESULT,	\
+      PRED, MODE, RMODE },
+#define ISEL_P_RESULT(FLAGS, ARG, PRED, CMP, MODE, RMODE)		\
+  ISEL_BASE (FLAGS | ISEL_FLAG_SEL_PTR, ARG, PP, PRED,		\
+	     CMP, MODE, ISEL_Pmode)
+#define ISEL_S_RESULT(FLAGS, ARG, PRED, CMP, MODE, RMODE)		\
+  ISEL_BASE (FLAGS | ISEL_FLAG_SEL_SIGNED, ARG, SS, PRED,		\
+	     CMP, MODE, RMODE)
+#define ISEL_U_RESULT(FLAGS, ARG, PRED, CMP, MODE, RMODE)		\
+  ISEL_BASE (FLAGS | ISEL_FLAG_SEL_UNSIGNED, ARG, UU, PRED,		\
+	     CMP, MODE, RMODE)
+
+#define ISEL_EXPAND_ARG(FLAG, ARG, PRED, CMP, MODE, RMODE)		\
+  ISEL_P_RESULT (FLAG, ARG, PRED, CMP, MODE, RMODE)		\
+  ISEL_S_RESULT (FLAG, ARG, PRED, CMP, MODE, RMODE)		\
+  ISEL_U_RESULT (FLAG, ARG, PRED, CMP, MODE, RMODE)
+#define ISEL_PTR_ARG(PRED, CMP, MODE)				\
+  ISEL_EXPAND_ARG (ISEL_FLAG_CMP_PTR, PP, PRED, CMP, ISEL_Pmode, MODE)
+#define ISEL_SIGNED_ARG(PRED, CMP, MODE)			\
+  ISEL_EXPAND_ARG (ISEL_FLAG_CMP_SIGNED, SS, PRED, CMP, MODE, MODE)
+#define ISEL_UNSIGNED_ARG(PRED, CMP, MODE)			\
+  ISEL_EXPAND_ARG (ISEL_FLAG_CMP_UNSIGNED, UU, PRED, CMP, MODE, MODE)
+
+#define ISEL_EQ(CMP, MODE)					\
+  ISEL_PTR_ARG (EQ, CMP, MODE)					\
+  ISEL_SIGNED_ARG (EQ, CMP, MODE)				\
+  ISEL_UNSIGNED_ARG (EQ, CMP, MODE)
+#define ISEL_LT(CMP, MODE) ISEL_SIGNED_ARG (LT, CMP, MODE)
+#define ISEL_GT(CMP, MODE) ISEL_SIGNED_ARG (GT, CMP, MODE)
+#define ISEL_LTU(CMP, MODE)					\
+  ISEL_PTR_ARG (LTU, CMP, MODE)					\
+  ISEL_UNSIGNED_ARG (LTU, CMP, MODE)
+#define ISEL_GTU(CMP, MODE)					\
+  ISEL_PTR_ARG (GTU, CMP, MODE)					\
+  ISEL_UNSIGNED_ARG (GTU, CMP, MODE)
+
+const struct isel_builtin_desc builtin_iselw[32] = {
+  ISEL_EQ (CMPW, SImode)
+  ISEL_LT (CMPW, SImode)
+  ISEL_GT (CMPW, SImode)
+  ISEL_LTU (CMPW, SImode)
+  ISEL_GTU (CMPW, SImode)
+  { "__builtin_iseleq", 0, RS6000_BUILTIN_ISELEQ, EQ, SImode, SImode },
+  { "__builtin_isellt", 0, RS6000_BUILTIN_ISELLT, LT, SImode, SImode },
+  { "__builtin_iselgt", 0, RS6000_BUILTIN_ISELGT, GT, SImode, SImode },
+  { "__builtin_iselltu", 0, RS6000_BUILTIN_ISELLTU, LTU, SImode, SImode },
+  { "__builtin_iselgtu", 0, RS6000_BUILTIN_ISELGTU, GTU, SImode, SImode }
+};
+
+const struct isel_builtin_desc builtin_iseld[32] = {
+  ISEL_EQ (CMPD, DImode)
+  ISEL_LT (CMPD, DImode)
+  ISEL_GT (CMPD, DImode)
+  ISEL_LTU (CMPD, DImode)
+  ISEL_GTU (CMPD, DImode)
+  { "__builtin_isel64eq", 0, RS6000_BUILTIN_ISELEQD, EQ, DImode, DImode },
+  { "__builtin_isel64lt", 0, RS6000_BUILTIN_ISELLTD, LT, DImode, DImode },
+  { "__builtin_isel64gt", 0, RS6000_BUILTIN_ISELGTD, GT, DImode, DImode },
+  { "__builtin_isel64ltu", 0, RS6000_BUILTIN_ISELLTDU, LTU, DImode, DImode },
+  { "__builtin_isel64gtu", 0, RS6000_BUILTIN_ISELGTDU, GTU, DImode, DImode }
+};
+
+/* Return the mode which DESC uses for comparisons.  */
+
+static enum machine_mode
+isel_cmp_mode (const struct isel_builtin_desc *desc)
+{
+  enum machine_mode mode = (enum machine_mode) desc->cmp_mode;
+
+  return (mode == VOIDmode ? Pmode : mode);
+}
+
+/* Return the mode in which DESC selects arguments.  */
+
+static enum machine_mode
+isel_sel_mode (const struct isel_builtin_desc *desc)
+{
+  enum machine_mode mode = (enum machine_mode) desc->sel_mode;
+
+  return (mode == VOIDmode ? Pmode : mode);
+}
+
+/* Return a tree describing the arguments for DESC according to CMPP:
+   true for comparison arguments, false for select arguments.  */
+
+static tree
+isel_argtype (const struct isel_builtin_desc *desc, bool cmpp)
+{
+  switch (desc->arg_flags & (cmpp
+			     ? ISEL_FLAG_CMP_MASK
+			     : ISEL_FLAG_SEL_MASK))
+    {
+    case ISEL_FLAG_CMP_PTR:
+    case ISEL_FLAG_SEL_PTR:
+      return ptr_type_node;
+    case ISEL_FLAG_CMP_SIGNED:
+      return (isel_cmp_mode (desc) == SImode
+	      ? integer_type_node
+	      : long_integer_type_node);
+    case ISEL_FLAG_SEL_SIGNED:
+      return (isel_sel_mode (desc) == SImode
+	      ? integer_type_node
+	      : long_integer_type_node);
+    case ISEL_FLAG_CMP_UNSIGNED:
+      return (isel_cmp_mode (desc) == SImode
+	      ? unsigned_type_node
+	      : long_unsigned_type_node);
+    case ISEL_FLAG_SEL_UNSIGNED:
+    default:
+      return (isel_sel_mode (desc) == SImode
+	      ? unsigned_type_node
+	      : long_unsigned_type_node);
+    }
+}
+
+/* Return a mnemonic string describing the argument or result of FLAGS
+   depending on CMPP.  */
+
+static const char *
+isel_strdesc (int flags, bool cmpp)
+{
+  switch (flags & (cmpp ? ISEL_FLAG_CMP_MASK : ISEL_FLAG_SEL_MASK))
+    {
+    case ISEL_FLAG_CMP_PTR:
+    case ISEL_FLAG_SEL_PTR:
+      return "p";
+    case ISEL_FLAG_CMP_SIGNED:
+    case ISEL_FLAG_SEL_SIGNED:
+      return "s";
+    case ISEL_FLAG_CMP_UNSIGNED:
+    case ISEL_FLAG_SEL_UNSIGNED:
+      return "u";
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Initialize N_DESC isel builtins from DESC.  SIGNED_TYPE holds the
+   basic type for signed variants of isel, UNSIGNED_TYPE the type for
+   unsigned variants.  */
+
+static void
+rs6000_init_isel_builtins (const struct isel_builtin_desc *desc, int n_descs)
+{
+  int i;
+  const char *is64 = (desc == &builtin_iselw[0] ? "32" : "64");
+
+  for (i = 0; i < n_descs; i++)
+    {
+      const struct isel_builtin_desc *d = &desc[i];
+      tree cmptype, seltype, ftype;
+
+      cmptype = isel_argtype (d, true);
+      seltype = isel_argtype (d, false);
+
+      ftype = build_function_type_list (seltype, cmptype, cmptype,
+					seltype, seltype, NULL_TREE);
+
+      if (d->name)
+	def_builtin (MASK_ISEL, d->name, ftype, d->code);
+      else
+	{
+	  char builtin_name[40];
+
+	  sprintf (builtin_name, "__builtin_isel%s%s%s%s%s%s",
+		   is64,
+		   GET_RTX_NAME (d->cmp_code),
+		   GET_MODE_NAME (isel_cmp_mode (d)),
+		   isel_strdesc (d->arg_flags, true),
+		   isel_strdesc (d->arg_flags, false),
+		   GET_MODE_NAME (isel_sel_mode (d)));
+
+	  def_builtin (MASK_ISEL, ggc_strdup (builtin_name), ftype, d->code);
+	}
+    }
+}
+
+static rtx
+rs6000_expand_isel_builtin (const struct isel_builtin_desc *desc,
+			    int n_descs, tree exp, rtx target, int fcode)
+{
+  int i;
+
+  for (i = 0; i < n_descs; i++)
+    {
+      const struct isel_builtin_desc *d = &desc[i];
+
+      if (fcode == (int) d->code)
+	{
+	  int opidx;
+	  unsigned int j;
+	  rtx cmp;
+	  rtx operands[4];
+	  enum insn_code icode;
+	  enum machine_mode opmode;
+	  enum machine_mode cmpmode = isel_cmp_mode (d);
+	  enum machine_mode selmode = isel_sel_mode (d);
+
+	  /* Determine underlying isel insn.  */
+	  switch (d->cmp_code)
+	    {
+	    case GTU:
+	    case LTU:
+	      icode = (Pmode == SImode
+		       ? CODE_FOR_isel_unsigned_si
+		       : CODE_FOR_isel_unsigned_di);
+	      break;
+	    default:
+	      icode = (Pmode == SImode
+		       ? CODE_FOR_isel_signed_si
+		       : CODE_FOR_isel_signed_di);
+	      break;
+	    }
+
+	  for (j = 0; j < ARRAY_SIZE (operands); j++)
+	    {
+	      tree arg = CALL_EXPR_ARG (exp, j);
+
+	      /* If we got invalid arguments, bail out before generating
+		 bad rtl.  */
+	      if (arg == error_mark_node)
+		return const0_rtx;
+
+	      operands[j] = expand_normal (arg);
+
+	      /* Validate.  */
+	      /* HACK: The isel pattern doesn't actually consume all the
+		 operands to the builtin; it only consumes 2 and 3.  The
+		 other two will be handed off to a compare
+		 insn. Unfortunately, said insn is not named, so we
+		 can't directly access its insn_data here.  Fake it by
+		 validating operands 0 and 1 with the isel pattern; that
+		 should be good enough.  */
+	      opidx = (j < 2 ? 2 : j);
+	      opmode = (j < 2 ? cmpmode : selmode);
+	      if (! (*insn_data[icode].operand[opidx].predicate) (operands[j],
+								  opmode))
+		operands[j] = copy_to_mode_reg (opmode, operands[j]);
+	    }
+
+	  /* Validate target.  */
+	  if (target == NULL_RTX
+	      || GET_MODE (target) != selmode
+	      || ! (*insn_data[icode].operand[0].predicate) (target, selmode))
+	    target = gen_reg_rtx (selmode);
+
+	  /* Generate comparison.  */
+	  cmp = gen_rtx_fmt_ee (d->cmp_code, cmpmode,
+				operands[0], operands[1]);
+
+	  rs6000_emit_int_cmove (target, cmp, operands[2], operands[3]);
+
+	  return target;
+	}
+    }
+
+  return NULL_RTX;
+}
+
 /* Expand an expression EXP that calls a built-in function,
    with result going to TARGET if that's convenient
    (and in mode MODE if that's convenient).
@@ -12536,6 +12838,24 @@
       if (success)
 	return ret;
     }  
+  if (TARGET_ISEL)
+    {
+      ret = rs6000_expand_isel_builtin (builtin_iselw,
+					ARRAY_SIZE (builtin_iselw),
+					exp, target, fcode);
+
+      if (ret != NULL_RTX)
+	return ret;
+    }
+  if (TARGET_ISEL64)
+    {
+      ret = rs6000_expand_isel_builtin (builtin_iseld,
+					ARRAY_SIZE (builtin_iseld),
+					exp, target, fcode);
+
+      if (ret != NULL_RTX)
+	return ret;
+    }
 
   gcc_assert (TARGET_ALTIVEC || TARGET_VSX || TARGET_SPE || TARGET_PAIRED_FLOAT);
 
@@ -12754,6 +13074,10 @@
     spe_init_builtins ();
   if (TARGET_ALTIVEC)
     altivec_init_builtins ();
+  if (TARGET_ISEL)
+    rs6000_init_isel_builtins (builtin_iselw, ARRAY_SIZE (builtin_iselw));
+  if (TARGET_ISEL64)
+    rs6000_init_isel_builtins (builtin_iseld, ARRAY_SIZE (builtin_iseld));
   if (TARGET_ALTIVEC || TARGET_SPE || TARGET_PAIRED_FLOAT || TARGET_VSX)
     rs6000_common_init_builtins ();
   if (TARGET_FRE)
@@ -14095,7 +14419,8 @@
       else if (bytes >= 8 && TARGET_POWERPC64
 	       /* 64-bit loads and stores require word-aligned
 		  displacements.  */
-	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)))
+	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)
+		   || rs6000_cpu == PROCESSOR_PPCE500MC64))
 	{
 	  clear_bytes = 8;
 	  mode = DImode;
@@ -14228,7 +14553,8 @@
       else if (bytes >= 8 && TARGET_POWERPC64
 	       /* 64-bit loads and stores require word-aligned
 		  displacements.  */
-	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)))
+	       && (align >= 64 || (!STRICT_ALIGNMENT && align >= 32)
+		   || rs6000_cpu == PROCESSOR_PPCE500MC64))
 	{
 	  move_bytes = 8;
 	  mode = DImode;
@@ -19454,6 +19780,8 @@
 	  lab = gen_label_rtx ();
 	  emit_insn (gen_load_toc_v4_PIC_1b (tocsym, lab));
 	  emit_move_insn (dest, gen_rtx_REG (Pmode, LR_REGNO));
+	  if (TARGET_LINK_STACK)
+	    emit_insn (gen_addsi3 (dest, dest, GEN_INT (4)));
 	  emit_move_insn (temp0, gen_rtx_MEM (Pmode, dest));
 	}
       emit_insn (gen_addsi3 (dest, temp0, dest));
@@ -20282,7 +20610,7 @@
   p = rtvec_alloc ((lr ? 4 : 3) + n_regs);
 
   if (!savep && lr)
-    RTVEC_ELT (p, offset++) = gen_rtx_RETURN (VOIDmode);
+    RTVEC_ELT (p, offset++) = ret_rtx;
 
   RTVEC_ELT (p, offset++)
     = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 65));
@@ -21270,7 +21598,7 @@
       alloc_rname = ggc_strdup (rname);
 
       j = 0;
-      RTVEC_ELT (p, j++) = gen_rtx_RETURN (VOIDmode);
+      RTVEC_ELT (p, j++) = ret_rtx;
       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,
 					gen_rtx_REG (Pmode,
 						     LR_REGNO));
@@ -21885,7 +22213,7 @@
       else
 	p = rtvec_alloc (2);
 
-      RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);
+      RTVEC_ELT (p, 0) = ret_rtx;
       RTVEC_ELT (p, 1) = ((restoring_FPRs_inline || !lr)
 			  ? gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 65))
 			  : gen_rtx_CLOBBER (VOIDmode,
@@ -22323,7 +22651,7 @@
 			gen_rtx_USE (VOIDmode,
 				     gen_rtx_REG (SImode,
 						  LR_REGNO)),
-			gen_rtx_RETURN (VOIDmode))));
+			ret_rtx)));
   SIBLING_CALL_P (insn) = 1;
   emit_barrier ();
 
@@ -23046,7 +23374,15 @@
 	}
       else if (TARGET_SECURE_PLT && flag_pic)
 	{
-	  asm_fprintf (file, "\tbcl 20,31,1f\n1:\n\t{st|stw} %s,4(%s)\n",
+	  if (TARGET_LINK_STACK)
+	    {
+	      char name[32];
+	      get_ppc476_thunk_name (name);
+	      asm_fprintf (file, "\tbl %s\n", name);
+	    }
+	  else
+	    asm_fprintf (file, "\tbcl 20,31,1f\n1:\n");
+	  asm_fprintf (file, "\t{st|stw} %s,4(%s)\n",
 		       reg_names[0], reg_names[1]);
 	  asm_fprintf (file, "\tmflr %s\n", reg_names[12]);
 	  asm_fprintf (file, "\t{cau|addis} %s,%s,",
@@ -23071,10 +23407,24 @@
 	  asm_fprintf (file, "\t{st|stw} %s,4(%s)\n",
 		       reg_names[0], reg_names[1]);
 	  /* Now, we need to get the address of the label.  */
-	  fputs ("\tbcl 20,31,1f\n\t.long ", file);
-	  assemble_name (file, buf);
-	  fputs ("-.\n1:", file);
-	  asm_fprintf (file, "\tmflr %s\n", reg_names[11]);
+	  if (TARGET_LINK_STACK)
+	    {
+	      char name[32];
+	      get_ppc476_thunk_name (name);
+	      asm_fprintf (file, "\tbl %s\n\tb 1f\n\t.long ", name);
+	      assemble_name (file, buf);
+	      fputs ("-.\n1:", file);
+	      asm_fprintf (file, "\tmflr %s\n", reg_names[11]);
+	      asm_fprintf (file, "\taddi %s,%s,4\n",
+			   reg_names[11], reg_names[11]);
+	    }
+	  else
+	    {
+	      fputs ("\tbcl 20,31,1f\n\t.long ", file);
+	      assemble_name (file, buf);
+	      fputs ("-.\n1:", file);
+	      asm_fprintf (file, "\tmflr %s\n", reg_names[11]);
+	    }
 	  asm_fprintf (file, "\t{l|lwz} %s,0(%s)\n",
 		       reg_names[0], reg_names[11]);
 	  asm_fprintf (file, "\t{cax|add} %s,%s,%s\n",
@@ -25552,11 +25902,24 @@
 #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
       if (flag_pic)
 	{
-	  strcat (tmp_buf, ":\n\tmflr r0\n\tbcl 20,31,");
-	  strcat (tmp_buf, label);
-	  strcat (tmp_buf, "_pic\n");
-	  strcat (tmp_buf, label);
-	  strcat (tmp_buf, "_pic:\n\tmflr r11\n");
+	  if (TARGET_LINK_STACK)
+	    {
+	      char name[32];
+	      get_ppc476_thunk_name (name);
+	      strcat (tmp_buf, ":\n\tmflr r0\n\tbl ");
+	      strcat (tmp_buf, name);
+	      strcat (tmp_buf, "\n");
+	      strcat (tmp_buf, label);
+	      strcat (tmp_buf, "_pic:\n\tmflr r11\n");
+	    }
+	  else
+	    {
+	      strcat (tmp_buf, ":\n\tmflr r0\n\tbcl 20,31,");
+	      strcat (tmp_buf, label);
+	      strcat (tmp_buf, "_pic\n");
+	      strcat (tmp_buf, label);
+	      strcat (tmp_buf, "_pic:\n\tmflr r11\n");
+	    }
 
 	  strcat (tmp_buf, "\taddis r11,r11,ha16(");
 	  strcat (tmp_buf, name_buf);
@@ -25702,8 +26065,18 @@
       sprintf (local_label_0, "\"L%011d$spb\"", label);
 
       fprintf (file, "\tmflr r0\n");
-      fprintf (file, "\tbcl 20,31,%s\n", local_label_0);
-      fprintf (file, "%s:\n\tmflr r11\n", local_label_0);
+      if (TARGET_LINK_STACK)
+	{
+	  char name[32];
+	  get_ppc476_thunk_name (name);
+	  fprintf (file, "\tbl %s\n", name);
+	  fprintf (file, "%s:\n\tmflr r11\n", local_label_0);
+	}
+      else
+	{
+	  fprintf (file, "\tbcl 20,31,%s\n", local_label_0);
+	  fprintf (file, "%s:\n\tmflr r11\n", local_label_0);
+	}
       fprintf (file, "\taddis r11,r11,ha16(%s-%s)\n",
 	       lazy_ptr_name, local_label_0);
       fprintf (file, "\tmtlr r0\n");
@@ -28250,4 +28623,79 @@
 }
 
 
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
+/* Fills in the label name that should be used for a 476 link stack thunk.  */
+
+void
+get_ppc476_thunk_name (char name[32])
+{
+  gcc_assert (TARGET_LINK_STACK);
+
+  if (USE_HIDDEN_LINKONCE)
+    sprintf (name, "__ppc476.get_thunk");
+  else
+    ASM_GENERATE_INTERNAL_LABEL (name, "LPPC476_", 0);
+}
+
+/* This function emits the simple thunk routine that is used to preserve
+   the link stack on the 476 cpu.  */
+
+static void
+rs6000_code_end (void)
+{
+  char name[32];
+  tree decl;
+
+  if (!TARGET_LINK_STACK)
+    return;
+
+  get_ppc476_thunk_name (name);
+
+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL, get_identifier (name),
+		     build_function_type_list (void_type_node, NULL_TREE));
+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
+				   NULL_TREE, void_type_node);
+  TREE_PUBLIC (decl) = 1;
+  TREE_STATIC (decl) = 1;
+
+  if (USE_HIDDEN_LINKONCE)
+    {
+      DECL_COMDAT_GROUP (decl) = DECL_ASSEMBLER_NAME (decl);
+      targetm.asm_out.unique_section (decl, 0);
+      switch_to_section (get_named_section (decl, NULL, 0));
+      DECL_WEAK (decl) = 1;
+      ASM_WEAKEN_DECL (asm_out_file, decl, name, 0);
+      targetm.asm_out.globalize_label (asm_out_file, name);
+      targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);
+      ASM_DECLARE_FUNCTION_NAME (asm_out_file, name, decl);
+    }
+  else
+    {
+      switch_to_section (text_section);
+      ASM_OUTPUT_LABEL (asm_out_file, name);
+    }
+
+  DECL_INITIAL (decl) = make_node (BLOCK);
+  current_function_decl = decl;
+  init_function_start (decl);
+  first_function_block_is_cold = false;
+  /* Make sure unwind info is emitted for the thunk if needed.  */
+  final_start_function (emit_barrier (), asm_out_file, 1);
+
+  fputs ("\tblr\n", asm_out_file);
+
+  final_end_function ();
+  init_insn_lengths ();
+  free_after_compilation (cfun);
+  set_cfun (NULL);
+  current_function_decl = NULL;
+}
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
 #include "gt-rs6000.h"
diff -ru ./gcc/config/rs6000/rs6000-c.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000-c.c
--- ./gcc/config/rs6000/rs6000-c.c	2014-06-06 11:50:16.387598633 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000-c.c	2012-03-29 18:03:07.000000000 +1000
@@ -3439,7 +3439,7 @@
 /* Implementation of the resolve_overloaded_builtin target hook, to
    support Altivec's overloaded builtins.  */
 
-tree
+static tree
 altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,
 				    void *passed_arglist)
 {
@@ -3770,3 +3770,148 @@
   error ("invalid parameter combination for AltiVec intrinsic");
   return error_mark_node;
 }
+
+/* Return true if the pair of arguments in ARGS is acceptable according
+   to DECLTYPES and FLAGS.  CMPP determines whether this is for the
+   comparison arguments.  */
+
+static bool
+isel_arguments_valid (tree *args, tree *decltypes, int flags, bool cmpp)
+{
+  tree type0 = TREE_TYPE (args[0]);
+  tree type1 = TREE_TYPE (args[1]);
+  tree decltype0 = decltypes[0];
+  tree decltype1 = decltypes[1];
+
+  switch (flags & (cmpp ? ISEL_FLAG_CMP_MASK : ISEL_FLAG_SEL_MASK))
+    {
+      /* For pointer arguments and results, we just need to make sure
+	 we're receiving pointers, and they can be freely converted to
+	 and from void *.  For pointer results, we also need to ensure
+	 that the types of the passed arguments are compatible: this is
+	 similar to what the ?: construct would need to ensure.  */
+    case ISEL_FLAG_CMP_PTR:
+    case ISEL_FLAG_SEL_PTR:
+      {
+	/* Results compatible with each other?  */
+	if (!lang_hooks.types_compatible_p (type0, type1))
+	  return false;
+
+	return (POINTER_TYPE_P (type0)
+		&& POINTER_TYPE_P (type1));
+      }
+      break;
+      /* For signed and unsigned arguments and results, we just need to
+	 make sure that the argument types are compatible with the
+	 declared types; we can insert conversions to make everything
+	 match up.  */
+    case ISEL_FLAG_CMP_SIGNED:
+    case ISEL_FLAG_SEL_SIGNED:
+    case ISEL_FLAG_CMP_UNSIGNED:
+    case ISEL_FLAG_SEL_UNSIGNED:
+      return (lang_hooks.types_compatible_p (type0, decltype0)
+	      && lang_hooks.types_compatible_p (type1, decltype1));
+    default:
+      ;
+    }
+
+  gcc_unreachable ();
+}
+
+/* Determine if FNDECL is a generic isel intrinsic and if it can be
+   resolved to a non-generic version with a proper type using the
+   descriptions found in DESC.  Return a call to the non-generic builtin
+   if so.  */
+
+static tree
+rs6000_resolve_isel_builtin (location_t loc, tree fndecl,
+			     void *passed_arglist,
+			     const struct isel_builtin_desc *desc,
+			     int n_descs)
+{
+  VEC(tree,gc) *arglist = (VEC(tree,gc) *) passed_arglist;
+  unsigned int nargs = VEC_length (tree, arglist);
+  int i;
+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);
+  const struct isel_builtin_desc *generic = NULL;
+
+  /* Is this even a builtin we care about?  */
+  if (fcode < ISEL_BUILTIN_OVERLOADED_FIRST
+      || fcode > ISEL_BUILTIN_OVERLOADED_LAST)
+    return NULL_TREE;
+
+  if (nargs != 4)
+    {
+      error ("isel intrinsics only accept 4 arguments");
+      return error_mark_node;
+    }
+
+  /* Find the generic builtin we're resolving.  */
+  for (i = 0; i < n_descs; i++)
+    if (desc[i].code == fcode)
+      {
+	generic = &desc[i];
+	break;
+      }
+
+  /* Happens if we're looking for a 64-bit builtin in the 32-bit
+     descriptors.  */
+  if (generic == NULL)
+    return NULL_TREE;
+
+  /* Try all the builtins whose comparison matches the generic one.  */
+  for (i = 0; i < n_descs; i++)
+    {
+      const struct isel_builtin_desc *d = &desc[i];
+      int j;
+      tree *argp = VEC_address (tree, arglist);
+      tree impl_fndecl;
+      tree decltypes[4], t;
+      tree converted_args[4];
+
+      if (d == generic || d->cmp_code != generic->cmp_code)
+	continue;
+
+      impl_fndecl = rs6000_builtin_decls[d->code];
+      t = TYPE_ARG_TYPES (TREE_TYPE (impl_fndecl));
+      for (j = 0 ; t != void_list_node; j++, t = TREE_CHAIN (t))
+	decltypes[j] = TREE_VALUE (t);
+
+      if (!isel_arguments_valid (argp, decltypes, d->arg_flags, true)
+	  || !isel_arguments_valid (argp+2, decltypes+2, d->arg_flags, false))
+	continue;
+
+      /* We got here, we're ok.  Build a new, resolved CALL_EXPR.  */
+      for (j = 0; j < 4; j++)
+	converted_args[j] = fold_convert (decltypes[j], argp[j]);
+
+      return build_call_expr_loc (loc, impl_fndecl, 4,
+				  converted_args[0], converted_args[1],
+				  converted_args[2], converted_args[3]);
+    }
+
+  error ("invalid parameter combination for isel intrinsic");
+  return error_mark_node;
+}
+
+tree
+rs6000_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)
+{
+  tree t;
+
+  t = altivec_resolve_overloaded_builtin (loc, fndecl, arglist);
+  if (t)
+    return t;
+
+  t = rs6000_resolve_isel_builtin (loc, fndecl, arglist,
+				   builtin_iselw, ARRAY_SIZE (builtin_iselw));
+  if (t)
+    return t;
+
+  t = rs6000_resolve_isel_builtin (loc, fndecl, arglist,
+				   builtin_iseld, ARRAY_SIZE (builtin_iseld));
+  if (t)
+    return t;
+
+  return NULL_TREE;
+}
diff -ru ./gcc/config/rs6000/rs6000.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000.h
--- ./gcc/config/rs6000/rs6000.h	2014-06-06 14:25:27.346150547 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000.h	2012-04-03 17:46:44.000000000 +1000
@@ -168,6 +168,7 @@
 %{mcpu=e300c3: -me300} \
 %{mcpu=e500mc: -me500mc} \
 %{mcpu=e500mc64: -me500mc64} \
+%{mcpu=e5500: -me500mc64} \
 %{maltivec: -maltivec} \
 %{mvsx: -mvsx %{!maltivec: -maltivec} %{!mcpu*: %(asm_cpu_power7)}} \
 -many"
@@ -194,6 +195,7 @@
   { "asm_cpu_native",		ASM_CPU_NATIVE_SPEC },			\
   { "asm_default",		ASM_DEFAULT_SPEC },			\
   { "cc1_cpu",			CC1_CPU_SPEC },				\
+  { "cc1_float",		CC1_FLOAT_SPEC },			\
   { "asm_cpu_power5",		ASM_CPU_POWER5_SPEC },			\
   { "asm_cpu_power6",		ASM_CPU_POWER6_SPEC },			\
   { "asm_cpu_power7",		ASM_CPU_POWER7_SPEC },			\
@@ -206,9 +208,12 @@
 #if defined(__powerpc__) || defined(__POWERPC__) || defined(_AIX)
 /* In driver-rs6000.c.  */
 extern const char *host_detect_local_cpu (int argc, const char **argv);
+extern const char *host_detect_local_float (int argc, const char **argv);
 #define EXTRA_SPEC_FUNCTIONS \
-  { "local_cpu_detect", host_detect_local_cpu },
+  { "local_cpu_detect", host_detect_local_cpu }, \
+  { "local_float_detect", host_detect_local_float },
 #define HAVE_LOCAL_CPU_DETECT
+#define HAVE_LOCAL_FLOAT_DETECT
 #define ASM_CPU_NATIVE_SPEC "%:local_cpu_detect(asm)"
 
 #else
@@ -225,7 +230,16 @@
 #endif
 #endif
 
-/* Architecture type.  */
+#ifndef CC1_FLOAT_SPEC
+#ifdef HAVE_LOCAL_FLOAT_DETECT
+#define CC1_FLOAT_SPEC \
+"%{mnative-float:%<mnative-float %:local_float_detect()}"
+#else
+#define CC1_FLOAT_SPEC ""
+#endif
+#endif
+
+  /* Architecture type.  */
 
 /* Define TARGET_MFCRF if the target assembler does not support the
    optional field operand for mfcr.  */
@@ -313,6 +327,14 @@
 #define HAVE_AS_TLS 0
 #endif
 
+#ifndef TARGET_LINK_STACK
+#define TARGET_LINK_STACK 0
+#endif
+
+#ifndef SET_TARGET_LINK_STACK
+#define SET_TARGET_LINK_STACK(X) do { } while (0)
+#endif
+
 /* Return 1 for a symbol ref for a thread-local storage symbol.  */
 #define RS6000_SYMBOL_REF_TLS_P(RTX) \
   (GET_CODE (RTX) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (RTX) != 0)
@@ -473,7 +495,8 @@
 			 || TARGET_POPCNTB	/* ISA 2.02 */ \
 			 || TARGET_CMPB		/* ISA 2.05 */ \
 			 || TARGET_POPCNTD	/* ISA 2.06 */ \
-			 || TARGET_XILINX_FPU)
+			 || TARGET_XILINX_FPU		       \
+			 || rs6000_cpu == PROCESSOR_PPCE500MC64)
 
 #define TARGET_FCTIDZ	TARGET_FCFID
 #define TARGET_STFIWX	TARGET_PPC_GFXOPT
@@ -485,8 +508,10 @@
 #define TARGET_FCTIDUZ	TARGET_POPCNTD
 #define TARGET_FCTIWUZ	TARGET_POPCNTD
 
-/* E500 processors only support plain "sync", not lwsync.  */
-#define TARGET_NO_LWSYNC TARGET_E500
+/* Some processors only support plain "sync", not lwsync.  */
+#define TARGET_NO_LWSYNC (TARGET_E500 \
+			  || rs6000_cpu == PROCESSOR_PPC440 \
+			  || rs6000_cpu == PROCESSOR_PPC603)
 
 /* Which machine supports the various reciprocal estimate instructions.  */
 #define TARGET_FRES	(TARGET_HARD_FLOAT && TARGET_PPC_GFXOPT \
@@ -535,7 +560,7 @@
 #define REGISTER_TARGET_PRAGMAS() do {				\
   c_register_pragma (0, "longcall", rs6000_pragma_longcall);	\
   targetm.target_option.pragma_parse = rs6000_pragma_target_parse; \
-  targetm.resolve_overloaded_builtin = altivec_resolve_overloaded_builtin; \
+  targetm.resolve_overloaded_builtin = rs6000_resolve_overloaded_builtin; \
 } while (0)
 
 /* Target #defines.  */
@@ -686,9 +711,16 @@
 
 /* A C expression to compute the alignment for a variables in the
    local store.  TYPE is the data type, and ALIGN is the alignment
-   that the object would ordinarily have.  */
-#define LOCAL_ALIGNMENT(TYPE, ALIGN)				\
-  DATA_ALIGNMENT (TYPE, ALIGN)
+   that the object would ordinarily have.  
+   Align most data using the DATA_ALIGNMENT macro but     
+   (per issue #9850) align local Altivec arrays >= 16 bytes  
+   to 16 bytes (128 bits).  The DATA_ALIGNMENT macro aligns
+   all char arrays (not struct fields) to 16 bytes. These  
+   alignments don't appear to affect struct field arrays.   */
+#define LOCAL_ALIGNMENT(TYPE, ALIGN)			  \
+  (TARGET_ALTIVEC &&  (TREE_CODE (TYPE) == ARRAY_TYPE)    \
+    && tree_low_cst (TYPE_SIZE (TYPE), 1) >= 128 ? 128       \
+    : DATA_ALIGNMENT (TYPE, ALIGN))
 
 /* Alignment of field after `int : 0' in a structure.  */
 #define EMPTY_FIELD_BOUNDARY 32
@@ -738,7 +770,7 @@
       ? 64								\
       : (TREE_CODE (TYPE) == ARRAY_TYPE					\
 	 && TYPE_MODE (TREE_TYPE (TYPE)) == QImode			\
-	 && (ALIGN) < BITS_PER_WORD) ? BITS_PER_WORD : (ALIGN)))
+	 && (ALIGN) < BITS_PER_WORD) ? (TARGET_ALTIVEC ? 128 : BITS_PER_WORD) : (ALIGN)))
 
 /* Nonzero if move instructions will actually fail to work
    when given unaligned data.  */
@@ -864,8 +896,8 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,	   \
    /* AltiVec registers.  */			   \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1						   \
    , 1, 1, 1                                       \
 }
@@ -883,8 +915,8 @@
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1,	   \
    /* AltiVec registers.  */			   \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \
+   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
    0, 0						   \
    , 0, 0, 0                                       \
 }
@@ -2436,3 +2468,41 @@
 extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];
 extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];
 
+/* Values for struct isel_builtin_desc.arg_flags.  */
+enum {
+  ISEL_FLAG_CMP_PTR = 0x1,
+  ISEL_FLAG_CMP_SIGNED = 0x2,
+  ISEL_FLAG_CMP_UNSIGNED = 0x4,
+  ISEL_FLAG_CMP_MASK = 0x7,
+  ISEL_FLAG_SEL_PTR = 0x10,
+  ISEL_FLAG_SEL_SIGNED = 0x20,
+  ISEL_FLAG_SEL_UNSIGNED = 0x40,
+  ISEL_FLAG_SEL_MASK = 0x70
+};
+
+struct isel_builtin_desc {
+  /* Name of this builtin.  NULL if we should construct it.  */
+  const char *name;
+
+  /* Flags for argument combinations accepted by the builtin.
+     Zero if this builtin is a generic builtin, to be resolved later.  */
+  int arg_flags;
+
+  /* The code of the builtin.  */
+  enum rs6000_builtins code;
+
+  /* rtx_code and machine_mode are not available here; use ints instead.  */
+  /* The comparison code the builtin uses.  */
+  int cmp_code;
+
+  /* The mode the builtin does comparisons in.  */
+  int cmp_mode;
+
+  /* The mode the builtin's selected arguments are in.
+     Also happens to be its result mode.  */
+  int sel_mode;
+};
+
+/* Arrays describing isel builtins.  */
+extern const struct isel_builtin_desc builtin_iselw[32];
+extern const struct isel_builtin_desc builtin_iseld[32];
diff -ru ./gcc/config/rs6000/rs6000.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000.md
--- ./gcc/config/rs6000/rs6000.md	2014-06-06 14:25:27.350150547 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000.md	2012-04-03 17:46:44.000000000 +1000
@@ -12039,27 +12039,81 @@
   [(set_attr "type" "branch")
    (set_attr "length" "4")])
 
-(define_insn "load_toc_v4_PIC_1"
+(define_expand "load_toc_v4_PIC_1"
+  [(parallel [(set (reg:SI LR_REGNO)
+		   (match_operand:SI 0 "immediate_operand" "s"))
+	      (use (unspec [(match_dup 0)] UNSPEC_TOC))])]
+  "TARGET_ELF && DEFAULT_ABI != ABI_AIX
+   && (flag_pic == 2 || (flag_pic && TARGET_SECURE_PLT))"
+  "")
+
+(define_insn "load_toc_v4_PIC_1_normal"
   [(set (reg:SI LR_REGNO)
 	(match_operand:SI 0 "immediate_operand" "s"))
    (use (unspec [(match_dup 0)] UNSPEC_TOC))]
-  "TARGET_ELF && DEFAULT_ABI != ABI_AIX
+  "!TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI != ABI_AIX
    && (flag_pic == 2 || (flag_pic && TARGET_SECURE_PLT))"
   "bcl 20,31,%0\\n%0:"
   [(set_attr "type" "branch")
    (set_attr "length" "4")])
 
-(define_insn "load_toc_v4_PIC_1b"
+(define_insn "load_toc_v4_PIC_1_476"
+  [(set (reg:SI LR_REGNO)
+	(match_operand:SI 0 "immediate_operand" "s"))
+   (use (unspec [(match_dup 0)] UNSPEC_TOC))]
+  "TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI != ABI_AIX
+   && (flag_pic == 2 || (flag_pic && TARGET_SECURE_PLT))"
+  "*
+{
+  char name[32];
+  static char templ[32];
+
+  get_ppc476_thunk_name (name);
+  sprintf (templ, \"bl %s\\n%%0:\", name);
+  return templ;
+}"
+  [(set_attr "type" "branch")
+   (set_attr "length" "4")])
+
+(define_expand "load_toc_v4_PIC_1b"
+  [(parallel [(set (reg:SI LR_REGNO)
+		   (unspec:SI [(match_operand:SI 0 "immediate_operand" "s")
+			       (label_ref (match_operand 1 "" ""))]
+		           UNSPEC_TOCPTR))
+	      (match_dup 1)])]
+  "TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2"
+  "")
+
+(define_insn "load_toc_v4_PIC_1b_normal"
   [(set (reg:SI LR_REGNO)
 	(unspec:SI [(match_operand:SI 0 "immediate_operand" "s")
 		    (label_ref (match_operand 1 "" ""))]
 		UNSPEC_TOCPTR))
    (match_dup 1)]
-  "TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2"
+  "!TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2"
   "bcl 20,31,$+8\;.long %0-$"
   [(set_attr "type" "branch")
    (set_attr "length" "8")])
 
+(define_insn "load_toc_v4_PIC_1b_476"
+  [(set (reg:SI LR_REGNO)
+	(unspec:SI [(match_operand:SI 0 "immediate_operand" "s")
+		    (label_ref (match_operand 1 "" ""))]
+		UNSPEC_TOCPTR))
+   (match_dup 1)]
+  "TARGET_LINK_STACK && TARGET_ELF && DEFAULT_ABI != ABI_AIX && flag_pic == 2"
+  "*
+{
+  char name[32];
+  static char templ[32];
+
+  get_ppc476_thunk_name (name);
+  sprintf (templ, \"bl %s\\n\\tb $+8\\n\\t.long %%0-$\", name);
+  return templ;
+}"
+  [(set_attr "type" "branch")
+   (set_attr "length" "16")])
+
 (define_insn "load_toc_v4_PIC_2"
   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
 	(mem:SI (plus:SI (match_operand:SI 1 "gpc_reg_operand" "b")
diff -ru ./gcc/config/rs6000/rs6000-protos.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000-protos.h
--- ./gcc/config/rs6000/rs6000-protos.h	2014-06-06 11:50:16.387598633 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/rs6000-protos.h	2012-04-03 17:46:44.000000000 +1000
@@ -142,7 +142,7 @@
 						     unsigned int);
 extern unsigned int darwin_rs6000_special_round_type_align (tree, unsigned int,
 							    unsigned int);
-extern tree altivec_resolve_overloaded_builtin (location_t, tree, void *);
+extern tree rs6000_resolve_overloaded_builtin (location_t, tree, void *);
 extern rtx rs6000_libcall_value (enum machine_mode);
 extern rtx rs6000_va_arg (tree, tree);
 extern int function_ok_for_sibcall (tree);
@@ -173,6 +173,7 @@
 extern bool rs6000_tls_referenced_p (rtx);
 
 extern void rs6000_aix_asm_output_dwarf_table_ref (char *);
+extern void get_ppc476_thunk_name (char name[32]);
 
 /* Declare functions in rs6000-c.c */
 
diff -ru ./gcc/config/rs6000/sysv4.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/sysv4.h
--- ./gcc/config/rs6000/sysv4.h	2014-06-06 11:50:16.475598636 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/sysv4.h	2012-03-29 18:03:07.000000000 +1000
@@ -575,8 +575,11 @@
 #define CC1_SECURE_PLT_DEFAULT_SPEC ""
 #endif
 
+#undef CC1_EXTRA_SPEC
+#define CC1_EXTRA_SPEC ""
+
 /* Pass -G xxx to the compiler and set correct endian mode.  */
-#define	CC1_SPEC "%{G*} %(cc1_cpu) \
+#define	CC1_SPEC "%{G*} %(cc1_cpu) %(cc1_float) \
 %{mlittle|mlittle-endian: %(cc1_endian_little);           \
   mbig   |mbig-endian   : %(cc1_endian_big);              \
   mcall-aixdesc |					  \
@@ -599,7 +602,7 @@
 %{msdata: -msdata=default} \
 %{mno-sdata: -msdata=none} \
 %{!mbss-plt: %{!msecure-plt: %(cc1_secure_plt_default)}} \
-%{profile: -p}"
+%{profile: -p}" CC1_EXTRA_SPEC
 
 /* Default starting address if specified.  */
 #define LINK_START_SPEC "\
@@ -760,15 +763,15 @@
 #define CPP_OS_MVME_SPEC ""
 
 /* PowerPC simulator based on netbsd system calls support.  */
-#define LIB_SIM_SPEC "--start-group -lsim -lc --end-group"
+#define LIB_SIM_SPEC LIB_DEFAULT_SPEC
 
-#define	STARTFILE_SIM_SPEC "ecrti.o%s sim-crt0.o%s crtbegin.o%s"
+#define	STARTFILE_SIM_SPEC "ecrti.o%s crtbegin.o%s"
 
-#define	ENDFILE_SIM_SPEC "crtend.o%s ecrtn.o%s"
+#define	ENDFILE_SIM_SPEC "crtend.o%s ecrtn.o%s -Tsim-hosted.ld"
 
 #define LINK_START_SIM_SPEC ""
 
-#define LINK_OS_SIM_SPEC "-m elf32ppcsim"
+#define LINK_OS_SIM_SPEC ""
 
 #define CPP_OS_SIM_SPEC ""
 
diff -ru ./gcc/config/rs6000/t-aix43 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/t-aix43
--- ./gcc/config/rs6000/t-aix43	2014-06-06 11:50:16.479598637 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/t-aix43	2012-03-29 18:03:07.000000000 +1000
@@ -82,7 +82,7 @@
 		$$(DESTDIR)$$(slibdir)@shlib_slibdir_qual@/
 SHLIB_LIBS = -lc `case @multilib_dir@ in *pthread*) echo -lpthread ;; esac`
 SHLIB_MKMAP = $(srcdir)/mkmap-flat.awk
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver $(srcdir)/config/rs6000/libgcc-ppc64.ver
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver $(srcdir)/config/rs6000/libgcc-ppc64.ver
 SHLIB_NM_FLAGS = -Bpg -X32_64
 
 # GCC 128-bit long double support routines.
diff -ru ./gcc/config/rs6000/t-aix52 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/t-aix52
--- ./gcc/config/rs6000/t-aix52	2014-06-06 11:50:16.479598637 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/t-aix52	2012-03-29 18:03:07.000000000 +1000
@@ -63,7 +63,7 @@
 		$$(DESTDIR)$$(slibdir)@shlib_slibdir_qual@/
 SHLIB_LIBS = -lc `case @multilib_dir@ in *pthread*) echo -lpthread ;; esac`
 SHLIB_MKMAP = $(srcdir)/mkmap-flat.awk
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver $(srcdir)/config/rs6000/libgcc-ppc64.ver
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver $(srcdir)/config/rs6000/libgcc-ppc64.ver
 SHLIB_NM_FLAGS = -Bpg -X32_64
 
 # GCC 128-bit long double support routines.
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: t-apm-linux
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: t-cs-eabi
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: t-cs-eabi-lite
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: t-cs-linux
diff -ru ./gcc/config/rs6000/t-ppccomm /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/t-ppccomm
--- ./gcc/config/rs6000/t-ppccomm	2014-06-06 11:50:16.479598637 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000/t-ppccomm	2012-03-29 18:03:07.000000000 +1000
@@ -21,12 +21,6 @@
 
 LIB2FUNCS_EXTRA += tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c
 
-# These can't end up in shared libgcc
-LIB2FUNCS_STATIC_EXTRA = eabi.S
-
-eabi.S: $(srcdir)/config/rs6000/eabi.asm
-	cat $(srcdir)/config/rs6000/eabi.asm > eabi.S
-
 tramp.S: $(srcdir)/config/rs6000/tramp.asm
 	cat $(srcdir)/config/rs6000/tramp.asm > tramp.S
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rs6000: t-ppc-e500mc
diff -ru ./gcc/config/rx/rx.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rx/rx.c
--- ./gcc/config/rx/rx.c	2014-06-06 14:25:27.350150547 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/rx/rx.c	2012-03-29 18:02:50.000000000 +1000
@@ -1566,7 +1566,7 @@
 				: plus_constant (stack_pointer_rtx,
 						 i * UNITS_PER_WORD)));
 
-  XVECEXP (vector, 0, count - 1) = gen_rtx_RETURN (VOIDmode);
+  XVECEXP (vector, 0, count - 1) = ret_rtx;
 
   return vector;
 }
@@ -2348,7 +2348,7 @@
 rx_option_override (void)
 {
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 
   rx_override_options_after_change ();
diff -ru ./gcc/config/s390/s390.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/s390/s390.c
--- ./gcc/config/s390/s390.c	2014-06-06 11:50:16.507598638 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/s390/s390.c	2012-03-29 18:02:46.000000000 +1000
@@ -4856,7 +4856,7 @@
   if (ac.aligned && MEM_P (cmp))
     {
       cmpv = force_reg (SImode, val);
-      store_bit_field (cmpv, GET_MODE_BITSIZE (mode), 0, SImode, cmp);
+      store_bit_field (cmpv, GET_MODE_BITSIZE (mode), 0, false, SImode, cmp);
     }
   else
     cmpv = force_reg (SImode, expand_simple_binop (SImode, IOR, cmp, val,
@@ -4864,7 +4864,8 @@
   if (ac.aligned && MEM_P (new_rtx))
     {
       newv = force_reg (SImode, val);
-      store_bit_field (newv, GET_MODE_BITSIZE (mode), 0, SImode, new_rtx);
+      store_bit_field (newv, GET_MODE_BITSIZE (mode), 0, false, SImode,
+		       new_rtx);
     }
   else
     newv = force_reg (SImode, expand_simple_binop (SImode, IOR, new_rtx, val,
@@ -4941,7 +4942,8 @@
       /* FALLTHRU */
     case SET:
       if (ac.aligned && MEM_P (val))
-	store_bit_field (new_rtx, GET_MODE_BITSIZE (mode), 0, SImode, val);
+	store_bit_field (new_rtx, GET_MODE_BITSIZE (mode), 0, false, SImode,
+			 val);
       else
 	{
 	  new_rtx = expand_simple_binop (SImode, AND, new_rtx, ac.modemaski,
@@ -8479,7 +8481,7 @@
 
       p = rtvec_alloc (2);
 
-      RTVEC_ELT (p, 0) = gen_rtx_RETURN (VOIDmode);
+      RTVEC_ELT (p, 0) = ret_rtx;
       RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);
       emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));
     }
@@ -8736,7 +8738,7 @@
   if (INTEGRAL_MODE_P (mode)
       && GET_MODE_SIZE (mode) < UNITS_PER_LONG)
     {
-      if (POINTER_TYPE_P (type))
+      if (type != NULL_TREE && POINTER_TYPE_P (type))
 	*punsignedp = POINTERS_EXTEND_UNSIGNED;
       return Pmode;
     }
diff -ru ./gcc/config/sh/constraints.md /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/constraints.md
--- ./gcc/config/sh/constraints.md	2014-06-06 11:50:16.547598639 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/constraints.md	2012-03-29 18:02:56.000000000 +1000
@@ -75,6 +75,9 @@
 (define_register_constraint "t" "T_REGS"
   "T register.")
 
+(define_register_constraint "u" "NON_SP_REGS"
+  "Non-stack-pointer register.")
+
 (define_register_constraint "w" "FP0_REGS"
   "Floating-point register 0.")
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh: cs-sgxxlite-linux.h
diff -ru ./gcc/config/sh/linux.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/linux.h
--- ./gcc/config/sh/linux.h	2014-06-06 11:50:16.551598639 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/linux.h	2012-03-29 18:02:56.000000000 +1000
@@ -27,6 +27,13 @@
 #undef DWARF2_UNWIND_INFO
 #define DWARF2_UNWIND_INFO 1
 
+#undef DRIVER_SELF_SPECS
+#define DRIVER_SELF_SPECS \
+  BASE_DRIVER_SELF_SPECS \
+  " %{funwind-tables|fno-unwind-tables|ffreestanding|nostdlib:;: -funwind-tables}"
+
+#define TARGET_UNWIND_TABLES_DEFAULT 1
+
 #undef SUBTARGET_CPP_SPEC
 #define SUBTARGET_CPP_SPEC "\
    %{posix:-D_POSIX_SOURCE} \
diff -ru ./gcc/config/sh/sh.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/sh.c
--- ./gcc/config/sh/sh.c	2014-06-06 14:25:27.354150547 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/sh.c	2012-03-29 18:02:56.000000000 +1000
@@ -1018,7 +1018,7 @@
     sh_fix_range (sh_fixed_range_str);
 
   /* This target defaults to strict volatile bitfields.  */
-  if (flag_strict_volatile_bitfields < 0)
+  if (flag_strict_volatile_bitfields < 0 && abi_version_at_least(2))
     flag_strict_volatile_bitfields = 1;
 }
 
@@ -2163,8 +2163,6 @@
 	  lsw_taken_prob = prob;
 	}
     }
-  operands[1] = op1h;
-  operands[2] = op2h;
   operands[4] = NULL_RTX;
   if (reload_completed
       && ! arith_reg_or_0_operand (op2h, SImode)
@@ -2173,8 +2171,10 @@
 	  || msw_skip != LAST_AND_UNUSED_RTX_CODE))
     {
       emit_move_insn (scratch, operands[2]);
-      operands[2] = scratch;
+      op2h = scratch;
     }
+  operands[1] = op1h;
+  operands[2] = op2h;
   if (msw_taken != LAST_AND_UNUSED_RTX_CODE)
     expand_cbranchsi4 (operands, msw_taken, msw_taken_prob);
   if (msw_skip != LAST_AND_UNUSED_RTX_CODE)
@@ -4866,8 +4866,12 @@
       /* Don't emit a constant table int the middle of global pointer setting,
 	 since that that would move the addressing base GOT into another table. 
 	 We need the first mov instruction before the _GLOBAL_OFFSET_TABLE_
-	 in the pool anyway, so just move up the whole constant pool.  */
-      if (last_got)
+	 in the pool anyway, so just move up the whole constant pool.
+
+	 However, avoid doing so when the last single GOT mov is the starting
+	 insn itself. Going past above the start insn would create a negative
+	 offset, causing errors.  */
+      if (last_got && last_got != orig)
         from = PREV_INSN (last_got);
 
       /* Don't insert the constant pool table at the position which
@@ -5444,7 +5448,8 @@
 	}
       if (prev
 	  && JUMP_P (prev)
-	  && JUMP_LABEL (prev))
+	  && JUMP_LABEL (prev)
+	  && !ANY_RETURN_P (JUMP_LABEL (prev)))
 	{
 	  rtx x;
 	  if (jump_to_next
@@ -6143,7 +6148,7 @@
 			JUMP_LABEL (insn) = far_label;
 			LABEL_NUSES (far_label)++;
 		      }
-		    redirect_jump (insn, NULL_RTX, 1);
+		    redirect_jump (insn, ret_rtx, 1);
 		    far_label = 0;
 		  }
 	      }
@@ -6456,11 +6461,10 @@
 	      emit_insn (GEN_MOV (const_reg, GEN_INT (size)));
 	      insn = emit_fn (GEN_ADD3 (reg, reg, const_reg));
 	    }
-	  if (! epilogue_p)
-	    add_reg_note (insn, REG_FRAME_RELATED_EXPR,
-			  gen_rtx_SET (VOIDmode, reg,
-				       gen_rtx_PLUS (SImode, reg,
-						     GEN_INT (size))));
+	  add_reg_note (insn, REG_FRAME_RELATED_EXPR,
+			gen_rtx_SET (VOIDmode, reg,
+				     gen_rtx_PLUS (SImode, reg,
+						   GEN_INT (size))));
 	}
     }
 }
@@ -6505,7 +6509,7 @@
 static void
 pop (int rn)
 {
-  rtx x;
+  rtx x, sp_reg, reg;
   if (rn == FPUL_REG)
     x = gen_pop_fpul ();
   else if (rn == FPSCR_REG)
@@ -6523,7 +6527,18 @@
     x = gen_pop (gen_rtx_REG (SImode, rn));
 
   x = emit_insn (x);
+
+  sp_reg = gen_rtx_REG (SImode, STACK_POINTER_REGNUM);
+  reg = copy_rtx (GET_CODE (PATTERN (x)) == PARALLEL
+		  ? SET_DEST (XVECEXP (PATTERN (x), 0, 0))
+		  : SET_DEST (PATTERN (x)));
+  add_reg_note (x, REG_CFA_RESTORE, reg);
+  add_reg_note (x, REG_CFA_ADJUST_CFA,
+		gen_rtx_SET (SImode, sp_reg,
+			     plus_constant (sp_reg,
+					    GET_MODE_SIZE (GET_MODE (reg)))));
   add_reg_note (x, REG_INC, gen_rtx_REG (SImode, STACK_POINTER_REGNUM));
+  RTX_FRAME_RELATED_P (x) = 1;
 }
 
 /* Generate code to push the regs specified in the mask.  */
@@ -7396,14 +7411,14 @@
 	 See PR/18032 and PR/40313.  */
       emit_insn (gen_blockage ());
       output_stack_adjust (frame_size, hard_frame_pointer_rtx, e,
-			   &live_regs_mask, false);
+			   &live_regs_mask, true);
 
       /* We must avoid moving the stack pointer adjustment past code
 	 which reads from the local frame, else an interrupt could
 	 occur after the SP adjustment and clobber data in the local
 	 frame.  */
       emit_insn (gen_blockage ());
-      emit_insn (GEN_MOV (stack_pointer_rtx, hard_frame_pointer_rtx));
+      frame_insn (GEN_MOV (stack_pointer_rtx, hard_frame_pointer_rtx));
     }
   else if (frame_size)
     {
@@ -7413,7 +7428,7 @@
 	 frame.  */
       emit_insn (gen_blockage ());
       output_stack_adjust (frame_size, stack_pointer_rtx, e,
-			   &live_regs_mask, false);
+			   &live_regs_mask, true);
     }
 
   if (SHMEDIA_REGS_STACK_ADJUST ())
@@ -7628,7 +7643,7 @@
   output_stack_adjust (crtl->args.pretend_args_size
 		       + save_size + d_rounding
 		       + crtl->args.info.stack_regs * 8,
-		       stack_pointer_rtx, e, NULL, false);
+		       stack_pointer_rtx, e, NULL, true);
 
   if (crtl->calls_eh_return)
     emit_insn (GEN_ADD3 (stack_pointer_rtx, stack_pointer_rtx,
diff -ru ./gcc/config/sh/sh.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/sh.h
--- ./gcc/config/sh/sh.h	2014-06-06 11:50:16.583598640 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/sh.h	2012-03-29 18:02:56.000000000 +1000
@@ -338,8 +338,8 @@
 #endif
 
 #define SH_ASM_SPEC \
- "%(subtarget_asm_endian_spec) %{mrelax:-relax %(subtarget_asm_relax_spec)}\
-%(subtarget_asm_isa_spec) %(subtarget_asm_spec)\
+ "%(subtarget_asm_endian_spec) %{mrelax:-relax %(subtarget_asm_relax_spec)} \
+%(subtarget_asm_isa_spec) %(subtarget_asm_spec) \
 %{m2a:--isa=sh2a} \
 %{m2a-single:--isa=sh2a} \
 %{m2a-single-only:--isa=sh2a} \
@@ -420,7 +420,10 @@
 #define SH_DIV_STR_FOR_SIZE "call"
 #endif
 
-#define DRIVER_SELF_SPECS "%{m2a:%{ml:%eSH2a does not support little-endian}}"
+#define BASE_DRIVER_SELF_SPECS \
+  "%{m2a:%{ml:%eSH2a does not support little-endian}}"
+
+#define DRIVER_SELF_SPECS BASE_DRIVER_SELF_SPECS
 
 #define ASSEMBLER_DIALECT assembler_dialect
 
@@ -1046,6 +1049,7 @@
   MAC_REGS,
   FPUL_REGS,
   SIBCALL_REGS,
+  NON_SP_REGS,
   GENERAL_REGS,
   FP0_REGS,
   FP_REGS,
@@ -1071,6 +1075,7 @@
   "MAC_REGS",		\
   "FPUL_REGS",		\
   "SIBCALL_REGS",	\
+  "NON_SP_REGS",	\
   "GENERAL_REGS",	\
   "FP0_REGS",		\
   "FP_REGS",		\
@@ -1103,6 +1108,8 @@
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00400000 },	\
 /* SIBCALL_REGS: Initialized in TARGET_CONDITIONAL_REGISTER_USAGE.  */	\
   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },	\
+/* NON_SP_REGS:  */							\
+  { 0xffff7fff, 0xffffffff, 0x00000000, 0x00000000, 0x03020000 },	\
 /* GENERAL_REGS:  */							\
   { 0xffffffff, 0xffffffff, 0x00000000, 0x00000000, 0x03020000 },	\
 /* FP0_REGS:  */							\
@@ -2084,7 +2091,7 @@
    register information here is not used for SFmode.  */
 
 #define REGCLASS_HAS_GENERAL_REG(CLASS) \
-  ((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS \
+  ((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS || (CLASS) == NON_SP_REGS \
     || (! TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))
 
 #define REGCLASS_HAS_FP_REG(CLASS) \
diff -ru ./gcc/config/sh/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/t-linux
--- ./gcc/config/sh/t-linux	2014-06-06 11:50:16.627598642 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh/t-linux	2012-03-29 18:02:56.000000000 +1000
@@ -6,3 +6,6 @@
 MULTILIB_MATCHES = 
 
 EXTRA_MULTILIB_PARTS= crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+
+CRTSTUFF_T_CFLAGS = -fno-unwind-tables
+CRTSTUFF_T_CFLAGS_S = $(CRTSTUFF_T_CFLAGS) -fPIC
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sh: t-sgxxlite-linux
diff -ru ./gcc/config/sparc/sparc.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sparc/sparc.c
--- ./gcc/config/sparc/sparc.c	2014-06-06 14:25:27.358150547 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sparc/sparc.c	2012-03-29 18:02:49.000000000 +1000
@@ -5031,13 +5031,13 @@
 /* Handle promotion of pointer and integer arguments.  */
 
 static enum machine_mode
-sparc_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,
+sparc_promote_function_mode (const_tree type,
                              enum machine_mode mode,
-                             int *punsignedp ATTRIBUTE_UNUSED,
+                             int *punsignedp,
                              const_tree fntype ATTRIBUTE_UNUSED,
                              int for_return ATTRIBUTE_UNUSED)
 {
-  if (POINTER_TYPE_P (type))
+  if (type != NULL_TREE && POINTER_TYPE_P (type))
     {
       *punsignedp = POINTERS_EXTEND_UNSIGNED;
       return Pmode;
@@ -6111,7 +6111,7 @@
 	  /* We must check and adjust the return address, as it is
 	     optional as to whether the return object is really
 	     provided.  */
-	  rtx ret_rtx = gen_rtx_REG (Pmode, 31);
+	  rtx ret_reg = gen_rtx_REG (Pmode, 31);
 	  rtx scratch = gen_reg_rtx (SImode);
 	  rtx endlab = gen_label_rtx ();
 
@@ -6128,12 +6128,12 @@
 	     it's an unimp instruction (the most significant 10 bits
 	     will be zero).  */
 	  emit_move_insn (scratch, gen_rtx_MEM (SImode,
-						plus_constant (ret_rtx, 8)));
+						plus_constant (ret_reg, 8)));
 	  /* Assume the size is valid and pre-adjust */
-	  emit_insn (gen_add3_insn (ret_rtx, ret_rtx, GEN_INT (4)));
+	  emit_insn (gen_add3_insn (ret_reg, ret_reg, GEN_INT (4)));
 	  emit_cmp_and_jump_insns (scratch, size_rtx, EQ, const0_rtx, SImode,
 				   0, endlab);
-	  emit_insn (gen_sub3_insn (ret_rtx, ret_rtx, GEN_INT (4)));
+	  emit_insn (gen_sub3_insn (ret_reg, ret_reg, GEN_INT (4)));
 	  /* Write the address of the memory pointed to by temp_val into
 	     the memory pointed to by mem */
 	  emit_move_insn (mem, XEXP (temp_val, 0));
diff -ru ./gcc/config/sparc/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sparc/t-linux
--- ./gcc/config/sparc/t-linux	2014-06-06 14:25:27.362150548 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/sparc/t-linux	2012-03-29 18:02:49.000000000 +1000
@@ -1,5 +1,5 @@
 # Override t-slibgcc-elf-ver to export some libgcc symbols with
 # the symbol versions that glibc used.
 # Avoid the t-linux version file.
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver \
 		 $(srcdir)/config/sparc/libgcc-sparc-glibc.ver
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config: t-eglibc
diff -ru ./gcc/config/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-linux
--- ./gcc/config/t-linux	2014-06-06 11:50:16.799598649 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-linux	2012-03-29 18:03:17.000000000 +1000
@@ -28,5 +28,6 @@
 
 # Use unwind-dw2-fde-glibc
 LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \
+  $(srcdir)/unwind-compact.c \
   $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
-LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c unwind-compact.h
diff -ru ./gcc/config/t-slibgcc-elf-ver /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-slibgcc-elf-ver
--- ./gcc/config/t-slibgcc-elf-ver	2014-06-06 11:50:16.799598649 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-slibgcc-elf-ver	2012-03-29 18:03:17.000000000 +1000
@@ -53,4 +53,4 @@
 	rm -f $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK); \
 	$(SHLIB_INSTALL_SOLINK)
 SHLIB_MKMAP = $(srcdir)/mkmap-symver.awk
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver
diff -ru ./gcc/config/t-slibgcc-sld /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-slibgcc-sld
--- ./gcc/config/t-slibgcc-sld	2014-06-06 11:50:16.799598649 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-slibgcc-sld	2012-03-29 18:03:17.000000000 +1000
@@ -47,4 +47,4 @@
 	$(LN_S) $(SHLIB_SONAME) \
 	  $$(DESTDIR)$$(slibdir)$(SHLIB_SLIBDIR_QUAL)/$(SHLIB_SOLINK)
 SHLIB_MKMAP = $(srcdir)/mkmap-symver.awk
-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver
+SHLIB_MAPFILES = $$(libgcc_objdir)/libgcc-std.ver
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config: t-slibgcc-symbian
diff -ru ./gcc/config/t-sysroot-suffix /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-sysroot-suffix
--- ./gcc/config/t-sysroot-suffix	2014-06-06 11:50:16.799598649 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/t-sysroot-suffix	2012-03-29 18:03:17.000000000 +1000
@@ -3,5 +3,5 @@
 sysroot-suffix.h: $(srcdir)/config/print-sysroot-suffix.sh
 	$(SHELL) $(srcdir)/config/print-sysroot-suffix.sh \
 	  "$(MULTILIB_OSDIRNAMES)" "$(MULTILIB_OPTIONS)" \
-	  "$(MULTILIB_MATCHES)" > tmp-sysroot-suffix.h
+	  "$(MULTILIB_MATCHES)" "$(MULTILIB_ALIASES)" > tmp-sysroot-suffix.h
 	mv tmp-sysroot-suffix.h $@
diff -ru ./gcc/config/v850/v850.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/v850/v850.c
--- ./gcc/config/v850/v850.c	2014-06-06 11:50:16.819598649 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/v850/v850.c	2012-03-29 18:03:17.000000000 +1000
@@ -1886,7 +1886,7 @@
 	  int offset;
 	  restore_all = gen_rtx_PARALLEL (VOIDmode,
 					  rtvec_alloc (num_restore + 2));
-	  XVECEXP (restore_all, 0, 0) = gen_rtx_RETURN (VOIDmode);
+	  XVECEXP (restore_all, 0, 0) = ret_rtx;
 	  XVECEXP (restore_all, 0, 1)
 	    = gen_rtx_SET (VOIDmode, stack_pointer_rtx,
 			    gen_rtx_PLUS (Pmode,
diff -ru ./gcc/config/vx-common.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/vx-common.h
--- ./gcc/config/vx-common.h	2014-06-06 11:50:16.835598650 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config/vx-common.h	2012-03-29 18:03:17.000000000 +1000
@@ -92,3 +92,6 @@
 /* We occasionally need to distinguish between the VxWorks variants.  */
 #define VXWORKS_KIND_NORMAL  1
 #define VXWORKS_KIND_AE      2
+
+/* Enable get_feature license checking.  */
+#define TARGET_FLEXLM
diff -ru ./gcc/config.gcc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config.gcc
--- ./gcc/config.gcc	2014-06-06 14:25:27.242150543 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config.gcc	2012-04-03 17:46:44.000000000 +1000
@@ -396,7 +396,7 @@
 	extra_headers="ppc-asm.h altivec.h spe.h ppu_intrinsics.h paired.h spu2vmx.h vec_types.h si2vmx.h"
 	need_64bit_hwint=yes
 	case x$with_cpu in
-	    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[34567]|xpower6x|xrs64a|xcell|xa2|xe500mc64)
+	    xpowerpc64|xdefault64|x6[23]0|x970|xG5|xpower[34567]|xpower6x|xrs64a|xcell|xa2|xe500mc64|xe5500)
 		cpu_is_64bit=yes
 		;;
 	esac
@@ -839,11 +839,23 @@
 	    need_64bit_hwint=yes
 	    # The EABI requires the use of __cxa_atexit.
 	    default_use_cxa_atexit=yes
+	    case ${target} in
+	    *)
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-cs-linux"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+			tmake_file="${tmake_file} arm/t-cs-linux-lite"
+		fi
+		tm_file="$tm_file ./sysroot-suffix.h"
+		tmake_file="$tmake_file t-sysroot-suffix"
+		;;
+	    esac
 	    ;;
 	*)
 	    tmake_file="$tmake_file arm/t-linux"
 	    ;;
 	esac
+	with_tls=${with_tls:-gnu}
 	tm_file="$tm_file arm/aout.h arm/arm.h"
 	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
 	;;
@@ -861,6 +873,13 @@
 	    need_64bit_hwint=yes
 	    # The EABI requires the use of __cxa_atexit.
 	    default_use_cxa_atexit=yes
+	    if test x$enable_extra_sgxx_multilibs = xyes; then
+		    tmake_file="${tmake_file} arm/t-cs-uclinux-eabi"
+	    elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		    tmake_file="${tmake_file} arm/t-cs-uclinux-eabi"
+	    fi
+	    tm_file="$tm_file ./sysroot-suffix.h"
+	    tmake_file="$tmake_file t-sysroot-suffix"
 	esac
 	tm_file="$tm_file arm/aout.h arm/arm.h"
 	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
@@ -870,7 +889,7 @@
 	tmake_file="arm/t-arm arm/t-arm-elf"
 	tmake_file="${tmake_file} arm/t-arm-softfp soft-fp/t-softfp"
 	;;
-arm*-*-eabi* | arm*-*-symbianelf* )
+arm*-*-eabi* | arm*-*-nucleuseabi* | arm*-*-symbianelf* )
 	# The BPABI long long divmod functions return a 128-bit value in
 	# registers r0-r3.  Correctly modeling that requires the use of
 	# TImode.
@@ -882,14 +901,38 @@
 	case ${target} in
 	arm*-*-eabi*)
 	  tm_file="$tm_file newlib-stdint.h"
+	  tm_file="${tm_file} arm/nocrt0.h"
 	  tmake_file="${tmake_file} arm/t-bpabi"
+	  if test x$enable_extra_sgxx_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-eabi"
+	  elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-eabi-lite"
+	  elif test x$enable_extra_brewmp_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-brewmp-eabi"
+	  fi
 	  use_gcc_stdint=wrap
 	  ;;
+	arm*-*-nucleuseabi*)
+	  tm_file="$tm_file arm/eabi.h"
+	  tm_file="${tm_file} arm/nocrt0.h"
+	  tm_file="$tm_file arm/nucleus.h"
+	  case ${target} in
+	    *samsung-nucleuseabi*)
+	      tmake_file="${tmake_file} t-slibgcc-elf-ver t-libc-ok"
+	      tmake_file="${tmake_file} t-libgcc-pic arm/t-nucleus"
+	      tm_defines="${tm_defines} NUCLEUS_SHARED_EXEC=1"
+	      ;;
+	  esac
+	  tmake_file="${tmake_file} arm/t-bpabi"
+	  extra_options="${extra_options} arm/eabi.opt"
+	  if test x$enable_extra_sgxx_multilibs = xyes; then
+		  tmake_file="${tmake_file} arm/t-cs-nucleuseabi"
+	  fi
+	  ;;
 	arm*-*-symbianelf*)
 	  tm_file="${tm_file} arm/symbian.h"
-	  # We do not include t-bpabi for Symbian OS because the system
-	  # provides its own implementation of the BPABI functions.
-	  tmake_file="${tmake_file} arm/t-symbian"
+	  tmake_file="${tmake_file} t-slibgcc-symbian t-libc-ok"
+	  tmake_file="${tmake_file} arm/t-bpabi arm/t-symbian"
 	  ;;
 	esac
 	tm_file="${tm_file} arm/aout.h arm/arm.h"
@@ -1205,11 +1248,11 @@
 	;;
 i[34567]86-*-elf*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h"
-	tmake_file="${tmake_file} i386/t-i386elf t-svr4"
+	tmake_file="${tmake_file} i386/t-i386elf i386/t-crtstuff t-svr4"
 	;;
 x86_64-*-elf*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
-	tmake_file="${tmake_file} i386/t-i386elf t-svr4"
+	tmake_file="${tmake_file} i386/t-i386elf i386/t-crtstuff t-svr4"
 	;;
 i[34567]86-*-freebsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h"
@@ -1281,6 +1324,14 @@
 		else
 			tm_file="${tm_file} i386/linux.h"
 		fi
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+			tm_file="${tm_file} i386/cs-linux.h"
+			tmake_file="${tmake_file} i386/t-cs-linux"
+			extra_options="${extra_options} i386/cs-linux.opt"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+			tm_file="${tm_file} i386/cs-linux-lite.h"
+			tmake_file="${tmake_file} i386/t-cs-linux-lite"
+		fi
 		;;
 	i[34567]86-*-knetbsd*-gnu)
 		tm_file="${tm_file} i386/linux.h knetbsd-gnu.h i386/knetbsd-gnu.h"
@@ -1874,11 +1925,15 @@
 	tm_file="elfos.h ${tm_file} mips/elf.h netbsd.h netbsd-elf.h mips/netbsd.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
 	;;
-mips64*-*-linux* | mipsisa64*-*-linux*)
+mips64*-*-linux* | mipsisa63*-*-linux*)
 	tm_file="dbxelf.h elfos.h gnu-user.h linux.h glibc-stdint.h ${tm_file} mips/linux.h mips/linux64.h"
-	tmake_file="${tmake_file} mips/t-linux64 mips/t-libgcc-mips16"
+ 	tmake_file="${tmake_file} mips/t-linux64 mips/t-libgcc-mips16 t-slibgcc-libgcc"
 	tm_defines="${tm_defines} MIPS_ABI_DEFAULT=ABI_N32"
 	case ${target} in
+		mips64-nlm-linux-gnu)
+			tm_file="${tm_file} mips/netlogic.h"
+			tmake_file="${tmake_file} mips/t-netlogic"
+			;;
 		mips64el-st-linux-gnu)
 			tm_file="${tm_file} mips/st.h"
 			tmake_file="${tmake_file} mips/t-st"
@@ -1898,13 +1953,21 @@
 	;;
 mips*-*-linux*)				# Linux MIPS, either endian.
         tm_file="dbxelf.h elfos.h gnu-user.h linux.h glibc-stdint.h ${tm_file} mips/linux.h"
-	tmake_file="${tmake_file} mips/t-libgcc-mips16"
+ 	tmake_file="${tmake_file} mips/t-libgcc-mips16 t-slibgcc-libgcc"
 	case ${target} in
         mipsisa32r2*)
 		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=33"
                 ;;
         mipsisa32*)
 		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=32"
+		;;
+	*)
+		if test x$enable_extra_sgxxlite_multilibs = xyes \
+		   || test x$enable_extra_sgxx_multilibs = xyes; then
+		    tmake_file="$tmake_file mips/t-linux64 mips/t-sgxx-linux"
+		    tm_file="$tm_file mips/linux64.h mips/cs-sgxx-linux.h"
+		fi
+		;;
         esac
 	extra_parts="$extra_parts crtfastmath.o"
 	test x$with_llsc != x || with_llsc=yes
@@ -1953,6 +2016,12 @@
 	    tm_defines="MIPS_ISA_DEFAULT=64 MIPS_ABI_DEFAULT=ABI_N32"
 	    ;;
 	esac
+	if [ "$enable_sgxx_sde_multilibs" = "yes" ]; then
+	  tm_file="$tm_file mips/sdemtk.h"
+	  tmake_file="$tmake_file mips/t-sgxx-sde"
+          # SourceryG++ is configured --with-arch=mips32r2.
+	  tm_defines="MIPS_ISA_DEFAULT=33 MIPS_ABI_DEFAULT=ABI_32"
+	fi
 	;;
 mipsisa32-*-elf* | mipsisa32el-*-elf* | \
 mipsisa32r2-*-elf* | mipsisa32r2el-*-elf* | \
@@ -2119,6 +2188,18 @@
 	tm_file="${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	case ${enable_targets}:${cpu_is_64bit} in
+	    *powerpc64* | all:* | *:yes)
+		if test x$cpu_is_64bit = xyes; then
+		    tm_file="${tm_file} rs6000/default64.h"
+		fi
+		tm_file="rs6000/biarch64.h ${tm_file}"
+		;;
+	esac
+	if test x$enable_powerpc_e500mc_elf = xyes; then
+	  tm_file="${tm_file} rs6000/e500mc.h"
+	  tmake_file="${tmake_file} rs6000/t-ppc-e500mc"
+	fi
 	;;
 powerpc-*-eabialtivec*)
 	tm_file="${tm_file} dbxelf.h elfos.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/eabialtivec.h"
@@ -2135,7 +2216,12 @@
 powerpc-*-eabi*)
 	tm_file="${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
-	tmake_file="rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm"
+	tmake_file="rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcgas rs6000/t-ppccomm"
+	if test x$enable_extra_sgxx_multilibs = xyes; then
+	  tmake_file="${tmake_file} rs6000/t-cs-eabi"
+	elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+	  tmake_file="${tmake_file} rs6000/t-cs-eabi-lite"
+	fi
 	use_gcc_stdint=wrap
 	;;
 powerpc-*-rtems*)
@@ -2176,6 +2262,9 @@
 	esac
 	tmake_file="${tmake_file} t-slibgcc-libgcc rs6000/t-fprules-softfp soft-fp/t-softfp"
 	case ${target} in
+	    powerpc*-*-linux*ppc476* | powerpc-lsi-linux*)
+		tm_file="${tm_file} rs6000/476.h"
+		extra_options="${extra_options} rs6000/476.opt" ;;
 	    powerpc*-*-linux*altivec*)
 		tm_file="${tm_file} rs6000/linuxaltivec.h" ;;
 	    powerpc*-*-linux*spe*)
@@ -2186,6 +2275,21 @@
 	if test x${enable_secureplt} = xyes; then
 		tm_file="rs6000/secureplt.h ${tm_file}"
 	fi
+	case ${target} in
+	powerpc-apm-linux*)
+		tm_file="$tm_file rs6000/apm-linux.h"
+		tmake_file="$tmake_file rs6000/t-apm-linux"
+		;;
+	*)
+		if test x$enable_extra_sgxx_multilibs = xyes; then
+		  tm_file="${tm_file} rs6000/cs-linux.h rs6000/e500.h"
+		  tmake_file="$tmake_file rs6000/t-cs-linux"
+		elif test x$enable_extra_sgxxlite_multilibs = xyes; then
+		  tm_file="${tm_file} rs6000/cs-linux.h rs6000/e500.h"
+		  tmake_file="$tmake_file rs6000/t-cs-linux"
+		fi
+		;;
+	esac
 	;;
 powerpc64-*-gnu*)
 	tm_file="${tm_file} elfos.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/default64.h rs6000/linux64.h rs6000/gnu.h glibc-stdint.h"
@@ -2511,6 +2615,12 @@
 	if test x${enable_incomplete_targets} = xyes ; then
 		tm_defines="$tm_defines SUPPORT_SH1=1 SUPPORT_SH2E=1 SUPPORT_SH4=1 SUPPORT_SH4_SINGLE=1 SUPPORT_SH2A=1 SUPPORT_SH2A_SINGLE=1 SUPPORT_SH5_32MEDIA=1 SUPPORT_SH5_32MEDIA_NOFPU=1 SUPPORT_SH5_64MEDIA=1 SUPPORT_SH5_64MEDIA_NOFPU=1"
 	fi
+	if test x$enable_extra_sgxxlite_multilibs = xyes \
+	   || test x$enable_extra_sgxx_multilibs = xyes; then
+		# SG++ and Lite do not differ, as yet, so use the Lite files for both
+		tm_file="$tm_file sh/cs-sgxxlite-linux.h"
+		tmake_file="$tmake_file sh/t-sgxxlite-linux"
+	fi
 	tm_file="$tm_file ./sysroot-suffix.h"
 	tmake_file="$tmake_file t-sysroot-suffix"
 	;;
@@ -3191,7 +3301,7 @@
 		;;
 
 	arm*-*-*)
-		supported_defaults="arch cpu float tune fpu abi mode"
+		supported_defaults="arch cpu float tune fpu abi mode tls"
 		for which in cpu tune; do
 			# See if it matches any of the entries in arm-cores.def
 			eval "val=\$with_$which"
@@ -3274,6 +3384,17 @@
 			;;
 		esac
 
+		case "$with_tls" in
+		"" \
+		| gnu | gnu2)
+			# OK
+			;;
+		*)
+			echo "Unknown TLS method used in --with-tls=$with_tls" 1>&2
+			exit 1
+			;;
+		esac
+
 		if test "x$with_arch" != x && test "x$with_cpu" != x; then
 			echo "Warning: --with-arch overrides --with-cpu=$with_cpu" 1>&2
 		fi
@@ -3495,13 +3616,13 @@
 				tm_defines="${tm_defines} CONFIG_PPC405CR"
 				eval "with_$which=405"
 				;;
-			"" | common \
+			"" | common | native \
 			| power | power[234567] | power6x | powerpc | powerpc64 \
 			| rios | rios1 | rios2 | rsc | rsc1 | rs64a \
 			| 401 | 403 | 405 | 405fp | 440 | 440fp | 464 | 464fp \
 			| 476 | 476fp | 505 | 601 | 602 | 603 | 603e | ec603e \
 			| 604 | 604e | 620 | 630 | 740 | 750 | 7400 | 7450 \
-			| a2 | e300c[23] | 854[08] | e500mc | e500mc64 | titan\
+			| a2 | e300c[23] | 854[08] | e500mc | e500mc64 | e5500 | titan \
 			| 801 | 821 | 823 | 860 | 970 | G3 | G4 | G5 | cell)
 				# OK
 				;;
@@ -3687,7 +3808,14 @@
 				tm_defines="TARGET_ENDIAN_DEFAULT=0 $tm_defines"
 				;;
 		esac
-		tmake_file="mips/t-mips $tmake_file"
+		case ${target} in
+			mips*-sde-elf*)
+				tmake_file="mips/t-fprules-softfp soft-fp/t-softfp $tmake_file"
+				;;
+			*)
+				tmake_file="mips/t-mips $tmake_file"
+				;;
+		esac
 		;;
 
 	powerpc*-*-* | rs6000-*-*)
@@ -3750,8 +3878,24 @@
 		;;
 esac
 
+case ${target} in
+    *-eglibc-*-*)
+	tmake_file="${tmake_file} t-eglibc"
+
+	case ${target} in
+	    arm-*)
+	     # ARM already includes below.
+		;;
+	    *)
+		tmake_file="${tmake_file} t-sysroot-suffix"
+		tm_file="${tm_file} ./sysroot-suffix.h"
+		;;
+	esac
+	;;
+esac
+
 t=
-all_defaults="abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu divide llsc mips-plt synci"
+all_defaults="abi cpu cpu_32 cpu_64 arch arch_32 arch_64 tune tune_32 tune_64 schedule float mode fpu divide llsc mips-plt synci tls"
 for option in $all_defaults
 do
 	eval "val=\$with_"`echo $option | sed s/-/_/g`
diff -ru ./gcc/config.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config.in
--- ./gcc/config.in	2014-06-06 11:50:14.327598555 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/config.in	2012-03-29 18:03:38.000000000 +1000
@@ -18,6 +18,18 @@
 #endif
 
 
+/* Required license feature */
+#ifndef USED_FOR_TARGET
+#undef CSL_LICENSE_FEATURE
+#endif
+
+
+/* Required license version */
+#ifndef USED_FOR_TARGET
+#undef CSL_LICENSE_VERSION
+#endif
+
+
 /* Define to enable the use of a default assembler. */
 #ifndef USED_FOR_TARGET
 #undef DEFAULT_ASSEMBLER
@@ -144,6 +156,12 @@
 #endif
 
 
+/* Define to warn for use of native system header directories */
+#ifndef USED_FOR_TARGET
+#undef ENABLE_POISON_SYSTEM_DIRECTORIES
+#endif
+
+
 /* Define if you want all operations on RTL (the basic data structure of the
    optimizer and back end) to be checked for dynamic type safety at runtime.
    This is quite expensive. */
@@ -956,6 +974,13 @@
 #endif
 
 
+/* Define if your assembler supports generation of .eh_frame_entry from CFI
+   directives. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_GAS_EH_FRAME_ENTRY
+#endif
+
+
 /* Define if your assembler supports @gnu_unique_object. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_GAS_GNU_UNIQUE_OBJECT
diff -ru ./gcc/configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/configure
--- ./gcc/configure	2014-06-06 14:25:27.374150548 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/configure	2012-03-29 18:03:38.000000000 +1000
@@ -755,6 +755,7 @@
 REPORT_BUGS_TEXI
 REPORT_BUGS_TO
 PKGVERSION
+EGLIBC_CONFIGS
 CONFIGURE_SPECS
 CROSS_SYSTEM_HEADER_DIR
 TARGET_SYSTEM_ROOT_DEFINE
@@ -798,6 +799,7 @@
 host_subdir
 build_subdir
 build_libsubdir
+licensedir
 target_noncanonical
 target_os
 target_vendor
@@ -853,6 +855,9 @@
 language_hooks'
 ac_user_opts='
 enable_option_checking
+with_csl_license_version
+with_license
+with_csl_license_feature
 with_build_libsubdir
 with_local_prefix
 with_gxx_include_dir
@@ -882,6 +887,7 @@
 with_build_sysroot
 with_sysroot
 with_specs
+with_eglibc_configs
 with_pkgversion
 with_bugurl
 enable_languages
@@ -911,6 +917,7 @@
 enable_maintainer_mode
 enable_version_specific_runtime_libs
 with_slibdir
+enable_poison_system_directories
 enable_plugin
 enable_libquadmath_support
 '
@@ -1622,6 +1629,8 @@
   --enable-version-specific-runtime-libs
                           specify that runtime libraries should be
                           installed in a compiler-specific directory
+  --enable-poison-system-directories
+                          warn for use of native system header directories
   --enable-plugin         enable plugin support
   --disable-libquadmath-support
                           disable libquadmath support for Fortran
@@ -1629,6 +1638,11 @@
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-csl-license-version=VERSION
+                          Use VERSION to communicate with the license manager
+  --with-license          the path to the installed license component
+  --with-csl-license-feature=FEATURE
+                          Use FEATURE to communicate with the license manager
   --with-build-libsubdir=DIR  Directory where to find libraries for build system
   --with-local-prefix=DIR specifies directory to put local include
   --with-gxx-include-dir=DIR
@@ -1647,6 +1661,8 @@
                           use sysroot as the system root during the build
   --with-sysroot=DIR Search for usr/lib, usr/include, et al, within DIR.
   --with-specs=SPECS      add SPECS to driver command-line processing
+  --with-eglibc-configs=CONFIGS
+                          build multilibs for these EGLIBC configurations
   --with-pkgversion=PKG   Use PKG in the version string in place of "GCC"
   --with-bugurl=URL       Direct users to URL to report a bug
   --with-multilib-list    Select multilibs (SH only)
@@ -3158,6 +3174,67 @@
 
 
 
+
+
+# Check whether --with-csl-license-version was given.
+if test "${with_csl_license_version+set}" = set; then :
+  withval=$with_csl_license_version; case "$withval" in
+      (yes) as_fn_error "license version not specified" "$LINENO" 5 ;;
+      (no)  CSL_LICENSE_VERSION="" ;;
+      (*)   CSL_LICENSE_VERSION="$withval" ;;
+     esac
+else
+  CSL_LICENSE_VERSION=""
+
+fi
+
+  if test x"$CSL_LICENSE_VERSION" != x; then
+
+cat >>confdefs.h <<_ACEOF
+#define CSL_LICENSE_VERSION "$CSL_LICENSE_VERSION"
+_ACEOF
+
+  fi
+
+
+
+# Check whether --with-license was given.
+if test "${with_license+set}" = set; then :
+  withval=$with_license; case "$withval" in
+     (yes) as_fn_error "license not specified" "$LINENO" 5 ;;
+     (no)  with_license= ;;
+     (*) ;;
+  esac
+else
+  with_license=
+fi
+
+  licensedir=$with_license
+
+
+
+
+# Check whether --with-csl-license-feature was given.
+if test "${with_csl_license_feature+set}" = set; then :
+  withval=$with_csl_license_feature; case "$withval" in
+      (yes) as_fn_error "license feature not specified" "$LINENO" 5 ;;
+      (no)  CSL_LICENSE_FEATURE="" ;;
+      (*)   CSL_LICENSE_FEATURE="$withval" ;;
+     esac
+else
+  CSL_LICENSE_FEATURE=""
+
+fi
+
+  if test x"$CSL_LICENSE_FEATURE" != x; then
+
+cat >>confdefs.h <<_ACEOF
+#define CSL_LICENSE_FEATURE "$CSL_LICENSE_FEATURE"
+_ACEOF
+
+  fi
+
+
 # Determine the target- and build-specific subdirectories
 
 # post-stage1 host modules use a different CC_FOR_BUILD so, in order to
@@ -3405,7 +3482,7 @@
 if test "${with_demangler_in_ld+set}" = set; then :
   withval=$with_demangler_in_ld; demangler_in_ld="$with_demangler_in_ld"
 else
-  demangler_in_ld=no
+  demangler_in_ld=yes
 fi
 
 
@@ -4842,7 +4919,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $acx_cv_cc_gcc_supports_ada" >&5
 $as_echo "$acx_cv_cc_gcc_supports_ada" >&6; }
 
-if test x$GNATBIND != xno && test x$GNATMAKE != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
+if test "x$GNATBIND" != xno && test "x$GNATMAKE" != xno && test x$acx_cv_cc_gcc_supports_ada != xno; then
   have_gnat=yes
 else
   have_gnat=no
@@ -6958,6 +7035,10 @@
 else
 
   case $target in
+    arm*)
+      enable_fixed_point=yes
+      ;;
+
     mips*-*-*)
       case $host in
 	mips*-sgi-irix*)
@@ -7120,6 +7201,17 @@
 
 
 
+# Check whether --with-eglibc-configs was given.
+if test "${with_eglibc_configs+set}" = set; then :
+  withval=$with_eglibc_configs; EGLIBC_CONFIGS=$withval
+else
+  EGLIBC_CONFIGS=
+
+fi
+
+
+
+
 
 # Check whether --with-pkgversion was given.
 if test "${with_pkgversion+set}" = set; then :
@@ -12417,6 +12509,10 @@
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
+nucleuseabi*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -12521,6 +12617,10 @@
   lt_cv_deplibs_check_method=pass_all
   ;;
 
+symbian*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -16895,6 +16995,21 @@
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -16982,6 +17097,14 @@
   need_version=yes
   ;;
 
+symbian*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+  library_names_spec='${libname}.dll'
+  ;;
+
 sysv4 | sysv4.3*)
   version_type=linux
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
@@ -17495,7 +17618,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17498 "configure"
+#line 17621 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -17601,7 +17724,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17604 "configure"
+#line 17727 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -19443,6 +19566,10 @@
       # Interix 3.x gcc -fpic/-fPIC options generate broken code.
       # Instead, we relocate shared libraries at runtime.
       ;;
+    symbian*)
+      # symbian does not have PIC, the loader relocates non-pic shared objects
+      lt_prog_compiler_pic_CXX=
+      ;;
     sysv4*MP*)
       if test -d /usr/nec; then
 	lt_prog_compiler_pic_CXX=-Kconform_pic
@@ -20554,6 +20681,21 @@
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -20641,6 +20783,14 @@
   need_version=yes
   ;;
 
+symbian*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+  library_names_spec='${libname}.dll'
+  ;;
+
 sysv4 | sysv4.3*)
   version_type=linux
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
@@ -25490,6 +25640,37 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_eh_gc_sections_bug" >&5
 $as_echo "$gcc_cv_ld_eh_gc_sections_bug" >&6; }
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for CFI .eh_frame_entry" >&5
+$as_echo_n "checking assembler for CFI .eh_frame_entry... " >&6; }
+if test "${gcc_cv_as_eh_frame_entry+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  gcc_cv_as_eh_frame_entry=no
+  if test x$gcc_cv_as != x; then
+    echo '	.cfi_sections .eh_frame_entry ' > conftest.s
+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }
+    then
+	gcc_cv_as_eh_frame_entry=yes
+    else
+      echo "configure: failed program was" >&5
+      cat conftest.s >&5
+    fi
+    rm -f conftest.o conftest.s
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_eh_frame_entry" >&5
+$as_echo "$gcc_cv_as_eh_frame_entry" >&6; }
+if test $gcc_cv_as_eh_frame_entry = yes; then
+
+$as_echo "#define HAVE_GAS_EH_FRAME_ENTRY 1" >>confdefs.h
+
+fi
+
 # --------
 # UNSORTED
 # --------
@@ -25741,6 +25922,9 @@
   gcc_cv_libc_provides_ssp=no
     case "$target" in
        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
+      if test "x$enable_libssp" = "xno"; then
+	gcc_cv_libc_provides_ssp=yes
+      fi
       # glibc 2.4 and later provides __stack_chk_fail and
       # either __stack_chk_guard, or TLS access to stack guard canary.
       if test -f $target_header_dir/features.h \
@@ -26122,6 +26306,19 @@
 
 
 
+# Check whether --enable-poison-system-directories was given.
+if test "${enable_poison_system_directories+set}" = set; then :
+  enableval=$enable_poison_system_directories;
+else
+  enable_poison_system_directories=no
+fi
+
+if test "x${enable_poison_system_directories}" = "xyes"; then
+
+$as_echo "#define ENABLE_POISON_SYSTEM_DIRECTORIES 1" >>confdefs.h
+
+fi
+
 # Substitute configuration variables
 
 
diff -ru ./gcc/configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/configure.ac
--- ./gcc/configure.ac	2014-06-06 14:25:27.378150548 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/configure.ac	2012-03-29 18:03:19.000000000 +1000
@@ -39,6 +39,10 @@
 # Determine the noncanonical target name, for directory use.
 ACX_NONCANONICAL_TARGET
 
+CSL_AC_LICENSE_VERSION
+CSL_AC_LICENSE
+CSL_AC_LICENSE_FEATURE
+
 # Determine the target- and build-specific subdirectories
 GCC_TOPLEV_SUBDIRS
 
@@ -221,7 +225,7 @@
 AC_ARG_WITH(demangler-in-ld,
 [  --with-demangler-in-ld  try to use demangler in GNU ld.],
 demangler_in_ld="$with_demangler_in_ld",
-demangler_in_ld=no)
+demangler_in_ld=yes)
 
 # ----------------------
 # Find default assembler
@@ -633,6 +637,10 @@
 ],
 [
   case $target in
+    arm*)
+      enable_fixed_point=yes
+      ;;
+
     mips*-*-*)
       case $host in
 	mips*-sgi-irix*)
@@ -760,6 +768,14 @@
 )
 AC_SUBST(CONFIGURE_SPECS)
 
+AC_ARG_WITH(eglibc-configs,
+  [AS_HELP_STRING([--with-eglibc-configs=CONFIGS],
+                  [build multilibs for these EGLIBC configurations])],
+  [EGLIBC_CONFIGS=$withval],
+  [EGLIBC_CONFIGS=]
+)
+AC_SUBST(EGLIBC_CONFIGS)
+
 ACX_PKGVERSION([GCC])
 ACX_BUGURL([http://gcc.gnu.org/bugs.html])
 
@@ -4140,6 +4156,13 @@
 fi
 AC_MSG_RESULT($gcc_cv_ld_eh_gc_sections_bug)
 
+gcc_GAS_CHECK_FEATURE([CFI .eh_frame_entry],
+ gcc_cv_as_eh_frame_entry,
+ ,,
+[	.cfi_sections .eh_frame_entry ],,
+[AC_DEFINE(HAVE_GAS_EH_FRAME_ENTRY, 1,
+[Define if your assembler supports generation of .eh_frame_entry from CFI directives.])])
+
 # --------
 # UNSORTED
 # --------
@@ -4339,6 +4362,9 @@
       [gcc_cv_libc_provides_ssp=no
     case "$target" in
        *-*-linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu)
+      if test "x$enable_libssp" = "xno"; then
+	gcc_cv_libc_provides_ssp=yes
+      fi
       [# glibc 2.4 and later provides __stack_chk_fail and
       # either __stack_chk_guard, or TLS access to stack guard canary.
       if test -f $target_header_dir/features.h \
@@ -4690,6 +4716,16 @@
 fi)
 AC_SUBST(slibdir)
 
+AC_ARG_ENABLE([poison-system-directories],
+	      AS_HELP_STRING([--enable-poison-system-directories],
+			     [warn for use of native system header directories]),,
+	      [enable_poison_system_directories=no])
+if test "x${enable_poison_system_directories}" = "xyes"; then
+  AC_DEFINE([ENABLE_POISON_SYSTEM_DIRECTORIES],
+	    [1],
+	    [Define to warn for use of native system header directories])
+fi
+
 # Substitute configuration variables
 AC_SUBST(subdirs)
 AC_SUBST(srcdir)
diff -ru ./gcc/cp/cp-lang.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cp/cp-lang.c
--- ./gcc/cp/cp-lang.c	2014-06-06 11:50:16.951598654 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cp/cp-lang.c	2012-04-28 17:58:33.000000000 +1000
@@ -161,7 +161,10 @@
   if (!cp_eh_personality_decl)
     {
       const char *lang = (pragma_java_exceptions ? "gcj" : "gxx");
-      cp_eh_personality_decl = build_personality_function (lang);
+      cp_eh_personality_decl = build_personality_function (lang, false);
+      if (TARGET_COMPACT_EH)
+	 DECL_FUNCTION_PERSONALITY2 (current_function_decl) =
+           build_personality_function (lang, true);
     }
 
   return cp_eh_personality_decl;
diff -ru ./gcc/cp/decl2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cp/decl2.c
--- ./gcc/cp/decl2.c	2014-06-06 14:25:27.390150549 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cp/decl2.c	2012-03-29 18:01:56.000000000 +1000
@@ -4173,6 +4173,15 @@
 
   /* Set TREE_USED for the benefit of -Wunused.  */
   TREE_USED (decl) = 1;
+  if (current_function_decl != NULL_TREE
+      && (TREE_CODE (decl) == VAR_DECL
+	  || TREE_CODE (decl) == PARM_DECL
+	  || TREE_CODE (decl) == FUNCTION_DECL))
+    {
+      tree context = decl_function_context (decl);
+      if (context != NULL_TREE && context != current_function_decl)
+	DECL_NONLOCAL (decl) = 1;
+    }
   if (DECL_CLONED_FUNCTION_P (decl))
     TREE_USED (DECL_CLONED_FUNCTION (decl)) = 1;
 
diff -ru ./gcc/cp/semantics.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cp/semantics.c
--- ./gcc/cp/semantics.c	2014-06-06 14:25:27.426150550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cp/semantics.c	2012-04-18 18:11:41.000000000 +1000
@@ -6763,7 +6763,6 @@
 
   STRIP_NOPS (sub);
   subtype = TREE_TYPE (sub);
-  gcc_assert (POINTER_TYPE_P (subtype));
 
   if (TREE_CODE (sub) == ADDR_EXPR)
     {
diff -ru ./gcc/crtstuff.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/crtstuff.c
--- ./gcc/crtstuff.c	2014-06-06 11:50:17.047598658 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/crtstuff.c	2012-03-29 18:03:19.000000000 +1000
@@ -152,6 +152,9 @@
 extern void __register_frame_info_bases (const void *, struct object *,
 					 void *, void *)
 				  TARGET_ATTRIBUTE_WEAK;
+extern void __register_frame_info_header_bases (const void *, struct object *,
+					 void *, void *)
+				  TARGET_ATTRIBUTE_WEAK;
 extern void *__deregister_frame_info (const void *)
 				     TARGET_ATTRIBUTE_WEAK;
 extern void *__deregister_frame_info_bases (const void *)
@@ -226,6 +229,10 @@
 STATIC EH_FRAME_SECTION_CONST char __EH_FRAME_BEGIN__[]
      __attribute__((section(EH_FRAME_SECTION_NAME), aligned(4)))
      = { };
+
+#ifdef MD_HAVE_COMPACT_EH
+extern char __GNU_EH_FRAME_HDR[] TARGET_ATTRIBUTE_WEAK;
+#endif /* MD_HAVE_COMPACT_EH */
 #endif /* USE_EH_FRAME_REGISTRY */
 
 #ifdef JCR_SECTION_NAME
@@ -327,6 +334,12 @@
 
 #ifdef USE_EH_FRAME_REGISTRY
 #ifdef CRT_GET_RFIB_DATA
+#ifdef MD_HAVE_COMPACT_EH
+  if (__register_frame_info_header_bases && __GNU_EH_FRAME_HDR &&
+      __GNU_EH_FRAME_HDR[0] > 1)
+    __deregister_frame_info_bases (__GNU_EH_FRAME_HDR);
+  else
+#endif /* MD_HAVE_COMPACT_EH */
   /* If we used the new __register_frame_info_bases interface,
      make sure that we deregister from the same place.  */
   if (__deregister_frame_info_bases)
@@ -370,6 +383,13 @@
   void *tbase, *dbase;
   tbase = 0;
   CRT_GET_RFIB_DATA (dbase);
+#ifdef MD_HAVE_COMPACT_EH
+  if (__register_frame_info_header_bases && __GNU_EH_FRAME_HDR &&
+      __GNU_EH_FRAME_HDR[0] > 1)
+    __register_frame_info_header_bases (__GNU_EH_FRAME_HDR, &object,
+					tbase, dbase);
+  else
+#endif /* MD_HAVE_COMPACT_EH */
   if (__register_frame_info_bases)
     __register_frame_info_bases (__EH_FRAME_BEGIN__, &object, tbase, dbase);
 #else
diff -ru ./gcc/cse.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cse.c
--- ./gcc/cse.c	2014-06-06 11:50:17.051598658 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/cse.c	2012-03-29 18:03:19.000000000 +1000
@@ -3054,6 +3054,12 @@
 	  if (! exp_equiv_p (p->exp, p->exp, 1, false))
 	    continue;
 
+	  /* If it's the same comparison we're already looking at, skip it.  */
+	  if (COMPARISON_P (p->exp)
+	      && XEXP (p->exp, 0) == arg1
+	      && XEXP (p->exp, 1) == arg2)
+	    continue;
+
 	  if (GET_CODE (p->exp) == COMPARE
 	      /* Another possibility is that this machine has a compare insn
 		 that includes the comparison code.  In that case, ARG1 would
@@ -4231,7 +4237,8 @@
 	{
 	  if (GET_CODE (XEXP (tem, 0)) == CLOBBER)
 	    invalidate (SET_DEST (XEXP (tem, 0)), VOIDmode);
-	  XEXP (tem, 0) = canon_reg (XEXP (tem, 0), insn);
+	  if (GET_CODE (XEXP (tem, 0)) != SET)
+	    XEXP (tem, 0) = canon_reg (XEXP (tem, 0), insn);
 	}
     }
 
@@ -6071,6 +6078,11 @@
       validate_change (object, &XEXP (x, i),
 		       cse_process_notes (XEXP (x, i), object, changed), 0);
 
+  /* Rebuild a PLUS expression in canonical form if the first operand
+     ends up as a constant.  */
+  if (code == PLUS && GET_CODE (XEXP (x, 0)) == CONST_INT)
+    return plus_constant (XEXP(x, 1), INTVAL (XEXP (x, 0)));
+
   return x;
 }
 
diff -ru ./gcc/dbgcnt.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dbgcnt.def
--- ./gcc/dbgcnt.def	2014-06-06 11:50:17.059598659 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dbgcnt.def	2012-03-29 18:03:19.000000000 +1000
@@ -184,3 +184,4 @@
 DEBUG_COUNTER (store_motion)
 DEBUG_COUNTER (split_for_sched2)
 DEBUG_COUNTER (tail_call)
+DEBUG_COUNTER (ira_move)
diff -ru ./gcc/defaults.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/defaults.h
--- ./gcc/defaults.h	2014-06-06 11:50:17.067598659 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/defaults.h	2012-05-01 20:55:44.000000000 +1000
@@ -380,6 +380,10 @@
 #endif
 #endif
 
+#ifndef TARGET_COMPACT_EH
+#define TARGET_COMPACT_EH 0
+#endif
+
 /* If we have named section and we support weak symbols, then use the
    .jcr section for recording java classes which need to be registered
    at program start-up time.  */
diff -ru ./gcc/df-problems.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/df-problems.c
--- ./gcc/df-problems.c	2014-06-06 14:25:27.434150550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/df-problems.c	2012-03-29 18:03:19.000000000 +1000
@@ -4024,7 +4024,10 @@
 	  if (bitmap_intersect_p (merge_set, test_use)
 	      || bitmap_intersect_p (merge_use, test_set))
 	    break;
-	  max_to = insn;
+#ifdef HAVE_cc0
+	  if (!sets_cc0_p (insn))
+#endif
+	    max_to = insn;
 	}
       next = NEXT_INSN (insn);
       if (insn == to)
@@ -4061,7 +4064,11 @@
     {
       if (NONDEBUG_INSN_P (insn))
 	{
-	  if (!bitmap_intersect_p (test_set, local_merge_live))
+	  if (!bitmap_intersect_p (test_set, local_merge_live)
+#ifdef HAVE_cc0
+	      && !sets_cc0_p (insn)
+#endif
+	      )
 	    {
 	      max_to = insn;
 	      break;
diff -ru ./gcc/df-scan.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/df-scan.c
--- ./gcc/df-scan.c	2014-06-06 11:50:17.075598659 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/df-scan.c	2012-03-29 18:03:19.000000000 +1000
@@ -3181,6 +3181,7 @@
       }
 
     case RETURN:
+    case SIMPLE_RETURN:
       break;
 
     case ASM_OPERANDS:
@@ -3323,6 +3324,7 @@
   unsigned int i;
   df_ref def;
   bitmap_head defs_generated;
+  HARD_REG_SET fn_reg_set_usage;
 
   bitmap_initialize (&defs_generated, &df_bitmap_obstack);
 
@@ -3374,9 +3376,14 @@
 			   NULL, bb, insn_info, DF_REF_REG_DEF, flags);
 	}
 
+  get_call_reg_set_usage (insn_info->insn, &fn_reg_set_usage,
+			  regs_invalidated_by_call);
   is_sibling_call = SIBLING_CALL_P (insn_info->insn);
   EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, ui, bi)
     {
+      if (!TEST_HARD_REG_BIT (fn_reg_set_usage, ui))
+	 continue;
+
       if (!global_regs[ui]
 	  && (!bitmap_bit_p (&defs_generated, ui))
 	  && (!is_sibling_call
diff -ru ./gcc/doc/extend.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/extend.texi
--- ./gcc/doc/extend.texi	2014-06-06 11:50:17.103598660 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/extend.texi	2012-03-29 17:55:03.000000000 +1000
@@ -2785,6 +2785,25 @@
 may interact badly with some GCC extensions such as @code{__builtin_apply}
 (@pxref{Constructing Calls}).
 
+@item micromips/nomicromips
+@cindex @code{micromips} attribute
+@cindex @code{nomicromips} attribute
+
+On MIPS targets, you can use the @code{micromips} and @code{nomicromips}
+function attributes to locally select or turn off microMIPS code generation.
+A function with the @code{micromips} attribute is emitted as microMIPS code,
+while microMIPS code generation is disabled for functions with the
+@code{nomicromips} attribute.  These attributes override the
+@option{-mmicromips} and @option{-mno-micromips} options on the command line
+(@pxref{MIPS Options}).
+
+When compiling files containing mixed microMIPS and non-microMIPS code, the
+preprocessor symbol @code{__mips_micromips} reflects the setting on the
+command line,
+not that within individual functions.  Mixed microMIPS and non-microMIPS code
+may interact badly with some GCC extensions such as @code{__builtin_apply}
+(@pxref{Constructing Calls}).
+
 @item model (@var{model-name})
 @cindex function addressability on the M32R/D
 @cindex variable addressability on the IA-64
@@ -12528,6 +12547,106 @@
 functions generate multiple instructions to implement division using
 the reciprocal estimate instructions.
 
+GCC also provides a family of builtins on PowerPC to explicitly use
+the @code{isel} instruction.  While GCC can and does generate
+@code{isel} instructions normally, the builtins enable you to
+explicitly force generation of these instructions.  The builtins are
+only available when compiling for processors that support the
+@code{isel} instruction; they compile to a code sequence of
+@code{cmpw} followed by @code{isel}.
+
+@table @code
+@item int __builtin_iseleq (int @var{x}, int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iseleq (unsigned int @var{x}, unsigned int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iseleq (void *@var{x}, void *@var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iseleq (int @var{x}, int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iseleq (unsigned int @var{x}, unsigned int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iseleq (void *@var{x}, void *@var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iseleq (int @var{x}, int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iseleq (unsigned int @var{x}, unsigned int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iseleq (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} and @var{y} are equal, otherwise return @var{b}.
+
+@item int __builtin_isellt (int @var{x}, int @var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_isellt (int @var{x}, int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_isellt (int @var{x}, int @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item int __builtin_iselgt (int @var{x}, int @var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iselgt (int @var{x}, int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iselgt (int @var{x}, int @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item int __builtin_iselltu (unsigned int @var{x}, unsigned int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iselltu (void *@var{x}, void *@var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iselltu (unsigned int @var{x}, unsigned int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iselltu (void *@var{x}, void *@var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iselltu (unsigned int @var{x}, unsigned int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iselltu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_isellt}, this uses unsigned comparison.
+
+@item int __builtin_iselgtu (unsigned int @var{x}, unsigned int @var{y}, int @var{a}, int @var{b})
+@itemx int __builtin_iselgtu (void *@var{x}, void *@var{y}, int @var{a}, int @var{b})
+@itemx unsigned int __builtin_iselgtu (unsigned int @var{x}, unsigned int @var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx unsigned int __builtin_iselgtu (void *@var{x}, void *@var{y}, unsigned int @var{a}, unsigned int @var{b})
+@itemx void *__builtin_iselgtu (unsigned int @var{x}, unsigned int @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_iselgtu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_iselgt}, this uses unsigned comparison.
+
+@end table
+
+Builtins that do 64-bit comparisons (i.e. using @code{cmpd} instead of
+@code{cmpw}) are also available on 64-bit processors supporting
+@code{isel}.
+
+@table @code
+@item long __builtin_isel64eq (long @var{x}, long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64eq (unsigned long @var{x}, unsigned long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64eq (void *@var{x}, void *@var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64eq (long @var{x}, long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64eq (unsigned long @var{x}, unsigned long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64eq (void *@var{x}, void *@var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64eq (long @var{x}, long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64eq (unsigned long @var{x}, unsigned long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64eq (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} and @var{y} are equal, otherwise return @var{b}.
+
+@item long __builtin_isel64lt (long @var{x}, long @var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64lt (long @var{x}, long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64lt (long @var{x}, long @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item long __builtin_isel64gt (long @var{x}, long @var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64gt (long @var{x}, long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64gt (long @var{x}, long @var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}.
+Note that this uses signed comparison.
+
+@item long __builtin_isel64ltu (unsigned long @var{x}, unsigned long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64ltu (void *@var{x}, void *@var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64ltu (unsigned long @var{x}, unsigned long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64ltu (void *@var{x}, void *@var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64ltu (unsigned long @var{x}, unsigned long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64ltu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is less than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_isel64lt}, this uses unsigned comparison.
+
+@item long __builtin_isel64gtu (unsigned long @var{x}, unsigned long @var{y}, long @var{a}, long @var{b})
+@itemx long __builtin_isel64gtu (void *@var{x}, void *@var{y}, long @var{a}, long @var{b})
+@itemx unsigned long __builtin_isel64gtu (unsigned long @var{x}, unsigned long @var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx unsigned long __builtin_isel64gtu (void *@var{x}, void *@var{y}, unsigned long @var{a}, unsigned long @var{b})
+@itemx void *__builtin_isel64gtu (unsigned long @var{x}, unsigned long @var{y}, void *@var{a}, void *@var{b})
+@itemx void *__builtin_isel64gtu (void *@var{x}, void *@var{y}, void *@var{a}, void *@var{b})
+Return @var{a} if @var{x} is greater than @var{y}, otherwise return @var{b}
+In contrast to @code{__builtin_isel64gt}, this uses unsigned comparison.
+
+@end table
+
 @node RX Built-in Functions
 @subsection RX Built-in Functions
 GCC supports some of the RX instructions which cannot be expressed in
diff -ru ./gcc/doc/fragments.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/fragments.texi
--- ./gcc/doc/fragments.texi	2014-06-06 14:25:27.434150550 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/fragments.texi	2012-03-29 17:55:03.000000000 +1000
@@ -143,6 +143,22 @@
 *mthumb/*mhard-float*
 @end smallexample
 
+@findex MULTILIB_ALIASES
+@item MULTILIB_ALIASES
+Sometimes it is desirable to support a large set of multilib options, but
+only build libraries for a subset of those multilibs.  The remaining
+combinations use a sutiable alternative multilb.  In that case, set
+@code{MULTILIB_ALIASES} to a list of the form @samp{realname=aliasname}.
+
+For example, consider a little-endian ARM toolchain with big-endian and
+Thumb multilibs.  If a big-endian Thumb multilib is not wanted, then
+setting @code{MULTILIB_ALIASES} to @samp{mbig-endian=mbig-endian/mthumb} 
+makes this combination use the big-endian ARM libraries instead.
+
+If the multilib is instead excluded by setting @code{MULTILIB_EXCEPTIONS}
+then big-endian Thumb code uses the default multilib as none of the
+remaining multilibs match.
+
 @findex MULTILIB_EXTRA_OPTS
 @item MULTILIB_EXTRA_OPTS
 Sometimes it is desirable that when building multiple versions of
diff -ru ./gcc/doc/install.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/install.texi
--- ./gcc/doc/install.texi	2014-06-06 14:25:27.442150551 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/install.texi	2012-03-29 17:55:03.000000000 +1000
@@ -1005,6 +1005,12 @@
 workable alternative.  This requires gas and gdb, as the normal SVR4
 tools can not generate or interpret stabs.
 
+@item --with-tls=@var{dialect}
+Specify the default TLS dialect, for systems were there is a choice.
+For ARM targets, possible values for @var{dialect} are @code{gnu} or
+@code{gnu2}, which select between the original GNU dialect and the GNU TLS
+descriptor-based dialect.
+
 @item --disable-multilib
 Specify that multiple target
 libraries to support different target variants, calling
diff -ru ./gcc/doc/invoke.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/invoke.texi
--- ./gcc/doc/invoke.texi	2014-06-06 14:25:27.454150551 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/invoke.texi	2012-03-29 17:55:03.000000000 +1000
@@ -257,6 +257,7 @@
 -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol
 -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol
 -Wpointer-arith  -Wno-pointer-to-int-cast @gol
+-Wno-poison-system-directories @gol
 -Wredundant-decls @gol
 -Wreturn-type  -Wsequence-point  -Wshadow @gol
 -Wsign-compare  -Wsign-conversion  -Wstack-protector @gol
@@ -334,7 +335,8 @@
 
 @item Optimization Options
 @xref{Optimize Options,,Options that Control Optimization}.
-@gccoptlist{-falign-functions[=@var{n}] -falign-jumps[=@var{n}] @gol
+@gccoptlist{-falign-arrays
+-falign-functions[=@var{n}] -falign-jumps[=@var{n}] @gol
 -falign-labels[=@var{n}] -falign-loops[=@var{n}] -fassociative-math @gol
 -fauto-inc-dec -fbranch-probabilities -fbranch-target-load-optimize @gol
 -fbranch-target-load-optimize2 -fbtr-bb-exclusive -fcaller-saves @gol
@@ -385,14 +387,14 @@
 -fschedule-insns -fschedule-insns2 -fsection-anchors @gol
 -fselective-scheduling -fselective-scheduling2 @gol
 -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol
--fsignaling-nans -fsingle-precision-constant -fsplit-ivs-in-unroller @gol
--fsplit-wide-types -fstack-protector -fstack-protector-all @gol
--fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer @gol
--ftree-bit-ccp @gol
+-fshrink-wrap -fsignaling-nans -fsingle-precision-constant @gol
+-fsplit-ivs-in-unroller -fsplit-wide-types -fstack-protector @gol
+-fstack-protector-all -fstrict-aliasing -fstrict-overflow @gol
+-fthread-jumps -ftracer -ftree-bit-ccp @gol
 -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copy-prop @gol
 -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse @gol
--ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol
--ftree-loop-if-convert-stores -ftree-loop-im @gol
+-ftree-forwprop -ftree-fre -ftree-if-to-switch-conversion @gol
+-ftree-loop-if-convert -ftree-loop-if-convert-stores -ftree-loop-im @gol
 -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol
 -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol
 -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-pta -ftree-reassoc @gol
@@ -474,7 +476,7 @@
 -mthumb  -marm @gol
 -mtpcs-frame  -mtpcs-leaf-frame @gol
 -mcaller-super-interworking  -mcallee-super-interworking @gol
--mtp=@var{name} @gol
+-mtp=@var{name} -mtls-dialect=@var{dialect} @gol
 -mword-relocations @gol
 -mfix-cortex-m3-ldrd}
 
@@ -705,12 +707,13 @@
 @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol
 -mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2 @gol
 -mips64  -mips64r2 @gol
--mips16  -mno-mips16  -mflip-mips16 @gol
+-mips16  -mips16e  -mno-mips16  -mflip-mips16 @gol
 -minterlink-mips16  -mno-interlink-mips16 @gol
 -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol
 -mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot @gol
 -mgp32  -mgp64  -mfp32  -mfp64  -mhard-float  -msoft-float @gol
 -msingle-float  -mdouble-float  -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol
+-mmicromips -mno-micromips -mmcu -mmno-mcu @gol
 -mfpu=@var{fpu-type} @gol
 -msmartmips  -mno-smartmips @gol
 -mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx @gol
@@ -726,7 +729,9 @@
 -mcheck-zero-division  -mno-check-zero-division @gol
 -mdivide-traps  -mdivide-breaks @gol
 -mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls @gol
+-mjals -mno-jals @gol
 -mmad  -mno-mad  -mfused-madd  -mno-fused-madd  -nocpp @gol
+-mfix-24k -mno-fix-24k @gol
 -mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 @gol
 -mfix-r10000 -mno-fix-r10000  -mfix-vr4120  -mno-fix-vr4120 @gol
 -mfix-vr4130  -mno-fix-vr4130  -mfix-sb1  -mno-fix-sb1 @gol
@@ -734,7 +739,7 @@
 -mbranch-cost=@var{num}  -mbranch-likely  -mno-branch-likely @gol
 -mfp-exceptions -mno-fp-exceptions @gol
 -mvr4130-align -mno-vr4130-align -msynci -mno-synci @gol
--mrelax-pic-calls -mno-relax-pic-calls -mmcount-ra-address}
+-mrelax-pic-calls -mno-relax-pic-calls -mmcount-ra-address -mno-compact-eh}
 
 @emph{MMIX Options}
 @gccoptlist{-mlibfuncs  -mno-libfuncs  -mepsilon  -mno-epsilon  -mabi=gnu @gol
@@ -937,6 +942,7 @@
 -finhibit-size-directive  -finstrument-functions @gol
 -finstrument-functions-exclude-function-list=@var{sym},@var{sym},@dots{} @gol
 -finstrument-functions-exclude-file-list=@var{file},@var{file},@dots{} @gol
+-finstrument-function-calls @gol
 -fno-common  -fno-ident @gol
 -fpcc-struct-return  -fpic  -fPIC -fpie -fPIE @gol
 -fno-jump-tables @gol
@@ -3782,6 +3788,14 @@
  for most targets, it is made up of code and thus requires the stack
  to be made executable in order for the program to work properly.
 
+@item -Wno-poison-system-directories
+@opindex Wno-poison-system-directories
+Do not warn for @option{-I} or @option{-L} options using system
+directories such as @file{/usr/include} when cross compiling.  This
+option is intended for use in chroot environments when such
+directories contain the correct headers and libraries for the target
+system rather than the host.
+
 @item -Wfloat-equal
 @opindex Wfloat-equal
 @opindex Wno-float-equal
@@ -5975,6 +5989,7 @@
 -fsched-interblock  -fsched-spec @gol
 -fschedule-insns  -fschedule-insns2 @gol
 -fstrict-aliasing -fstrict-overflow @gol
+-ftree-if-to-switch-conversion @gol
 -ftree-switch-conversion @gol
 -ftree-pre @gol
 -ftree-vrp}
@@ -6716,6 +6731,11 @@
 When pipelining loops during selective scheduling, also pipeline outer loops.
 This option has no effect until @option{-fsel-sched-pipelining} is turned on.
 
+@item -fshrink-wrap
+@opindex fshrink-wrap
+Emit function prologues only before parts of the function that need it,
+rather than at the top of the function.
+
 @item -fcaller-saves
 @opindex fcaller-saves
 Enable values to be allocated in registers that will be clobbered by
@@ -6870,6 +6890,10 @@
 initializations from a scalar array.  This flag is enabled by default
 at @option{-O2} and higher.
 
+@item -ftree-if-to-switch-conversion
+Perform conversion of chains of ifs into switches.  This flag is enabled by
+default at @option{-O2} and higher.
+
 @item -ftree-dce
 @opindex ftree-dce
 Perform dead code elimination (DCE) on trees.  This flag is enabled by
@@ -7403,6 +7427,14 @@
 The @option{-fstrict-overflow} option is enabled at levels
 @option{-O2}, @option{-O3}, @option{-Os}.
 
+@item -falign-arrays
+@opindex falign-arrays
+Set the minimum alignment for array variables to be the largest power
+of two less than or equal to their total storage size, or the biggest
+alignment used on the machine, whichever is smaller.  This option may be
+helpful when compiling legacy code that uses type punning on arrays that
+does not strictly conform to the C standard.
+
 @item -falign-functions
 @itemx -falign-functions=@var{n}
 @opindex falign-functions
@@ -8214,6 +8246,21 @@
 
 Not all targets support this option.
 
+@item -fremove-local-statics
+@opindex fremove-local-statics
+Converts function-local static variables to automatic variables when it
+is safe to do so.  This transformation can reduce the number of
+instructions executed due to automatic variables being cheaper to
+read/write than static variables.
+
+@item -fpromote-loop-indices
+@opindex fpromote-loop-indices
+Converts loop indices that have a type shorter than the word size to
+word-sized quantities.  This transformation can reduce the overhead
+associated with sign/zero-extension and truncation of such variables.
+Using @option{-funsafe-loop-optimizations} with this option may result
+in more effective optimization.
+
 @item --param @var{name}=@var{value}
 @opindex param
 In some places, GCC uses various constants to control the amount of
@@ -8302,6 +8349,11 @@
 with few branches or calls can create excessively large lists which
 needlessly consume memory and resources.
 
+@item max-modulo-backtrack-attempts
+The maximum number of backtrack attempts the scheduler should make
+when modulo scheduling a loop.  Larger values can exponentially increase
+compile time.
+
 @item max-inline-insns-single
 Several parameters control the tree inliner used in gcc.
 This number sets the maximum number of instructions (counted in GCC's
@@ -8707,6 +8759,11 @@
 speculative insn will be scheduled.
 The default value is 40.
 
+@item sched-spec-state-edge-prob-cutoff
+The minimum probability an edge must have for the scheduler to save its
+state across it.
+The default value is 10.
+
 @item sched-mem-true-dep-cost
 Minimal distance (in CPU cycles) between store and load targeting same
 memory locations.  The default value is 1.
@@ -8904,6 +8961,12 @@
 The maximum number of namespaces to consult for suggestions when C++
 name lookup fails for an identifier.  The default is 1000.
 
+@item if-to-switch-threshold
+If-chain to switch conversion, enabled by
+@option{-ftree-if-to-switch-conversion} convert chains of ifs of sufficient
+length into switches.  The parameter @option{if-to-switch-threshold} can be
+used to set the minimal required length.  The default value is 3.
+
 @end table
 @end table
 
@@ -10194,9 +10257,8 @@
 @samp{arm1136j-s}, @samp{arm1136jf-s}, @samp{mpcore}, @samp{mpcorenovfp},
 @samp{arm1156t2-s}, @samp{arm1156t2f-s}, @samp{arm1176jz-s}, @samp{arm1176jzf-s},
 @samp{cortex-a5}, @samp{cortex-a8}, @samp{cortex-a9}, @samp{cortex-a15},
-@samp{cortex-r4}, @samp{cortex-r4f}, @samp{cortex-m4}, @samp{cortex-m3},
-@samp{cortex-m1},
-@samp{cortex-m0},
+@samp{cortex-r4}, @samp{cortex-r4f}, @samp{cortex-r5}, @samp{cortex-m4},
+@samp{cortex-m3}, @samp{cortex-m1}, @samp{cortex-m0},
 @samp{xscale}, @samp{iwmmxt}, @samp{iwmmxt2}, @samp{ep9312}.
 
 @item -mtune=@var{name}
@@ -10401,6 +10463,18 @@
 best available method for the selected processor.  The default setting is
 @option{auto}.
 
+@item -mtls-dialect=@var{dialect}
+@opindex mtls-dialect
+Specify the dialect to use for accessing thread local storage.  Two
+dialects are supported - @option{gnu} and @option{gnu2}.  The
+@option{gnu} dialect selects the original GNU scheme for supporting
+local and global dynamic TLS models.  The @option{gnu2} dialect
+selects the GNU descriptor scheme, which provides better performance
+for shared libraries.  The GNU descriptor scheme is compatible with
+the original scheme, but does require new assembler, linker and
+library support.  Initial and local exec TLS models are unaffected by
+this option and always use the original scheme.
+
 @item -mword-relocations
 @opindex mword-relocations
 Only generate absolute relocations on word sized values (i.e. R_ARM_ABS32).
@@ -13534,7 +13608,7 @@
 
 @multitable @columnfractions 0.20 0.80
 @item @strong{Family} @tab @strong{@samp{-mcpu} arguments}
-@item @samp{51} @tab @samp{51} @samp{51ac} @samp{51cn} @samp{51em} @samp{51qe}
+@item @samp{51} @tab @samp{51} @samp{51ac} @samp{51ag} @samp{51cn} @samp{51em} @samp{51je} @samp{51jf} @samp{51jg} @samp{51jm} @samp{51mm} @samp{51qe} @samp{51qm}
 @item @samp{5206} @tab @samp{5202} @samp{5204} @samp{5206}
 @item @samp{5206e} @tab @samp{5206e}
 @item @samp{5208} @tab @samp{5207} @samp{5208}
@@ -14314,7 +14388,7 @@
 @samp{74kc}, @samp{74kf2_1}, @samp{74kf1_1}, @samp{74kf3_2},
 @samp{1004kc}, @samp{1004kf2_1}, @samp{1004kf1_1},
 @samp{loongson2e}, @samp{loongson2f}, @samp{loongson3a},
-@samp{m4k},
+@samp{m4k}, @samp{m14k}, @samp{m14ke}, @samp{m14kec},
 @samp{octeon},
 @samp{orion},
 @samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},
@@ -14412,11 +14486,14 @@
 Equivalent to @samp{-march=mips64r2}.
 
 @item -mips16
+@itemx -mips16e
 @itemx -mno-mips16
 @opindex mips16
+@opindex mips16e
 @opindex mno-mips16
 Generate (do not generate) MIPS16 code.  If GCC is targetting a
 MIPS32 or MIPS64 architecture, it will make use of the MIPS16e ASE@.
+@option{-mips16e} is a deprecated alias for @option{-mips16}.
 
 MIPS16 code generation can also be controlled on a per-function basis
 by means of @code{mips16} and @code{nomips16} attributes.
@@ -14432,13 +14509,14 @@
 @itemx -mno-interlink-mips16
 @opindex minterlink-mips16
 @opindex mno-interlink-mips16
-Require (do not require) that non-MIPS16 code be link-compatible with
-MIPS16 code.
+Require (do not require) that non-MIPS16/non-microMIPS code be link-compatible
+with MIPS16/microMIPS code.
 
-For example, non-MIPS16 code cannot jump directly to MIPS16 code;
+For example, non-MIPS16/non-microMIPS code cannot jump directly to
+MIPS16/microMIPS code;
 it must either use a call or an indirect jump.  @option{-minterlink-mips16}
 therefore disables direct jumps unless GCC knows that the target of the
-jump is not MIPS16.
+jump is not MIPS16/non microMIPS.
 
 @item -mabi=32
 @itemx -mabi=o64
@@ -14641,12 +14719,29 @@
 Use (do not use) the MIPS-3D ASE@.  @xref{MIPS-3D Built-in Functions}.
 The option @option{-mips3d} implies @option{-mpaired-single}.
 
+@item -mmicromips
+@itemx -mno-micromips
+@opindex mmicromips
+@opindex mno-mmicromips
+Generate (do not generate) microMIPS code.  If GCC is targetting a
+MIPS32 or MIPS64 architecture, it will make use of the microMIPS ASE@.
+
+MicroMIPS code generation can also be controlled on a per-function basis
+by means of @code{micromips} and @code{nomicromips} attributes.
+@xref{Function Attributes}, for more information.
+
 @item -mmt
 @itemx -mno-mt
 @opindex mmt
 @opindex mno-mt
 Use (do not use) MT Multithreading instructions.
 
+@item -mmcu
+@itemx -mno-mcu
+@opindex mmcu
+@opindex mno-mcu
+Use (do not use) the MIPS MCU ASE instructions.
+
 @item -mlong64
 @opindex mlong64
 Force @code{long} types to be 64 bits wide.  See @option{-mlong32} for
@@ -14842,6 +14937,16 @@
 This option has no effect on abicalls code.  The default is
 @option{-mno-long-calls}.
 
+@item -mjals
+@itemx -mno-jals
+@opindex mjals
+@opindex mno-jals
+Generate (do not generate) the @code{jals} instruction for microMIPS
+by recognizing that the branch delay slot instruction can be 16 bits.
+This implies that the funciton call cannot switch the current mode
+during the linking stage, because we don't have the @code{jalxs}
+instruction that supports 16-bit branch delay slot instructions.
+
 @item -mmad
 @itemx -mno-mad
 @opindex mmad
@@ -14857,16 +14962,25 @@
 instructions, when they are available.  The default is
 @option{-mfused-madd}.
 
-When multiply-accumulate instructions are used, the intermediate
-product is calculated to infinite precision and is not subject to
-the FCSR Flush to Zero bit.  This may be undesirable in some
-circumstances.
+On the R8000 CPU when multiply-accumulate instructions are used,
+the intermediate product is calculated to infinite precision
+and is not subject to the FCSR Flush to Zero bit.  This may be
+undesirable in some circumstances.  On other processors the result
+is numerically identical to the equivalent computation using
+separate multiply, add, subtract and negate instructions.
 
 @item -nocpp
 @opindex nocpp
 Tell the MIPS assembler to not run its preprocessor over user
 assembler files (with a @samp{.s} suffix) when assembling them.
 
+@item -mfix-24k
+@item -mno-fix-24k
+@opindex mfix-24k
+@opindex mno-fix-24k
+Work around the 24K E48 (lost data on stores during refill) errata.
+The workarounds are implemented by the assembler rather than by GCC.
+
 @item -mfix-r4000
 @itemx -mno-fix-r4000
 @opindex mfix-r4000
@@ -15114,6 +15228,13 @@
 
 The default is @option{-mno-mcount-ra-address}.
 
+@item -mno-compact-eh
+@itemx -mcompact-eh
+@opindex mno-compact-eh
+@opindex mcompact-eh
+Disable generation of compact EH frame tables.
+@option{-mcompact-eh} is the default where supported.
+
 @end table
 
 @node MMIX Options
@@ -16202,12 +16323,11 @@
 On System V.4 and embedded PowerPC systems do (do not) adhere to the
 Embedded Applications Binary Interface (eabi) which is a set of
 modifications to the System V.4 specifications.  Selecting @option{-meabi}
-means that the stack is aligned to an 8 byte boundary, a function
-@code{__eabi} is called to from @code{main} to set up the eabi
-environment, and the @option{-msdata} option can use both @code{r2} and
+means that the stack is aligned to an 8 byte boundary,
+and the @option{-msdata} option can use both @code{r2} and
 @code{r13} to point to two separate small data areas.  Selecting
 @option{-mno-eabi} means that the stack is aligned to a 16 byte boundary,
-do not call an initialization function from @code{main}, and the
+and the
 @option{-msdata} option will only use @code{r13} to point to a single
 small data area.  The @option{-meabi} option is on by default if you
 configured GCC using one of the @samp{powerpc*-*-eabi*} options.
@@ -18241,6 +18361,33 @@
 extended identifiers, the function name must be given in UTF-8, not
 using universal character names.
 
+@item -finstrument-function-calls
+@opindex finstrument-function-calls
+Generate instrumentation calls immediately before and after each
+function call. The following profiling functions will be called with
+the address of the function that is called between them. Use
+@code{__builtin_return_address(0)} inside the profiling functions to
+get the addresses from where they are called.
+
+@smallexample
+void __cyg_profile_call_enter  (void *fn);
+void __cyg_profile_call_exit   (void *fn);
+@end smallexample
+
+Additionally instrumentation calls are inserted at the beginning of
+each function. The argument is the address of the function where the
+insertion occurred. 
+
+@smallexample
+void __cyg_profile_call_inside (void *fn);
+@end smallexample
+
+If an instrumented function gets inlined, calling
+@code{__builtin_return_address(0)} from inside @code{__cyg_profile_call_inside}
+will return an address that is in the address range of the function
+where it was inlined into. This can be used to detect if inlining
+occurred for the function that contains @code{__cyg_profile_call_inside}.
+
 @item -fstack-check
 @opindex fstack-check
 Generate code to verify that you do not go beyond the boundary of the
diff -ru ./gcc/doc/md.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/md.texi
--- ./gcc/doc/md.texi	2014-06-06 11:50:17.143598662 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/md.texi	2012-03-29 17:55:03.000000000 +1000
@@ -2778,6 +2778,9 @@
 
 @item R
 An address that can be used in a non-macro load or store.
+
+@item YC
+For MIPS, it is the same as the constraint @code{R}.  For microMIPS, it matches an address within a 12-bit offset that can be used for microMIPS @code{ll}, @code{sc}, etc.
 @end table
 
 @item Motorola 680x0---@file{config/m68k/constraints.md}
@@ -4951,7 +4954,19 @@
 multiple instructions are usually needed to return from a function, but
 some class of functions only requires one instruction to implement a
 return.  Normally, the applicable functions are those which do not need
-to save any registers or allocate stack space.
+to save any registers or allocate stack space, although some targets
+have instructions that can perform both the epilogue and function return
+in one instruction.
+
+@cindex @code{simple_return} instruction pattern
+@item @samp{simple_return}
+Subroutine return instruction.  This instruction pattern name should be
+defined only if a single instruction can do all the work of returning
+from a function on a path where no epilogue is required.  This pattern
+is very similar to the @code{return} instruction pattern, but it is emitted
+only by the shrink-wrapping optimization on paths where the function
+prologue has not been executed, and a function return should occur without
+any of the effects of the epilogue.
 
 @findex reload_completed
 @findex leaf_function_p
@@ -5321,6 +5336,13 @@
 parameter passing or any stack slots for arguments passed to the current
 function.
 
+@cindex @code{use_initial_val} instruction pattern
+@item @samp{use_initial_val}
+This pattern, if defined, emits an insn that shows use a pseudo register
+created by @code{get_hard_reg_initial_val}.  This is useful if a port may
+introduce additional uses of this pseudo in late optimization passes, when
+the initial ones may already have been optimized away.
+
 @cindex @code{trap} instruction pattern
 @item @samp{trap}
 This pattern, if defined, signals an error, typically by causing some
diff -ru ./gcc/doc/rtl.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/rtl.texi
--- ./gcc/doc/rtl.texi	2014-06-06 11:50:17.147598662 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/rtl.texi	2012-03-29 17:55:03.000000000 +1000
@@ -2895,6 +2895,13 @@
 Note that an insn pattern of @code{(return)} is logically equivalent to
 @code{(set (pc) (return))}, but the latter form is never used.
 
+@findex simple_return
+@item (simple_return)
+Like @code{(return)}, but truly represents only a function return, while
+@code{(return)} may represent an insn that also performs other functions
+of the function epilogue.  Like @code{(return)}, this may also occur in
+conditional jumps.
+
 @findex call
 @item (call @var{function} @var{nargs})
 Represents a function call.  @var{function} is a @code{mem} expression
@@ -3024,7 +3031,7 @@
 brackets stand for a vector; the operand of @code{parallel} is a
 vector of expressions.  @var{x0}, @var{x1} and so on are individual
 side effect expressions---expressions of code @code{set}, @code{call},
-@code{return}, @code{clobber} or @code{use}.
+@code{return}, @code{simple_return}, @code{clobber} or @code{use}.
 
 ``In parallel'' means that first all the values used in the individual
 side-effects are computed, and second all the actual side-effects are
@@ -3449,20 +3456,26 @@
 @code{call_insn} insns have the same extra fields as @code{insn} insns,
 accessed in the same way and in addition contain a field
 @code{CALL_INSN_FUNCTION_USAGE}, which contains a list (chain of
-@code{expr_list} expressions) containing @code{use} and @code{clobber}
-expressions that denote hard registers and @code{MEM}s used or
-clobbered by the called function.
+@code{expr_list} expressions) containing @code{use}, @code{clobber} and
+sometimes @code{set} expressions that denote hard registers and
+@code{mem}s used or clobbered by the called function.
 
-A @code{MEM} generally points to a stack slots in which arguments passed
+A @code{mem} generally points to a stack slots in which arguments passed
 to the libcall by reference (@pxref{Register Arguments,
 TARGET_PASS_BY_REFERENCE}) are stored.  If the argument is
 caller-copied (@pxref{Register Arguments, TARGET_CALLEE_COPIES}),
-the stack slot will be mentioned in @code{CLOBBER} and @code{USE}
-entries; if it's callee-copied, only a @code{USE} will appear, and the
-@code{MEM} may point to addresses that are not stack slots.
-
-@code{CLOBBER}ed registers in this list augment registers specified in
-@code{CALL_USED_REGISTERS} (@pxref{Register Basics}).
+the stack slot will be mentioned in @code{clobber} and @code{use}
+entries; if it's callee-copied, only a @code{use} will appear, and the
+@code{mem} may point to addresses that are not stack slots.
+
+Registers occurring inside a @code{clobber} in this list augment
+registers specified in @code{CALL_USED_REGISTERS} (@pxref{Register
+Basics}).
+
+If the list contains a @code{set} involving two registers, it indicates
+that the function returns one of its arguments.  Such a @code{set} may
+look like a no-op if the same register holds the argument and the return
+value.
 
 @findex code_label
 @findex CODE_LABEL_NUMBER
@@ -3663,14 +3676,16 @@
 @table @code
 @findex PATTERN
 @item PATTERN (@var{i})
-An expression for the side effect performed by this insn.  This must be
-one of the following codes: @code{set}, @code{call}, @code{use},
-@code{clobber}, @code{return}, @code{asm_input}, @code{asm_output},
-@code{addr_vec}, @code{addr_diff_vec}, @code{trap_if}, @code{unspec},
-@code{unspec_volatile}, @code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a @code{parallel},
-each element of the @code{parallel} must be one these codes, except that
-@code{parallel} expressions cannot be nested and @code{addr_vec} and
-@code{addr_diff_vec} are not permitted inside a @code{parallel} expression.
+An expression for the side effect performed by this insn.  This must
+be one of the following codes: @code{set}, @code{call}, @code{use},
+@code{clobber}, @code{return}, @code{simple_return}, @code{asm_input},
+@code{asm_output}, @code{addr_vec}, @code{addr_diff_vec},
+@code{trap_if}, @code{unspec}, @code{unspec_volatile},
+@code{parallel}, @code{cond_exec}, or @code{sequence}.  If it is a
+@code{parallel}, each element of the @code{parallel} must be one these
+codes, except that @code{parallel} expressions cannot be nested and
+@code{addr_vec} and @code{addr_diff_vec} are not permitted inside a
+@code{parallel} expression.
 
 @findex INSN_CODE
 @item INSN_CODE (@var{i})
diff -ru ./gcc/doc/sourcebuild.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/sourcebuild.texi
--- ./gcc/doc/sourcebuild.texi	2014-06-06 11:50:17.147598662 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/sourcebuild.texi	2012-03-29 17:55:03.000000000 +1000
@@ -1671,6 +1671,9 @@
 conversion functions and overflow is not always detected correctly by
 those functions.
 
+@item mmap
+Target supports @code{mmap}.
+
 @item newlib
 Target supports Newlib.
 
diff -ru ./gcc/doc/tm.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/tm.texi
--- ./gcc/doc/tm.texi	2014-06-06 14:25:27.458150551 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/tm.texi	2012-03-29 17:55:03.000000000 +1000
@@ -973,6 +973,8 @@
 then the hook should return the same mode as @code{promote_mode}, though
 the signedness may be different.
 
+@var{type} can be NULL when promoting function arguments of libcalls.
+
 The default is to not promote arguments and return values.  You can
 also define the hook to @code{default_promote_function_mode_always_promote}
 if you would like to apply the same rules given by @code{PROMOTE_MODE}.
@@ -1590,6 +1592,15 @@
 is 128 then the default is 1, otherwise it is 0.
 @end defmac
 
+@defmac LIBGCC2_GNU_PREFIX
+This macro corresponds to the @code{TARGET_LIBFUNC_GNU_PREFIX} target
+hook and should be defined if that hook is overriden to be true.  It
+causes function names in libgcc to be changed to use a @code{__gnu_}
+prefix for their name rather than the default @code{__}.  A port which
+uses this macro should also arrange to use @file{t-gnu-prefix} in
+the libgcc @file{config.host}.
+@end defmac
+
 @defmac SF_SIZE
 @defmacx DF_SIZE
 @defmacx XF_SIZE
@@ -2450,6 +2461,15 @@
 added to another register (as well as added to a displacement).
 @end defmac
 
+@defmac MODE_INDEX_REG_CLASS (@var{mode})
+This is a variation of the @code{INDEX_REG_CLASS} macro which allows
+the selection of an index register in a mode dependent manner.  It can
+return @code{NO_REGS} for modes that do not support any form of index
+register.  If @var{mode} is @code{VOIDmode} then the macro should
+return a class of registers that is suitable for all addresses in
+which an index register of some form is allowed.
+@end defmac
+
 @defmac REGNO_OK_FOR_BASE_P (@var{num})
 A C expression which is nonzero if register number @var{num} is
 suitable for use as a base register in operand addresses.
@@ -2544,6 +2564,14 @@
 the SSE registers (and vice versa).
 @end deftypefn
 
+@defmac REGNO_MODE_OK_FOR_INDEX_P (@var{num}, @var{mode})
+A C expression that is just like @code{REGNO_OK_FOR_INDEX_P}, except
+that the expression may examine the mode of the memory reference
+in @var{mode}.  If @var{mode} is @code{VOIDmode}, the macro should
+return true if @var{x} is suitable for all modes in which some
+form of index register is allowed.
+@end defmac
+
 @defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})
 A C expression that places additional restrictions on the register class
 to use when it is necessary to copy value @var{x} into a register in class
@@ -3210,6 +3238,12 @@
 from the frame pointer of the previous stack frame.
 @end defmac
 
+@defmac RETURN_ADDR_REGNUM
+If defined, a C expression whose value is the register number of the return
+address for the current function.  Targets that pass the return address on
+the stack should not define this macro.
+@end defmac
+
 @defmac INCOMING_RETURN_ADDR_RTX
 A C expression whose value is RTL representing the location of the
 incoming return address at the beginning of any function, before the
@@ -4928,6 +4962,10 @@
 FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.
 @end deftypefn
 
+@deftypefn {Target Hook} bool TARGET_WARN_FUNC_RESULT (void)
+True if a function's return statements should be checked for matching the function's return type.  This includes checking for falling off the end of a non-void function.  Return false if no such check should be made.
+@end deftypefn
+
 @node Stack Smashing Protection
 @subsection Stack smashing protection
 @cindex stack smashing protection
@@ -5257,6 +5295,15 @@
 The default is to do nothing.  Most ports don't need to define this hook.
 @end deftypefn
 
+@deftypevr {Target Hook} bool TARGET_LIBFUNC_GNU_PREFIX
+If false (the default), internal library routines start with two
+underscores.  If set to true, these routines start with @code{__gnu_}
+instead.  E.g., @code{__muldi3} changes to @code{__gnu_muldi3}.  This
+currently only affects functions defined in @file{libgcc2.c}.  If this
+is set to true, the @file{tm.h} file must also
+@code{#define LIBGCC2_GNU_PREFIX}.
+@end deftypevr
+
 @defmac FLOAT_LIB_COMPARE_RETURNS_BOOL (@var{mode}, @var{comparison})
 This macro should return @code{true} if the library routine that
 implements the floating point comparison operator @var{comparison} in
@@ -6786,6 +6833,12 @@
 in its second parameter.
 @end deftypefn
 
+@deftypevr {Target Hook} bool TARGET_SCHED_EXPOSED_PIPELINE
+True if the processor has an exposed pipeline, which means that not just
+the order of instructions is important for correctness when scheduling, but
+also the latencies of operations.
+@end deftypevr
+
 @node Sections
 @section Dividing the Output into Sections (Texts, Data, @dots{})
 @c the above section title is WAY too long.  maybe cut the part between
@@ -9880,6 +9933,10 @@
 specific target options and the caller does not use the same options.
 @end deftypefn
 
+@deftypefn {Target Hook} int TARGET_ALIGN_INSNS (void)
+Return the log2 of the instruction alignment in bytes.
+@end deftypefn
+
 @node Emulated TLS
 @section Emulating TLS
 @cindex Emulated TLS
@@ -10031,6 +10088,13 @@
 value is the same as for @code{TARGET_PCH_VALID_P}.
 @end deftypefn
 
+@deftypefn {Target Hook} void TARGET_PREPARE_PCH_SAVE (void)
+Called before writing out a PCH file.  If the target has some
+garbage-collected data that needs to be in a particular state on PCH loads,
+it can use this hook to enforce that state.  Very few targets need
+to do anything here.
+@end deftypefn
+
 @node C++ ABI
 @section C++ ABI parameters
 @cindex parameters, c++ abi
diff -ru ./gcc/doc/tm.texi.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/tm.texi.in
--- ./gcc/doc/tm.texi.in	2014-06-06 14:25:27.462150551 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/doc/tm.texi.in	2012-03-29 17:55:03.000000000 +1000
@@ -963,6 +963,8 @@
 then the hook should return the same mode as @code{promote_mode}, though
 the signedness may be different.
 
+@var{type} can be NULL when promoting function arguments of libcalls.
+
 The default is to not promote arguments and return values.  You can
 also define the hook to @code{default_promote_function_mode_always_promote}
 if you would like to apply the same rules given by @code{PROMOTE_MODE}.
@@ -1580,6 +1582,15 @@
 is 128 then the default is 1, otherwise it is 0.
 @end defmac
 
+@defmac LIBGCC2_GNU_PREFIX
+This macro corresponds to the @code{TARGET_LIBFUNC_GNU_PREFIX} target
+hook and should be defined if that hook is overriden to be true.  It
+causes function names in libgcc to be changed to use a @code{__gnu_}
+prefix for their name rather than the default @code{__}.  A port which
+uses this macro should also arrange to use @file{t-gnu-prefix} in
+the libgcc @file{config.host}.
+@end defmac
+
 @defmac SF_SIZE
 @defmacx DF_SIZE
 @defmacx XF_SIZE
@@ -2440,6 +2451,15 @@
 added to another register (as well as added to a displacement).
 @end defmac
 
+@defmac MODE_INDEX_REG_CLASS (@var{mode})
+This is a variation of the @code{INDEX_REG_CLASS} macro which allows
+the selection of an index register in a mode dependent manner.  It can
+return @code{NO_REGS} for modes that do not support any form of index
+register.  If @var{mode} is @code{VOIDmode} then the macro should
+return a class of registers that is suitable for all addresses in
+which an index register of some form is allowed.
+@end defmac
+
 @defmac REGNO_OK_FOR_BASE_P (@var{num})
 A C expression which is nonzero if register number @var{num} is
 suitable for use as a base register in operand addresses.
@@ -2532,6 +2552,14 @@
 the SSE registers (and vice versa).
 @end deftypefn
 
+@defmac REGNO_MODE_OK_FOR_INDEX_P (@var{num}, @var{mode})
+A C expression that is just like @code{REGNO_OK_FOR_INDEX_P}, except
+that the expression may examine the mode of the memory reference
+in @var{mode}.  If @var{mode} is @code{VOIDmode}, the macro should
+return true if @var{x} is suitable for all modes in which some
+form of index register is allowed.
+@end defmac
+
 @defmac PREFERRED_RELOAD_CLASS (@var{x}, @var{class})
 A C expression that places additional restrictions on the register class
 to use when it is necessary to copy value @var{x} into a register in class
@@ -3198,6 +3226,12 @@
 from the frame pointer of the previous stack frame.
 @end defmac
 
+@defmac RETURN_ADDR_REGNUM
+If defined, a C expression whose value is the register number of the return
+address for the current function.  Targets that pass the return address on
+the stack should not define this macro.
+@end defmac
+
 @defmac INCOMING_RETURN_ADDR_RTX
 A C expression whose value is RTL representing the location of the
 incoming return address at the beginning of any function, before the
@@ -4908,6 +4942,8 @@
 FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM, and the PIC_OFFSET_TABLE_REGNUM.
 @end deftypefn
 
+@hook TARGET_WARN_FUNC_RESULT
+
 @node Stack Smashing Protection
 @subsection Stack smashing protection
 @cindex stack smashing protection
@@ -5235,6 +5271,8 @@
 The default is to do nothing.  Most ports don't need to define this hook.
 @end deftypefn
 
+@hook TARGET_LIBFUNC_GNU_PREFIX
+
 @defmac FLOAT_LIB_COMPARE_RETURNS_BOOL (@var{mode}, @var{comparison})
 This macro should return @code{true} if the library routine that
 implements the floating point comparison operator @var{comparison} in
@@ -6764,6 +6802,8 @@
 in its second parameter.
 @end deftypefn
 
+@hook TARGET_SCHED_EXPOSED_PIPELINE
+
 @node Sections
 @section Dividing the Output into Sections (Texts, Data, @dots{})
 @c the above section title is WAY too long.  maybe cut the part between
@@ -9832,6 +9872,8 @@
 specific target options and the caller does not use the same options.
 @end deftypefn
 
+@hook TARGET_ALIGN_INSNS
+
 @node Emulated TLS
 @section Emulating TLS
 @cindex Emulated TLS
@@ -9983,6 +10025,8 @@
 value is the same as for @code{TARGET_PCH_VALID_P}.
 @end deftypefn
 
+@hook TARGET_PREPARE_PCH_SAVE
+
 @node C++ ABI
 @section C++ ABI parameters
 @cindex parameters, c++ abi
diff -ru ./gcc/dojump.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dojump.c
--- ./gcc/dojump.c	2014-06-06 11:50:17.163598663 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dojump.c	2012-03-29 18:03:19.000000000 +1000
@@ -36,6 +36,7 @@
 #include "ggc.h"
 #include "basic-block.h"
 #include "output.h"
+#include "tm_p.h"
 
 static bool prefer_and_bit_test (enum machine_mode, int);
 static void do_jump_by_parts_greater (tree, tree, int, rtx, rtx, int);
diff -ru ./gcc/dwarf2asm.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dwarf2asm.c
--- ./gcc/dwarf2asm.c	2014-06-06 11:50:17.167598663 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dwarf2asm.c	2012-04-28 17:58:33.000000000 +1000
@@ -91,6 +91,22 @@
     }
 }
 
+/* Output a comment.  */
+void
+dw2_asm_output_comment (const char *comment, ...)
+{
+  va_list ap;
+
+  va_start (ap, comment);
+
+  if (flag_debug_asm && comment)
+    {
+      fprintf (asm_out_file, "\t%s ", ASM_COMMENT_START);
+      vfprintf (asm_out_file, comment, ap);
+    }
+  fputc ('\n', asm_out_file);
+}
+
 /* Output an immediate constant in a given SIZE in bytes.  */
 
 void
@@ -750,6 +766,36 @@
 #else
   gcc_unreachable ();
 #endif
+
+  if (flag_debug_asm && comment)
+    {
+      fprintf (asm_out_file, "\t%s ", ASM_COMMENT_START);
+      vfprintf (asm_out_file, comment, ap);
+    }
+  fputc ('\n', asm_out_file);
+
+  va_end (ap);
+}
+
+void
+dw2_asm_output_delta_setbit0_uleb128 (const char *lab1, const char *lab2,
+				      const char *comment, ...)
+{
+  va_list ap;
+
+  va_start (ap, comment);
+
+#ifdef HAVE_AS_LEB128
+  fputs ("\t.uleb128 ", asm_out_file);
+  fputc ('(', asm_out_file);
+  assemble_name (asm_out_file, lab1);
+  fputc ('-', asm_out_file);
+  assemble_name (asm_out_file, lab2);
+  fputc (')', asm_out_file);
+  fprintf (asm_out_file, "|1");
+#else
+  gcc_unreachable ();
+#endif
 
   if (flag_debug_asm && comment)
     {
diff -ru ./gcc/dwarf2asm.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dwarf2asm.h
--- ./gcc/dwarf2asm.h	2014-06-06 11:50:17.167598663 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dwarf2asm.h	2012-04-28 17:58:33.000000000 +1000
@@ -23,6 +23,8 @@
 
 extern void dw2_asm_output_data_raw (int, unsigned HOST_WIDE_INT);
 
+extern void dw2_asm_output_comment (const char *, ...);
+
 extern void dw2_asm_output_data (int, unsigned HOST_WIDE_INT,
 				 const char *, ...)
      ATTRIBUTE_NULL_PRINTF_3;
@@ -69,6 +71,10 @@
 					  const char *, ...)
      ATTRIBUTE_NULL_PRINTF_3;
 
+extern void dw2_asm_output_delta_setbit0_uleb128 (const char *, const char *,
+					          const char *, ...)
+     ATTRIBUTE_NULL_PRINTF_3;
+
 extern int size_of_uleb128 (unsigned HOST_WIDE_INT);
 extern int size_of_sleb128 (HOST_WIDE_INT);
 extern int size_of_encoded_value (int);
diff -ru ./gcc/dwarf2out.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dwarf2out.c
--- ./gcc/dwarf2out.c	2014-06-06 11:50:17.183598663 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/dwarf2out.c	2012-03-29 18:03:19.000000000 +1000
@@ -159,6 +159,16 @@
   return false;
 }
 
+static bool
+asm_cfi_special_encoding (int enc ATTRIBUTE_UNUSED)
+{
+#ifdef ASM_CFI_SPECIAL_ENCODING
+  return ASM_CFI_SPECIAL_ENCODING (enc);
+#else
+  return false;
+#endif
+}
+
 /* Decide whether to emit frame unwind via assembler directives.  */
 
 int
@@ -179,10 +189,12 @@
   /* Make sure the personality encoding is one the assembler can support.
      In particular, aligned addresses can't be handled.  */
   enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2,/*global=*/1);
-  if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel)
+  if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel
+      && ! asm_cfi_special_encoding (enc))
     return false;
   enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0,/*global=*/0);
-  if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel)
+  if ((enc & 0x70) != 0 && (enc & 0x70) != DW_EH_PE_pcrel
+      && ! asm_cfi_special_encoding (enc))
     return false;
 
   /* If we can't get the assembler to emit only .debug_frame, and we don't need
@@ -1485,7 +1497,7 @@
     {
       rtx dest = JUMP_LABEL (insn);
 
-      if (dest)
+      if (dest && !ANY_RETURN_P (dest))
 	{
 	  if (barrier_args_size [INSN_UID (dest)] < 0)
 	    {
@@ -2967,15 +2979,15 @@
 	  int idx;
 	  rtx seq = PATTERN (i);
 
+	  for (idx = 0; idx < XVECLEN (seq, 0); idx++)
+	    if (RTX_FRAME_RELATED_P (XVECEXP (seq, 0, idx)))
+	      saw_frp = true;
+
 	  if (returnjump_p (XVECEXP (seq, 0, 0)))
 	    break;
 	  if (CALL_P (XVECEXP (seq, 0, 0))
 	      && SIBLING_CALL_P (XVECEXP (seq, 0, 0)))
 	    break;
-
-	  for (idx = 0; idx < XVECLEN (seq, 0); idx++)
-	    if (RTX_FRAME_RELATED_P (XVECEXP (seq, 0, idx)))
-	      saw_frp = true;
 	}
 
       if (RTX_FRAME_RELATED_P (i))
@@ -3001,9 +3013,8 @@
   while (1)
     {
       rtx p = PREV_INSN (i);
-      if (!NOTE_P (p))
-	break;
-      if (NOTE_KIND (p) == NOTE_INSN_BASIC_BLOCK)
+      if (!LABEL_P (p)
+	  && (!NOTE_P (p) || NOTE_KIND (p) == NOTE_INSN_BASIC_BLOCK))
 	break;
       i = p;
     }
@@ -4002,7 +4013,7 @@
 	 handle indirect support ourselves, but PC-relative is done
 	 in the assembler.  Further, the assembler can't handle any
 	 of the weirder relocation types.  */
-      if (enc & DW_EH_PE_indirect)
+      if (enc & DW_EH_PE_indirect && !asm_cfi_special_encoding (enc))
 	ref = dw2_force_const_mem (ref, true);
 
       fprintf (asm_out_file, "\t.cfi_personality %#x,", enc);
@@ -4020,7 +4031,7 @@
       ref = gen_rtx_SYMBOL_REF (Pmode, lab);
       SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;
 
-      if (enc & DW_EH_PE_indirect)
+      if (enc & DW_EH_PE_indirect && !asm_cfi_special_encoding (enc))
 	ref = dw2_force_const_mem (ref, true);
 
       fprintf (asm_out_file, "\t.cfi_lsda %#x,", enc);
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc: ee.c
diff -ru ./gcc/emit-rtl.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/emit-rtl.c
--- ./gcc/emit-rtl.c	2014-06-06 11:50:17.187598663 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/emit-rtl.c	2012-03-29 18:03:19.000000000 +1000
@@ -547,6 +547,13 @@
       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)
 	return gen_int_mode (i0, mode);
 
+      /* For modes larger than 2 * HOST_BITS_PER_WIDE_INT, the integer may
+	 still be representable if it fits in one word. For other cases,
+	 assert fail below.  */
+      if (GET_MODE_BITSIZE (mode) > 2 * HOST_BITS_PER_WIDE_INT
+	  && ((i1 == 0 && i0 >= 0) || (i1 == ~0 && i0 < 0)))
+	return GEN_INT (i0);
+
       gcc_assert (GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT);
     }
 
@@ -1680,6 +1687,11 @@
 	  && !TREE_THIS_VOLATILE (base))
 	MEM_READONLY_P (ref) = 1;
 
+      /* Mark static const strings readonly as well.  */
+      if (base && TREE_CODE (base) == STRING_CST && TREE_READONLY (base)
+	  && TREE_STATIC (base))
+	MEM_READONLY_P (ref) = 1;
+
       /* If this expression uses it's parent's alias set, mark it such
 	 that we won't change it.  */
       if (component_uses_parent_alias_set (t))
@@ -2447,6 +2459,8 @@
     case CODE_LABEL:
     case PC:
     case CC0:
+    case RETURN:
+    case SIMPLE_RETURN:
     case SCRATCH:
       return;
       /* SCRATCH must be shared because they represent distinct values.  */
@@ -2547,6 +2561,8 @@
 	    for (i = 0; i < XVECLEN (sequence, 0); i++)
 	      {
 		q = XVECEXP (sequence, 0, i);
+		if (LABEL_P (q) || DELETED_NOTE_P (q))
+		  continue;
 		gcc_assert (INSN_P (q));
 		reset_used_flags (PATTERN (q));
 		reset_used_flags (REG_NOTES (q));
@@ -3251,14 +3267,17 @@
   return insn;
 }
 
-/* Return the last label to mark the same position as LABEL.  Return null
-   if LABEL itself is null.  */
+/* Return the last label to mark the same position as LABEL.  Return LABEL
+   itself if it is null or any return rtx.  */
 
 rtx
 skip_consecutive_labels (rtx label)
 {
   rtx insn;
 
+  if (label && ANY_RETURN_P (label))
+    return label;
+
   for (insn = label; insn != 0 && !INSN_P (insn); insn = NEXT_INSN (insn))
     if (LABEL_P (insn))
       label = insn;
@@ -5148,7 +5167,7 @@
     return CODE_LABEL;
   if (GET_CODE (x) == CALL)
     return CALL_INSN;
-  if (GET_CODE (x) == RETURN)
+  if (GET_CODE (x) == RETURN || GET_CODE (x) == SIMPLE_RETURN)
     return JUMP_INSN;
   if (GET_CODE (x) == SET)
     {
@@ -5655,8 +5674,10 @@
   init_reg_modes_target ();
 
   /* Assign register numbers to the globally defined register rtx.  */
-  pc_rtx = gen_rtx_PC (VOIDmode);
-  cc0_rtx = gen_rtx_CC0 (VOIDmode);
+  pc_rtx = gen_rtx_fmt_ (PC, VOIDmode);
+  ret_rtx = gen_rtx_fmt_ (RETURN, VOIDmode);
+  simple_return_rtx = gen_rtx_fmt_ (SIMPLE_RETURN, VOIDmode);
+  cc0_rtx = gen_rtx_fmt_ (CC0, VOIDmode);
   stack_pointer_rtx = gen_raw_REG (Pmode, STACK_POINTER_REGNUM);
   frame_pointer_rtx = gen_raw_REG (Pmode, FRAME_POINTER_REGNUM);
   hard_frame_pointer_rtx = gen_raw_REG (Pmode, HARD_FRAME_POINTER_REGNUM);
diff -ru ./gcc/except.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/except.c
--- ./gcc/except.c	2014-06-06 11:50:17.191598664 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/except.c	2012-04-28 17:58:33.000000000 +1000
@@ -1,6 +1,7 @@
 /* Implements exception handling.
    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
+   2012
    Free Software Foundation, Inc.
    Contributed by Mike Stump <mrs@cygnus.com>.
 
@@ -197,6 +198,15 @@
 #endif
 static void dw2_output_call_site_table (int, int);
 static void sjlj_output_call_site_table (void);
+static int compact_count_like_headers (enum eh_compact_header_type,
+				       const unsigned char *);
+static int compact_count_eh_specs (HOST_WIDE_INT);
+static int compact_encode_catch_count (int, const unsigned char *);
+static void compact_emit_region_header (enum eh_compact_header_type rtype,
+                                        int region_no);
+static bool compact_ends_in_catchall (int, const unsigned char *);
+static const unsigned char *read_sleb128 (const unsigned char *p,
+                                          HOST_WIDE_INT *val);
 
 
 void
@@ -824,6 +834,7 @@
   htab_t ttypes, ehspec;
   eh_region r;
   eh_catch c;
+  int compact_flt_no = 0;
 
   cfun->eh->ttype_data = VEC_alloc (tree, gc, 16);
   if (targetm.arm_eabi_unwinder)
@@ -836,6 +847,9 @@
 
   for (i = 1; VEC_iterate (eh_region, cfun->eh->region_array, i, r); ++i)
     {
+
+      compact_flt_no = 0;
+
       if (r == NULL)
 	continue;
 
@@ -861,6 +875,15 @@
 
 		      c->filter_list
 			= tree_cons (NULL_TREE, flt_node, c->filter_list);
+
+		      if (TARGET_COMPACT_EH)
+			{
+			  tree compact_flt_node = 
+			    build_int_cst (NULL_TREE, ++compact_flt_no);
+			  c->compact_filter_list
+			    = tree_cons (NULL_TREE, compact_flt_node,
+					 c->compact_filter_list);
+			}
 		    }
 		}
 	      else
@@ -2703,6 +2726,160 @@
   while (more);
 }
 
+/* The catch count is encoded.  Multiply the count by two and
+   use bit zero to indicate the presence of a catchall handler.  */
+static int
+compact_encode_catch_count (int count, const unsigned char *p)
+{
+  bool encode_catchall = compact_ends_in_catchall (count, p);
+
+  if (encode_catchall)
+    {
+      count--;
+      count <<= 1;
+      count |= 1;
+    }
+  else
+    count <<= 1;
+
+  return count;
+}
+
+static int
+compact_count_eh_specs (HOST_WIDE_INT filter)
+{
+  HOST_WIDE_INT eh_filter;
+  int count = 0;
+
+  eh_filter = VEC_index (uchar, cfun->eh->ehspec_data.other, filter - 1);
+
+  while (eh_filter != 0)
+    {
+      eh_filter = VEC_index (uchar, cfun->eh->ehspec_data.other, eh_filter);
+      count++;
+    }
+  return count;
+}
+
+/* Return true if the catch type list ends in a NULL_TREE,
+   otherwise return false.  */
+static bool
+compact_ends_in_catchall (int count, const unsigned char *p)
+{
+  int i;
+  HOST_WIDE_INT ar_filter;
+  HOST_WIDE_INT ar_disp = -1;
+  tree type = NULL_TREE;
+
+  for (i = 0; i < count; i++)
+    {
+      p = read_sleb128 (p, &ar_filter);
+      p = read_sleb128 (p, &ar_disp);
+      p = p + ar_disp - 1;
+    }
+
+  type = VEC_index (tree, cfun->eh->ttype_data, ar_filter - 1);
+
+  if (type == NULL_TREE)
+    return true;
+  else
+    return false;
+}
+
+/* Count the number of adjacent cleanup or catch headers.  */
+static int
+compact_count_like_headers (enum eh_compact_header_type rtype,
+			    const unsigned char *p)
+{
+  int count = 0;
+  HOST_WIDE_INT ar_filter;
+  HOST_WIDE_INT ar_disp = -1;
+
+  while (ar_disp != 0)
+    {
+      p = read_sleb128 (p, &ar_filter);
+      p = read_sleb128 (p, &ar_disp);
+
+      if (rtype == ECHT_CLEANUP && ar_filter != 0)
+	return count;
+
+      if (rtype == ECHT_CATCH && ar_filter <= 0)
+	return count;
+
+      p = p + ar_disp - 1;
+      count++;
+    }
+
+  return count;
+}
+
+/* Emit the region header for this entry.  */
+static void
+compact_emit_region_header (enum eh_compact_header_type rtype, int region_no)
+{
+  const char *begin;
+  char region_start[32];
+  char region_end[32];
+  char landing_pad[32];
+
+  struct call_site_record_d *cs =
+    VEC_index (call_site_record, crtl->eh.call_site_record[0], region_no);
+
+  begin = current_function_func_begin_label;
+  ASM_GENERATE_INTERNAL_LABEL (region_start, "LEHB",
+                               call_site_base + region_no);
+  ASM_GENERATE_INTERNAL_LABEL (region_end, "LEHE",
+                               call_site_base + region_no);
+
+  if (cs->landing_pad)
+    ASM_GENERATE_INTERNAL_LABEL (landing_pad, "L",
+                                 CODE_LABEL_NUMBER (cs->landing_pad));
+
+  switch (rtype)
+    {
+    case ECHT_CLEANUP:
+      /* Offset bit 0 = 0.  */
+      /* Length bit 0 = 0.  */
+      dw2_asm_output_comment ("Cleanup Region");
+      dw2_asm_output_delta_uleb128 (region_end, region_start, "Length");
+      dw2_asm_output_delta_uleb128 (region_start, begin, "Offset");
+      dw2_asm_output_delta_uleb128 (landing_pad, begin, "Landing Pad Offset");
+      break;
+
+    case ECHT_CATCH:
+      /* Offset bit 0 = 0.  */
+      /* Length bit 0 = 1.  */
+      dw2_asm_output_comment ("Catch Region");
+      dw2_asm_output_delta_setbit0_uleb128 (region_end,
+                                            region_start, "Length");
+      dw2_asm_output_delta_uleb128 (region_start, begin, "Offset");
+      dw2_asm_output_delta_uleb128 (landing_pad, begin, "Landing Pad Offset");
+      break;
+
+    case ECHT_SPEC:
+      /* Offset bit 0 = 1.  */
+      /* Length bit 0 = 1.  */
+      dw2_asm_output_comment ("Exception Specification Region");
+      dw2_asm_output_delta_setbit0_uleb128 (region_end,
+                                            region_start, "Length");
+      dw2_asm_output_delta_setbit0_uleb128 (region_start, begin, "Offset");
+      dw2_asm_output_delta_uleb128 (landing_pad, begin, "Landing Pad Offset");
+      break;
+
+    case ECHT_CONTINUE_UNWINDING:
+      /* Offset bit 0 = 1.  */
+      /* Length bit 0 = 0.  */
+      dw2_asm_output_comment ("Continue Unwinding Region");
+      dw2_asm_output_delta_uleb128 (region_end, region_start, "Length");
+      dw2_asm_output_delta_setbit0_uleb128 (region_start, begin, "Offset");
+      break;
+
+   case ECHT_NOT_INITIALIZED:
+      break;
+
+    }
+}
+
 
 #ifndef HAVE_AS_LEB128
 static int
@@ -2852,11 +3029,16 @@
 	    flags = SECTION_WRITE;
 
 #ifdef HAVE_LD_EH_GC_SECTIONS
-	  if (flag_function_sections)
+	  if (flag_function_sections
+	      || (DECL_ONE_ONLY (current_function_decl) && HAVE_COMDAT_GROUP))
 	    {
 	      char *section_name = XNEWVEC (char, strlen (fnname) + 32);
+	      /* The EH table must match the code section, so only mark
+		 it linkonce if we have COMDAT groups to tie them together.  */
+	      if (DECL_ONE_ONLY (current_function_decl) && HAVE_COMDAT_GROUP)
+		flags |= SECTION_LINKONCE;
 	      sprintf (section_name, ".gcc_except_table.%s", fnname);
-	      s = get_section (section_name, flags, NULL);
+	      s = get_section (section_name, flags, current_function_decl);
 	      free (section_name);
 	    }
 	  else
@@ -2929,6 +3111,159 @@
     dw2_asm_output_encoded_addr_rtx (tt_format, value, is_public, NULL);
 }
 
+static const unsigned char *
+read_sleb128 (const unsigned char *p, HOST_WIDE_INT *val)
+{
+  unsigned int shift = 0;
+  unsigned char byte;
+  HOST_WIDE_INT result;
+
+  result = 0;
+  do
+    {
+      byte = *p++;
+      result |= ((HOST_WIDE_INT) byte & 0x7f) << shift;
+      shift += 7;
+    }
+  while (byte & 0x80);
+
+  /* Sign-extend a negative value.  */
+  if (shift < 8 * sizeof(result) && (byte & 0x40) != 0)
+    result |= -(((unsigned HOST_WIDE_INT)1L) << shift);
+
+  *val = (HOST_WIDE_INT) result;
+  return p;
+}
+
+/* Walk the DWARF2 exception-handling tables and emit a compact-encoding
+   of the information.  */
+
+static void
+output_one_function_compact_eh_table (void)
+{
+  int i, k, count;
+  enum eh_compact_header_type this_region = ECHT_NOT_INITIALIZED;
+  int tt_format = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/1);
+  int tt_format_size = size_of_encoded_value (tt_format);
+
+  int nregions = VEC_length (call_site_record, crtl->eh.call_site_record[0]);
+
+  targetm.asm_out.internal_label (asm_out_file, "LLSDA",
+                                  current_function_funcdef_no);
+
+  for (i = 0; i < nregions; ++i)
+    {
+      HOST_WIDE_INT ar_filter, ar_disp;
+      const unsigned char *p, *like_start_p;
+      bool seen_cleanup = false;
+
+      struct call_site_record_d *cs =
+        VEC_index (call_site_record, crtl->eh.call_site_record[0], i);
+
+      if (cs->action == 0 && cs->landing_pad == 0)
+        {
+	  compact_emit_region_header (ECHT_CONTINUE_UNWINDING, i);
+	  continue;
+	}
+
+      else if (cs->action == 0)
+        {
+	  compact_emit_region_header (ECHT_CLEANUP, i);
+	  continue;
+	}
+
+      /* cs->action is an offset into ctrl->eh.action_record_data
+	 The action_record_data will be a pair of values.  Each
+	 pair is a catch/exception spec type.  The first is an
+	 index into cfun->eh->ttype_data and the second is the
+	 offset of the next action.  If the index is positive, it's
+	 a catch.  If it's negative, it's an exception spec.  */
+
+      /* Exception Specification, Catch or Cleanup.  */
+      p = VEC_address (uchar, crtl->eh.action_record_data)
+			+ cs->action - 1;
+
+      ar_disp = -1;
+      while (ar_disp != 0)
+	{
+	  int eh_filter, j, eh_count, encoded_count;
+	  tree type;
+
+	  like_start_p = p;
+	  p = read_sleb128 (p, &ar_filter);
+	  p = read_sleb128 (p, &ar_disp);
+
+	  if (ar_filter == 0)
+	    this_region = ECHT_CLEANUP;
+	  else if (ar_filter > 0)
+	    this_region = ECHT_CATCH;
+	  else if (ar_filter < 0)
+	    {
+	      this_region = ECHT_SPEC;
+	      ar_filter = abs (ar_filter);
+	    }
+
+	  /* Cleanups are emitted later.  */
+	  if (this_region != ECHT_CLEANUP)
+	    compact_emit_region_header (this_region, i);
+
+	  switch (this_region)
+	    {
+	    case ECHT_SPEC:
+	      eh_count = compact_count_eh_specs (ar_filter);
+	      dw2_asm_output_data_uleb128
+		(eh_count, "Number of exception specifications");
+	      eh_filter = VEC_index (uchar, cfun->eh->ehspec_data.other,
+				     ar_filter - 1);
+	      for (j = 0; j < eh_count; j++)
+		{
+		  type = VEC_index (tree, cfun->eh->ttype_data, eh_filter - 1);
+		  output_ttype (type, tt_format, tt_format_size);
+		  eh_filter++;
+		 }
+	      break;
+	    
+	    case ECHT_CATCH:
+	      count = compact_count_like_headers (this_region, like_start_p);
+	      encoded_count = compact_encode_catch_count (count, like_start_p);
+	      dw2_asm_output_data_uleb128 (encoded_count,
+					   "Number of catch clauses (encoded)");
+	      for (k = 0; k < count; k++)
+		{
+		  type = VEC_index (tree, cfun->eh->ttype_data, ar_filter - 1);
+		  /* Don't emit the catchall, if present.  */
+		  if (type != NULL_TREE)
+		    output_ttype (type, tt_format, tt_format_size);
+
+		  if ((k + 1) < count)
+		    {
+		      p = p + ar_disp - 1;
+		      p = read_sleb128 (p, &ar_filter);
+		      p = read_sleb128 (p, &ar_disp);
+		      ar_filter = abs (ar_filter);
+		    }
+		}
+	      break;
+	    
+	    case ECHT_CLEANUP:
+	      seen_cleanup = true;
+	      break;
+
+	    default:
+	      break;
+	    }
+	    
+	  p += ar_disp - 1;
+	}
+      /* Emit the saved cleanup region entry.  */
+      if (seen_cleanup)
+        compact_emit_region_header (ECHT_CLEANUP, i);
+    }
+
+  dw2_asm_output_data_uleb128 (0, "End of Region List");
+  call_site_base += nregions;
+}
+
 static void
 output_one_function_exception_table (int section)
 {
@@ -3127,9 +3462,16 @@
   /* If the target wants a label to begin the table, emit it here.  */
   targetm.asm_out.emit_except_table_label (asm_out_file);
 
-  output_one_function_exception_table (0);
-  if (crtl->eh.call_site_record[1] != NULL)
-    output_one_function_exception_table (1);
+  if (TARGET_COMPACT_EH)
+    {
+      output_one_function_compact_eh_table ();
+    }
+  else
+    {
+      output_one_function_exception_table (0);
+      if (crtl->eh.call_site_record[1] != NULL)
+	output_one_function_exception_table (1);
+    }
 
   switch_to_section (current_function_section ());
 }
diff -ru ./gcc/except.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/except.h
--- ./gcc/except.h	2014-06-06 11:50:17.191598664 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/except.h	2012-04-28 17:58:33.000000000 +1000
@@ -68,6 +68,15 @@
   ERT_MUST_NOT_THROW
 };
 
+/* Region header types in the compact EH scheme.  */
+enum eh_compact_header_type
+{
+  ECHT_NOT_INITIALIZED,
+  ECHT_CLEANUP,
+  ECHT_CATCH,
+  ECHT_CONTINUE_UNWINDING,
+  ECHT_SPEC
+};
 
 /* A landing pad for a given exception region.  Any transfer of control
    from the EH runtime to the function happens at a landing pad.  */
@@ -113,6 +122,12 @@
      compared against the __builtin_eh_filter value.  */
   tree filter_list;
 
+  /* For the compact exception handling encoding:  A TREE_LIST
+     of INTEGER_CSTs that correspond to the type_list entries,
+     having been mapped by compact_assign_filter_values.  These integers
+     are to be compared against the __builtin_eh_filter value.  */
+  tree compact_filter_list;
+
   /* The code that should be executed if this catch handler matches the
      thrown exception.  This label is only maintained until
      pass_lower_eh_dispatch, at which point it is cleared.  */
diff -ru ./gcc/explow.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/explow.c
--- ./gcc/explow.c	2014-06-06 11:50:17.191598664 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/explow.c	2012-04-30 20:22:05.000000000 +1000
@@ -771,6 +771,17 @@
 promote_function_mode (const_tree type, enum machine_mode mode, int *punsignedp,
 		       const_tree funtype, int for_return)
 {
+  /* Called without a type node for a libcall.  */
+  if (type == NULL_TREE)
+    {
+      if (INTEGRAL_MODE_P (mode))
+	return targetm.calls.promote_function_mode (NULL_TREE, mode,
+						    punsignedp, funtype,
+						    for_return);
+      else
+	return mode;
+    }
+
   switch (TREE_CODE (type))
     {
     case INTEGER_TYPE:   case ENUMERAL_TYPE:   case BOOLEAN_TYPE:
@@ -791,12 +802,23 @@
 promote_mode (const_tree type ATTRIBUTE_UNUSED, enum machine_mode mode,
 	      int *punsignedp ATTRIBUTE_UNUSED)
 {
+#ifdef PROMOTE_MODE
+  enum tree_code code;
+  int unsignedp;
+#endif
+
+  /* For libcalls this is invoked without TYPE from the backends
+     TARGET_PROMOTE_FUNCTION_MODE hooks.  Don't do anything in that
+     case.  */
+  if (type == NULL_TREE)
+    return mode;
+
   /* FIXME: this is the same logic that was there until GCC 4.4, but we
      probably want to test POINTERS_EXTEND_UNSIGNED even if PROMOTE_MODE
      is not defined.  The affected targets are M32C, S390, SPARC.  */
 #ifdef PROMOTE_MODE
-  const enum tree_code code = TREE_CODE (type);
-  int unsignedp = *punsignedp;
+  code = TREE_CODE (type);
+  unsignedp = *punsignedp;
 
   switch (code)
     {
diff -ru ./gcc/expmed.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/expmed.c
--- ./gcc/expmed.c	2014-06-06 11:50:17.195598664 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/expmed.c	2012-03-29 18:03:19.000000000 +1000
@@ -47,7 +47,7 @@
 
 static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,
 				   unsigned HOST_WIDE_INT,
-				   unsigned HOST_WIDE_INT, rtx);
+				   unsigned HOST_WIDE_INT, rtx, bool);
 static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,
 				   unsigned HOST_WIDE_INT, rtx);
 static rtx extract_fixed_bit_field (enum machine_mode, rtx,
@@ -349,7 +349,8 @@
 
 static bool
 store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,
-		   unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,
+		   unsigned HOST_WIDE_INT bitnum, bool packedp,
+		   enum machine_mode fieldmode,
 		   rtx value, bool fallback_p)
 {
   unsigned int unit
@@ -599,7 +600,7 @@
 
 	  if (!store_bit_field_1 (op0, MIN (BITS_PER_WORD,
 					    bitsize - i * BITS_PER_WORD),
-				  bitnum + bit_offset, word_mode,
+				  bitnum + bit_offset, false, word_mode,
 				  value_word, fallback_p))
 	    {
 	      delete_insns_since (last);
@@ -657,6 +658,10 @@
       && GET_MODE (value) != BLKmode
       && bitsize > 0
       && GET_MODE_BITSIZE (op_mode) >= bitsize
+      /* Do not use insv for volatile bitfields when
+         -fstrict-volatile-bitfields is in effect.  */
+      && !(MEM_P (op0) && MEM_VOLATILE_P (op0)
+	   && flag_strict_volatile_bitfields > 0)
       && ! ((REG_P (op0) || GET_CODE (op0) == SUBREG)
 	    && (bitsize + bitpos > GET_MODE_BITSIZE (op_mode)))
       && insn_data[CODE_FOR_insv].operand[1].predicate (GEN_INT (bitsize),
@@ -700,19 +705,19 @@
 	  copy_back = true;
 	}
 
-      /* On big-endian machines, we count bits from the most significant.
-	 If the bit field insn does not, we must invert.  */
-
-      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)
-	xbitpos = unit - bitsize - xbitpos;
-
       /* We have been counting XBITPOS within UNIT.
 	 Count instead within the size of the register.  */
-      if (BITS_BIG_ENDIAN && !MEM_P (xop0))
+      if (BYTES_BIG_ENDIAN && !MEM_P (xop0))
 	xbitpos += GET_MODE_BITSIZE (op_mode) - unit;
 
       unit = GET_MODE_BITSIZE (op_mode);
 
+      /* On big-endian machines, we count bits from the most significant.
+	 If the bit field insn does not, we must invert.  */
+
+      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)
+	xbitpos = unit - bitsize - xbitpos;
+
       /* Convert VALUE to op_mode (which insv insn wants) in VALUE1.  */
       value1 = value;
       if (GET_MODE (value) != op_mode)
@@ -808,7 +813,7 @@
 	  /* Fetch that unit, store the bitfield in it, then store
 	     the unit.  */
 	  tempreg = copy_to_reg (xop0);
-	  if (store_bit_field_1 (tempreg, bitsize, xbitpos,
+	  if (store_bit_field_1 (tempreg, bitsize, xbitpos, false,
 				 fieldmode, orig_value, false))
 	    {
 	      emit_move_insn (xop0, tempreg);
@@ -821,7 +826,7 @@
   if (!fallback_p)
     return false;
 
-  store_fixed_bit_field (op0, offset, bitsize, bitpos, value);
+  store_fixed_bit_field (op0, offset, bitsize, bitpos, value, packedp);
   return true;
 }
 
@@ -832,12 +837,52 @@
 
 void
 store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,
-		 unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,
-		 rtx value)
+		 unsigned HOST_WIDE_INT bitnum, bool packedp,
+		 enum machine_mode fieldmode, rtx value)
 {
-  if (!store_bit_field_1 (str_rtx, bitsize, bitnum, fieldmode, value, true))
+  if (!store_bit_field_1 (str_rtx, bitsize, bitnum, packedp, fieldmode, value,
+			  true))
     gcc_unreachable ();
 }
+
+static void
+warn_misaligned_bitfield (bool struct_member, bool packedp)
+{
+  static bool informed_about_misalignment = false;
+  bool warned;
+
+  if (packedp)
+    {
+      if (struct_member)
+	warning_at (input_location, OPT_fstrict_volatile_bitfields,
+			     "multiple accesses to volatile structure member"
+			     " because of packed attribute");
+      else
+	warning_at (input_location, OPT_fstrict_volatile_bitfields,
+			     "multiple accesses to volatile structure bitfield"
+			     " because of packed attribute");
+    }
+  else
+    {
+      if (struct_member)
+	warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,
+			     "mis-aligned access used for structure member");
+      else
+	warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,
+			     "mis-aligned access used for structure bitfield");
+    }
+
+  if (! informed_about_misalignment && warned && !packedp)
+    {
+      informed_about_misalignment = true;
+      inform (input_location,
+	      "When a volatile object spans multiple type-sized locations,"
+	      " the compiler must choose between using a single mis-aligned"
+	      " access to preserve the volatility, or using multiple aligned"
+	      " accesses to avoid runtime faults.  This code may fail at"
+	      " runtime if the hardware does not allow this access.");
+    }
+}
 
 /* Use shifts and boolean operations to store VALUE
    into a bit field of width BITSIZE
@@ -851,7 +896,8 @@
 static void
 store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,
 		       unsigned HOST_WIDE_INT bitsize,
-		       unsigned HOST_WIDE_INT bitpos, rtx value)
+		       unsigned HOST_WIDE_INT bitpos, rtx value,
+		       bool packedp)
 {
   enum machine_mode mode;
   unsigned int total_bits = BITS_PER_WORD;
@@ -882,6 +928,7 @@
 	 includes the entire field.  If such a mode would be larger than
 	 a word, we won't be doing the extraction the normal way.
 	 We don't want a mode bigger than the destination.  */
+      bool realign = true;
 
       mode = GET_MODE (op0);
       if (GET_MODE_BITSIZE (mode) == 0
@@ -891,7 +938,25 @@
       if (MEM_VOLATILE_P (op0)
           && GET_MODE_BITSIZE (GET_MODE (op0)) > 0
 	  && flag_strict_volatile_bitfields > 0)
-	mode = GET_MODE (op0);
+	{
+	  /* We must use the specified access size.  */
+	  mode = GET_MODE (op0);
+	  total_bits = GET_MODE_BITSIZE (mode);
+	  if (bitpos + bitsize <= total_bits
+	      && bitpos + bitsize 
+		 + (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT
+		 > total_bits)
+	    {
+	      realign = false;
+	      if (STRICT_ALIGNMENT)
+		{
+		  warn_misaligned_bitfield (bitsize == GET_MODE_BITSIZE (mode),
+					    packedp);
+		  if (packedp)
+		    mode = VOIDmode;
+		}
+	    }
+	}
       else
 	mode = get_best_mode (bitsize, bitpos + offset * BITS_PER_UNIT,
 			      MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));
@@ -899,7 +964,8 @@
       if (mode == VOIDmode)
 	{
 	  /* The only way this should occur is if the field spans word
-	     boundaries.  */
+	     boundaries, or container bondaries with
+	     -fstrict-volatile-bitfields.  */
 	  store_split_bit_field (op0, bitsize, bitpos + offset * BITS_PER_UNIT,
 				 value);
 	  return;
@@ -917,12 +983,15 @@
 		     * BITS_PER_UNIT);
 	}
 
-      /* Get ref to an aligned byte, halfword, or word containing the field.
-	 Adjust BITPOS to be position within a word,
-	 and OFFSET to be the offset of that word.
-	 Then alter OP0 to refer to that word.  */
-      bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;
-      offset -= (offset % (total_bits / BITS_PER_UNIT));
+      if (realign)
+	{
+	  /* Get ref to an aligned byte, halfword, or word containing the field.
+	     Adjust BITPOS to be position within a word,
+	     and OFFSET to be the offset of that word.
+	     Then alter OP0 to refer to that word.  */
+	  bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;
+	  offset -= (offset % (total_bits / BITS_PER_UNIT));
+	}
       op0 = adjust_address (op0, mode, offset);
     }
 
@@ -1136,7 +1205,7 @@
 	 it is just an out-of-bounds access.  Ignore it.  */
       if (word != const0_rtx)
 	store_fixed_bit_field (word, offset * unit / BITS_PER_UNIT, thissize,
-			       thispos, part);
+			       thispos, part, false);
       bitsdone += thissize;
     }
 }
@@ -1528,6 +1597,10 @@
   if (ext_mode != MAX_MACHINE_MODE
       && bitsize > 0
       && GET_MODE_BITSIZE (ext_mode) >= bitsize
+      /* Do not use extv/extzv for volatile bitfields when
+         -fstrict-volatile-bitfields is in effect.  */
+      && !(MEM_P (op0) && MEM_VOLATILE_P (op0)
+	   && flag_strict_volatile_bitfields > 0)
       /* If op0 is a register, we need it in EXT_MODE to make it
 	 acceptable to the format of ext(z)v.  */
       && !(GET_CODE (op0) == SUBREG && GET_MODE (op0) != ext_mode)
@@ -1552,17 +1625,17 @@
 	/* Get ref to first byte containing part of the field.  */
 	xop0 = adjust_address (xop0, byte_mode, xoffset);
 
-      /* On big-endian machines, we count bits from the most significant.
-	 If the bit field insn does not, we must invert.  */
-      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)
-	xbitpos = unit - bitsize - xbitpos;
-
       /* Now convert from counting within UNIT to counting in EXT_MODE.  */
-      if (BITS_BIG_ENDIAN && !MEM_P (xop0))
+      if (BYTES_BIG_ENDIAN && !MEM_P (xop0))
 	xbitpos += GET_MODE_BITSIZE (ext_mode) - unit;
 
       unit = GET_MODE_BITSIZE (ext_mode);
 
+      /* On big-endian machines, we count bits from the most significant.
+	 If the bit field insn does not, we must invert.  */
+      if (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)
+	xbitpos = unit - bitsize - xbitpos;
+
       if (xtarget == 0)
 	xtarget = xspec_target = gen_reg_rtx (tmode);
 
@@ -1783,42 +1856,13 @@
 	{
 	  if (STRICT_ALIGNMENT)
 	    {
-	      static bool informed_about_misalignment = false;
-	      bool warned;
-
+	      warn_misaligned_bitfield (bitsize == total_bits, packedp);
 	      if (packedp)
 		{
-		  if (bitsize == total_bits)
-		    warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,
-					 "multiple accesses to volatile structure member"
-					 " because of packed attribute");
-		  else
-		    warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,
-					 "multiple accesses to volatile structure bitfield"
-					 " because of packed attribute");
-
 		  return extract_split_bit_field (op0, bitsize,
 						  bitpos + offset * BITS_PER_UNIT,
 						  unsignedp);
 		}
-
-	      if (bitsize == total_bits)
-		warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,
-				     "mis-aligned access used for structure member");
-	      else
-		warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,
-				     "mis-aligned access used for structure bitfield");
-
-	      if (! informed_about_misalignment && warned)
-		{
-		  informed_about_misalignment = true;
-		  inform (input_location,
-			  "when a volatile object spans multiple type-sized locations,"
-			  " the compiler must choose between using a single mis-aligned access to"
-			  " preserve the volatility, or using multiple aligned accesses to avoid"
-			  " runtime faults; this code may fail at runtime if the hardware does"
-			  " not allow this access");
-		}
 	    }
 	}
       else
diff -ru ./gcc/expr.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/expr.c
--- ./gcc/expr.c	2014-06-06 14:25:27.466150551 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/expr.c	2012-04-28 17:58:33.000000000 +1000
@@ -143,7 +143,7 @@
 				     tree, tree, int, alias_set_type);
 static void store_constructor (tree, rtx, int, HOST_WIDE_INT);
 static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,
-			tree, tree, alias_set_type, bool);
+			tree, tree, alias_set_type, bool, bool);
 
 static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (const_tree, const_tree);
 
@@ -1387,7 +1387,7 @@
 {
   if (!block_move_fn)
     {
-      tree args, fn;
+      tree args, fn, attrs, attr_args;
 
       fn = get_identifier ("memcpy");
       args = build_function_type_list (ptr_type_node, ptr_type_node,
@@ -1402,6 +1402,11 @@
       DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;
       DECL_VISIBILITY_SPECIFIED (fn) = 1;
 
+      attr_args = build_tree_list (NULL_TREE, build_string (1, "1"));
+      attrs = tree_cons (get_identifier ("fn spec"), attr_args, NULL);
+
+      decl_attributes (&fn, attrs, ATTR_FLAG_BUILT_IN);
+
       block_move_fn = fn;
     }
 
@@ -2077,7 +2082,7 @@
 	emit_move_insn (adjust_address (dest, mode, bytepos), tmps[i]);
       else
 	store_bit_field (dest, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,
-			 mode, tmps[i]);
+			 false, mode, tmps[i]);
     }
 
   /* Copy from the pseudo into the (probable) hard reg.  */
@@ -2171,7 +2176,7 @@
 
       /* Use xbitpos for the source extraction (right justified) and
 	 bitpos for the destination store (left justified).  */
-      store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, copy_mode,
+      store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, false, copy_mode,
 		       extract_bit_field (src, bitsize,
 					  xbitpos % BITS_PER_WORD, 1, false,
 					  NULL_RTX, copy_mode, copy_mode));
@@ -2249,7 +2254,8 @@
 
       /* Use bitpos for the source extraction (left justified) and
 	 xbitpos for the destination store (right justified).  */
-      store_bit_field (dst_word, bitsize, xbitpos % BITS_PER_WORD, word_mode,
+      store_bit_field (dst_word, bitsize, xbitpos % BITS_PER_WORD, false,
+		       word_mode,
 		       extract_bit_field (src_word, bitsize,
 					  bitpos % BITS_PER_WORD, 1, false,
 					  NULL_RTX, word_mode, word_mode));
@@ -2935,7 +2941,7 @@
 	gcc_assert (MEM_P (cplx) && ibitsize < BITS_PER_WORD);
     }
 
-  store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, imode, val);
+  store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, false, imode, val);
 }
 
 /* Extract one of the components of the complex value CPLX.  Extract the
@@ -4409,12 +4415,12 @@
 	  else if (bitpos + bitsize <= mode_bitsize / 2)
 	    result = store_field (XEXP (to_rtx, 0), bitsize, bitpos,
 				  mode1, from, TREE_TYPE (tem),
-				  get_alias_set (to), nontemporal);
+				  get_alias_set (to), nontemporal, false);
 	  else if (bitpos >= mode_bitsize / 2)
 	    result = store_field (XEXP (to_rtx, 1), bitsize,
 				  bitpos - mode_bitsize / 2, mode1, from,
 				  TREE_TYPE (tem), get_alias_set (to),
-				  nontemporal);
+				  nontemporal, false);
 	  else if (bitpos == 0 && bitsize == mode_bitsize)
 	    {
 	      rtx from_rtx;
@@ -4435,7 +4441,7 @@
 	      write_complex_part (temp, XEXP (to_rtx, 1), true);
 	      result = store_field (temp, bitsize, bitpos, mode1, from,
 				    TREE_TYPE (tem), get_alias_set (to),
-				    nontemporal);
+				    nontemporal, false);
 	      emit_move_insn (XEXP (to_rtx, 0), read_complex_part (temp, false));
 	      emit_move_insn (XEXP (to_rtx, 1), read_complex_part (temp, true));
 	    }
@@ -4462,9 +4468,19 @@
 					       to_rtx, to, from))
 	    result = NULL;
 	  else
-	    result = store_field (to_rtx, bitsize, bitpos, mode1, from,
-				  TREE_TYPE (tem), get_alias_set (to),
-				  nontemporal);
+	    {
+	      bool packedp = false;
+
+	      if (TREE_CODE(to) == COMPONENT_REF
+		  && (TYPE_PACKED (TREE_TYPE (TREE_OPERAND (to, 0)))
+		      || (TREE_CODE (TREE_OPERAND (to, 1)) == FIELD_DECL
+			  && DECL_PACKED (TREE_OPERAND (to, 1)))))
+		packedp = true;
+
+	      result = store_field (to_rtx, bitsize, bitpos, mode1, from,
+				    TREE_TYPE (tem), get_alias_set (to),
+				    nontemporal, packedp);
+	    }
 	}
 
       if (result)
@@ -4875,7 +4891,7 @@
 			      : BLOCK_OP_NORMAL));
 	  else if (GET_MODE (target) == BLKmode)
 	    store_bit_field (target, INTVAL (expr_size (exp)) * BITS_PER_UNIT,
-			     0, GET_MODE (temp), temp);
+			     0, false, GET_MODE (temp), temp);
 	  else
 	    convert_move (target, temp, unsignedp);
 	}
@@ -5318,7 +5334,8 @@
       store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);
     }
   else
-    store_field (target, bitsize, bitpos, mode, exp, type, alias_set, false);
+    store_field (target, bitsize, bitpos, mode, exp, type, alias_set, false,
+		 false);
 }
 
 /* Store the value of constructor EXP into the rtx TARGET.
@@ -5906,7 +5923,7 @@
 static rtx
 store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,
 	     enum machine_mode mode, tree exp, tree type,
-	     alias_set_type alias_set, bool nontemporal)
+	     alias_set_type alias_set, bool nontemporal, bool packedp)
 {
   if (TREE_CODE (exp) == ERROR_MARK)
     return const0_rtx;
@@ -5938,7 +5955,7 @@
 	emit_move_insn (object, target);
 
       store_field (blk_object, bitsize, bitpos, mode, exp, type, alias_set,
-		   nontemporal);
+		   nontemporal, false);
 
       emit_move_insn (target, object);
 
@@ -5971,6 +5988,8 @@
 		|| bitpos % GET_MODE_ALIGNMENT (mode))
 	       && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target)))
 	      || (bitpos % BITS_PER_UNIT != 0)))
+      || (bitsize >= 0 && mode != BLKmode
+	  && GET_MODE_BITSIZE (mode) > bitsize)
       /* If the RHS and field are a constant size and the size of the
 	 RHS isn't the same size as the bitfield, we must use bitfield
 	 operations.  */
@@ -6053,7 +6072,7 @@
 	}
 
       /* Store the value in the bitfield.  */
-      store_bit_field (target, bitsize, bitpos, mode, temp);
+      store_bit_field (target, bitsize, bitpos, packedp, mode, temp);
 
       return const0_rtx;
     }
@@ -7501,7 +7520,7 @@
 				 * BITS_PER_UNIT),
 				(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),
 			   0, TYPE_MODE (valtype), treeop0,
-			   type, 0, false);
+			   type, 0, false, false);
 	    }
 
 	  /* Return the entire union.  */
@@ -10525,9 +10544,8 @@
 /* Build a decl for a personality function given a language prefix.  */
 
 tree
-build_personality_function (const char *lang)
+build_personality_function (const char *lang, bool alternative)
 {
-  const char *unwind_and_version;
   tree decl, type;
   char *name;
 
@@ -10536,18 +10554,26 @@
     case UI_NONE:
       return NULL;
     case UI_SJLJ:
-      unwind_and_version = "_sj0";
+      name = ACONCAT (("__", lang, "_personality_sj0", NULL));
       break;
     case UI_DWARF2:
     case UI_TARGET:
-      unwind_and_version = "_v0";
+
+      if (TARGET_COMPACT_EH
+          && (strcmp (lang_hooks.name, "GNU C++") == 0))
+	{
+	  if (alternative)
+	    name = ACONCAT (("__gnu_compact_pr3", NULL));
+	  else
+	    name = ACONCAT (("__gnu_compact_pr2", NULL));
+	}
+      else
+	name = ACONCAT (("__", lang, "_personality_v0", NULL));
       break;
     default:
       gcc_unreachable ();
     }
 
-  name = ACONCAT (("__", lang, "_personality", unwind_and_version, NULL));
-
   type = build_function_type_list (integer_type_node, integer_type_node,
 				   long_long_unsigned_type_node,
 				   ptr_type_node, ptr_type_node, NULL_TREE);
diff -ru ./gcc/expr.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/expr.h
--- ./gcc/expr.h	2014-06-06 11:50:17.203598664 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/expr.h	2012-03-29 18:03:19.000000000 +1000
@@ -668,7 +668,8 @@
 mode_for_extraction (enum extraction_pattern, int);
 
 extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,
-			     unsigned HOST_WIDE_INT, enum machine_mode, rtx);
+			     unsigned HOST_WIDE_INT, bool,
+			     enum machine_mode, rtx);
 extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,
 			      unsigned HOST_WIDE_INT, int, bool, rtx,
 			      enum machine_mode, enum machine_mode);
diff -ru ./gcc/final.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/final.c
--- ./gcc/final.c	2014-06-06 11:50:17.203598664 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/final.c	2012-03-29 18:03:19.000000000 +1000
@@ -232,6 +232,7 @@
 #ifdef HAVE_ATTR_length
 static int align_fuzz (rtx, rtx, int, unsigned);
 #endif
+static void collect_fn_hard_reg_usage (void);
 
 /* Initialize data in final at the beginning of a compilation.  */
 
@@ -704,6 +705,8 @@
   int freq_max = 0;
   int freq_threshold = 0;
 
+  collect_fn_hard_reg_usage ();
+
   if (label_align)
     {
       free (label_align);
@@ -1129,7 +1132,9 @@
 	      int inner_uid = INSN_UID (inner_insn);
 	      int inner_length;
 
-	      if (GET_CODE (body) == ASM_INPUT
+              if (LABEL_P (inner_insn) || DELETED_NOTE_P (inner_insn))
+                inner_length = 0;
+	      else if (GET_CODE (body) == ASM_INPUT
 		  || asm_noperands (PATTERN (XVECEXP (body, 0, i))) >= 0)
 		inner_length = (asm_insn_count (PATTERN (inner_insn))
 				* insn_default_length (inner_insn));
@@ -1139,8 +1144,9 @@
 	      insn_lengths[inner_uid] = inner_length;
 	      if (const_delay_slots)
 		{
-		  if ((varying_length[inner_uid]
-		       = insn_variable_length_p (inner_insn)) != 0)
+		  if (!(LABEL_P (inner_insn) || DELETED_NOTE_P (inner_insn))
+                      && (varying_length[inner_uid]
+                          = insn_variable_length_p (inner_insn)) != 0)
 		    varying_length[uid] = 1;
 		  INSN_ADDRESSES (inner_uid) = (insn_current_address
 						+ insn_lengths[uid]);
@@ -2290,9 +2296,15 @@
 
 	    /* Record the delay slots' frame information before the branch.
 	       This is needed for delayed calls: see execute_cfa_program().  */
-	    if (dwarf2out_do_frame ())
+	    if (!JUMP_P (XVECEXP (body, 0, 0))
+		&& dwarf2out_do_frame ())
 	      for (i = 1; i < XVECLEN (body, 0); i++)
-		dwarf2out_frame_debug (XVECEXP (body, 0, i), false);
+                {
+                  if (LABEL_P (XVECEXP (body, 0, i))
+		      || DELETED_NOTE_P (XVECEXP (body, 0, i)))
+                    continue;
+                  dwarf2out_frame_debug (XVECEXP (body, 0, i), false);
+                }
 
 	    /* The first insn in this SEQUENCE might be a JUMP_INSN that will
 	       force the restoration of a comparison that was previously
@@ -2319,6 +2331,16 @@
 #ifdef DBR_OUTPUT_SEQEND
 	    DBR_OUTPUT_SEQEND (file);
 #endif
+	    if (JUMP_P (XVECEXP (body, 0, 0))
+		&& dwarf2out_do_frame ())
+	      for (i = 1; i < XVECLEN (body, 0); i++)
+                {
+                  if (LABEL_P (XVECEXP (body, 0, i))
+		      || DELETED_NOTE_P (XVECEXP (body, 0, i)))
+                    continue;
+                  dwarf2out_frame_debug (XVECEXP (body, 0, i), false);
+                }
+
 	    final_sequence = 0;
 
 	    /* If the insn requiring the delay slot was a CALL_INSN, the
@@ -2428,7 +2450,8 @@
 	        delete_insn (insn);
 		break;
 	      }
-	    else if (GET_CODE (SET_SRC (body)) == RETURN)
+	    else if (GET_CODE (SET_SRC (body)) == RETURN
+		     || GET_CODE (SET_SRC (body)) == SIMPLE_RETURN)
 	      /* Replace (set (pc) (return)) with (return).  */
 	      PATTERN (insn) = body = SET_SRC (body);
 
@@ -2751,6 +2774,12 @@
   if (filename == NULL)
     return false;
 
+#ifdef HAVE_ATTR_length
+  /* Prevent duplicate line markers at the same location.  */
+  if (get_attr_length (insn) == 0)
+    return false;
+#endif
+
   if (force_source_line
       || filename != last_filename
       || last_linenum != linenum)
@@ -3576,8 +3605,7 @@
       break;
 
     case CONST_FIXED:
-      fprintf (file, HOST_WIDE_INT_PRINT_HEX,
-	       (unsigned HOST_WIDE_INT) CONST_FIXED_VALUE_LOW (x));
+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_FIXED_VALUE_LOW (x));
       break;
 
     case PLUS:
@@ -4520,3 +4548,190 @@
   0                                     /* todo_flags_finish */
  }
 };
+
+struct GTY (()) fn_hard_reg_usage
+{
+  /* Function declaration.  */
+  tree fndecl;
+
+  /* Hardware registers used by this function.  */
+  HARD_REG_SET used_regs;
+};
+
+/* Real hardware register usage for all seen functions.  Hash table is used
+   because there is no suitable structure which is not freed after function
+   compilation.  */
+
+static GTY ((param_is (struct fn_hard_reg_usage))) htab_t fn_hard_reg_usage_htab;
+
+/* Returns a hash value for p.  */
+
+static hashval_t
+fn_hard_reg_usage_hash (const void *p)
+{
+  /* Function declaration pointer is used as a hash index.  */
+  const struct fn_hard_reg_usage *entry =
+    (const struct fn_hard_reg_usage *) p;
+  return (hashval_t) (uintptr_t) entry->fndecl;
+}
+
+/* Used by hashtable to compare two fn_hard_reg_usage entries.  */
+
+static int
+fn_hard_reg_usage_eq (const void *p1, const void *p2)
+{
+  const struct fn_hard_reg_usage *entry1 =
+    (const struct fn_hard_reg_usage *) p1;
+  const struct fn_hard_reg_usage *entry2 =
+    (const struct fn_hard_reg_usage *) p2;
+  return entry1->fndecl == entry2->fndecl;
+}
+
+/* Collect function hard register usage for the current function.  */
+
+static void
+collect_fn_hard_reg_usage (void)
+{
+  basic_block bb;
+  rtx insn;
+  struct fn_hard_reg_usage dummy;
+  void **slot;
+  struct fn_hard_reg_usage *element;
+  int i;
+
+  if (!flag_use_caller_save)
+    return;
+
+  df_analyze ();
+
+  if (!fn_hard_reg_usage_htab)
+    fn_hard_reg_usage_htab = htab_create_ggc (128, fn_hard_reg_usage_hash,
+					      fn_hard_reg_usage_eq, NULL);
+
+  dummy.fndecl = current_function_decl;
+  slot = htab_find_slot (fn_hard_reg_usage_htab, &dummy, INSERT);
+  if (*slot != HTAB_EMPTY_ENTRY)
+    {
+      element = (struct fn_hard_reg_usage *) *slot;
+      gcc_assert (current_function_decl == element->fndecl);
+      return;
+    }
+
+  /* Insert node into hash table.  */
+  element = ggc_alloc_fn_hard_reg_usage ();
+  memset (element, 0, sizeof (struct fn_hard_reg_usage));
+  element->fndecl = current_function_decl;
+  *slot = element;
+
+  FOR_EACH_BB (bb)
+  {
+    for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));
+	 insn = NEXT_INSN (insn))
+      {
+	df_ref *def_rec;
+
+	unsigned int uid = INSN_UID (insn);
+
+	if (!NONDEBUG_INSN_P (insn))
+	  continue;
+
+	for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)
+	  {
+	    df_ref def = *def_rec;
+	    unsigned int dregno = DF_REF_REGNO (def);
+	    if (dregno < FIRST_PSEUDO_REGISTER)
+	      SET_HARD_REG_BIT (element->used_regs, dregno);
+	  }
+      }
+  }
+
+  /* Be conservative - mark fixed and global registers as used.  */
+  IOR_HARD_REG_SET (element->used_regs, fixed_reg_set);
+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+    if (global_regs[i])
+      SET_HARD_REG_BIT (element->used_regs, i);
+
+#ifdef STACK_REGS
+  /* Handle STACK_REGS conservatively, since the df-framework does not
+     provide accurate information for them.  */
+
+  for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)
+    SET_HARD_REG_BIT (element->used_regs, i);
+#endif
+}
+
+/* Get registers used by given function.  */
+
+static bool
+get_fn_reg_set_usage (tree fndecl, HARD_REG_SET *reg_set)
+{
+  struct fn_hard_reg_usage dummy;
+  void **slot = NULL;
+  struct fn_hard_reg_usage *element;
+
+  dummy.fndecl = fndecl;
+  if (fn_hard_reg_usage_htab)
+    slot = htab_find_slot (fn_hard_reg_usage_htab, &dummy, NO_INSERT);
+
+  if (slot == NULL || !targetm.binds_local_p (fndecl))
+    return FALSE;
+  else
+    {
+      element = (struct fn_hard_reg_usage *) (*slot);
+      COPY_HARD_REG_SET (*reg_set, element->used_regs);
+      return TRUE;
+    }
+}
+
+/* Recursive part of the function get_call_fndecl.  */
+
+static tree
+get_call_fndecl_rec (rtx x)
+{
+  if (GET_CODE (x) == PARALLEL)
+    return get_call_fndecl_rec (XVECEXP (x, 0, 0));
+  if (GET_CODE (x) == SET)
+    return get_call_fndecl_rec (SET_SRC (x));
+  if (GET_CODE (x) == CALL)
+    {
+      if (GET_CODE (XEXP (x, 0)) != MEM)
+	return NULL_TREE;
+
+      if (GET_CODE (XEXP (XEXP (x, 0), 0)) != SYMBOL_REF)
+	return NULL_TREE;
+
+      return SYMBOL_REF_DECL (XEXP (XEXP (x, 0), 0));
+    }
+  return NULL_TREE;
+}
+
+/* Get the declaration of the function called by instruction insn.  */
+
+static bool
+get_call_fndecl (rtx insn, tree *fndecl)
+{
+  *fndecl = get_call_fndecl_rec (PATTERN (insn));
+  if (*fndecl)
+    return true;
+  return false;
+}
+
+/* Get registers used by given function call instruction.  */
+
+void
+get_call_reg_set_usage (rtx insn, HARD_REG_SET *reg_set,
+			HARD_REG_SET default_set)
+{
+  tree fndecl;
+  if (get_call_fndecl (insn, &fndecl))
+    {
+      if (get_fn_reg_set_usage (fndecl, reg_set))
+	AND_HARD_REG_SET (*reg_set, default_set);
+      else
+	COPY_HARD_REG_SET (*reg_set, default_set);
+    }
+  else
+    COPY_HARD_REG_SET (*reg_set, default_set);
+}
+
+#include "gt-final.h"
diff -ru ./gcc/function.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/function.c
--- ./gcc/function.c	2014-06-06 11:50:17.351598670 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/function.c	2012-03-29 18:03:19.000000000 +1000
@@ -146,9 +146,6 @@
    can always export `prologue_epilogue_contains'.  */
 static void record_insns (rtx, rtx, htab_t *) ATTRIBUTE_UNUSED;
 static bool contains (const_rtx, htab_t);
-#ifdef HAVE_return
-static void emit_return_into_block (basic_block);
-#endif
 static void prepare_function_start (void);
 static void do_clobber_return_reg (rtx, void *);
 static void do_use_return_reg (rtx, void *);
@@ -274,7 +271,11 @@
   if (! type)
     type = lang_hooks.types.type_for_mode (mode, 0);
 
-  return STACK_SLOT_ALIGNMENT (type, mode, alignment);
+  alignment = STACK_SLOT_ALIGNMENT (type, mode, alignment);
+
+  alignment = alignment_for_aligned_arrays (type, alignment);
+
+  return alignment;
 }
 
 /* Determine whether it is possible to fit a stack slot of size SIZE and
@@ -2914,21 +2915,6 @@
   SET_DECL_RTL (parm, stack_parm);
 }
 
-/* A subroutine of assign_parm_setup_reg, called through note_stores.
-   This collects sets and clobbers of hard registers in a HARD_REG_SET,
-   which is pointed to by DATA.  */
-static void
-record_hard_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)
-{
-  HARD_REG_SET *pset = (HARD_REG_SET *)data;
-  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)
-    {
-      int nregs = hard_regno_nregs[REGNO (x)][GET_MODE (x)];
-      while (nregs-- > 0)
-	SET_HARD_REG_BIT (*pset, REGNO (x) + nregs);
-    }
-}
-
 /* A subroutine of assign_parms.  Allocate a pseudo to hold the current
    parameter.  Get it there.  Perform all ABI specified conversions.  */
 
@@ -5263,42 +5249,313 @@
   return 0;
 }
 
+#ifdef HAVE_simple_return
+/* A subroutine of requires_stack_frame_p, called via for_each_rtx.
+   If any change is made, set CHANGED
+   to true.  */
+
+static int
+frame_required_for_rtx (rtx *loc, void *data ATTRIBUTE_UNUSED)
+{
+  rtx x = *loc;
+  if (x == stack_pointer_rtx || x == hard_frame_pointer_rtx
+      || x == arg_pointer_rtx || x == pic_offset_table_rtx
+#ifdef RETURN_ADDR_REGNUM
+      || (REG_P (x) && REGNO (x) == RETURN_ADDR_REGNUM)
+#endif
+      )
+    return 1;
+  return 0;
+}
+
+/* Return true if INSN requires the stack frame to be set up.
+   PROLOGUE_USED contains the hard registers used in the function
+   prologue.  */
+static bool
+requires_stack_frame_p (rtx insn, HARD_REG_SET prologue_used)
+{
+  HARD_REG_SET hardregs;
+  unsigned regno;
+
+  if (!INSN_P (insn) || DEBUG_INSN_P (insn))
+    return false;
+  if (CALL_P (insn))
+    return !SIBLING_CALL_P (insn);
+  if (for_each_rtx (&PATTERN (insn), frame_required_for_rtx, NULL))
+    return true;
+  CLEAR_HARD_REG_SET (hardregs);
+  note_stores (PATTERN (insn), record_hard_reg_sets, &hardregs);
+  if (hard_reg_set_intersect_p (hardregs, prologue_used))
+    return true;
+  AND_COMPL_HARD_REG_SET (hardregs, call_used_reg_set);
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (TEST_HARD_REG_BIT (hardregs, regno)
+	&& df_regs_ever_live_p (regno))
+      return true;
+  return false;
+}
+
+/* Look for sets of call-saved registers in the first block of the
+   function, and move them down into successor blocks if the register
+   is used only on one path.  This exposes more opportunities for
+   shrink-wrapping.
+   These kinds of sets often occur when incoming argument registers are
+   moved to call-saved registers because their values are live across
+   one or more calls during the function.  */
+
+static void
+prepare_shrink_wrap (basic_block entry_block)
+{
+  rtx insn, curr;
+  FOR_BB_INSNS_SAFE (entry_block, insn, curr)
+    {
+      basic_block next_bb;
+      edge e, live_edge;
+      edge_iterator ei;
+      rtx set, scan;
+      unsigned destreg, srcreg;
+
+      if (!NONDEBUG_INSN_P (insn))
+	continue;
+      set = single_set (insn);
+      if (!set)
+	continue;
+
+      if (!REG_P (SET_SRC (set)) || !REG_P (SET_DEST (set)))
+	continue;
+      srcreg = REGNO (SET_SRC (set));
+      destreg = REGNO (SET_DEST (set));
+      if (hard_regno_nregs[srcreg][GET_MODE (SET_SRC (set))] > 1
+	  || hard_regno_nregs[destreg][GET_MODE (SET_DEST (set))] > 1)
+	continue;
+
+      next_bb = entry_block;
+      scan = insn;
+
+      for (;;)
+	{
+	  live_edge = NULL;
+	  FOR_EACH_EDGE (e, ei, next_bb->succs)
+	    {
+	      if (REGNO_REG_SET_P (df_get_live_in (e->dest), destreg))
+		{
+		  if (live_edge)
+		    {
+		      live_edge = NULL;
+		      break;
+		    }
+		  live_edge = e;
+		}
+	    }
+	  if (!live_edge)
+	    break;
+	  /* We can sometimes encounter dead code.  Don't try to move it
+	     into the exit block.  */
+	  if (live_edge->dest == EXIT_BLOCK_PTR)
+	    break;
+	  if (EDGE_COUNT (live_edge->dest->preds) > 1)
+	    break;
+	  while (scan != BB_END (next_bb))
+	    {
+	      scan = NEXT_INSN (scan);
+	      if (NONDEBUG_INSN_P (scan))
+		{
+		  rtx link;
+		  HARD_REG_SET set_regs;
+
+		  CLEAR_HARD_REG_SET (set_regs);
+		  note_stores (PATTERN (scan), record_hard_reg_sets,
+			       &set_regs);
+		  if (CALL_P (scan))
+		    IOR_HARD_REG_SET (set_regs, call_used_reg_set);
+		  for (link = REG_NOTES (scan); link; link = XEXP (link, 1))
+		    if (REG_NOTE_KIND (link) == REG_INC)
+		      record_hard_reg_sets (XEXP (link, 0), NULL, &set_regs);
+
+		  if (TEST_HARD_REG_BIT (set_regs, srcreg)
+		      || TEST_HARD_REG_BIT (set_regs, destreg)
+		      || reg_referenced_p (SET_DEST (set),
+					   PATTERN (scan)))
+		    {
+		      scan = NULL_RTX;
+		      break;
+		    }
+		  if (CALL_P (scan))
+		    {
+		      rtx link = CALL_INSN_FUNCTION_USAGE (scan);
+		      while (link)
+			{
+			  rtx tmp = XEXP (link, 0);
+			  if (GET_CODE (tmp) == USE
+			      && reg_referenced_p (SET_DEST (set), tmp))
+			    break;
+			  link = XEXP (link, 1);
+			}
+		      if (link)
+			{
+			  scan = NULL_RTX;
+			  break;
+			}
+		    }
+		}
+	    }
+	  if (!scan)
+	    break;
+	  next_bb = live_edge->dest;
+	}
+
+      if (next_bb != entry_block)
+	{
+	  rtx after = BB_HEAD (next_bb);
+	  while (!NOTE_P (after)
+		 || NOTE_KIND (after) != NOTE_INSN_BASIC_BLOCK)
+	    after = NEXT_INSN (after);
+	  emit_insn_after (PATTERN (insn), after);
+	  delete_insn (insn);
+	}
+    }
+}
+
+#endif
+
 #ifdef HAVE_return
-/* Insert gen_return at the end of block BB.  This also means updating
-   block_for_insn appropriately.  */
+
+static rtx
+gen_return_pattern (bool simple_p)
+{
+#ifdef HAVE_simple_return
+  return simple_p ? gen_simple_return () : gen_return ();
+#else
+  gcc_assert (!simple_p);
+  return gen_return ();
+#endif
+}
+
+/* Insert an appropriate return pattern at the end of block BB.  This
+   also means updating block_for_insn appropriately.  */
 
 static void
-emit_return_into_block (basic_block bb)
+emit_return_into_block (bool simple_p, basic_block bb)
 {
-  emit_jump_insn_after (gen_return (), BB_END (bb));
+  rtx jump;
+  jump = emit_jump_insn_after (gen_return_pattern (simple_p), BB_END (bb));
+  JUMP_LABEL (jump) = simple_p ? simple_return_rtx : ret_rtx;
+}
+#endif
+
+/* Return true if BB has any active insns.  */
+static bool
+bb_active_p (basic_block bb)
+{
+  rtx label;
+
+  /* Test whether there are active instructions in the last block.  */
+  label = BB_END (bb);
+  while (label && !LABEL_P (label))
+    {
+      if (active_insn_p (label))
+	break;
+      label = PREV_INSN (label);
+    }
+  return BB_HEAD (bb) != label || !LABEL_P (label);
 }
-#endif /* HAVE_return */
 
 /* Generate the prologue and epilogue RTL if the machine supports it.  Thread
    this into place with notes indicating where the prologue ends and where
-   the epilogue begins.  Update the basic block information when possible.  */
+   the epilogue begins.  Update the basic block information when possible.
+
+   Notes on epilogue placement:
+   There are several kinds of edges to the exit block:
+   * a single fallthru edge from LAST_BB
+   * possibly, edges from blocks containing sibcalls
+   * possibly, fake edges from infinite loops
+
+   The epilogue is always emitted on the fallthru edge from the last basic
+   block in the function, LAST_BB, into the exit block.
+
+   If LAST_BB is empty except for a label, it is the target of every
+   other basic block in the function that ends in a return.  If a
+   target has a return or simple_return pattern (possibly with
+   conditional variants), these basic blocks can be changed so that a
+   return insn is emitted into them, and their target is adjusted to
+   the real exit block.
+
+   Notes on shrink wrapping: We implement a fairly conservative
+   version of shrink-wrapping rather than the textbook one.  We only
+   generate a single prologue and a single epilogue.  This is
+   sufficient to catch a number of interesting cases involving early
+   exits.
+
+   First, we identify the blocks that require the prologue to occur before
+   them.  These are the ones that modify a call-saved register, or reference
+   any of the stack or frame pointer registers.  To simplify things, we then
+   mark everything reachable from these blocks as also requiring a prologue.
+   This takes care of loops automatically, and avoids the need to examine
+   whether MEMs reference the frame, since it is sufficient to check for
+   occurrences of the stack or frame pointer.
+
+   We then compute the set of blocks for which the need for a prologue
+   is anticipatable (borrowing terminology from the shrink-wrapping
+   description in Muchnick's book).  These are the blocks which either
+   require a prologue themselves, or those that have only successors
+   where the prologue is anticipatable.  The prologue needs to be
+   inserted on all edges from BB1->BB2 where BB2 is in ANTIC and BB1
+   is not.  For the moment, we ensure that only one such edge exists.
+
+   The epilogue is placed as described above, but we make a
+   distinction between inserting return and simple_return patterns
+   when modifying other blocks that end in a return.  Blocks that end
+   in a sibcall omit the sibcall_epilogue if the block is not in
+   ANTIC.  */
 
 static void
 thread_prologue_and_epilogue_insns (void)
 {
   bool inserted;
+  basic_block last_bb;
+  bool last_bb_active;
+#ifdef HAVE_simple_return
+  bool unconverted_simple_returns = false;
+  basic_block simple_return_block = NULL;
+#endif
+  rtx returnjump ATTRIBUTE_UNUSED;
   rtx seq ATTRIBUTE_UNUSED, epilogue_end ATTRIBUTE_UNUSED;
-  edge entry_edge ATTRIBUTE_UNUSED;
+  rtx prologue_seq ATTRIBUTE_UNUSED, split_prologue_seq ATTRIBUTE_UNUSED;
+  edge entry_edge, orig_entry_edge, exit_fallthru_edge;
   edge e;
   edge_iterator ei;
+  bitmap_head bb_flags;
+
+  df_analyze ();
 
   rtl_profile_for_bb (ENTRY_BLOCK_PTR);
 
   inserted = false;
   seq = NULL_RTX;
+  prologue_seq = NULL_RTX;
   epilogue_end = NULL_RTX;
+  returnjump = NULL_RTX;
 
   /* Can't deal with multiple successors of the entry block at the
      moment.  Function should always have at least one entry
      point.  */
   gcc_assert (single_succ_p (ENTRY_BLOCK_PTR));
   entry_edge = single_succ_edge (ENTRY_BLOCK_PTR);
+  orig_entry_edge = entry_edge;
 
+  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR->preds);
+  if (exit_fallthru_edge != NULL)
+    {
+      last_bb = exit_fallthru_edge->src;
+      last_bb_active = bb_active_p (last_bb);
+    }
+  else
+    {
+      last_bb = NULL;
+      last_bb_active = false;
+    }
+
+  split_prologue_seq = NULL_RTX;
   if (flag_split_stack
       && (lookup_attribute ("no_split_stack", DECL_ATTRIBUTES (cfun->decl))
 	  == NULL))
@@ -5310,21 +5567,15 @@
 
       start_sequence ();
       emit_insn (gen_split_stack_prologue ());
-      seq = get_insns ();
+      split_prologue_seq = get_insns ();
       end_sequence ();
 
-      record_insns (seq, NULL, &prologue_insn_hash);
-      set_insn_locators (seq, prologue_locator);
-
-      /* This relies on the fact that committing the edge insertion
-	 will look for basic blocks within the inserted instructions,
-	 which in turn relies on the fact that we are not in CFG
-	 layout mode here.  */
-      insert_insn_on_edge (seq, entry_edge);
-      inserted = true;
+      record_insns (split_prologue_seq, NULL, &prologue_insn_hash);
+      set_insn_locators (split_prologue_seq, prologue_locator);
 #endif
     }
 
+  prologue_seq = NULL_RTX;
 #ifdef HAVE_prologue
   if (HAVE_prologue)
     {
@@ -5347,15 +5598,201 @@
       if (!targetm.profile_before_prologue () && crtl->profile)
         emit_insn (gen_blockage ());
 
-      seq = get_insns ();
+      prologue_seq = get_insns ();
       end_sequence ();
-      set_insn_locators (seq, prologue_locator);
+      set_insn_locators (prologue_seq, prologue_locator);
+    }
+#endif
 
-      insert_insn_on_edge (seq, entry_edge);
-      inserted = true;
+  bitmap_initialize (&bb_flags, &bitmap_default_obstack);
+
+#ifdef HAVE_simple_return
+  /* Try to perform a kind of shrink-wrapping, making sure the
+     prologue/epilogue is emitted only around those parts of the
+     function that require it.  */
+
+  if (flag_shrink_wrap && HAVE_simple_return && !flag_non_call_exceptions
+      && HAVE_prologue && !crtl->calls_eh_return)
+    {
+      HARD_REG_SET prologue_clobbered, prologue_used, live_on_edge;
+      rtx p_insn;
+
+      VEC(basic_block, heap) *vec;
+      basic_block bb;
+      bitmap_head bb_antic_flags;
+      bitmap_head bb_on_list;
+
+      prepare_shrink_wrap (entry_edge->dest);
+
+      /* That may have inserted instructions into the last block.  */
+      if (last_bb && !last_bb_active)
+	last_bb_active = bb_active_p (last_bb);
+
+      /* Compute the registers set and used in the prologue.  */
+      CLEAR_HARD_REG_SET (prologue_clobbered);
+      CLEAR_HARD_REG_SET (prologue_used);
+      for (p_insn = prologue_seq; p_insn; p_insn = NEXT_INSN (p_insn))
+	{
+	  HARD_REG_SET this_used;
+	  if (!NONDEBUG_INSN_P (p_insn))
+	    continue;
+
+	  CLEAR_HARD_REG_SET (this_used);
+	  note_uses (&PATTERN (p_insn), record_hard_reg_uses,
+		     &this_used);
+	  AND_COMPL_HARD_REG_SET (this_used, prologue_clobbered);
+	  IOR_HARD_REG_SET (prologue_used, this_used);
+	  note_stores (PATTERN (p_insn), record_hard_reg_sets,
+		       &prologue_clobbered);
+	}
+
+      bitmap_initialize (&bb_antic_flags, &bitmap_default_obstack);
+      bitmap_initialize (&bb_on_list, &bitmap_default_obstack);
+
+      vec = VEC_alloc (basic_block, heap, n_basic_blocks);
+
+      FOR_EACH_BB (bb)
+	{
+	  rtx insn;
+	  FOR_BB_INSNS (bb, insn)
+	    {
+	      if (requires_stack_frame_p (insn, prologue_used))
+		{
+		  bitmap_set_bit (&bb_flags, bb->index);
+		  VEC_quick_push (basic_block, vec, bb);
+		  break;
+		}
+	    }
+	}
+
+      /* For every basic block that needs a prologue, mark all blocks
+	 reachable from it, so as to ensure they are also seen as
+	 requiring a prologue.  */
+      while (!VEC_empty (basic_block, vec))
+	{
+	  basic_block tmp_bb = VEC_pop (basic_block, vec);
+	  edge e;
+	  edge_iterator ei;
+	  FOR_EACH_EDGE (e, ei, tmp_bb->succs)
+	    {
+	      if (e->dest == EXIT_BLOCK_PTR
+		  || bitmap_bit_p (&bb_flags, e->dest->index))
+		continue;
+	      bitmap_set_bit (&bb_flags, e->dest->index);
+	      VEC_quick_push (basic_block, vec, e->dest);
+	    }
+	}
+      /* If the last basic block contains only a label, we'll be able
+	 to convert jumps to it to (potentially conditional) return
+	 insns later.  This means we don't necessarily need a prologue
+	 for paths reaching it.  */
+      if (last_bb)
+	{
+	  if (!last_bb_active)
+	    bitmap_clear_bit (&bb_flags, last_bb->index);
+	  else if (!bitmap_bit_p (&bb_flags, last_bb->index))
+	    goto fail_shrinkwrap;
+	}
+
+      /* Now walk backwards from every block that is marked as needing
+	 a prologue to compute the bb_antic_flags bitmap.  */
+      bitmap_copy (&bb_antic_flags, &bb_flags);
+      FOR_EACH_BB (bb)
+	{
+	  edge e;
+	  edge_iterator ei;
+	  if (!bitmap_bit_p (&bb_flags, bb->index))
+	    continue;
+	  FOR_EACH_EDGE (e, ei, bb->preds)
+	    if (!bitmap_bit_p (&bb_antic_flags, e->src->index))
+	      {
+		VEC_quick_push (basic_block, vec, e->src);
+		bitmap_set_bit (&bb_on_list, e->src->index);
+	      }
+	}
+      while (!VEC_empty (basic_block, vec))
+	{
+	  basic_block tmp_bb = VEC_pop (basic_block, vec);
+	  edge e;
+	  edge_iterator ei;
+	  bool all_set = true;
+
+	  bitmap_clear_bit (&bb_on_list, tmp_bb->index);
+	  FOR_EACH_EDGE (e, ei, tmp_bb->succs)
+	    {
+	      if (!bitmap_bit_p (&bb_antic_flags, e->dest->index))
+		{
+		  all_set = false;
+		  break;
+		}
+	    }
+	  if (all_set)
+	    {
+	      bitmap_set_bit (&bb_antic_flags, tmp_bb->index);
+	      FOR_EACH_EDGE (e, ei, tmp_bb->preds)
+		if (!bitmap_bit_p (&bb_antic_flags, e->src->index))
+		  {
+		    VEC_quick_push (basic_block, vec, e->src);
+		    bitmap_set_bit (&bb_on_list, e->src->index);
+		  }
+	    }
+	}
+      /* Find exactly one edge that leads to a block in ANTIC from
+	 a block that isn't.  */
+      if (!bitmap_bit_p (&bb_antic_flags, entry_edge->dest->index))
+	FOR_EACH_BB (bb)
+	  {
+	    if (!bitmap_bit_p (&bb_antic_flags, bb->index))
+	      continue;
+	    FOR_EACH_EDGE (e, ei, bb->preds)
+	      if (!bitmap_bit_p (&bb_antic_flags, e->src->index))
+		{
+		  if (entry_edge != orig_entry_edge)
+		    {
+		      entry_edge = orig_entry_edge;
+		      goto fail_shrinkwrap;
+		    }
+		  entry_edge = e;
+		}
+	  }
+
+      /* Test whether the prologue is known to clobber any register
+	 (other than FP or SP) which are live on the edge.  */
+      CLEAR_HARD_REG_BIT (prologue_clobbered, STACK_POINTER_REGNUM);
+      if (frame_pointer_needed)
+	CLEAR_HARD_REG_BIT (prologue_clobbered, HARD_FRAME_POINTER_REGNUM);
+
+      CLEAR_HARD_REG_SET (live_on_edge);
+      reg_set_to_hard_reg_set (&live_on_edge,
+			       df_get_live_in (entry_edge->dest));
+      if (hard_reg_set_intersect_p (live_on_edge, prologue_clobbered))
+	entry_edge = orig_entry_edge;
+
+      if (dump_file && entry_edge != orig_entry_edge)
+	fprintf (dump_file, "Prologue moved down by shrink-wrapping.\n");
+
+    fail_shrinkwrap:
+      bitmap_clear (&bb_antic_flags);
+      bitmap_clear (&bb_on_list);
+      VEC_free (basic_block, heap, vec);
     }
 #endif
 
+  if (split_prologue_seq != NULL_RTX)
+    {
+      /* This relies on the fact that committing the edge insertion
+	 will look for basic blocks within the inserted instructions,
+	 which in turn relies on the fact that we are not in CFG
+	 layout mode here.  */
+      insert_insn_on_edge (split_prologue_seq, entry_edge);
+      inserted = true;
+    }
+  if (prologue_seq != NULL_RTX)
+    {
+      insert_insn_on_edge (prologue_seq, entry_edge);
+      inserted = true;
+    }
+
   /* If the exit block has no non-fake predecessors, we don't need
      an epilogue.  */
   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)
@@ -5365,98 +5802,130 @@
     goto epilogue_done;
 
   rtl_profile_for_bb (EXIT_BLOCK_PTR);
+
 #ifdef HAVE_return
-  if (optimize && HAVE_return)
+  /* If we're allowed to generate a simple return instruction, then by
+     definition we don't need a full epilogue.  If the last basic
+     block before the exit block does not contain active instructions,
+     examine its predecessors and try to emit (conditional) return
+     instructions.  */
+  if (optimize && !last_bb_active
+      && (HAVE_return || entry_edge != orig_entry_edge))
     {
-      /* If we're allowed to generate a simple return instruction,
-	 then by definition we don't need a full epilogue.  Examine
-	 the block that falls through to EXIT.   If it does not
-	 contain any code, examine its predecessors and try to
-	 emit (conditional) return instructions.  */
-
-      basic_block last;
+      edge_iterator ei2;
+      int i;
+      basic_block bb;
       rtx label;
+      VEC(basic_block,heap) *src_bbs;
 
-      e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);
-      if (e == NULL)
+      if (exit_fallthru_edge == NULL)
 	goto epilogue_done;
-      last = e->src;
+      label = BB_HEAD (last_bb);
 
-      /* Verify that there are no active instructions in the last block.  */
-      label = BB_END (last);
-      while (label && !LABEL_P (label))
-	{
-	  if (active_insn_p (label))
-	    break;
-	  label = PREV_INSN (label);
-	}
+      src_bbs = VEC_alloc (basic_block, heap, EDGE_COUNT (last_bb->preds));
+      FOR_EACH_EDGE (e, ei2, last_bb->preds)
+	if (e->src != ENTRY_BLOCK_PTR)
+	  VEC_quick_push (basic_block, src_bbs, e->src);
 
-      if (BB_HEAD (last) == label && LABEL_P (label))
+      FOR_EACH_VEC_ELT (basic_block, src_bbs, i, bb)
 	{
-	  edge_iterator ei2;
+	  bool simple_p;
+	  rtx jump;
+	  e = find_edge (bb, last_bb);
 
-	  for (ei2 = ei_start (last->preds); (e = ei_safe_edge (ei2)); )
-	    {
-	      basic_block bb = e->src;
-	      rtx jump;
+	  jump = BB_END (bb);
 
-	      if (bb == ENTRY_BLOCK_PTR)
-		{
-		  ei_next (&ei2);
-		  continue;
-		}
+#ifdef HAVE_simple_return
+	  simple_p = (entry_edge != orig_entry_edge
+		      ? !bitmap_bit_p (&bb_flags, bb->index) : false);
+#else
+	  simple_p = false;
+#endif
 
-	      jump = BB_END (bb);
-	      if (!JUMP_P (jump) || JUMP_LABEL (jump) != label)
-		{
-		  ei_next (&ei2);
-		  continue;
-		}
+	  if (!simple_p
+	      && (!HAVE_return || !JUMP_P (jump)
+		  || JUMP_LABEL (jump) != label))
+	    continue;
 
-	      /* If we have an unconditional jump, we can replace that
-		 with a simple return instruction.  */
-	      if (simplejump_p (jump))
-		{
-		  emit_return_into_block (bb);
-		  delete_insn (jump);
-		}
+	  /* If we have an unconditional jump, we can replace that
+	     with a simple return instruction.  */
+	  if (!JUMP_P (jump))
+	    {
+	      emit_barrier_after (BB_END (bb));
+	      emit_return_into_block (simple_p, bb);
+	    }
+	  else if (simplejump_p (jump))
+	    {
+	      emit_return_into_block (simple_p, bb);
+	      delete_insn (jump);
+	    }
+	  else if (condjump_p (jump) && JUMP_LABEL (jump) != label)
+	    {
+	      basic_block new_bb;
+	      edge new_e;
 
-	      /* If we have a conditional jump, we can try to replace
-		 that with a conditional return instruction.  */
-	      else if (condjump_p (jump))
-		{
-		  if (! redirect_jump (jump, 0, 0))
-		    {
-		      ei_next (&ei2);
-		      continue;
-		    }
+	      gcc_assert (simple_p);
+	      new_bb = split_edge (e);
+	      emit_barrier_after (BB_END (new_bb));
+	      emit_return_into_block (simple_p, new_bb);
+#ifdef HAVE_simple_return
+	      simple_return_block = new_bb;
+#endif
+	      new_e = single_succ_edge (new_bb);
+	      redirect_edge_succ (new_e, EXIT_BLOCK_PTR);
 
-		  /* If this block has only one successor, it both jumps
-		     and falls through to the fallthru block, so we can't
-		     delete the edge.  */
-		  if (single_succ_p (bb))
-		    {
-		      ei_next (&ei2);
-		      continue;
-		    }
-		}
+	      continue;
+	    }
+	  /* If we have a conditional jump branching to the last
+	     block, we can try to replace that with a conditional
+	     return instruction.  */
+	  else if (condjump_p (jump))
+	    {
+	      rtx dest;
+	      if (simple_p)
+		dest = simple_return_rtx;
 	      else
+		dest = ret_rtx;
+	      if (! redirect_jump (jump, dest, 0))
 		{
-		  ei_next (&ei2);
+#ifdef HAVE_simple_return
+		  if (simple_p)
+		    unconverted_simple_returns = true;
+#endif
 		  continue;
 		}
 
-	      /* Fix up the CFG for the successful change we just made.  */
-	      redirect_edge_succ (e, EXIT_BLOCK_PTR);
+	      /* If this block has only one successor, it both jumps
+		 and falls through to the fallthru block, so we can't
+		 delete the edge.  */
+	      if (single_succ_p (bb))
+		continue;
 	    }
+	  else
+	    {
+#ifdef HAVE_simple_return
+	      if (simple_p)
+		unconverted_simple_returns = true;
+#endif
+	      continue;
+	    }
+
+	  /* Fix up the CFG for the successful change we just made.  */
+	  redirect_edge_succ (e, EXIT_BLOCK_PTR);
+	}
+      VEC_free (basic_block, heap, src_bbs);
 
+      if (HAVE_return)
+	{
 	  /* Emit a return insn for the exit fallthru block.  Whether
 	     this is still reachable will be determined later.  */
 
-	  emit_barrier_after (BB_END (last));
-	  emit_return_into_block (last);
-	  epilogue_end = BB_END (last);
-	  single_succ_edge (last)->flags &= ~EDGE_FALLTHRU;
+	  emit_barrier_after (BB_END (last_bb));
+	  emit_return_into_block (false, last_bb);
+	  epilogue_end = BB_END (last_bb);
+	  if (JUMP_P (epilogue_end))
+	    JUMP_LABEL (epilogue_end) = ret_rtx;
+	  single_succ_edge (last_bb)->flags &= ~EDGE_FALLTHRU;
 	  goto epilogue_done;
 	}
     }
@@ -5493,13 +5962,10 @@
     }
 #endif
 
-  /* Find the edge that falls through to EXIT.  Other edges may exist
-     due to RETURN instructions, but those don't need epilogues.
-     There really shouldn't be a mixture -- either all should have
-     been converted or none, however...  */
+  /* If nothing falls through into the exit block, we don't need an
+     epilogue.  */
 
-  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);
-  if (e == NULL)
+  if (exit_fallthru_edge == NULL)
     goto epilogue_done;
 
 #ifdef HAVE_epilogue
@@ -5516,25 +5982,38 @@
       set_insn_locators (seq, epilogue_locator);
 
       seq = get_insns ();
+      returnjump = get_last_insn ();
       end_sequence ();
 
-      insert_insn_on_edge (seq, e);
+      insert_insn_on_edge (seq, exit_fallthru_edge);
       inserted = true;
+      if (JUMP_P (returnjump))
+	{
+	  rtx pat = PATTERN (returnjump);
+	  if (GET_CODE (pat) == PARALLEL)
+	    pat = XVECEXP (pat, 0, 0);
+	  if (ANY_RETURN_P (pat))
+	    JUMP_LABEL (returnjump) = pat;
+	  else
+	    JUMP_LABEL (returnjump) = ret_rtx;
+	}
+      else
+	returnjump = NULL_RTX;
     }
   else
 #endif
     {
       basic_block cur_bb;
 
-      if (! next_active_insn (BB_END (e->src)))
+      if (! next_active_insn (BB_END (exit_fallthru_edge->src)))
 	goto epilogue_done;
       /* We have a fall-through edge to the exit block, the source is not
          at the end of the function, and there will be an assembler epilogue
          at the end of the function.
          We can't use force_nonfallthru here, because that would try to
-         use return.  Inserting a jump 'by hand' is extremely messy, so
+	 use return.  Inserting a jump 'by hand' is extremely messy, so
 	 we take advantage of cfg_layout_finalize using
-	fixup_fallthru_exit_predecessor.  */
+	 fixup_fallthru_exit_predecessor.  */
       cfg_layout_initialize (0);
       FOR_EACH_BB (cur_bb)
 	if (cur_bb->index >= NUM_FIXED_BLOCKS
@@ -5543,6 +6022,7 @@
       cfg_layout_finalize ();
     }
 epilogue_done:
+
   default_rtl_profile ();
 
   if (inserted)
@@ -5559,33 +6039,93 @@
 	}
     }
 
+#ifdef HAVE_simple_return
+  /* If there were branches to an empty LAST_BB which we tried to
+     convert to conditional simple_returns, but couldn't for some
+     reason, create a block to hold a simple_return insn and redirect
+     those remaining edges.  */
+  if (unconverted_simple_returns)
+    {
+      edge_iterator ei2;
+      basic_block exit_pred = EXIT_BLOCK_PTR->prev_bb;
+
+      gcc_assert (entry_edge != orig_entry_edge);
+
+#ifdef HAVE_epilogue
+      if (simple_return_block == NULL && returnjump != NULL_RTX
+	  && JUMP_LABEL (returnjump) == simple_return_rtx)
+	{
+	  edge e = split_block (exit_fallthru_edge->src,
+				PREV_INSN (returnjump));
+	  simple_return_block = e->dest;
+	}
+#endif
+      if (simple_return_block == NULL)
+	{
+	  basic_block bb;
+	  rtx start;
+
+	  bb = create_basic_block (NULL, NULL, exit_pred);
+	  start = emit_jump_insn_after (gen_simple_return (),
+					BB_END (bb));
+	  JUMP_LABEL (start) = simple_return_rtx;
+	  emit_barrier_after (start);
+
+	  simple_return_block = bb;
+	  make_edge (bb, EXIT_BLOCK_PTR, 0);
+	}
+
+    restart_scan:
+      for (ei2 = ei_start (last_bb->preds); (e = ei_safe_edge (ei2)); )
+	{
+	  basic_block bb = e->src;
+
+	  if (bb != ENTRY_BLOCK_PTR
+	      && !bitmap_bit_p (&bb_flags, bb->index))
+	    {
+	      redirect_edge_and_branch_force (e, simple_return_block);
+	      goto restart_scan;
+	    }
+	  ei_next (&ei2);
+
+	}
+    }
+#endif
+
 #ifdef HAVE_sibcall_epilogue
   /* Emit sibling epilogues before any sibling call sites.  */
   for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )
     {
       basic_block bb = e->src;
       rtx insn = BB_END (bb);
+      rtx ep_seq;
 
       if (!CALL_P (insn)
-	  || ! SIBLING_CALL_P (insn))
+	  || ! SIBLING_CALL_P (insn)
+	  || (entry_edge != orig_entry_edge
+	      && !bitmap_bit_p (&bb_flags, bb->index)))
 	{
 	  ei_next (&ei);
 	  continue;
 	}
 
-      start_sequence ();
-      emit_note (NOTE_INSN_EPILOGUE_BEG);
-      emit_insn (gen_sibcall_epilogue ());
-      seq = get_insns ();
-      end_sequence ();
+      ep_seq = gen_sibcall_epilogue ();
+      if (ep_seq)
+	{
+	  start_sequence ();
+	  emit_note (NOTE_INSN_EPILOGUE_BEG);
+	  emit_insn (ep_seq);
+	  seq = get_insns ();
+	  end_sequence ();
 
-      /* Retain a map of the epilogue insns.  Used in life analysis to
-	 avoid getting rid of sibcall epilogue insns.  Do this before we
-	 actually emit the sequence.  */
-      record_insns (seq, NULL, &epilogue_insn_hash);
-      set_insn_locators (seq, epilogue_locator);
+	  /* Retain a map of the epilogue insns.  Used in life analysis to
+	     avoid getting rid of sibcall epilogue insns.  Do this before we
+	     actually emit the sequence.  */
+	  record_insns (seq, NULL, &epilogue_insn_hash);
+	  set_insn_locators (seq, epilogue_locator);
 
-      emit_insn_before (seq, insn);
+	  emit_insn_before (seq, insn);
+	}
       ei_next (&ei);
     }
 #endif
@@ -5610,6 +6150,8 @@
     }
 #endif
 
+  bitmap_clear (&bb_flags);
+
   /* Threading the prologue and epilogue changes the artificial refs
      in the entry and exit blocks.  */
   epilogue_completed = 1;
@@ -5731,6 +6273,57 @@
     return "<none>";
   return lang_hooks.decl_printable_name (cfun->decl, 2);
 }
+
+/* This function adjusts alignments as appropriate according to the
+   setting of -falign-arrays.  If that is specified then the minimum
+   alignment for array variables is set to be the largest power of two
+   less than or equal to their total storage size, or the biggest
+   alignment used on the machine, whichever is smaller.  */
+
+unsigned int
+alignment_for_aligned_arrays (tree ty, unsigned int existing_alignment)
+{
+  unsigned int min_alignment;
+  tree size;
+
+  /* Return the existing alignment if not using -falign-arrays or if
+     the type is not an array type.  */
+  if (!flag_align_arrays || !ty || TREE_CODE (ty) != ARRAY_TYPE)
+    return existing_alignment;
+
+  /* Extract the total storage size of the array in bits.  */
+  size = TYPE_SIZE (ty);
+  gcc_assert (size);
+
+  /* At least for variable-length arrays, TREE_CODE (size) might not be an
+     integer constant; check it now.  If it is not, give the array at
+     least BIGGEST_ALIGNMENT just to be safe.   Furthermore, we assume that
+     alignments always fit into a host integer.  So if we can't fit the
+     size of the array in bits into a host integer, it must also be large
+     enough to deserve at least BIGGEST_ALIGNMENT (see below).  */
+  if (TREE_CODE (size) != INTEGER_CST || !host_integerp (size, 1))
+    min_alignment = BIGGEST_ALIGNMENT;
+  else
+    {
+      unsigned HOST_WIDE_INT bits = TREE_INT_CST_LOW (size);
+      bits = (bits ? bits : 1);
+
+      /* An array with size greater than BIGGEST_ALIGNMENT is assigned
+	 at least that alignment.  In all other cases the minimum
+	 alignment of the array is set to be the largest power of two
+	 less than or equal to the total storage size of the array.
+	 We assume that BIGGEST_ALIGNMENT fits in "unsigned int"; thus,
+	 the shift below will not overflow.  */
+      if (bits >= BIGGEST_ALIGNMENT)
+	min_alignment = BIGGEST_ALIGNMENT;
+      else
+	min_alignment = 1 << (floor_log2 (bits));
+    }
+
+  /* Having computed the minimum permissible alignment, enlarge it
+     if EXISTING_ALIGNMENT is greater.  */
+  return MAX (min_alignment, existing_alignment); 
+}
 
 
 static unsigned int
diff -ru ./gcc/function.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/function.h
--- ./gcc/function.h	2014-06-06 11:50:17.355598670 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/function.h	2012-03-29 18:03:19.000000000 +1000
@@ -755,6 +755,8 @@
 
 extern int get_next_funcdef_no (void);
 
+extern unsigned int alignment_for_aligned_arrays (tree, unsigned int);
+
 /* In predict.c */
 extern bool optimize_function_for_size_p (struct function *);
 extern bool optimize_function_for_speed_p (struct function *);
diff -ru ./gcc/gcc.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/gcc.c
--- ./gcc/gcc.c	2014-06-06 14:25:27.506150553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/gcc.c	2012-03-29 18:03:19.000000000 +1000
@@ -44,6 +44,13 @@
 #include "flags.h"
 #include "opts.h"
 #include "vec.h"
+#ifdef CSL_LICENSE_FEATURE
+#  include <csl/license.h>
+#else
+   /* TARGET_FLEXLM requires the CodeSourcery license library be
+      present.  */
+#  undef TARGET_FLEXLM
+#endif
 
 /* By default there is no special suffix for target executables.  */
 /* FIXME: when autoconf is fixed, remove the host check - dj */
@@ -144,6 +151,28 @@
 static char *save_temps_prefix = 0;
 static size_t save_temps_length = 0;
 
+/* Nonzero means that libgcc is being linked automatically by the
+   compiler from its normal installed location; that is, neither -B,
+   -nostdlib nor -nodefaultlibs was passed.  */
+
+static int using_libgcc = 1;
+
+/* Nonzero means that the current spec is executing the linker.  */
+
+static int executing_linker = 0;
+
+#ifdef CSL_LICENSE_FEATURE
+/* 0 if we have not checked for a license, 1 if a license was
+   obtained, -1 if license checkout failed.  */
+   
+static int license_checked = 0;
+
+# ifndef TARGET_FLEXLM
+#  undef license_me_flag
+#  define license_me_flag 1
+# endif /* defined (TARGET_FLELM) */
+#endif /* defined (CSL_LICENSE_FEATURE) */
+
 /* The compiler version.  */
 
 static const char *compiler_version;
@@ -659,6 +688,8 @@
     %{flto} %{flto=*} %l " LINK_PIE_SPEC \
    "%X %{o*} %{e*} %{N} %{n} %{r}\
     %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}}\
+    %{Wno-poison-system-directories:--no-poison-system-directories}\
+    %{Werror=poison-system-directories:--error-poison-system-directories}\
     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
     %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\
     %(mflib) " STACK_SPLIT_SPEC "\
@@ -2455,6 +2486,29 @@
 
   gcc_assert (!processing_spec_function);
 
+  if (executing_linker && using_libgcc)
+    {
+      const char *libgcc_a_filename;
+
+      /* Verify that the multilib being used is actually installed.  */
+      libgcc_a_filename = (gcc_exec_prefix
+			   ? gcc_exec_prefix
+			   : concat (standard_exec_prefix,
+				     machine_suffix, NULL));
+      if (multilib_dir && strcmp (multilib_dir, ".") != 0)
+	libgcc_a_filename = concat (libgcc_a_filename, multilib_dir,
+				    dir_separator_str, NULL);
+      libgcc_a_filename = concat (libgcc_a_filename, "libgcc.a", NULL);
+      if (access (libgcc_a_filename, R_OK) != 0)
+	{
+	  if (errno == ENOENT)
+	    fatal_error ("selected multilib %qs not installed",
+			 multilib_dir ? multilib_dir : ".");
+	  else
+	    pfatal_with_name (libgcc_a_filename);
+	}
+    }
+
   if (wrapper_string)
     {
       string = find_a_file (&exec_prefixes,
@@ -3410,6 +3464,23 @@
       do_save = false;
       break;
 
+#ifdef TARGET_FLEXLM
+    case OPT_flicense_me:
+    case OPT_ffeature_proxy:
+    case OPT_fno_feature_proxy:
+      /* These variables are all set automatically via common.opt.  */
+      do_save = false;
+      break;
+
+      /* WRS LOCAL only invoke get_feature if we are running the
+	 compiler proper.  */
+    case OPT_E:
+    case OPT_M:
+    case OPT_MM:
+      license_checked = 1;
+      break;
+#endif
+
     case OPT_B:
       {
 	size_t len = strlen (arg);
@@ -3438,6 +3509,7 @@
 	add_prefix (&include_prefixes, arg, NULL,
 		    PREFIX_PRIORITY_B_OPT, 0, 0);
       }
+      using_libgcc = 0;
       validated = true;
       break;
 
@@ -3475,6 +3547,11 @@
       validated = true;
       break;
 
+    case OPT_nodefaultlibs:
+    case OPT_nostdlib:
+      using_libgcc = 0;
+      break;
+
     default:
       /* Various driver options need no special processing at this
 	 point, having been handled in a prescan above or being
@@ -6104,6 +6181,10 @@
   char **old_argv = argv;
   struct cl_decoded_option *decoded_options;
   unsigned int decoded_options_count;
+#ifdef CSL_LICENSE_FEATURE
+  csl_license_impl *license_impl = csl_license_subproc;
+  csl_license *license = NULL;
+#endif
 
   /* Initialize here, not in definition.  The IRIX 6 O32 cc sometimes chokes
      on ?: in file-scope variable initializations.  */
@@ -6709,7 +6790,59 @@
 		  debug_check_temp_file[1] = NULL;
 		}
 
-	      value = do_spec (input_file_compiler->spec);
+	      value = 0;
+	      
+#ifdef CSL_LICENSE_FEATURE
+	      if (!license_checked)
+		{
+		  const char *subproc, *found_subproc;
+# ifdef TARGET_FLEXLM
+		  const char *subproc_argv[10];
+		  const char **p;
+		  subproc = "get_feature";
+		  p = subproc_argv;
+		  *p++ = subproc;
+		  if (feature_proxy_flag)
+		    *p++ = "-p";
+		  *p++ = "-co";
+		  *p++ = xstrdup (DEFAULT_TARGET_MACHINE);
+		  *p++ = "-v";
+		  *p++ = "3.3";
+		  *p++ = "gnu";
+		  *p++ = infiles[i].language;
+		  *p++ = (license_me_flag ? "-flicense-me" : "");
+		  *p++ = 0;
+# else /* !defined (TARGET_FLEXLM) */
+		  const char **subproc_argv = NULL;
+		  subproc = CSL_LICENSE_PROG;
+# endif /* !defined (TARGET_FLEXLM) */
+		  /* Find the licensing program.  */
+		  found_subproc = find_a_file (&exec_prefixes,
+					       subproc,
+					       X_OK,
+					       /*multilib=*/false);
+		  if (found_subproc)
+		    subproc = found_subproc;
+		  /* Begin checking out the license.  */
+		  license
+		    = csl_subproc_license_new (CSL_LICENSE_FEATURE,
+					       CSL_LICENSE_VERSION,
+					       /*argcp=*/NULL,
+					       /*argvp=*/NULL,
+					       subproc,
+					       subproc_argv);
+		  if (!license)
+		    {
+		      error ("could not invoke license program");
+		      license_checked = -1;
+		    }
+		}
+	      if (license_checked == -1 && license_me_flag)
+		value = -1;
+#endif /* defined (CSL_LICENSE_FEATURE) */
+	      /* Now do the compile.  */
+	      if (!value)
+		value = do_spec (input_file_compiler->spec);
 	      infiles[i].compiled = true;
 	      if (value < 0)
 		this_file_error = 1;
@@ -6746,6 +6879,28 @@
 		  if (compare_files (debug_check_temp_file))
 		    this_file_error = 1;
 		}
+#ifdef CSL_LICENSE_FEATURE
+	      if (!license_checked && license)
+		{
+		  /* Finish checking out the license.  */
+		  const csl_license_status *license_status;
+		  if (!license_impl->license_check (license,
+						    &license_status))
+		    {
+		      if (license_me_flag) /* WRS LOCAL */
+			error ("%s", license_status->msg);
+		      /* Remember that the license check failed so
+			 that we (a) do not check again, and (b) issue
+			 errors about other files as well.  */
+		      license_checked = -1;
+		      if (license_me_flag) /* WRS LOCAL */
+			/* Remove this file.  */
+			this_file_error = 1;
+		    }
+		  else
+		    license_checked = 1;
+		}
+#endif /* defined (CSL_LICENSE_FEATURE) */
 
 	      if (compare_debug)
 		{
@@ -6857,7 +7012,9 @@
 		    " to the linker.\n\n"));
 	  fflush (stdout);
 	}
+      executing_linker = 1;
       value = do_spec (link_command_spec);
+      executing_linker = 0;
       if (value < 0)
 	errorcount = 1;
       linker_was_run = (tmp != execution_count);
@@ -6885,6 +7042,12 @@
       printf ("%s\n", bug_report_url);
     }
 
+#ifdef CSL_LICENSE_FEATURE
+  /* Relinquish the license.  */
+  if (license)
+    license_impl->license_delete (license);
+#endif
+
  out:
   return (signal_count != 0 ? 2
 	  : seen_error () ? (pass_exit_codes ? greatest_status : 1)
diff -ru ./gcc/genautomata.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/genautomata.c
--- ./gcc/genautomata.c	2014-06-06 11:50:17.383598671 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/genautomata.c	2012-03-29 18:03:19.000000000 +1000
@@ -9131,44 +9131,43 @@
   return file_name + directory_name_length + 1;
 }
 
+/* A function passed as argument to init_rtx_reader_args_cb.  It parses the
+   options available for genautomata.  Returns true if the option was
+   recognized.  */
+static bool
+parse_automata_opt (const char *str)
+{
+  if (strcmp (str, NO_MINIMIZATION_OPTION) == 0)
+    no_minimization_flag = 1;
+  else if (strcmp (str, TIME_OPTION) == 0)
+    time_flag = 1;
+  else if (strcmp (str, STATS_OPTION) == 0)
+    stats_flag = 1;
+  else if (strcmp (str, V_OPTION) == 0)
+    v_flag = 1;
+  else if (strcmp (str, W_OPTION) == 0)
+    w_flag = 1;
+  else if (strcmp (str, NDFA_OPTION) == 0)
+    ndfa_flag = 1;
+  else if (strcmp (str, PROGRESS_OPTION) == 0)
+    progress_flag = 1;
+  else if (strcmp (str, "-split") == 0)
+    {
+      fatal ("option `-split' has not been implemented yet\n");
+      /* split_argument = atoi (argument_vect [i + 1]); */
+    }
+  else
+    return false;
+
+  return true;
+}
+
 /* The following is top level function to initialize the work of
    pipeline hazards description translator.  */
 static void
 initiate_automaton_gen (int argc, char **argv)
 {
   const char *base_name;
-  int i;
-
-  ndfa_flag = 0;
-  split_argument = 0;  /* default value */
-  no_minimization_flag = 0;
-  time_flag = 0;
-  stats_flag = 0;
-  v_flag = 0;
-  w_flag = 0;
-  progress_flag = 0;
-  for (i = 2; i < argc; i++)
-    if (strcmp (argv [i], NO_MINIMIZATION_OPTION) == 0)
-      no_minimization_flag = 1;
-    else if (strcmp (argv [i], TIME_OPTION) == 0)
-      time_flag = 1;
-    else if (strcmp (argv [i], STATS_OPTION) == 0)
-      stats_flag = 1;
-    else if (strcmp (argv [i], V_OPTION) == 0)
-      v_flag = 1;
-    else if (strcmp (argv [i], W_OPTION) == 0)
-      w_flag = 1;
-    else if (strcmp (argv [i], NDFA_OPTION) == 0)
-      ndfa_flag = 1;
-    else if (strcmp (argv [i], PROGRESS_OPTION) == 0)
-      progress_flag = 1;
-    else if (strcmp (argv [i], "-split") == 0)
-      {
-	if (i + 1 >= argc)
-	  fatal ("-split has no argument.");
-	fatal ("option `-split' has not been implemented yet\n");
-	/* split_argument = atoi (argument_vect [i + 1]); */
-      }
 
   /* Initialize IR storage.  */
   obstack_init (&irp);
@@ -9462,7 +9461,7 @@
 
   progname = "genautomata";
 
-  if (!init_rtx_reader_args (argc, argv))
+  if (!init_rtx_reader_args_cb (argc, argv, parse_automata_opt))
     return (FATAL_EXIT_CODE);
 
   initiate_automaton_gen (argc, argv);
diff -ru ./gcc/genemit.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/genemit.c
--- ./gcc/genemit.c	2014-06-06 11:50:17.383598671 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/genemit.c	2012-03-29 18:03:19.000000000 +1000
@@ -223,6 +223,12 @@
     case PC:
       printf ("pc_rtx");
       return;
+    case RETURN:
+      printf ("ret_rtx");
+      return;
+    case SIMPLE_RETURN:
+      printf ("simple_return_rtx");
+      return;
     case CLOBBER:
       if (REG_P (XEXP (x, 0)))
 	{
@@ -546,8 +552,8 @@
 	  || (GET_CODE (next) == PARALLEL
 	      && ((GET_CODE (XVECEXP (next, 0, 0)) == SET
 		   && GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)
-		  || GET_CODE (XVECEXP (next, 0, 0)) == RETURN))
-	  || GET_CODE (next) == RETURN)
+		  || ANY_RETURN_P (XVECEXP (next, 0, 0))))
+	  || ANY_RETURN_P (next))
 	printf ("  emit_jump_insn (");
       else if ((GET_CODE (next) == SET && GET_CODE (SET_SRC (next)) == CALL)
 	       || GET_CODE (next) == CALL
@@ -665,7 +671,7 @@
 	  || (GET_CODE (next) == PARALLEL
 	      && GET_CODE (XVECEXP (next, 0, 0)) == SET
 	      && GET_CODE (SET_DEST (XVECEXP (next, 0, 0))) == PC)
-	  || GET_CODE (next) == RETURN)
+	  || ANY_RETURN_P (next))
 	printf ("  emit_jump_insn (");
       else if ((GET_CODE (next) == SET && GET_CODE (SET_SRC (next)) == CALL)
 	       || GET_CODE (next) == CALL
diff -ru ./gcc/gengenrtl.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/gengenrtl.c
--- ./gcc/gengenrtl.c	2014-06-06 11:50:17.383598671 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/gengenrtl.c	2012-03-29 18:03:19.000000000 +1000
@@ -128,6 +128,10 @@
 	  || strcmp (defs[idx].enumname, "REG") == 0
 	  || strcmp (defs[idx].enumname, "SUBREG") == 0
 	  || strcmp (defs[idx].enumname, "MEM") == 0
+	  || strcmp (defs[idx].enumname, "PC") == 0
+	  || strcmp (defs[idx].enumname, "CC0") == 0
+	  || strcmp (defs[idx].enumname, "RETURN") == 0
+	  || strcmp (defs[idx].enumname, "SIMPLE_RETURN") == 0
 	  || strcmp (defs[idx].enumname, "CONST_VECTOR") == 0);
 }
 
diff -ru ./gcc/genmultilib /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/genmultilib
--- ./gcc/genmultilib	2014-06-06 14:25:27.510150553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/genmultilib	2012-03-29 18:03:19.000000000 +1000
@@ -73,6 +73,20 @@
 # the os directory names are used exclusively.  Use the mapping when
 # there is no one-to-one equivalence between GCC levels and the OS.
 
+# The optional eighth option is a list of multilib aliases.  This takes the
+# same form as the third argument.  It specifies that the second multilib is
+# a synonym for the first.  This allows a suitable multilib to be selected
+# for all option combinations while only building a subset of all possible
+# multilibs.
+# For example:
+#   genmultilib "mbig-endian mthumb" "eb thumb" "" "" "" "" "" \
+#		"mbig-endian=mbig-endian/mthumb" yes
+# This produces:
+#   ". !mbig-endian !mthumb;",
+#   "be mbig-endian !mthumb;",
+#   "be mbig-endian mthumb;",
+#   "thumb !mbig-endian mthumb;",
+
 # The last option should be "yes" if multilibs are enabled.  If it is not
 # "yes", all GCC multilib dir names will be ".".
 
@@ -121,7 +135,8 @@
 extra=$5
 exclusions=$6
 osdirnames=$7
-enable_multilib=$8
+aliases=$8
+enable_multilib=$9
 
 echo "static const char *const multilib_raw[] = {"
 
@@ -129,6 +144,23 @@
 # Use cd ./foo to avoid CDPATH output.
 cd ./tmpmultilib.$$ || exit 1
 
+# Handle aliases
+cat >tmpmultilib3 <<\EOF
+#!/bin/sh
+# Output a list of aliases (including the original name) for a multilib.
+
+echo $1
+EOF
+for a in ${aliases}; do
+  l=`echo $a | sed -e 's/=.*$//' -e 's/?/=/g'`
+  r=`echo $a | sed -e 's/^.*=//' -e 's/?/=/g'`
+  echo "[ \$1 == /$l/ ] && echo /$r/" >>tmpmultilib3
+  
+  # Also add the alias to the exclusion list
+  exceptions="${exceptions} $r"
+done
+chmod +x tmpmultilib3
+
 # What we want to do is select all combinations of the sets in
 # options.  Each combination which includes a set of mutually
 # exclusive options must then be output multiple times, once for each
@@ -195,6 +227,21 @@
   combinations=`./tmpmultilib2 ${combinations}`
 fi
 
+# Check that all the aliases actually exist
+for a in ${aliases}; do
+  l=`echo $a | sed -e 's/=.*$//' -e 's/?/=/g'`
+  for c in ${combinations}; do
+    if [ "/$l/" = "$c" ]; then
+      l=""
+      break;
+    fi
+  done
+  if [ -n "$l" ] ;then
+    echo "Missing multilib $l for alias $a" 1>&2
+    exit 1
+  fi
+done
+
 # Construct a sed pattern which will convert option names to directory
 # names.
 todirnames=
@@ -343,23 +390,25 @@
     fi
   fi
 
-  # Look through the options.  We must output each option that is
-  # present, and negate each option that is not present.
-  optout=
-  for set in ${options}; do
-    setopts=`echo ${set} | sed -e 's_[/|]_ _g'`
-    for opt in ${setopts}; do
-      if expr "${combo} " : ".*/${opt}/.*" > /dev/null; then
-	optout="${optout} ${opt}"
-      else
-	optout="${optout} !${opt}"
-      fi
+  for optcombo in `./tmpmultilib3 ${combo}`; do
+    # Look through the options.  We must output each option that is
+    # present, and negate each option that is not present.
+    optout=
+    for set in ${options}; do
+      setopts=`echo ${set} | sed -e 's_[/|]_ _g'`
+      for opt in ${setopts}; do
+	if expr "${optcombo} " : ".*/${opt}/.*" > /dev/null; then
+	  optout="${optout} ${opt}"
+	else
+	  optout="${optout} !${opt}"
+	fi
+      done
     done
-  done
-  optout=`echo ${optout} | sed -e 's/^ //'`
+    optout=`echo ${optout} | sed -e 's/^ //'`
 
-  # Output the line with all appropriate matches.
-  dirout="${dirout}" optout="${optout}" ./tmpmultilib2
+    # Output the line with all appropriate matches.
+    dirout="${dirout}" optout="${optout}" ./tmpmultilib2
+  done
 done
 
 # Terminate the list of string.
diff -ru ./gcc/gimplify.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/gimplify.c
--- ./gcc/gimplify.c	2014-06-06 14:25:27.514150553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/gimplify.c	2012-03-29 18:03:19.000000000 +1000
@@ -1117,6 +1117,62 @@
 			    1, tmp_var);
 }
 
+/* Returns the function decl that corresponds the function called in
+   CALL_EXPR if FLAG_INSTRUMENT_CALL_ENTRY_EXIT is enabled.  */
+
+static tree
+fndecl_for_call_instrumentation (tree call_expr)
+{
+  tree fndecl = NULL_TREE;
+
+  if (flag_instrument_call_entry_exit && !gimplify_ctxp->into_ssa)
+    {
+      fndecl = get_callee_fndecl (call_expr);
+      if (is_inexpensive_builtin (fndecl))
+	  fndecl = NULL_TREE;
+    }
+
+  return fndecl;
+}
+
+/* Prepare call to PROFILE_CALL_* builtin (specified by CODE) for
+   function with decl FNDECL and add it to the sequence of GIMPLE
+   statements in PRE_P.  */
+
+static void
+maybe_add_profile_call (tree fndecl, enum built_in_function code,
+			gimple_seq *pre_p)
+{
+  if (fndecl)
+    {
+      tree x = implicit_built_in_decls[code];
+      gimple call = gimple_build_call (x, 1, build_fold_addr_expr (fndecl));
+      gimplify_seq_add_stmt (pre_p, call);
+    }
+}
+
+/* Replace existing body of function with decl FNDECL with the sequence
+   of GIMPLE statements in BODY and return the new sequence of the
+   function body.  */
+
+static gimple_seq
+replace_body_for_instrumentation (tree fndecl, gimple *bind, gimple_seq body)
+{
+  gimple_seq seq;
+  gimple old_bind = *bind;
+  *bind = gimple_build_bind (NULL, body, gimple_bind_block (old_bind));
+  /* Clear the block for OLD_BIND, since it is no longer directly inside
+     the function, but within the new block.  */
+  gimple_bind_set_block (old_bind, NULL);
+
+  /* Replace the current function body with the new one.  */
+  seq = gimple_seq_alloc ();
+  gimple_seq_add_stmt (&seq, *bind);
+  gimple_set_body (fndecl, seq);
+
+  return seq;
+}
+
 /* Gimplify a BIND_EXPR.  Just voidify and recurse.  */
 
 static enum gimplify_status
@@ -2491,6 +2547,10 @@
      gimplify_modify_expr.  */
   if (!want_value)
     {
+      tree fndecl = fndecl_for_call_instrumentation (*expr_p);
+
+      maybe_add_profile_call (fndecl, BUILT_IN_PROFILE_CALL_ENTER, pre_p);
+
       /* The CALL_EXPR in *EXPR_P is already in GIMPLE form, so all we
 	 have to do is replicate it as a GIMPLE_CALL tuple.  */
       gimple_stmt_iterator gsi;
@@ -2498,6 +2558,9 @@
       gimplify_seq_add_stmt (pre_p, call);
       gsi = gsi_last (*pre_p);
       fold_stmt (&gsi);
+
+      maybe_add_profile_call (fndecl, BUILT_IN_PROFILE_CALL_EXIT, pre_p);
+
       *expr_p = NULL_TREE;
     }
 
@@ -4497,6 +4560,7 @@
   enum gimplify_status ret = GS_UNHANDLED;
   gimple assign;
   location_t loc = EXPR_LOCATION (*expr_p);
+  tree fndecl = NULL_TREE;
 
   gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR
 	      || TREE_CODE (*expr_p) == INIT_EXPR);
@@ -4611,6 +4675,8 @@
 
   if (TREE_CODE (*from_p) == CALL_EXPR)
     {
+      fndecl = fndecl_for_call_instrumentation (*from_p);
+
       /* Since the RHS is a CALL_EXPR, we need to create a GIMPLE_CALL
 	 instead of a GIMPLE_ASSIGN.  */
       assign = gimple_build_call_from_tree (*from_p);
@@ -4623,7 +4689,9 @@
       gimple_set_location (assign, EXPR_LOCATION (*expr_p));
     }
 
+  maybe_add_profile_call (fndecl, BUILT_IN_PROFILE_CALL_ENTER, pre_p);
   gimplify_seq_add_stmt (pre_p, assign);
+  maybe_add_profile_call (fndecl, BUILT_IN_PROFILE_CALL_EXIT, pre_p);
 
   if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))
     {
@@ -7875,6 +7943,16 @@
   gimple_seq_add_stmt (&seq, bind);
   gimple_set_body (fndecl, seq);
 
+  if (flag_instrument_call_entry_exit)
+    {
+      gimple_seq body = NULL;
+
+      maybe_add_profile_call (fndecl, BUILT_IN_PROFILE_CALL_INSIDE, &body);
+      gimplify_seq_add_seq (&body, seq);
+
+      seq = replace_body_for_instrumentation (fndecl, &bind, body);
+    }
+
   /* If we're instrumenting function entry/exit, then prepend the call to
      the entry hook and wrap the whole function in a TRY_FINALLY_EXPR to
      catch the exit hook.  */
@@ -7884,7 +7962,6 @@
       && !flag_instrument_functions_exclude_p (fndecl))
     {
       tree x;
-      gimple new_bind;
       gimple tf;
       gimple_seq cleanup = NULL, body = NULL;
       tree tmp_var;
@@ -7913,16 +7990,7 @@
 				tmp_var);
       gimplify_seq_add_stmt (&body, call);
       gimplify_seq_add_stmt (&body, tf);
-      new_bind = gimple_build_bind (NULL, body, gimple_bind_block (bind));
-      /* Clear the block for BIND, since it is no longer directly inside
-         the function, but within a try block.  */
-      gimple_bind_set_block (bind, NULL);
-
-      /* Replace the current function body with the body
-         wrapped in the try/finally TF.  */
-      seq = gimple_seq_alloc ();
-      gimple_seq_add_stmt (&seq, new_bind);
-      gimple_set_body (fndecl, seq);
+      seq = replace_body_for_instrumentation (fndecl, &bind, body);
     }
 
   DECL_SAVED_TREE (fndecl) = NULL_TREE;
diff -ru ./gcc/haifa-sched.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/haifa-sched.c
--- ./gcc/haifa-sched.c	2014-06-06 14:25:27.518150553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/haifa-sched.c	2012-03-29 18:03:19.000000000 +1000
@@ -129,9 +129,9 @@
 #include "coretypes.h"
 #include "tm.h"
 #include "diagnostic-core.h"
+#include "hard-reg-set.h"
 #include "rtl.h"
 #include "tm_p.h"
-#include "hard-reg-set.h"
 #include "regs.h"
 #include "function.h"
 #include "flags.h"
@@ -148,6 +148,7 @@
 #include "cfgloop.h"
 #include "ira.h"
 #include "emit-rtl.h"  /* FIXME: Can go away once crtl is moved to rtl.h.  */
+#include "hashtab.h"
 
 #ifdef INSN_SCHEDULING
 
@@ -157,6 +158,35 @@
 
 int issue_rate;
 
+/* This can be set to true by a backend if the scheduler should not
+   enable a DCE pass.  */
+bool sched_no_dce;
+
+/* The current initiation interval used when modulo scheduling.  */
+static int modulo_ii;
+
+/* The maximum number of stages we are prepared to handle.  */
+static int modulo_max_stages;
+
+/* The number of insns that exist in each iteration of the loop.  We use this
+   to detect when we've scheduled all insns from the first iteration.  */
+static int modulo_n_insns;
+
+/* The current count of insns in the first iteration of the loop that have
+   already been scheduled.  */
+static int modulo_insns_scheduled;
+
+/* The maximum uid of insns from the first iteration of the loop.  */
+static int modulo_iter0_max_uid;
+
+/* The number of times we should attempt to backtrack when modulo scheduling.
+   Decreased each time we have to backtrack.  */
+static int modulo_backtracks_left;
+
+/* The stage in which the last insn from the original loop was
+   scheduled.  */
+static int modulo_last_stage;
+
 /* sched-verbose controls the amount of debugging output the
    scheduler prints.  It is controlled by -fsched-verbose=N:
    N>0 and no -DSR : the output is directed to stderr.
@@ -177,7 +207,12 @@
 struct common_sched_info_def *common_sched_info;
 
 #define INSN_TICK(INSN)	(HID (INSN)->tick)
+#define INSN_EXACT_TICK(INSN) (HID (INSN)->exact_tick)
+#define INSN_TICK_ESTIMATE(INSN) (HID (INSN)->tick_estimate)
 #define INTER_TICK(INSN) (HID (INSN)->inter_tick)
+#define FEEDS_BACKTRACK_INSN(INSN) (HID (INSN)->feeds_backtrack_insn)
+#define SHADOW_P(INSN) (HID (INSN)->shadow_p)
+#define MUST_RECOMPUTE_SPEC_P(INSN) (HID (INSN)->must_recompute_spec)
 
 /* If INSN_TICK of an instruction is equal to INVALID_TICK,
    then it should be recalculated from scratch.  */
@@ -302,6 +337,22 @@
 /* Scheduling clock.  */
 static int clock_var;
 
+/* Clock at which the previous instruction was issued.  */
+static int last_clock_var;
+
+/* Set to true if, when queuing a shadow insn, we discover that it would be
+   scheduled too late.  */
+static bool must_backtrack;
+
+/* The following variable value is number of essential insns issued on
+   the current cycle.  An insn is essential one if it changes the
+   processors state.  */
+int cycle_issued_insns;
+
+/* This records the actual schedule.  It is built up during the main phase
+   of schedule_block, and afterwards used to reorder the insns in the RTL.  */
+static VEC(rtx, heap) *scheduled_insns;
+
 static int may_trap_exp (const_rtx, int);
 
 /* Nonzero iff the address is comprised from at most 1 register.  */
@@ -483,13 +534,267 @@
 {
   return haifa_classify_rtx (PATTERN (insn));
 }
+
+/* After the scheduler initialization function has been called, this function
+   can be called to enable modulo scheduling.  II is the initiation interval
+   we should use, it affects the delays for delay_pairs that were recorded as
+   separated by a given number of stages.
+
+   MAX_STAGES provides us with a limit
+   after which we give up scheduling; the caller must have unrolled at least
+   as many copies of the loop body and recorded delay_pairs for them.
+   
+   INSNS is the number of real (non-debug) insns in one iteration of
+   the loop.  MAX_UID can be used to test whether an insn belongs to
+   the first iteration of the loop; all of them have a uid lower than
+   MAX_UID.  */
+void
+set_modulo_params (int ii, int max_stages, int insns, int max_uid)
+{
+  modulo_ii = ii;
+  modulo_max_stages = max_stages;
+  modulo_n_insns = insns;
+  modulo_iter0_max_uid = max_uid;
+  modulo_backtracks_left = PARAM_VALUE (PARAM_MAX_MODULO_BACKTRACK_ATTEMPTS);
+}
+
+/* A structure to record a pair of insns where the first one is a real
+   insn that has delay slots, and the second is its delayed shadow.
+   I1 is scheduled normally and will emit an assembly instruction,
+   while I2 describes the side effect that takes place at the
+   transition between cycles CYCLES and (CYCLES + 1) after I1.  */
+struct delay_pair
+{
+  struct delay_pair *next_same_i1;
+  rtx i1, i2;
+  int cycles;
+  /* When doing modulo scheduling, we a delay_pair can also be used to
+     show that I1 and I2 are the same insn in a different stage.  If that
+     is the case, STAGES will be nonzero.  */
+  int stages;
+};
+
+/* Two hash tables to record delay_pairs, one indexed by I1 and the other
+   indexed by I2.  */
+static htab_t delay_htab;
+static htab_t delay_htab_i2;
+
+/* Called through htab_traverse.  Walk the hashtable using I2 as
+   index, and delete all elements involving an UID higher than
+   that pointed to by *DATA.  */
+static int
+htab_i2_traverse (void **slot, void *data)
+{
+  int maxuid = *(int *)data;
+  struct delay_pair *p = *(struct delay_pair **)slot;
+  if (INSN_UID (p->i2) >= maxuid || INSN_UID (p->i1) >= maxuid)
+    {
+      htab_clear_slot (delay_htab_i2, slot);
+    }
+  return 1;
+}
+
+/* Called through htab_traverse.  Walk the hashtable using I2 as
+   index, and delete all elements involving an UID higher than
+   that pointed to by *DATA.  */
+static int
+htab_i1_traverse (void **slot, void *data)
+{
+  int maxuid = *(int *)data;
+  struct delay_pair **pslot = (struct delay_pair **)slot;
+  struct delay_pair *p, *first, **pprev;
+
+  if (INSN_UID ((*pslot)->i1) >= maxuid)
+    {
+      htab_clear_slot (delay_htab, slot);
+      return 1;
+    }
+  pprev = &first;
+  for (p = *pslot; p; p = p->next_same_i1)
+    {
+      if (INSN_UID (p->i2) < maxuid)
+	{
+	  *pprev = p;
+	  pprev = &p->next_same_i1;
+	}
+    }
+  *pprev = NULL;
+  if (first == NULL)
+    htab_clear_slot (delay_htab, slot);
+  else
+    *pslot = first;
+  return 1;
+}
+
+/* Discard all delay pairs which involve an insn with an UID higher
+   than MAX_UID.  */
+void
+discard_delay_pairs_above (int max_uid)
+{
+  htab_traverse (delay_htab, htab_i1_traverse, &max_uid);
+  htab_traverse (delay_htab_i2, htab_i2_traverse, &max_uid);
+}
+
+/* Returns a hash value for X (which really is a delay_pair), based on
+   hashing just I1.  */
+static hashval_t
+delay_hash_i1 (const void *x)
+{
+  return htab_hash_pointer (((const struct delay_pair *) x)->i1);
+}
+
+/* Returns a hash value for X (which really is a delay_pair), based on
+   hashing just I2.  */
+static hashval_t
+delay_hash_i2 (const void *x)
+{
+  return htab_hash_pointer (((const struct delay_pair *) x)->i2);
+}
+
+/* Return nonzero if I1 of pair X is the same as that of pair Y.  */
+static int
+delay_i1_eq (const void *x, const void *y)
+{
+  return ((const struct delay_pair *) x)->i1 == y;
+}
+
+/* Return nonzero if I2 of pair X is the same as that of pair Y.  */
+static int
+delay_i2_eq (const void *x, const void *y)
+{
+  return ((const struct delay_pair *) x)->i2 == y;
+}
+
+/* This function can be called by a port just before it starts the final
+   scheduling pass.  It records the fact that an instruction with delay
+   slots has been split into two insns, I1 and I2.  The first one will be
+   scheduled normally and initiates the operation.  The second one is a
+   shadow which must follow a specific number of cycles after I1; its only
+   purpose is to show the side effect that occurs at that cycle in the RTL.
+   If a JUMP_INSN or a CALL_INSN has been split, I1 should be a normal INSN,
+   while I2 retains the original insn type.
+
+   There are two ways in which the number of cycles can be specified,
+   involving the CYCLES and STAGES arguments to this function.  If STAGES
+   is zero, we just use the value of CYCLES.  Otherwise, STAGES is a factor
+   which is multiplied by MODULO_II to give the number of cycles.  This is
+   only useful if the caller also calls set_modulo_params to enable modulo
+   scheduling.  */
+
+void
+record_delay_slot_pair (rtx i1, rtx i2, int cycles, int stages)
+{
+  struct delay_pair *p = XNEW (struct delay_pair);
+  struct delay_pair **slot;
+
+  p->i1 = i1;
+  p->i2 = i2;
+  p->cycles = cycles;
+  p->stages = stages;
+
+  if (!delay_htab)
+    {
+      delay_htab = htab_create (10, delay_hash_i1, delay_i1_eq, NULL);
+      delay_htab_i2 = htab_create (10, delay_hash_i2, delay_i2_eq, free);
+    }
+  slot = ((struct delay_pair **)
+	  htab_find_slot_with_hash (delay_htab, i1, htab_hash_pointer (i1),
+				    INSERT));
+  p->next_same_i1 = *slot;
+  *slot = p;
+  slot = ((struct delay_pair **)
+	  htab_find_slot_with_hash (delay_htab_i2, i2, htab_hash_pointer (i2),
+				    INSERT));
+  *slot = p;
+}
+
+/* Examine the delay pair hashtable to see if INSN is a shadow for another,
+   and return the other insn if so.  Return NULL otherwise.  */
+rtx
+real_insn_for_shadow (rtx insn)
+{
+  struct delay_pair *pair;
+
+  if (delay_htab == NULL)
+    return NULL_RTX;
+
+  pair
+    = (struct delay_pair *)htab_find_with_hash (delay_htab_i2, insn,
+						htab_hash_pointer (insn));
+  if (!pair || pair->stages > 0)
+    return NULL_RTX;
+  return pair->i1;
+}
+
+/* For a pair P of insns, return the fixed distance in cycles from the first
+   insn after which the second must be scheduled.  */
+static int
+pair_delay (struct delay_pair *p)
+{
+  if (p->stages == 0)
+    return p->cycles;
+  else
+    return p->stages * modulo_ii;
+}
+
+/* Given an insn INSN, add a dependence on its delayed shadow if it
+   has one.  Also try to find situations where shadows depend on each other
+   and add dependencies to the real insns to limit the amount of backtracking
+   needed.  */
+void
+add_delay_dependencies (rtx insn)
+{
+  struct delay_pair *pair;
+  sd_iterator_def sd_it;
+  dep_t dep;
+
+  if (!delay_htab)
+    return;
 
+  pair
+    = (struct delay_pair *)htab_find_with_hash (delay_htab_i2, insn,
+						htab_hash_pointer (insn));
+  if (!pair)
+    return;
+  add_dependence (insn, pair->i1, REG_DEP_ANTI);
+  if (pair->stages)
+    return;
+
+  FOR_EACH_DEP (pair->i2, SD_LIST_BACK, sd_it, dep)
+    {
+      rtx pro = DEP_PRO (dep);
+      struct delay_pair *other_pair
+	= (struct delay_pair *)htab_find_with_hash (delay_htab_i2, pro,
+						    htab_hash_pointer (pro));
+      if (!other_pair || other_pair->stages)
+	continue;
+      if (pair_delay (other_pair) >= pair_delay (pair))
+	{
+	  if (sched_verbose >= 4)
+	    {
+	      fprintf (sched_dump, ";;\tadding dependence %d <- %d\n",
+		       INSN_UID (other_pair->i1),
+		       INSN_UID (pair->i1));
+	      fprintf (sched_dump, ";;\tpair1 %d <- %d, cost %d\n",
+		       INSN_UID (pair->i1),
+		       INSN_UID (pair->i2),
+		       pair_delay (pair));
+	      fprintf (sched_dump, ";;\tpair2 %d <- %d, cost %d\n",
+		       INSN_UID (other_pair->i1),
+		       INSN_UID (other_pair->i2),
+		       pair_delay (other_pair));
+	    }
+	  add_dependence (pair->i1, other_pair->i1, REG_DEP_ANTI);
+	}
+    }
+}
+
 /* Forward declarations.  */
 
 static int priority (rtx);
 static int rank_for_schedule (const void *, const void *);
 static void swap_sort (rtx *, int);
-static void queue_insn (rtx, int);
+static void queue_insn (rtx, int, const char *);
 static int schedule_insn (rtx);
 static void adjust_priority (rtx);
 static void advance_one_cycle (void);
@@ -535,6 +840,7 @@
 
 static void extend_h_i_d (void);
 static void init_h_i_d (rtx);
+static int haifa_speculate_insn (rtx, ds_t, rtx *);
 static void generate_recovery_code (rtx);
 static void process_insn_forw_deps_be_in_spec (rtx, rtx, ds_t);
 static void begin_speculative_block (rtx);
@@ -542,7 +848,7 @@
 static void init_before_recovery (basic_block *);
 static void create_check_block_twin (rtx, bool);
 static void fix_recovery_deps (basic_block);
-static void haifa_change_pattern (rtx, rtx);
+static bool haifa_change_pattern (rtx, rtx);
 static void dump_new_block_header (int, basic_block, rtx, rtx);
 static void restore_bb_notes (basic_block);
 static void fix_jump_move (rtx);
@@ -773,13 +1079,192 @@
     }
   fprintf (sched_dump, "\n");
 }
+
+/* Determine if INSN has a condition that is clobbered if a register
+   in SET_REGS is modified.  */
+static bool
+cond_clobbered_p (rtx insn, HARD_REG_SET set_regs)
+{
+  rtx pat = PATTERN (insn);
+  gcc_assert (GET_CODE (pat) == COND_EXEC);
+  if (TEST_HARD_REG_BIT (set_regs, REGNO (XEXP (COND_EXEC_TEST (pat), 0))))
+    {
+      sd_iterator_def sd_it;
+      dep_t dep;
+      haifa_change_pattern (insn, ORIG_PAT (insn));
+      FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)
+	DEP_STATUS (dep) &= ~DEP_CANCELLED;
+      TODO_SPEC (insn) = HARD_DEP;
+      if (sched_verbose >= 2)
+	fprintf (sched_dump,
+		 ";;\t\tdequeue insn %s because of clobbered condition\n",
+		 (*current_sched_info->print_insn) (insn, 0));
+      return true;
+    }
+
+  return false;
+}
+
+/* Look at the remaining dependencies for insn NEXT, and compute and return
+   the TODO_SPEC value we should use for it.  This is called after one of
+   NEXT's dependencies has been resolved.  */
+
+static ds_t
+recompute_todo_spec (rtx next)
+{
+  ds_t new_ds;
+  sd_iterator_def sd_it;
+  dep_t dep, control_dep = NULL;
+  int n_spec = 0;
+  int n_control = 0;
+  bool first_p = true;
+
+  if (sd_lists_empty_p (next, SD_LIST_BACK))
+    /* NEXT has all its dependencies resolved.  */
+    return 0;
+
+  if (!sd_lists_empty_p (next, SD_LIST_HARD_BACK))
+    return HARD_DEP;
+
+  /* Now we've got NEXT with speculative deps only.
+     1. Look at the deps to see what we have to do.
+     2. Check if we can do 'todo'.  */
+  new_ds = 0;
+
+  FOR_EACH_DEP (next, SD_LIST_BACK, sd_it, dep)
+    {
+      ds_t ds = DEP_STATUS (dep) & SPECULATIVE;
+
+      if (DEBUG_INSN_P (DEP_PRO (dep)) && !DEBUG_INSN_P (next))
+	continue;
+
+      if (ds)
+	{
+	  n_spec++;
+	  if (first_p)
+	    {
+	      first_p = false;
+
+	      new_ds = ds;
+	    }
+	  else
+	    new_ds = ds_merge (new_ds, ds);
+	}
+      if (DEP_TYPE (dep) == REG_DEP_CONTROL)
+	{
+	  n_control++;
+	  control_dep = dep;
+	  DEP_STATUS (dep) &= ~DEP_CANCELLED;
+	}
+    }
+
+  if (n_control == 1 && n_spec == 0)
+    {
+      rtx pro, other, new_pat;
+      rtx cond = NULL_RTX;
+      bool success;
+      rtx prev = NULL_RTX;
+      int i;
+      unsigned regno;
+  
+      if ((current_sched_info->flags & DO_PREDICATION) == 0
+	  || (ORIG_PAT (next) != NULL_RTX
+	      && PREDICATED_PAT (next) == NULL_RTX))
+	return HARD_DEP;
+
+      pro = DEP_PRO (control_dep);
+      other = real_insn_for_shadow (pro);
+      if (other != NULL_RTX)
+	pro = other;
+
+      cond = sched_get_reverse_condition_uncached (pro);
+      regno = REGNO (XEXP (cond, 0));
+
+      /* Find the last scheduled insn that modifies the condition register.
+	 If we have a true dependency on it, it sets it to the correct value,
+	 otherwise it must be a later insn scheduled in-between that clobbers
+	 the condition.  */
+      FOR_EACH_VEC_ELT_REVERSE (rtx, scheduled_insns, i, prev)
+	{
+	  sd_iterator_def sd_it;
+	  dep_t dep;
+	  HARD_REG_SET t;
+	  bool found;
+
+	  find_all_hard_reg_sets (prev, &t);
+	  if (!TEST_HARD_REG_BIT (t, regno))
+	    continue;
+
+	  found = false;
+	  FOR_EACH_DEP (next, SD_LIST_RES_BACK, sd_it, dep)
+	    {
+	      if (DEP_PRO (dep) == prev && DEP_TYPE (dep) == REG_DEP_TRUE)
+		{
+		  found = true;
+		  break;
+		}
+	    }
+	  if (!found)
+	    return HARD_DEP;
+	  break;
+	}
+      if (ORIG_PAT (next) == NULL_RTX)
+	{
+	  ORIG_PAT (next) = PATTERN (next);
+
+	  new_pat = gen_rtx_COND_EXEC (VOIDmode, cond, PATTERN (next));
+	  success = haifa_change_pattern (next, new_pat);
+	  if (!success)
+	    return HARD_DEP;
+	  PREDICATED_PAT (next) = new_pat;
+	}
+      else if (PATTERN (next) != PREDICATED_PAT (next))
+	{
+	  bool success = haifa_change_pattern (next,
+					       PREDICATED_PAT (next));
+	  gcc_assert (success);
+	}
+      DEP_STATUS (control_dep) |= DEP_CANCELLED;
+      return DEP_CONTROL;
+    }
 
-/* Pointer to the last instruction scheduled.  Used by rank_for_schedule,
-   so that insns independent of the last scheduled insn will be preferred
-   over dependent instructions.  */
+  if (PREDICATED_PAT (next) != NULL_RTX)
+    {
+      int tick = INSN_TICK (next);
+      bool success = haifa_change_pattern (next,
+					   ORIG_PAT (next));
+      INSN_TICK (next) = tick;
+      gcc_assert (success);
+    }
 
+  /* We can't handle the case where there are both speculative and control
+     dependencies, so we return HARD_DEP in such a case.  Also fail if
+     we have speculative dependencies with not enough points, or more than
+     one control dependency.  */
+  if ((n_spec > 0 && n_control > 0)
+      || (n_spec > 0
+	  /* Too few points?  */
+	  && ds_weak (new_ds) < spec_info->data_weakness_cutoff)
+      || (n_control > 1))
+    return HARD_DEP;
+
+  return new_ds;
+}
+
+/* Pointer to the last instruction scheduled.  */
 static rtx last_scheduled_insn;
 
+/* Pointer to the last nondebug instruction scheduled within the
+   block, or the prev_head of the scheduling block.  Used by
+   rank_for_schedule, so that insns independent of the last scheduled
+   insn will be preferred over dependent instructions.  */
+static rtx last_nondebug_scheduled_insn;
+
+/* Pointer that iterates through the list of unscheduled insns if we
+   have a dbg_cnt enabled.  It always points at an insn prior to the
+   first unscheduled one.  */
+static rtx nonscheduled_insns_begin;
+
 /* Cached cost of the instruction.  Use below function to get cost of the
    insn.  -1 here means that the field is not initialized.  */
 #define INSN_COST(INSN)	(HID (INSN)->cost)
@@ -841,6 +1326,25 @@
   rtx used = DEP_CON (link);
   int cost;
 
+  if (DEP_COST (link) != UNKNOWN_DEP_COST)
+    return DEP_COST (link);
+
+  if (delay_htab)
+    {
+      struct delay_pair *delay_entry;
+      delay_entry
+	= (struct delay_pair *)htab_find_with_hash (delay_htab_i2, used,
+						    htab_hash_pointer (used));
+      if (delay_entry)
+	{
+	  if (delay_entry->i1 == insn)
+	    {
+	      DEP_COST (link) = pair_delay (delay_entry);
+	      return DEP_COST (link);
+	    }
+	}
+    }
+
   /* A USE insn should never require the value used to be computed.
      This allows the computation of a function's result and parameter
      values to overlap the return and call.  We don't care about the
@@ -898,6 +1402,7 @@
 	cost = 0;
     }
 
+  DEP_COST (link) = cost;
   return cost;
 }
 
@@ -1149,7 +1654,6 @@
 {
   rtx tmp = *(const rtx *) y;
   rtx tmp2 = *(const rtx *) x;
-  rtx last;
   int tmp_class, tmp2_class;
   int val, priority_val, info_val;
 
@@ -1196,6 +1700,17 @@
       else
 	return INSN_TICK (tmp) - INSN_TICK (tmp2);
     }
+
+  /* If we are doing backtracking in this schedule, prefer insns that
+     have forward dependencies with negative cost against an insn that
+     was already scheduled.  */
+  if (current_sched_info->flags & DO_BACKTRACKING)
+    {
+      priority_val = FEEDS_BACKTRACK_INSN (tmp2) - FEEDS_BACKTRACK_INSN (tmp);
+      if (priority_val)
+	return priority_val;
+    }
+
   /* Prefer insn with higher priority.  */
   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);
 
@@ -1230,23 +1745,13 @@
   if(flag_sched_rank_heuristic && info_val)
     return info_val;
 
-  if (flag_sched_last_insn_heuristic)
-    {
-      last = last_scheduled_insn;
-
-      if (DEBUG_INSN_P (last) && last != current_sched_info->prev_head)
-	do
-	  last = PREV_INSN (last);
-	while (!NONDEBUG_INSN_P (last)
-	       && last != current_sched_info->prev_head);
-    }
-
   /* Compare insns based on their relation to the last scheduled
      non-debug insn.  */
-  if (flag_sched_last_insn_heuristic && NONDEBUG_INSN_P (last))
+  if (flag_sched_last_insn_heuristic && last_nondebug_scheduled_insn)
     {
       dep_t dep1;
       dep_t dep2;
+      rtx last = last_nondebug_scheduled_insn;
 
       /* Classify the instructions into three classes:
          1) Data dependent on last schedule insn.
@@ -1310,13 +1815,15 @@
 
 /* Add INSN to the insn queue so that it can be executed at least
    N_CYCLES after the currently executing insn.  Preserve insns
-   chain for debugging purposes.  */
+   chain for debugging purposes.  REASON will be printed in debugging
+   output.  */
 
 HAIFA_INLINE static void
-queue_insn (rtx insn, int n_cycles)
+queue_insn (rtx insn, int n_cycles, const char *reason)
 {
   int next_q = NEXT_Q_AFTER (q_ptr, n_cycles);
   rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);
+  int new_tick;
 
   gcc_assert (n_cycles <= max_insn_queue_index);
   gcc_assert (!DEBUG_INSN_P (insn));
@@ -1329,10 +1836,25 @@
       fprintf (sched_dump, ";;\t\tReady-->Q: insn %s: ",
 	       (*current_sched_info->print_insn) (insn, 0));
 
-      fprintf (sched_dump, "queued for %d cycles.\n", n_cycles);
+      fprintf (sched_dump, "queued for %d cycles (%s).\n", n_cycles, reason);
     }
 
   QUEUE_INDEX (insn) = next_q;
+
+  if (current_sched_info->flags & DO_BACKTRACKING)
+    {
+      new_tick = clock_var + n_cycles;
+      if (INSN_TICK (insn) == INVALID_TICK || INSN_TICK (insn) < new_tick)
+	INSN_TICK (insn) = new_tick;
+
+      if (INSN_EXACT_TICK (insn) != INVALID_TICK
+	  && INSN_EXACT_TICK (insn) < clock_var + n_cycles)
+	{
+	  must_backtrack = true;
+	  if (sched_verbose >= 2)
+	    fprintf (sched_dump, ";;\t\tcausing a backtrack.\n");
+	}
+    }
 }
 
 /* Remove INSN from queue.  */
@@ -1392,6 +1914,12 @@
 
   gcc_assert (QUEUE_INDEX (insn) != QUEUE_READY);
   QUEUE_INDEX (insn) = QUEUE_READY;
+
+  if (INSN_EXACT_TICK (insn) != INVALID_TICK
+      && INSN_EXACT_TICK (insn) < clock_var)
+    {
+      must_backtrack = true;
+    }
 }
 
 /* Remove the element with the highest priority from the ready list and
@@ -1538,9 +2066,6 @@
     fprintf (sched_dump, ";;\tAdvanced a state.\n");
 }
 
-/* Clock at which the previous instruction was issued.  */
-static int last_clock_var;
-
 /* Update register pressure after scheduling INSN.  */
 static void
 update_register_pressure (rtx insn)
@@ -1630,6 +2155,67 @@
   initiate_bb_reg_pressure_info (bb);
   setup_insn_max_reg_pressure (after, false);
 }
+
+/* If doing predication while scheduling, verify whether INSN, which
+   has just been scheduled, clobbers the conditions of any
+   instructions that must be predicated in order to break their
+   dependencies.  If so, remove them from the queues so that they will
+   only be scheduled once their control dependency is resolved.  */
+
+static void
+check_clobbered_conditions (rtx insn)
+{
+  HARD_REG_SET t;
+  int i;
+
+  if ((current_sched_info->flags & DO_PREDICATION) == 0)
+    return;
+
+  find_all_hard_reg_sets (insn, &t);
+
+ restart:
+  for (i = 0; i < ready.n_ready; i++)
+    {
+      rtx x = ready_element (&ready, i);
+      if (TODO_SPEC (x) == DEP_CONTROL && cond_clobbered_p (x, t))
+	{
+	  ready_remove_insn (x);
+	  goto restart;
+	}
+    }
+  for (i = 0; i <= max_insn_queue_index; i++)
+    {
+      rtx link;
+      int q = NEXT_Q_AFTER (q_ptr, i);
+
+    restart_queue:
+      for (link = insn_queue[q]; link; link = XEXP (link, 1))
+	{
+	  rtx x = XEXP (link, 0);
+	  if (TODO_SPEC (x) == DEP_CONTROL && cond_clobbered_p (x, t))
+	    {
+	      queue_remove (x);
+	      goto restart_queue;
+	    }
+	}
+    }
+}
+
+/* A structure that holds local state for the loop in schedule_block.  */
+struct sched_block_state
+{
+  /* True if no real insns have been scheduled in the current cycle.  */
+  bool first_cycle_insn_p;
+  /* True if a shadow insn has been scheduled in the current cycle, which
+     means that no more normal insns can be issued.  */
+  bool shadows_only_p;
+  /* True if we're winding down a modulo schedule, which means that we only
+     issue insns with INSN_EXACT_TICK set.  */
+  bool modulo_epilogue;
+  /* Initialized with the machine's issue rate every cycle, and updated
+     by calls to the variable_issue hook.  */
+  int can_issue_more;
+};
 
 /* INSN is the "currently executing insn".  Launch each insn which was
    waiting on INSN.  READY is the ready list which contains the insns
@@ -1675,7 +2261,7 @@
 
   /* Scheduling instruction should have all its dependencies resolved and
      should have been removed from the ready list.  */
-  gcc_assert (sd_lists_empty_p (insn, SD_LIST_BACK));
+  gcc_assert (sd_lists_empty_p (insn, SD_LIST_HARD_BACK));
 
   /* Reset debug insns invalidated by moving this insn.  */
   if (MAY_HAVE_DEBUG_INSNS && !DEBUG_INSN_P (insn))
@@ -1685,6 +2271,12 @@
 	rtx dbg = DEP_PRO (dep);
 	struct reg_use_data *use, *next;
 
+	if (DEP_STATUS (dep) & DEP_CANCELLED)
+	  {
+	    sd_iterator_next (&sd_it);
+	    continue;
+	  }
+
 	gcc_assert (DEBUG_INSN_P (dbg));
 
 	if (sched_verbose >= 6)
@@ -1738,17 +2330,36 @@
      INSN_TICK untouched.  This is a machine-dependent issue, actually.  */
   INSN_TICK (insn) = clock_var;
 
+  check_clobbered_conditions (insn);
+
   /* Update dependent instructions.  */
   for (sd_it = sd_iterator_start (insn, SD_LIST_FORW);
        sd_iterator_cond (&sd_it, &dep);)
     {
       rtx next = DEP_CON (dep);
+      bool cancelled = (DEP_STATUS (dep) & DEP_CANCELLED) != 0;
 
       /* Resolve the dependence between INSN and NEXT.
 	 sd_resolve_dep () moves current dep to another list thus
 	 advancing the iterator.  */
       sd_resolve_dep (sd_it);
 
+      if (cancelled)
+	{
+	  if (QUEUE_INDEX (next) != QUEUE_SCHEDULED)
+	    {
+	      int tick = INSN_TICK (next);
+	      gcc_assert (ORIG_PAT (next) != NULL_RTX);
+	      haifa_change_pattern (next, ORIG_PAT (next));
+	      INSN_TICK (next) = tick;
+	      if (sd_lists_empty_p (next, SD_LIST_BACK))
+		TODO_SPEC (next) = 0;
+	      else if (!sd_lists_empty_p (next, SD_LIST_HARD_BACK))
+		TODO_SPEC (next) = HARD_DEP;
+	    }
+	  continue;
+	}
+
       /* Don't bother trying to mark next as ready if insn is a debug
 	 insn.  If insn is the last hard dependency, it will have
 	 already been discounted.  */
@@ -1775,18 +2386,6 @@
 	}
     }
 
-  /* This is the place where scheduler doesn't *basically* need backward and
-     forward dependencies for INSN anymore.  Nevertheless they are used in
-     heuristics in rank_for_schedule (), early_queue_to_ready () and in
-     some targets (e.g. rs6000).  Thus the earliest place where we *can*
-     remove dependencies is after targetm.sched.finish () call in
-     schedule_block ().  But, on the other side, the safest place to remove
-     dependencies is when we are finishing scheduling entire region.  As we
-     don't generate [many] dependencies during scheduling itself, we won't
-     need memory until beginning of next region.
-     Bottom line: Dependencies are removed for all insns in the end of
-     scheduling the region.  */
-
   /* Annotate the instruction with issue information -- TImode
      indicates that the instruction is expected not to be able
      to issue on the same cycle as the previous insn.  A machine
@@ -1882,32 +2481,521 @@
     }
 }
 
+/* A structure to record enough data to allow us to backtrack the scheduler to
+   a previous state.  */
+struct haifa_saved_data
+{
+  /* Next entry on the list.  */
+  struct haifa_saved_data *next;
+
+  /* Backtracking is associated with scheduling insns that have delay slots.
+     DELAY_PAIR points to the structure that contains the insns involved, and
+     the number of cycles between them.  */
+  struct delay_pair *delay_pair;
+
+  /* Data used by the frontend (e.g. sched-ebb or sched-rgn).  */
+  void *fe_saved_data;
+  /* Data used by the backend.  */
+  void *be_saved_data;
+
+  /* Copies of global state.  */
+  int clock_var, last_clock_var;
+  struct ready_list ready;
+  state_t curr_state;
+
+  rtx last_scheduled_insn;
+  rtx last_nondebug_scheduled_insn;
+  int cycle_issued_insns;
+
+  /* Copies of state used in the inner loop of schedule_block.  */
+  struct sched_block_state sched_block;
+
+  /* We don't need to save q_ptr, as its value is arbitrary and we can set it
+     to 0 when restoring.  */
+  int q_size;
+  rtx *insn_queue;
+};
 
-/* Return the head and tail pointers of ebb starting at BEG and ending
-   at END.  */
-void
-get_ebb_head_tail (basic_block beg, basic_block end, rtx *headp, rtx *tailp)
+/* A record, in reverse order, of all scheduled insns which have delay slots
+   and may require backtracking.  */
+static struct haifa_saved_data *backtrack_queue;
+
+/* For every dependency of INSN, set the FEEDS_BACKTRACK_INSN bit according
+   to SET_P.  */
+static void
+mark_backtrack_feeds (rtx insn, int set_p)
 {
-  rtx beg_head = BB_HEAD (beg);
-  rtx beg_tail = BB_END (beg);
-  rtx end_head = BB_HEAD (end);
-  rtx end_tail = BB_END (end);
+  sd_iterator_def sd_it;
+  dep_t dep;
+  FOR_EACH_DEP (insn, SD_LIST_HARD_BACK, sd_it, dep)
+    {
+      FEEDS_BACKTRACK_INSN (DEP_PRO (dep)) = set_p;
+    }
+}
 
-  /* Don't include any notes or labels at the beginning of the BEG
-     basic block, or notes at the end of the END basic blocks.  */
+/* Save the current scheduler state so that we can backtrack to it
+   later if necessary.  PAIR gives the insns that make it necessary to
+   save this point.  SCHED_BLOCK is the local state of schedule_block
+   that need to be saved.  */
+static void
+save_backtrack_point (struct delay_pair *pair,
+		      struct sched_block_state sched_block)
+{
+  int i;
+  struct haifa_saved_data *save = XNEW (struct haifa_saved_data);
 
-  if (LABEL_P (beg_head))
-    beg_head = NEXT_INSN (beg_head);
+  save->curr_state = xmalloc (dfa_state_size);
+  memcpy (save->curr_state, curr_state, dfa_state_size);
 
-  while (beg_head != beg_tail)
-    if (NOTE_P (beg_head))
-      beg_head = NEXT_INSN (beg_head);
-    else if (DEBUG_INSN_P (beg_head))
-      {
-	rtx note, next;
+  save->ready.first = ready.first;
+  save->ready.n_ready = ready.n_ready;
+  save->ready.n_debug = ready.n_debug;
+  save->ready.veclen = ready.veclen;
+  save->ready.vec = XNEWVEC (rtx, ready.veclen);
+  memcpy (save->ready.vec, ready.vec, ready.veclen * sizeof (rtx));
 
-	for (note = NEXT_INSN (beg_head);
-	     note != beg_tail;
+  save->insn_queue = XNEWVEC (rtx, max_insn_queue_index + 1);
+  save->q_size = q_size;
+  for (i = 0; i <= max_insn_queue_index; i++)
+    {
+      int q = NEXT_Q_AFTER (q_ptr, i);
+      save->insn_queue[i] = copy_INSN_LIST (insn_queue[q]);
+    }
+
+  save->clock_var = clock_var;
+  save->last_clock_var = last_clock_var;
+  save->cycle_issued_insns = cycle_issued_insns;
+  save->last_scheduled_insn = last_scheduled_insn;
+  save->last_nondebug_scheduled_insn = last_nondebug_scheduled_insn;
+
+  save->sched_block = sched_block;
+
+  if (current_sched_info->save_state)
+    save->fe_saved_data = (*current_sched_info->save_state) ();
+
+  if (targetm.sched.alloc_sched_context)
+    {
+      save->be_saved_data = targetm.sched.alloc_sched_context ();
+      targetm.sched.init_sched_context (save->be_saved_data, false);
+    }
+  else
+    save->be_saved_data = NULL;
+
+  save->delay_pair = pair;
+
+  save->next = backtrack_queue;
+  backtrack_queue = save;
+
+  while (pair)
+    {
+      mark_backtrack_feeds (pair->i2, 1);
+      INSN_TICK (pair->i2) = INVALID_TICK;
+      INSN_EXACT_TICK (pair->i2) = clock_var + pair_delay (pair);
+      SHADOW_P (pair->i2) = pair->stages == 0;
+      pair = pair->next_same_i1;
+    }
+}
+
+/* Walk the ready list and all queues. If any insns have unresolved backwards
+   dependencies, these must be cancelled deps, broken by predication.  Set or
+   clear (depending on SET) the DEP_CANCELLED bit in DEP_STATUS.  */
+
+static void
+toggle_cancelled_flags (bool set)
+{
+  int i;
+  sd_iterator_def sd_it;
+  dep_t dep;
+
+  if (ready.n_ready > 0)
+    {
+      rtx *first = ready_lastpos (&ready);
+      for (i = 0; i < ready.n_ready; i++)
+	FOR_EACH_DEP (first[i], SD_LIST_BACK, sd_it, dep)
+	  if (!DEBUG_INSN_P (DEP_PRO (dep)))
+	    {
+	      if (set)
+		DEP_STATUS (dep) |= DEP_CANCELLED;
+	      else
+		DEP_STATUS (dep) &= ~DEP_CANCELLED;
+	    }
+    }
+  for (i = 0; i <= max_insn_queue_index; i++)
+    {
+      int q = NEXT_Q_AFTER (q_ptr, i);
+      rtx link;
+      for (link = insn_queue[q]; link; link = XEXP (link, 1))
+	{
+	  rtx insn = XEXP (link, 0);
+	  FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)
+	    if (!DEBUG_INSN_P (DEP_PRO (dep)))
+	      {
+		if (set)
+		  DEP_STATUS (dep) |= DEP_CANCELLED;
+		else
+		  DEP_STATUS (dep) &= ~DEP_CANCELLED;
+	      }
+	}
+    }
+}
+
+/* Pop entries from the SCHEDULED_INSNS vector up to and including INSN.
+   Restore their dependencies to an unresolved state, and mark them as
+   queued nowhere.  */
+
+static void
+unschedule_insns_until (rtx insn)
+{
+  VEC (rtx, heap) *recompute_vec;
+
+  recompute_vec = VEC_alloc (rtx, heap, 0);
+
+  /* Make two passes over the insns to be unscheduled.  First, we clear out
+     dependencies and other trivial bookkeeping.  */
+  for (;;)
+    {
+      rtx last;
+      sd_iterator_def sd_it;
+      dep_t dep;
+
+      last = VEC_pop (rtx, scheduled_insns);
+
+      /* This will be changed by restore_backtrack_point if the insn is in
+	 any queue.  */
+      QUEUE_INDEX (last) = QUEUE_NOWHERE;
+      if (last != insn)
+	INSN_TICK (last) = INVALID_TICK;
+
+      if (modulo_ii > 0 && INSN_UID (last) < modulo_iter0_max_uid)
+	modulo_insns_scheduled--;
+
+      for (sd_it = sd_iterator_start (last, SD_LIST_RES_FORW);
+	   sd_iterator_cond (&sd_it, &dep);)
+	{
+	  rtx con = DEP_CON (dep);
+	  sd_unresolve_dep (sd_it);
+	  if (!MUST_RECOMPUTE_SPEC_P (con))
+	    {
+	      MUST_RECOMPUTE_SPEC_P (con) = 1;
+	      VEC_safe_push (rtx, heap, recompute_vec, con);
+	    }
+	}
+
+      if (last == insn)
+	break;
+    }
+
+  /* A second pass, to update ready and speculation status for insns
+     depending on the unscheduled ones.  The first pass must have
+     popped the scheduled_insns vector up to the point where we
+     restart scheduling, as recompute_todo_spec requires it to be
+     up-to-date.  */
+  while (!VEC_empty (rtx, recompute_vec))
+    {
+      rtx con;
+
+      con = VEC_pop (rtx, recompute_vec);
+      MUST_RECOMPUTE_SPEC_P (con) = 0;
+      if (!sd_lists_empty_p (con, SD_LIST_HARD_BACK))
+	{
+	  TODO_SPEC (con) = HARD_DEP;
+	  INSN_TICK (con) = INVALID_TICK;
+	  if (PREDICATED_PAT (con) != NULL_RTX)
+	    haifa_change_pattern (con, ORIG_PAT (con));
+	}
+      else if (QUEUE_INDEX (con) != QUEUE_SCHEDULED)
+	TODO_SPEC (con) = recompute_todo_spec (con);
+    }
+  VEC_free (rtx, heap, recompute_vec);
+}
+
+/* Restore scheduler state from the topmost entry on the backtracking queue.
+   PSCHED_BLOCK_P points to the local data of schedule_block that we must
+   overwrite with the saved data.
+   The caller must already have called unschedule_insns_until.  */
+
+static void
+restore_last_backtrack_point (struct sched_block_state *psched_block)
+{
+  rtx link;
+  int i;
+  struct haifa_saved_data *save = backtrack_queue;
+
+  backtrack_queue = save->next;
+
+  if (current_sched_info->restore_state)
+    (*current_sched_info->restore_state) (save->fe_saved_data);
+
+  if (targetm.sched.alloc_sched_context)
+    {
+      targetm.sched.set_sched_context (save->be_saved_data);
+      targetm.sched.free_sched_context (save->be_saved_data);
+    }
+
+  /* Clear the QUEUE_INDEX of everything in the ready list or one
+     of the queues.  */
+  if (ready.n_ready > 0)
+    {
+      rtx *first = ready_lastpos (&ready);
+      for (i = 0; i < ready.n_ready; i++)
+	{
+	  rtx insn = first[i];
+	  QUEUE_INDEX (insn) = QUEUE_NOWHERE;
+	  INSN_TICK (insn) = INVALID_TICK;
+	}
+    }
+  for (i = 0; i <= max_insn_queue_index; i++)
+    {
+      int q = NEXT_Q_AFTER (q_ptr, i);
+
+      for (link = insn_queue[q]; link; link = XEXP (link, 1))
+	{
+	  rtx x = XEXP (link, 0);
+	  QUEUE_INDEX (x) = QUEUE_NOWHERE;
+	  INSN_TICK (x) = INVALID_TICK;
+	}
+      free_INSN_LIST_list (&insn_queue[q]);
+    }
+
+  free (ready.vec);
+  ready = save->ready;
+
+  if (ready.n_ready > 0)
+    {
+      rtx *first = ready_lastpos (&ready);
+      for (i = 0; i < ready.n_ready; i++)
+	{
+	  rtx insn = first[i];
+	  QUEUE_INDEX (insn) = QUEUE_READY;
+	  TODO_SPEC (insn) = recompute_todo_spec (insn);
+	  INSN_TICK (insn) = save->clock_var;
+	}
+    }
+
+  q_ptr = 0;
+  q_size = save->q_size;
+  for (i = 0; i <= max_insn_queue_index; i++)
+    {
+      int q = NEXT_Q_AFTER (q_ptr, i);
+
+      insn_queue[q] = save->insn_queue[q];
+
+      for (link = insn_queue[q]; link; link = XEXP (link, 1))
+	{
+	  rtx x = XEXP (link, 0);
+	  QUEUE_INDEX (x) = i;
+	  TODO_SPEC (x) = recompute_todo_spec (x);
+	  INSN_TICK (x) = save->clock_var + i;
+	}
+    }
+  free (save->insn_queue);
+
+  toggle_cancelled_flags (true);
+
+  clock_var = save->clock_var;
+  last_clock_var = save->last_clock_var;
+  cycle_issued_insns = save->cycle_issued_insns;
+  last_scheduled_insn = save->last_scheduled_insn;
+  last_nondebug_scheduled_insn = save->last_nondebug_scheduled_insn;
+
+  *psched_block = save->sched_block;
+
+  memcpy (curr_state, save->curr_state, dfa_state_size);
+  free (save->curr_state);
+
+  mark_backtrack_feeds (save->delay_pair->i2, 0);
+
+  free (save);
+
+  for (save = backtrack_queue; save; save = save->next)
+    {
+      mark_backtrack_feeds (save->delay_pair->i2, 1);
+    }
+}
+
+/* Discard all data associated with the topmost entry in the backtrack
+   queue.  If RESET_TICK is false, we just want to free the data.  If true,
+   we are doing this because we discovered a reason to backtrack.  In the
+   latter case, also reset the INSN_TICK for the shadow insn.  */
+static void
+free_topmost_backtrack_point (bool reset_tick)
+{
+  struct haifa_saved_data *save = backtrack_queue;
+  int i;
+
+  backtrack_queue = save->next;
+
+  if (reset_tick)
+    {
+      struct delay_pair *pair = save->delay_pair;
+      while (pair)
+	{
+	  INSN_TICK (pair->i2) = INVALID_TICK;
+	  INSN_EXACT_TICK (pair->i2) = INVALID_TICK;
+	  pair = pair->next_same_i1;
+	}
+    }
+  if (targetm.sched.free_sched_context)
+    targetm.sched.free_sched_context (save->be_saved_data);
+  if (current_sched_info->restore_state)
+    free (save->fe_saved_data);
+  for (i = 0; i <= max_insn_queue_index; i++)
+    free_INSN_LIST_list (&save->insn_queue[i]);
+  free (save->insn_queue);
+  free (save->curr_state);
+  free (save->ready.vec);
+  free (save);
+}
+
+/* Free the entire backtrack queue.  */
+static void
+free_backtrack_queue (void)
+{
+  while (backtrack_queue)
+    free_topmost_backtrack_point (false);
+}
+
+/* Compute INSN_TICK_ESTIMATE for INSN.  PROCESSED is a bitmap of
+   instructions we've previously encountered, a set bit prevents
+   recursion.  BUDGET is a limit on how far ahead we look, it is
+   reduced on recursive calls.  Return true if we produced a good
+   estimate, or false if we exceeded the budget.  */
+static bool
+estimate_insn_tick (bitmap processed, rtx insn, int budget)
+{
+  sd_iterator_def sd_it;
+  dep_t dep;
+  int earliest = INSN_TICK (insn);
+
+  FOR_EACH_DEP (insn, SD_LIST_BACK, sd_it, dep)
+    {
+      rtx pro = DEP_PRO (dep);
+      int t;
+
+      if (DEP_STATUS (dep) & DEP_CANCELLED)
+	continue;
+
+      if (QUEUE_INDEX (pro) == QUEUE_SCHEDULED)
+	gcc_assert (INSN_TICK (pro) + dep_cost (dep) <= INSN_TICK (insn));
+      else
+	{
+	  int cost = dep_cost (dep);
+	  if (cost >= budget)
+	    return false;
+	  if (!bitmap_bit_p (processed, INSN_LUID (pro)))
+	    {
+	      if (!estimate_insn_tick (processed, pro, budget - cost))
+		return false;
+	    }
+	  gcc_assert (INSN_TICK_ESTIMATE (pro) != INVALID_TICK);
+	  t = INSN_TICK_ESTIMATE (pro) + cost;
+	  if (earliest == INVALID_TICK || t > earliest)
+	    earliest = t;
+	}
+    }
+  bitmap_set_bit (processed, INSN_LUID (insn));
+  INSN_TICK_ESTIMATE (insn) = earliest;
+  return true;
+}
+
+/* Examine the pair of insns in P, and estimate (optimistically, assuming
+   infinite resources) the cycle in which the delayed shadow can be issued.
+   Return the number of cycles that must pass before the real insn can be
+   issued in order to meet this constraint.  */
+static int
+estimate_shadow_tick (struct delay_pair *p)
+{
+  bitmap_head processed;
+  int t;
+  bool cutoff;
+  bitmap_initialize (&processed, 0);
+
+  cutoff = !estimate_insn_tick (&processed, p->i2,
+				max_insn_queue_index + pair_delay (p));
+  bitmap_clear (&processed);
+  if (cutoff)
+    return max_insn_queue_index;
+  t = INSN_TICK_ESTIMATE (p->i2) - (clock_var + pair_delay (p) + 1);
+  if (t > 0)
+    return t;
+  return 0;
+}
+
+/* If INSN has no unresolved backwards dependencies, add it to the schedule and
+   recursively resolve all its forward dependencies.  */
+static void
+resolve_dependencies (rtx insn)
+{
+  sd_iterator_def sd_it;
+  dep_t dep;
+
+  /* Don't use sd_lists_empty_p; it ignores debug insns.  */
+  if (DEPS_LIST_FIRST (INSN_HARD_BACK_DEPS (insn)) != NULL
+      || DEPS_LIST_FIRST (INSN_SPEC_BACK_DEPS (insn)) != NULL)
+    return;
+
+  if (sched_verbose >= 4)
+    fprintf (sched_dump, ";;\tquickly resolving %d\n", INSN_UID (insn));
+
+  if (QUEUE_INDEX (insn) >= 0)
+    queue_remove (insn);
+
+  VEC_safe_push (rtx, heap, scheduled_insns, insn);
+
+  /* Update dependent instructions.  */
+  for (sd_it = sd_iterator_start (insn, SD_LIST_FORW);
+       sd_iterator_cond (&sd_it, &dep);)
+    {
+      rtx next = DEP_CON (dep);
+
+      if (sched_verbose >= 4)
+	fprintf (sched_dump, ";;\t\tdep %d against %d\n", INSN_UID (insn),
+		 INSN_UID (next));
+
+      /* Resolve the dependence between INSN and NEXT.
+	 sd_resolve_dep () moves current dep to another list thus
+	 advancing the iterator.  */
+      sd_resolve_dep (sd_it);
+
+      if (!IS_SPECULATION_BRANCHY_CHECK_P (insn))
+	{
+	  resolve_dependencies (next);
+	}
+      else
+	/* Check always has only one forward dependence (to the first insn in
+	   the recovery block), therefore, this will be executed only once.  */
+	{
+	  gcc_assert (sd_lists_empty_p (insn, SD_LIST_FORW));
+	}
+    }
+}
+
+
+/* Return the head and tail pointers of ebb starting at BEG and ending
+   at END.  */
+void
+get_ebb_head_tail (basic_block beg, basic_block end, rtx *headp, rtx *tailp)
+{
+  rtx beg_head = BB_HEAD (beg);
+  rtx beg_tail = BB_END (beg);
+  rtx end_head = BB_HEAD (end);
+  rtx end_tail = BB_END (end);
+
+  /* Don't include any notes or labels at the beginning of the BEG
+     basic block, or notes at the end of the END basic blocks.  */
+
+  if (LABEL_P (beg_head))
+    beg_head = NEXT_INSN (beg_head);
+
+  while (beg_head != beg_tail)
+    if (NOTE_P (beg_head))
+      beg_head = NEXT_INSN (beg_head);
+    else if (DEBUG_INSN_P (beg_head))
+      {
+	rtx note, next;
+
+	for (note = NEXT_INSN (beg_head);
+	     note != beg_tail;
 	     note = next)
 	  {
 	    next = NEXT_INSN (note);
@@ -2036,9 +3124,16 @@
   q_ptr = NEXT_Q (q_ptr);
 
   if (dbg_cnt (sched_insn) == false)
-    /* If debug counter is activated do not requeue insn next after
-       last_scheduled_insn.  */
-    skip_insn = next_nonnote_nondebug_insn (last_scheduled_insn);
+    {
+      /* If debug counter is activated do not requeue the first
+	 nonscheduled insn.  */
+      skip_insn = nonscheduled_insns_begin;
+      do
+	{
+	  skip_insn = next_nonnote_nondebug_insn (skip_insn);
+	}
+      while (QUEUE_INDEX (skip_insn) == QUEUE_SCHEDULED);
+    }
   else
     skip_insn = NULL_RTX;
 
@@ -2059,11 +3154,7 @@
 	  && ready->n_ready - ready->n_debug > MAX_SCHED_READY_INSNS
 	  && !SCHED_GROUP_P (insn)
 	  && insn != skip_insn)
-	{
-	  if (sched_verbose >= 2)
-	    fprintf (sched_dump, "requeued because ready full\n");
-	  queue_insn (insn, 1);
-	}
+	queue_insn (insn, 1, "ready full");
       else
 	{
 	  ready_add (ready, insn, false);
@@ -2125,22 +3216,18 @@
 static bool
 ok_for_early_queue_removal (rtx insn)
 {
-  int n_cycles;
-  rtx prev_insn = last_scheduled_insn;
-
   if (targetm.sched.is_costly_dependence)
     {
+      rtx prev_insn;
+      int n_cycles;
+      int i = VEC_length (rtx, scheduled_insns);
       for (n_cycles = flag_sched_stalled_insns_dep; n_cycles; n_cycles--)
 	{
-	  for ( ; prev_insn; prev_insn = PREV_INSN (prev_insn))
+	  while (i-- > 0)
 	    {
 	      int cost;
 
-	      if (prev_insn == current_sched_info->prev_head)
-		{
-		  prev_insn = NULL;
-		  break;
-		}
+	      prev_insn = VEC_index (rtx, scheduled_insns, i);
 
 	      if (!NOTE_P (prev_insn))
 		{
@@ -2162,9 +3249,8 @@
 		break;
 	    }
 
-	  if (!prev_insn)
+	  if (i == 0)
 	    break;
-	  prev_insn = PREV_INSN (prev_insn);
 	}
     }
 
@@ -2451,11 +3537,6 @@
    function max_issue.  */
 static struct choice_entry *choice_stack;
 
-/* The following variable value is number of essential insns issued on
-   the current cycle.  An insn is essential one if it changes the
-   processors state.  */
-int cycle_issued_insns;
-
 /* This holds the value of the target dfa_lookahead hook.  */
 int dfa_lookahead;
 
@@ -2609,8 +3690,8 @@
 	    {
 	      if (state_dead_lock_p (state)
 		  || insn_finishes_cycle_p (insn))
- 		/* We won't issue any more instructions in the next
- 		   choice_state.  */
+		/* We won't issue any more instructions in the next
+		   choice_state.  */
 		top->rest = 0;
 	      else
 		top->rest--;
@@ -2669,13 +3750,17 @@
 
   if (dbg_cnt (sched_insn) == false)
     {
-      rtx insn;
-
-      insn = next_nonnote_insn (last_scheduled_insn);
+      rtx insn = nonscheduled_insns_begin;
+      do
+	{
+	  insn = next_nonnote_insn (insn);
+	}
+      while (QUEUE_INDEX (insn) == QUEUE_SCHEDULED);
 
       if (QUEUE_INDEX (insn) == QUEUE_READY)
 	/* INSN is in the ready_list.  */
 	{
+	  nonscheduled_insns_begin = insn;
 	  ready_remove_insn (insn);
 	  *insn_ptr = insn;
 	  return 0;
@@ -2783,46 +3868,263 @@
 	    gcc_checking_assert (INSN_CODE (insn) >= 0
 				 || recog_memoized (insn) < 0);
 
-	    ready_try [i]
-	      = (/* INSN_CODE check can be omitted here as it is also done later
-		    in max_issue ().  */
-		 INSN_CODE (insn) < 0
-		 || (targetm.sched.first_cycle_multipass_dfa_lookahead_guard
-		     && !targetm.sched.first_cycle_multipass_dfa_lookahead_guard
-		     (insn)));
-	  }
+	    ready_try [i]
+	      = (/* INSN_CODE check can be omitted here as it is also done later
+		    in max_issue ().  */
+		 INSN_CODE (insn) < 0
+		 || (targetm.sched.first_cycle_multipass_dfa_lookahead_guard
+		     && !targetm.sched.first_cycle_multipass_dfa_lookahead_guard
+		     (insn)));
+	  }
+
+      if (max_issue (ready, 1, curr_state, first_cycle_insn_p, &index) == 0)
+	{
+	  *insn_ptr = ready_remove_first (ready);
+	  if (sched_verbose >= 4)
+	    fprintf (sched_dump, ";;\t\tChosen insn (but can't issue) : %s \n",
+                     (*current_sched_info->print_insn) (*insn_ptr, 0));
+	  return 0;
+	}
+      else
+	{
+	  if (sched_verbose >= 4)
+	    fprintf (sched_dump, ";;\t\tChosen insn : %s\n",
+		     (*current_sched_info->print_insn)
+		     (ready_element (ready, index), 0));
+
+	  *insn_ptr = ready_remove (ready, index);
+	  return 0;
+	}
+    }
+}
+
+/* This function is called when we have successfully scheduled a
+   block.  It uses the schedule stored in the scheduled_insns vector
+   to rearrange the RTL.  PREV_HEAD is used as the anchor to which we
+   append the scheduled insns; TAIL is the insn after the scheduled
+   block.  TARGET_BB is the argument passed to schedule_block.  */
+
+static void
+commit_schedule (rtx prev_head, rtx tail, basic_block *target_bb)
+{
+  unsigned int i;
+  rtx insn;
+
+  last_scheduled_insn = prev_head;
+  for (i = 0;
+       VEC_iterate (rtx, scheduled_insns, i, insn);
+       i++)
+    {
+      if (control_flow_insn_p (last_scheduled_insn)
+	  || current_sched_info->advance_target_bb (*target_bb, insn))
+	{
+	  *target_bb = current_sched_info->advance_target_bb (*target_bb, 0);
+
+	  if (sched_verbose)
+	    {
+	      rtx x;
+
+	      x = next_real_insn (last_scheduled_insn);
+	      gcc_assert (x);
+	      dump_new_block_header (1, *target_bb, x, tail);
+	    }
+
+	  last_scheduled_insn = bb_note (*target_bb);
+	}
+
+      if (current_sched_info->begin_move_insn)
+	(*current_sched_info->begin_move_insn) (insn, last_scheduled_insn);
+      move_insn (insn, last_scheduled_insn,
+		 current_sched_info->next_tail);
+      if (!DEBUG_INSN_P (insn))
+	reemit_notes (insn);
+      last_scheduled_insn = insn;
+    }
+
+  VEC_truncate (rtx, scheduled_insns, 0);
+}
+
+/* Examine all insns on the ready list and queue those which can't be
+   issued in this cycle.  TEMP_STATE is temporary scheduler state we
+   can use as scratch space.  If FIRST_CYCLE_INSN_P is true, no insns
+   have been issued for the current cycle, which means it is valid to
+   issue an asm statement.
+
+   If SHADOWS_ONLY_P is true, we eliminate all real insns and only
+   leave those for which SHADOW_P is true.  If MODULO_EPILOGUE is true,
+   we only leave insns which have an INSN_EXACT_TICK.  */
+
+static void
+prune_ready_list (state_t temp_state, bool first_cycle_insn_p,
+		  bool shadows_only_p, bool modulo_epilogue_p)
+{
+  int i, pass;
+  bool sched_group_found = false;
+  int min_cost_group = 1;
+
+  for (i = 0; i < ready.n_ready; i++)
+    {
+      rtx insn = ready_element (&ready, i);
+      if (SCHED_GROUP_P (insn))
+	{
+	  sched_group_found = true;
+	  break;
+	}
+    }
+
+  /* Make two passes if there's a SCHED_GROUP_P insn; make sure to handle
+     such an insn first and note its cost, then schedule all other insns
+     for one cycle later.  */
+  for (pass = sched_group_found ? 0 : 1; pass < 2; )
+    {
+      int n = ready.n_ready;
+      for (i = 0; i < n; i++)
+	{
+	  rtx insn = ready_element (&ready, i);
+	  int cost = 0;
+	  const char *reason = "resource conflict";
+
+	  if (DEBUG_INSN_P (insn))
+	    continue;
+
+	  if (sched_group_found && !SCHED_GROUP_P (insn))
+	    {
+	      if (pass == 0)
+		continue;
+	      cost = min_cost_group;
+	      reason = "not in sched group";
+	    }
+	  else if (modulo_epilogue_p
+		   && INSN_EXACT_TICK (insn) == INVALID_TICK)
+	    {
+	      cost = max_insn_queue_index;
+	      reason = "not an epilogue insn";
+	    }
+	  else if (shadows_only_p && !SHADOW_P (insn))
+	    {
+	      cost = 1;
+	      reason = "not a shadow";
+	    }
+	  else if (recog_memoized (insn) < 0)
+	    {
+	      if (!first_cycle_insn_p
+		  && (GET_CODE (PATTERN (insn)) == ASM_INPUT
+		      || asm_noperands (PATTERN (insn)) >= 0))
+		cost = 1;
+	      reason = "asm";
+	    }
+	  else if (sched_pressure_p)
+	    cost = 0;
+	  else
+	    {
+	      int delay_cost = 0;
+
+	      if (delay_htab)
+		{
+		  struct delay_pair *delay_entry;
+		  delay_entry
+		    = (struct delay_pair *)htab_find_with_hash (delay_htab, insn,
+								htab_hash_pointer (insn));
+		  while (delay_entry && delay_cost == 0)
+		    {
+		      delay_cost = estimate_shadow_tick (delay_entry);
+		      if (delay_cost > max_insn_queue_index)
+			delay_cost = max_insn_queue_index;
+		      delay_entry = delay_entry->next_same_i1;
+		    }
+		}
+
+	      memcpy (temp_state, curr_state, dfa_state_size);
+	      cost = state_transition (temp_state, insn);
+	      if (cost < 0)
+		cost = 0;
+	      else if (cost == 0)
+		cost = 1;
+	      if (cost < delay_cost)
+		{
+		  cost = delay_cost;
+		  reason = "shadow tick";
+		}
+	    }
+	  if (cost >= 1)
+	    {
+	      if (SCHED_GROUP_P (insn) && cost > min_cost_group)
+		min_cost_group = cost;
+	      ready_remove (&ready, i);
+	      queue_insn (insn, cost, reason);
+	      if (i + 1 < n)
+		break;
+	    }
+	}
+      if (i == n)
+	pass++;
+    }
+}
+
+/* Called when we detect that the schedule is impossible.  We examine the
+   backtrack queue to find the earliest insn that caused this condition.  */
 
-      if (max_issue (ready, 1, curr_state, first_cycle_insn_p, &index) == 0)
-	{
-	  *insn_ptr = ready_remove_first (ready);
-	  if (sched_verbose >= 4)
-	    fprintf (sched_dump, ";;\t\tChosen insn (but can't issue) : %s \n",
-                     (*current_sched_info->print_insn) (*insn_ptr, 0));
-	  return 0;
-	}
-      else
+static struct haifa_saved_data *
+verify_shadows (void)
+{
+  struct haifa_saved_data *save, *earliest_fail = NULL;
+  for (save = backtrack_queue; save; save = save->next)
+    {
+      int t;
+      struct delay_pair *pair = save->delay_pair;
+      rtx i1 = pair->i1;
+
+      for (; pair; pair = pair->next_same_i1)
 	{
-	  if (sched_verbose >= 4)
-	    fprintf (sched_dump, ";;\t\tChosen insn : %s\n",
-		     (*current_sched_info->print_insn)
-		     (ready_element (ready, index), 0));
+	  rtx i2 = pair->i2;
 
-	  *insn_ptr = ready_remove (ready, index);
-	  return 0;
+	  if (QUEUE_INDEX (i2) == QUEUE_SCHEDULED)
+	    continue;
+
+	  t = INSN_TICK (i1) + pair_delay (pair);
+	  if (t < clock_var)
+	    {
+	      if (sched_verbose >= 2)
+		fprintf (sched_dump,
+			 ";;\t\tfailed delay requirements for %d/%d (%d->%d)"
+			 ", not ready\n",
+			 INSN_UID (pair->i1), INSN_UID (pair->i2),
+			 INSN_TICK (pair->i1), INSN_EXACT_TICK (pair->i2));
+	      earliest_fail = save;
+	      break;
+	    }
+	  if (QUEUE_INDEX (i2) >= 0)
+	    {
+	      int queued_for = INSN_TICK (i2);
+
+	      if (t < queued_for)
+		{
+		  if (sched_verbose >= 2)
+		    fprintf (sched_dump,
+			     ";;\t\tfailed delay requirements for %d/%d"
+			     " (%d->%d), queued too late\n",
+			     INSN_UID (pair->i1), INSN_UID (pair->i2),
+			     INSN_TICK (pair->i1), INSN_EXACT_TICK (pair->i2));
+		  earliest_fail = save;
+		  break;
+		}
+	    }
 	}
     }
+
+  return earliest_fail;
 }
 
 /* Use forward list scheduling to rearrange insns of block pointed to by
    TARGET_BB, possibly bringing insns from subsequent blocks in the same
    region.  */
 
-void
-schedule_block (basic_block *target_bb)
+bool
+schedule_block (basic_block *target_bb, state_t init_state)
 {
   int i;
-  bool first_cycle_insn_p;
-  int can_issue_more;
+  bool success = modulo_ii == 0;
+  struct sched_block_state ls;
   state_t temp_state = NULL;  /* It is used for multipass scheduling.  */
   int sort_p, advance, start_clock_var;
 
@@ -2843,11 +4145,16 @@
 
   haifa_recovery_bb_recently_added_p = false;
 
+  backtrack_queue = NULL;
+
   /* Debug info.  */
   if (sched_verbose)
     dump_new_block_header (0, *target_bb, head, tail);
 
-  state_reset (curr_state);
+  if (init_state == NULL)
+    state_reset (curr_state);
+  else
+    memcpy (curr_state, init_state, dfa_state_size);
 
   /* Clear the ready list.  */
   ready.first = ready.veclen - 1;
@@ -2861,7 +4168,8 @@
     targetm.sched.init (sched_dump, sched_verbose, ready.veclen);
 
   /* We start inserting insns after PREV_HEAD.  */
-  last_scheduled_insn = prev_head;
+  last_scheduled_insn = nonscheduled_insns_begin = prev_head;
+  last_nondebug_scheduled_insn = NULL_RTX;
 
   gcc_assert ((NOTE_P (last_scheduled_insn)
 	       || DEBUG_INSN_P (last_scheduled_insn))
@@ -2906,12 +4214,12 @@
 
       /* Delay all insns past it for 1 cycle.  If debug counter is
 	 activated make an exception for the insn right after
-	 last_scheduled_insn.  */
+	 nonscheduled_insns_begin.  */
       {
 	rtx skip_insn;
 
 	if (dbg_cnt (sched_insn) == false)
-	  skip_insn = next_nonnote_insn (last_scheduled_insn);
+	  skip_insn = next_nonnote_insn (nonscheduled_insns_begin);
 	else
 	  skip_insn = NULL_RTX;
 
@@ -2922,8 +4230,10 @@
 	    insn = ready_remove (&ready, i);
 
 	    if (insn != skip_insn)
-	      queue_insn (insn, 1);
+	      queue_insn (insn, 1, "list truncated");
 	  }
+	if (skip_insn)
+	  ready_add (&ready, skip_insn, true);
       }
     }
 
@@ -2934,7 +4244,13 @@
 
   advance = 0;
 
+  gcc_assert (VEC_length (rtx, scheduled_insns) == 0);
   sort_p = TRUE;
+  must_backtrack = false;
+  modulo_insns_scheduled = 0;
+
+  ls.modulo_epilogue = false;
+
   /* Loop until all the insns in BB are scheduled.  */
   while ((*current_sched_info->schedule_more_p) ())
     {
@@ -2963,78 +4279,114 @@
 	}
       while (advance > 0);
 
-      if (sort_p)
+      if (ls.modulo_epilogue)
 	{
-	  /* Sort the ready list based on priority.  */
-	  ready_sort (&ready);
-
-	  if (sched_verbose >= 2)
+	  int stage = clock_var / modulo_ii;
+	  if (stage > modulo_last_stage * 2 + 2)
 	    {
-	      fprintf (sched_dump, ";;\t\tReady list after ready_sort:  ");
-	      debug_ready_list (&ready);
+	      if (sched_verbose >= 2)
+		fprintf (sched_dump,
+			 ";;\t\tmodulo scheduled succeeded at II %d\n",
+			 modulo_ii);
+	      success = true;
+	      goto end_schedule;
 	    }
 	}
-
-      /* We don't want md sched reorder to even see debug isns, so put
-	 them out right away.  */
-      if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))
+      else if (modulo_ii > 0)
 	{
-	  if (control_flow_insn_p (last_scheduled_insn))
+	  int stage = clock_var / modulo_ii;
+	  if (stage > modulo_max_stages)
 	    {
-	      *target_bb = current_sched_info->advance_target_bb
-		(*target_bb, 0);
-
-	      if (sched_verbose)
-		{
-		  rtx x;
-
-		  x = next_real_insn (last_scheduled_insn);
-		  gcc_assert (x);
-		  dump_new_block_header (1, *target_bb, x, tail);
-		}
-
-	      last_scheduled_insn = bb_note (*target_bb);
+	      if (sched_verbose >= 2)
+		fprintf (sched_dump,
+			 ";;\t\tfailing schedule due to excessive stages\n");
+	      goto end_schedule;
 	    }
-
-	  while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))
+	  if (modulo_n_insns == modulo_insns_scheduled
+	      && stage > modulo_last_stage)
 	    {
-	      rtx insn = ready_remove_first (&ready);
-	      gcc_assert (DEBUG_INSN_P (insn));
-	      (*current_sched_info->begin_schedule_ready) (insn,
-							   last_scheduled_insn);
-	      move_insn (insn, last_scheduled_insn,
-			 current_sched_info->next_tail);
-	      last_scheduled_insn = insn;
-	      advance = schedule_insn (insn);
-	      gcc_assert (advance == 0);
-	      if (ready.n_ready > 0)
-		ready_sort (&ready);
+	      if (sched_verbose >= 2)
+		fprintf (sched_dump,
+			 ";;\t\tfound kernel after %d stages, II %d\n",
+			 stage, modulo_ii);
+	      ls.modulo_epilogue = true;
 	    }
-
-	  if (!ready.n_ready)
-	    continue;
 	}
 
-      /* Allow the target to reorder the list, typically for
-	 better instruction bundling.  */
-      if (sort_p && targetm.sched.reorder
-	  && (ready.n_ready == 0
-	      || !SCHED_GROUP_P (ready_element (&ready, 0))))
-	can_issue_more =
-	  targetm.sched.reorder (sched_dump, sched_verbose,
-				 ready_lastpos (&ready),
-				 &ready.n_ready, clock_var);
-      else
-	can_issue_more = issue_rate;
+      prune_ready_list (temp_state, true, false, ls.modulo_epilogue);
+      if (ready.n_ready == 0)
+	continue;
+      if (must_backtrack)
+	goto do_backtrack;
 
-      first_cycle_insn_p = true;
+      ls.first_cycle_insn_p = true;
+      ls.shadows_only_p = false;
       cycle_issued_insns = 0;
+      ls.can_issue_more = issue_rate;
       for (;;)
 	{
 	  rtx insn;
 	  int cost;
-	  bool asm_p = false;
+	  bool asm_p;
+
+	  if (sort_p && ready.n_ready > 0)
+	    {
+	      /* Sort the ready list based on priority.  This must be
+		 done every iteration through the loop, as schedule_insn
+		 may have readied additional insns that will not be
+		 sorted correctly.  */
+	      ready_sort (&ready);
+
+	      if (sched_verbose >= 2)
+		{
+		  fprintf (sched_dump, ";;\t\tReady list after ready_sort:  ");
+		  debug_ready_list (&ready);
+		}
+	    }
+
+	  /* We don't want md sched reorder to even see debug isns, so put
+	     them out right away.  */
+	  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))
+	      && (*current_sched_info->schedule_more_p) ())
+	    {
+	      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))
+		{
+		  rtx insn = ready_remove_first (&ready);
+		  gcc_assert (DEBUG_INSN_P (insn));
+		  (*current_sched_info->begin_schedule_ready) (insn);
+		  VEC_safe_push (rtx, heap, scheduled_insns, insn);
+		  last_scheduled_insn = insn;
+		  advance = schedule_insn (insn);
+		  gcc_assert (advance == 0);
+		  if (ready.n_ready > 0)
+		    ready_sort (&ready);
+		}
+	    }
+
+	  if (ls.first_cycle_insn_p && !ready.n_ready)
+	    break;
+
+	resume_after_backtrack:
+	  /* Allow the target to reorder the list, typically for
+	     better instruction bundling.  */
+	  if (sort_p
+	      && (ready.n_ready == 0
+		  || !SCHED_GROUP_P (ready_element (&ready, 0))))
+	    {
+	      if (ls.first_cycle_insn_p && targetm.sched.reorder)
+		ls.can_issue_more
+		  = targetm.sched.reorder (sched_dump, sched_verbose,
+					   ready_lastpos (&ready),
+					   &ready.n_ready, clock_var);
+	      else if (!ls.first_cycle_insn_p && targetm.sched.reorder2)
+		ls.can_issue_more
+		  = targetm.sched.reorder2 (sched_dump, sched_verbose,
+					    ready.n_ready
+					    ? ready_lastpos (&ready) : NULL,
+					    &ready.n_ready, clock_var);
+	    }
 
+	restart_choose_ready:
 	  if (sched_verbose >= 2)
 	    {
 	      fprintf (sched_dump, ";;\tReady list (t = %3d):  ",
@@ -3045,7 +4397,7 @@
 	    }
 
 	  if (ready.n_ready == 0
-	      && can_issue_more
+	      && ls.can_issue_more
 	      && reload_completed)
 	    {
 	      /* Allow scheduling insns directly from the queue in case
@@ -3059,7 +4411,7 @@
 	    }
 
 	  if (ready.n_ready == 0
-	      || !can_issue_more
+	      || !ls.can_issue_more
 	      || state_dead_lock_p (curr_state)
 	      || !(*current_sched_info->schedule_more_p) ())
 	    break;
@@ -3070,14 +4422,13 @@
 	      int res;
 
 	      insn = NULL_RTX;
-	      res = choose_ready (&ready, first_cycle_insn_p, &insn);
+	      res = choose_ready (&ready, ls.first_cycle_insn_p, &insn);
 
 	      if (res < 0)
 		/* Finish cycle.  */
 		break;
 	      if (res > 0)
-		/* Restart choose_ready ().  */
-		continue;
+		goto restart_choose_ready;
 
 	      gcc_assert (insn != NULL_RTX);
 	    }
@@ -3112,172 +4463,187 @@
 	    }
 
 	  sort_p = TRUE;
-	  memcpy (temp_state, curr_state, dfa_state_size);
-	  if (recog_memoized (insn) < 0)
-	    {
-	      asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT
-		       || asm_noperands (PATTERN (insn)) >= 0);
-	      if (!first_cycle_insn_p && asm_p)
-		/* This is asm insn which is tried to be issued on the
-		   cycle not first.  Issue it on the next cycle.  */
-		cost = 1;
-	      else
-		/* A USE insn, or something else we don't need to
-		   understand.  We can't pass these directly to
-		   state_transition because it will trigger a
-		   fatal error for unrecognizable insns.  */
-		cost = 0;
-	    }
-	  else if (sched_pressure_p)
-	    cost = 0;
-	  else
-	    {
-	      cost = state_transition (temp_state, insn);
-	      if (cost < 0)
-		cost = 0;
-	      else if (cost == 0)
-		cost = 1;
-	    }
-
-	  if (cost >= 1)
-	    {
-	      queue_insn (insn, cost);
- 	      if (SCHED_GROUP_P (insn))
- 		{
- 		  advance = cost;
- 		  break;
- 		}
-
-	      continue;
-	    }
 
 	  if (current_sched_info->can_schedule_ready_p
 	      && ! (*current_sched_info->can_schedule_ready_p) (insn))
 	    /* We normally get here only if we don't want to move
 	       insn from the split block.  */
 	    {
-	      TODO_SPEC (insn) = (TODO_SPEC (insn) & ~SPECULATIVE) | HARD_DEP;
-	      continue;
+	      TODO_SPEC (insn) = HARD_DEP;
+	      goto restart_choose_ready;
 	    }
 
-	  /* DECISION is made.  */
-
-          if (TODO_SPEC (insn) & SPECULATIVE)
-            generate_recovery_code (insn);
-
-	  if (control_flow_insn_p (last_scheduled_insn)
-	      /* This is used to switch basic blocks by request
-		 from scheduler front-end (actually, sched-ebb.c only).
-		 This is used to process blocks with single fallthru
-		 edge.  If succeeding block has jump, it [jump] will try
-		 move at the end of current bb, thus corrupting CFG.  */
-	      || current_sched_info->advance_target_bb (*target_bb, insn))
+	  if (delay_htab)
 	    {
-	      *target_bb = current_sched_info->advance_target_bb
-		(*target_bb, 0);
-
-	      if (sched_verbose)
+	      /* If this insn is the first part of a delay-slot pair, record a
+		 backtrack point.  */
+	      struct delay_pair *delay_entry;
+	      delay_entry
+		= (struct delay_pair *)htab_find_with_hash (delay_htab, insn,
+							    htab_hash_pointer (insn));
+	      if (delay_entry)
 		{
-		  rtx x;
-
-		  x = next_real_insn (last_scheduled_insn);
-		  gcc_assert (x);
-		  dump_new_block_header (1, *target_bb, x, tail);
+		  save_backtrack_point (delay_entry, ls);
+		  if (sched_verbose >= 2)
+		    fprintf (sched_dump, ";;\t\tsaving backtrack point\n");
 		}
-
-	      last_scheduled_insn = bb_note (*target_bb);
 	    }
 
-	  /* Update counters, etc in the scheduler's front end.  */
-	  (*current_sched_info->begin_schedule_ready) (insn,
-						       last_scheduled_insn);
+	  /* DECISION is made.  */
 
-	  move_insn (insn, last_scheduled_insn, current_sched_info->next_tail);
+	  if (modulo_ii > 0 && INSN_UID (insn) < modulo_iter0_max_uid)
+	    {
+	      modulo_insns_scheduled++;
+	      modulo_last_stage = clock_var / modulo_ii;
+	    }
+          if (TODO_SPEC (insn) & SPECULATIVE)
+            generate_recovery_code (insn);
 
 	  if (targetm.sched.dispatch (NULL_RTX, IS_DISPATCH_ON))
 	    targetm.sched.dispatch_do (insn, ADD_TO_DISPATCH_WINDOW);
 
-	  reemit_notes (insn);
-	  last_scheduled_insn = insn;
+	  /* Update counters, etc in the scheduler's front end.  */
+	  (*current_sched_info->begin_schedule_ready) (insn);
+ 	  VEC_safe_push (rtx, heap, scheduled_insns, insn);
+	  gcc_assert (NONDEBUG_INSN_P (insn));
+	  last_nondebug_scheduled_insn = last_scheduled_insn = insn;
 
-	  if (memcmp (curr_state, temp_state, dfa_state_size) != 0)
-            {
-              cycle_issued_insns++;
-              memcpy (curr_state, temp_state, dfa_state_size);
-            }
+	  if (recog_memoized (insn) >= 0)
+	    {
+	      memcpy (temp_state, curr_state, dfa_state_size);
+	      cost = state_transition (curr_state, insn);
+	      if (!sched_pressure_p)
+		gcc_assert (cost < 0);
+	      if (memcmp (temp_state, curr_state, dfa_state_size) != 0)
+		cycle_issued_insns++;
+	      asm_p = false;
+	    }
+	  else
+	    asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT
+		     || asm_noperands (PATTERN (insn)) >= 0);
 
 	  if (targetm.sched.variable_issue)
-	    can_issue_more =
+	    ls.can_issue_more =
 	      targetm.sched.variable_issue (sched_dump, sched_verbose,
-					    insn, can_issue_more);
+					    insn, ls.can_issue_more);
 	  /* A naked CLOBBER or USE generates no instruction, so do
 	     not count them against the issue rate.  */
 	  else if (GET_CODE (PATTERN (insn)) != USE
 		   && GET_CODE (PATTERN (insn)) != CLOBBER)
-	    can_issue_more--;
+	    ls.can_issue_more--;
 	  advance = schedule_insn (insn);
 
+	  if (SHADOW_P (insn))
+	    ls.shadows_only_p = true;
+
 	  /* After issuing an asm insn we should start a new cycle.  */
 	  if (advance == 0 && asm_p)
 	    advance = 1;
-	  if (advance != 0)
+
+	  if (must_backtrack)
 	    break;
 
-	  first_cycle_insn_p = false;
+	  if (advance != 0)
+	    break;
 
-	  /* Sort the ready list based on priority.  This must be
-	     redone here, as schedule_insn may have readied additional
-	     insns that will not be sorted correctly.  */
+	  ls.first_cycle_insn_p = false;
 	  if (ready.n_ready > 0)
-	    ready_sort (&ready);
+	    prune_ready_list (temp_state, false, ls.shadows_only_p,
+			      ls.modulo_epilogue);
+	}
 
-	  /* Quickly go through debug insns such that md sched
-	     reorder2 doesn't have to deal with debug insns.  */
-	  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))
-	      && (*current_sched_info->schedule_more_p) ())
+    do_backtrack:
+      if (!must_backtrack)
+	for (i = 0; i < ready.n_ready; i++)
+	  {
+	    rtx insn = ready_element (&ready, i);
+	    if (INSN_EXACT_TICK (insn) == clock_var)
+	      {
+		must_backtrack = true;
+		clock_var++;
+		break;
+	      }
+	  }
+      if (must_backtrack && modulo_ii > 0)
+	{
+	  if (modulo_backtracks_left == 0)
+	    goto end_schedule;
+	  modulo_backtracks_left--;
+	}
+      while (must_backtrack)
+	{
+	  struct haifa_saved_data *failed;
+	  rtx failed_insn;
+
+	  must_backtrack = false;
+	  failed = verify_shadows ();
+	  gcc_assert (failed);
+
+	  failed_insn = failed->delay_pair->i1;
+	  toggle_cancelled_flags (false);
+	  unschedule_insns_until (failed_insn);
+	  while (failed != backtrack_queue)
+	    free_topmost_backtrack_point (true);
+	  restore_last_backtrack_point (&ls);
+	  if (sched_verbose >= 2)
+	    fprintf (sched_dump, ";;\t\trewind to cycle %d\n", clock_var);
+	  /* Delay by at least a cycle.  This could cause additional
+	     backtracking.  */
+	  queue_insn (failed_insn, 1, "backtracked");
+	  advance = 0;
+	  if (must_backtrack)
+	    continue;
+	  if (ready.n_ready > 0)
+	    goto resume_after_backtrack;
+	  else
 	    {
-	      if (control_flow_insn_p (last_scheduled_insn))
-		{
-		  *target_bb = current_sched_info->advance_target_bb
-		    (*target_bb, 0);
-
-		  if (sched_verbose)
-		    {
-		      rtx x;
-
-		      x = next_real_insn (last_scheduled_insn);
-		      gcc_assert (x);
-		      dump_new_block_header (1, *target_bb, x, tail);
-		    }
+	      if (clock_var == 0 && ls.first_cycle_insn_p)
+		goto end_schedule;
+	      advance = 1;
+	      break;
+	    }
+	}
+    }
+  if (ls.modulo_epilogue)
+    success = true;
 
-		  last_scheduled_insn = bb_note (*target_bb);
-		}
+ end_schedule:
+  advance_one_cycle ();
+  if (modulo_ii > 0)
+    {
+      /* Once again, debug insn suckiness: they can be on the ready list
+	 even if they have unresolved dependencies.  To make our view
+	 of the world consistent, remove such "ready" insns.  */
+    restart_debug_insn_loop:
+      for (i = ready.n_ready - 1; i >= 0; i--)
+	{
+	  rtx x;
 
- 	      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))
-		{
-		  insn = ready_remove_first (&ready);
-		  gcc_assert (DEBUG_INSN_P (insn));
-		  (*current_sched_info->begin_schedule_ready)
-		    (insn, last_scheduled_insn);
-		  move_insn (insn, last_scheduled_insn,
-			     current_sched_info->next_tail);
-		  advance = schedule_insn (insn);
-		  last_scheduled_insn = insn;
-		  gcc_assert (advance == 0);
-		  if (ready.n_ready > 0)
-		    ready_sort (&ready);
-		}
+	  x = ready_element (&ready, i);
+	  if (DEPS_LIST_FIRST (INSN_HARD_BACK_DEPS (x)) != NULL
+	      || DEPS_LIST_FIRST (INSN_SPEC_BACK_DEPS (x)) != NULL)
+	    {
+	      ready_remove (&ready, i);
+	      goto restart_debug_insn_loop;
 	    }
+	}
+      for (i = ready.n_ready - 1; i >= 0; i--)
+	{
+	  rtx x;
 
-	  if (targetm.sched.reorder2
-	      && (ready.n_ready == 0
-		  || !SCHED_GROUP_P (ready_element (&ready, 0))))
+	  x = ready_element (&ready, i);
+	  resolve_dependencies (x);
+	}
+      for (i = 0; i <= max_insn_queue_index; i++)
+	{
+	  rtx link;
+	  while ((link = insn_queue[i]) != NULL)
 	    {
-	      can_issue_more =
-		targetm.sched.reorder2 (sched_dump, sched_verbose,
-					ready.n_ready
-					? ready_lastpos (&ready) : NULL,
-					&ready.n_ready, clock_var);
+	      rtx x = XEXP (link, 0);
+	      insn_queue[i] = XEXP (link, 1);
+	      QUEUE_INDEX (x) = QUEUE_NOWHERE;
+	      free_INSN_LIST_node (link);
+	      resolve_dependencies (x);
 	    }
 	}
     }
@@ -3289,11 +4655,11 @@
       debug_ready_list (&ready);
     }
 
-  if (current_sched_info->queue_must_finish_empty)
+  if (modulo_ii == 0 && current_sched_info->queue_must_finish_empty)
     /* Sanity check -- queue must be empty now.  Meaningless if region has
        multiple bbs.  */
     gcc_assert (!q_size && !ready.n_ready && !ready.n_debug);
-  else
+  else if (modulo_ii == 0)
     {
       /* We must maintain QUEUE_INDEX between blocks in region.  */
       for (i = ready.n_ready - 1; i >= 0; i--)
@@ -3302,7 +4668,7 @@
 
 	  x = ready_element (&ready, i);
 	  QUEUE_INDEX (x) = QUEUE_NOWHERE;
-	  TODO_SPEC (x) = (TODO_SPEC (x) & ~SPECULATIVE) | HARD_DEP;
+	  TODO_SPEC (x) = HARD_DEP;
 	}
 
       if (q_size)
@@ -3315,14 +4681,22 @@
 
 		x = XEXP (link, 0);
 		QUEUE_INDEX (x) = QUEUE_NOWHERE;
-		TODO_SPEC (x) = (TODO_SPEC (x) & ~SPECULATIVE) | HARD_DEP;
+		TODO_SPEC (x) = HARD_DEP;
 	      }
 	    free_INSN_LIST_list (&insn_queue[i]);
 	  }
     }
 
-  if (sched_verbose)
-    fprintf (sched_dump, ";;   total time = %d\n", clock_var);
+  if (success)
+    {
+      commit_schedule (prev_head, tail, target_bb);
+      if (sched_verbose)
+	fprintf (sched_dump, ";;   total time = %d\n", clock_var);
+    }
+  else
+    last_scheduled_insn = tail;
+
+  VEC_truncate (rtx, scheduled_insns, 0);
 
   if (!current_sched_info->queue_must_finish_empty
       || haifa_recovery_bb_recently_added_p)
@@ -3358,6 +4732,10 @@
 
   current_sched_info->head = head;
   current_sched_info->tail = tail;
+
+  free_backtrack_queue ();
+
+  return success;
 }
 
 /* Set_priorities: compute priority of each insn in the block.  */
@@ -3482,7 +4860,8 @@
 
   init_alias_analysis ();
 
-  df_set_flags (DF_LR_RUN_DCE);
+  if (!sched_no_dce)
+    df_set_flags (DF_LR_RUN_DCE);
   df_note_add_problem ();
 
   /* More problems needed for interloop dep calculation in SMS.  */
@@ -3533,6 +4912,8 @@
   setup_sched_dump ();
   sched_init ();
 
+  scheduled_insns = VEC_alloc (rtx, heap, 0);
+
   if (spec_info != NULL)
     {
       sched_deps_info->use_deps_list = 1;
@@ -3572,6 +4953,8 @@
   nr_begin_data = nr_begin_control = nr_be_in_data = nr_be_in_control = 0;
   before_recovery = 0;
   after_recovery = 0;
+
+  modulo_ii = 0;
 }
 
 /* Finish work with the data specific to the Haifa scheduler.  */
@@ -3603,6 +4986,8 @@
                c, nr_be_in_control);
     }
 
+  VEC_free (rtx, heap, scheduled_insns);
+
   /* Finalize h_i_d, dependency caches, and luids for the whole
      function.  Target will be finalized in md_global_finish ().  */
   sched_deps_finish ();
@@ -3643,6 +5028,17 @@
 #endif
 }
 
+/* Free all delay_pair structures that were recorded.  */
+void
+free_delay_pairs (void)
+{
+  if (delay_htab)
+    {
+      htab_empty (delay_htab);
+      htab_empty (delay_htab_i2);
+    }
+}
+
 /* Fix INSN_TICKs of the instructions in the current block as well as
    INSN_TICKs of their dependents.
    HEAD and TAIL are the begin and the end of the current scheduled block.  */
@@ -3715,8 +5111,6 @@
   bitmap_clear (&processed);
 }
 
-static int haifa_speculate_insn (rtx, ds_t, rtx *);
-
 /* Check if NEXT is ready to be added to the ready or queue list.
    If "yes", add it to the proper list.
    Returns:
@@ -3726,72 +5120,22 @@
 int
 try_ready (rtx next)
 {
-  ds_t old_ts, *ts;
+  ds_t old_ts, new_ts;
 
-  ts = &TODO_SPEC (next);
-  old_ts = *ts;
+  old_ts = TODO_SPEC (next);
 
-  gcc_assert (!(old_ts & ~(SPECULATIVE | HARD_DEP))
+  gcc_assert (!(old_ts & ~(SPECULATIVE | HARD_DEP | DEP_CONTROL))
 	      && ((old_ts & HARD_DEP)
-		  || (old_ts & SPECULATIVE)));
-
-  if (sd_lists_empty_p (next, SD_LIST_BACK))
-    /* NEXT has all its dependencies resolved.  */
-    {
-      /* Remove HARD_DEP bit from NEXT's status.  */
-      *ts &= ~HARD_DEP;
-
-      if (current_sched_info->flags & DO_SPECULATION)
-	/* Remove all speculative bits from NEXT's status.  */
-	*ts &= ~SPECULATIVE;
-    }
-  else
-    {
-      /* One of the NEXT's dependencies has been resolved.
-	 Recalculate NEXT's status.  */
-
-      *ts &= ~SPECULATIVE & ~HARD_DEP;
-
-      if (sd_lists_empty_p (next, SD_LIST_HARD_BACK))
-	/* Now we've got NEXT with speculative deps only.
-	   1. Look at the deps to see what we have to do.
-	   2. Check if we can do 'todo'.  */
-	{
-	  sd_iterator_def sd_it;
-	  dep_t dep;
-	  bool first_p = true;
-
-	  FOR_EACH_DEP (next, SD_LIST_BACK, sd_it, dep)
-	    {
-	      ds_t ds = DEP_STATUS (dep) & SPECULATIVE;
-
-	      if (DEBUG_INSN_P (DEP_PRO (dep))
-		  && !DEBUG_INSN_P (next))
-		continue;
-
-	      if (first_p)
-		{
-		  first_p = false;
-
-		  *ts = ds;
-		}
-	      else
-		*ts = ds_merge (*ts, ds);
-	    }
+		  || (old_ts & SPECULATIVE)
+		  || (old_ts & DEP_CONTROL)));
 
-	  if (ds_weak (*ts) < spec_info->data_weakness_cutoff)
-	    /* Too few points.  */
-	    *ts = (*ts & ~SPECULATIVE) | HARD_DEP;
-	}
-      else
-	*ts |= HARD_DEP;
-    }
+  new_ts = recompute_todo_spec (next);
 
-  if (*ts & HARD_DEP)
-    gcc_assert (*ts == old_ts
+  if (new_ts & HARD_DEP)
+    gcc_assert (new_ts == old_ts
 		&& QUEUE_INDEX (next) == QUEUE_NOWHERE);
   else if (current_sched_info->new_ready)
-    *ts = current_sched_info->new_ready (next, *ts);
+    new_ts = current_sched_info->new_ready (next, new_ts);
 
   /* * if !(old_ts & SPECULATIVE) (e.g. HARD_DEP or 0), then insn might
      have its original pattern or changed (speculative) one.  This is due
@@ -3799,29 +5143,29 @@
      * But if (old_ts & SPECULATIVE), then we are pretty sure that insn
      has speculative pattern.
 
-     We can't assert (!(*ts & HARD_DEP) || *ts == old_ts) here because
+     We can't assert (!(new_ts & HARD_DEP) || new_ts == old_ts) here because
      control-speculative NEXT could have been discarded by sched-rgn.c
      (the same case as when discarded by can_schedule_ready_p ()).  */
 
-  if ((*ts & SPECULATIVE)
-      /* If (old_ts == *ts), then (old_ts & SPECULATIVE) and we don't
+  if ((new_ts & SPECULATIVE)
+      /* If (old_ts == new_ts), then (old_ts & SPECULATIVE) and we don't
 	 need to change anything.  */
-      && *ts != old_ts)
+      && new_ts != old_ts)
     {
       int res;
       rtx new_pat;
 
-      gcc_assert ((*ts & SPECULATIVE) && !(*ts & ~SPECULATIVE));
+      gcc_assert ((new_ts & SPECULATIVE) && !(new_ts & ~SPECULATIVE));
 
-      res = haifa_speculate_insn (next, *ts, &new_pat);
+      res = haifa_speculate_insn (next, new_ts, &new_pat);
 
       switch (res)
 	{
 	case -1:
 	  /* It would be nice to change DEP_STATUS of all dependences,
-	     which have ((DEP_STATUS & SPECULATIVE) == *ts) to HARD_DEP,
+	     which have ((DEP_STATUS & SPECULATIVE) == new_ts) to HARD_DEP,
 	     so we won't reanalyze anything.  */
-	  *ts = (*ts & ~SPECULATIVE) | HARD_DEP;
+	  new_ts = HARD_DEP;
 	  break;
 
 	case 0:
@@ -3837,7 +5181,8 @@
 	       save it.  */
 	    ORIG_PAT (next) = PATTERN (next);
 
-	  haifa_change_pattern (next, new_pat);
+	  res = haifa_change_pattern (next, new_pat);
+	  gcc_assert (res);
 	  break;
 
 	default:
@@ -3845,14 +5190,16 @@
 	}
     }
 
-  /* We need to restore pattern only if (*ts == 0), because otherwise it is
-     either correct (*ts & SPECULATIVE),
-     or we simply don't care (*ts & HARD_DEP).  */
+  /* We need to restore pattern only if (new_ts == 0), because otherwise it is
+     either correct (new_ts & SPECULATIVE),
+     or we simply don't care (new_ts & HARD_DEP).  */
 
   gcc_assert (!ORIG_PAT (next)
 	      || !IS_SPECULATION_BRANCHY_CHECK_P (next));
 
-  if (*ts & HARD_DEP)
+  TODO_SPEC (next) = new_ts;
+
+  if (new_ts & HARD_DEP)
     {
       /* We can't assert (QUEUE_INDEX (next) == QUEUE_NOWHERE) here because
 	 control-speculative NEXT could have been discarded by sched-rgn.c
@@ -3860,35 +5207,38 @@
       /*gcc_assert (QUEUE_INDEX (next) == QUEUE_NOWHERE);*/
 
       change_queue_index (next, QUEUE_NOWHERE);
+
       return -1;
     }
-  else if (!(*ts & BEGIN_SPEC) && ORIG_PAT (next) && !IS_SPECULATION_CHECK_P (next))
+  else if (!(new_ts & BEGIN_SPEC)
+	   && ORIG_PAT (next) && PREDICATED_PAT (next) == NULL_RTX
+	   && !IS_SPECULATION_CHECK_P (next))
     /* We should change pattern of every previously speculative
        instruction - and we determine if NEXT was speculative by using
        ORIG_PAT field.  Except one case - speculation checks have ORIG_PAT
        pat too, so skip them.  */
     {
-      haifa_change_pattern (next, ORIG_PAT (next));
+      bool success = haifa_change_pattern (next, ORIG_PAT (next));
+      gcc_assert (success);
       ORIG_PAT (next) = 0;
     }
 
   if (sched_verbose >= 2)
     {
-      int s = TODO_SPEC (next);
-
       fprintf (sched_dump, ";;\t\tdependencies resolved: insn %s",
                (*current_sched_info->print_insn) (next, 0));
 
       if (spec_info && spec_info->dump)
         {
-          if (s & BEGIN_DATA)
+          if (new_ts & BEGIN_DATA)
             fprintf (spec_info->dump, "; data-spec;");
-          if (s & BEGIN_CONTROL)
+          if (new_ts & BEGIN_CONTROL)
             fprintf (spec_info->dump, "; control-spec;");
-          if (s & BE_IN_CONTROL)
+          if (new_ts & BE_IN_CONTROL)
             fprintf (spec_info->dump, "; in-control-spec;");
         }
-
+      if (TODO_SPEC (next) & DEP_CONTROL)
+	fprintf (sched_dump, " predicated");
       fprintf (sched_dump, "\n");
     }
 
@@ -3971,7 +5321,7 @@
   if (delay == QUEUE_READY)
     ready_add (readyp, next, false);
   else if (delay >= 1)
-    queue_insn (next, delay);
+    queue_insn (next, delay, "change queue index");
 
   if (sched_verbose >= 2)
     {
@@ -4001,6 +5351,7 @@
     {
       i = 0;
       sched_ready_n_insns = 0;
+      VEC_reserve (rtx, heap, scheduled_insns, new_sched_ready_n_insns);
     }
   else
     i = sched_ready_n_insns + 1;
@@ -4863,28 +6214,33 @@
   add_jump_dependencies (insn, jump);
 }
 
-/* Change pattern of INSN to NEW_PAT.  */
-void
-sched_change_pattern (rtx insn, rtx new_pat)
+/* Change pattern of INSN to NEW_PAT.  Invalidate cached haifa
+   instruction data.  */
+static bool
+haifa_change_pattern (rtx insn, rtx new_pat)
 {
+  sd_iterator_def sd_it;
+  dep_t dep;
   int t;
 
   t = validate_change (insn, &PATTERN (insn), new_pat, 0);
-  gcc_assert (t);
+  if (!t)
+    return false;
   dfa_clear_single_insn_cache (insn);
-}
 
-/* Change pattern of INSN to NEW_PAT.  Invalidate cached haifa
-   instruction data.  */
-static void
-haifa_change_pattern (rtx insn, rtx new_pat)
-{
-  sched_change_pattern (insn, new_pat);
+  sd_it = sd_iterator_start (insn,
+			     SD_LIST_FORW | SD_LIST_BACK | SD_LIST_RES_BACK);
+  while (sd_iterator_cond (&sd_it, &dep))
+    {
+      DEP_COST (dep) = UNKNOWN_DEP_COST;
+      sd_iterator_next (&sd_it);
+    }
 
   /* Invalidate INSN_COST, so it'll be recalculated.  */
   INSN_COST (insn) = -1;
   /* Invalidate INSN_TICK, so it'll be recalculated.  */
   INSN_TICK (insn) = INVALID_TICK;
+  return true;
 }
 
 /* -1 - can't speculate,
@@ -5310,6 +6666,11 @@
 		    gcc_assert (/* Usual case.  */
                                 (EDGE_COUNT (bb->succs) > 1
                                  && !BARRIER_P (NEXT_INSN (head)))
+				/* Special cases, see cfglayout.c:
+				   fixup_reorder_chain.  */
+				|| (EDGE_COUNT (bb->succs) == 1
+				    && (!onlyjump_p (head)
+					|| returnjump_p (head)))
                                 /* Or jump to the next instruction.  */
                                 || (EDGE_COUNT (bb->succs) == 1
                                     && (BB_HEAD (EDGE_I (bb->succs, 0)->dest)
@@ -5526,6 +6887,7 @@
       INSN_COST (insn) = -1;
       QUEUE_INDEX (insn) = QUEUE_NOWHERE;
       INSN_TICK (insn) = INVALID_TICK;
+      INSN_EXACT_TICK (insn) = INVALID_TICK;
       INTER_TICK (insn) = INVALID_TICK;
       TODO_SPEC (insn) = HARD_DEP;
     }
@@ -5627,9 +6989,16 @@
 rtx
 sched_emit_insn (rtx pat)
 {
-  rtx insn = emit_insn_after (pat, last_scheduled_insn);
-  last_scheduled_insn = insn;
+  rtx insn = emit_insn_before (pat, nonscheduled_insns_begin);
   haifa_init_insn (insn);
+
+  if (current_sched_info->add_remove_insn)
+    current_sched_info->add_remove_insn (insn, 0);
+
+  (*current_sched_info->begin_schedule_ready) (insn);
+  VEC_safe_push (rtx, heap, scheduled_insns, insn);
+
+  last_scheduled_insn = insn;
   return insn;
 }
 
diff -ru ./gcc/hooks.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/hooks.c
--- ./gcc/hooks.c	2014-06-06 11:50:17.499598675 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/hooks.c	2012-03-29 18:03:19.000000000 +1000
@@ -149,6 +149,12 @@
   return 0;
 }
 
+int
+hook_int_void_0 (void)
+{
+  return 0;
+}
+
 /* ??? Used for comp_type_attributes, which ought to return bool.  */
 int
 hook_int_const_tree_const_tree_1 (const_tree a ATTRIBUTE_UNUSED, const_tree b ATTRIBUTE_UNUSED)
diff -ru ./gcc/hooks.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/hooks.h
--- ./gcc/hooks.h	2014-06-06 11:50:17.503598675 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/hooks.h	2012-03-29 18:03:19.000000000 +1000
@@ -69,6 +69,8 @@
 extern int hook_int_rtx_0 (rtx);
 extern int hook_int_rtx_bool_0 (rtx, bool);
 
+extern int hook_int_void_0 (void);
+
 extern tree hook_tree_const_tree_null (const_tree);
 
 extern tree hook_tree_tree_tree_null (tree, tree);
diff -ru ./gcc/ifcvt.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ifcvt.c
--- ./gcc/ifcvt.c	2014-06-06 11:50:17.507598676 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ifcvt.c	2012-03-29 18:03:19.000000000 +1000
@@ -103,7 +103,7 @@
 static int find_if_case_1 (basic_block, edge, edge);
 static int find_if_case_2 (basic_block, edge, edge);
 static int dead_or_predicable (basic_block, basic_block, basic_block,
-			       basic_block, int);
+			       edge, int);
 static void noce_emit_move_insn (rtx, rtx);
 static rtx block_has_only_trap (basic_block);
 
@@ -304,6 +304,10 @@
 
   for (insn = start; ; insn = NEXT_INSN (insn))
     {
+      /* dwarf2out can't cope with conditional prologues.  */
+      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_PROLOGUE_END)
+	return FALSE;
+
       if (NOTE_P (insn) || DEBUG_INSN_P (insn))
 	goto insn_done;
 
@@ -879,7 +883,7 @@
 		}
 
 	      gcc_assert (start < (MEM_P (op) ? BITS_PER_UNIT : BITS_PER_WORD));
-	      store_bit_field (op, size, start, GET_MODE (x), y);
+	      store_bit_field (op, size, start, false, GET_MODE (x), y);
 	      return;
 	    }
 
@@ -933,7 +937,7 @@
   inner = XEXP (outer, 0);
   outmode = GET_MODE (outer);
   bitpos = SUBREG_BYTE (outer) * BITS_PER_UNIT;
-  store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos, outmode, y);
+  store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos, false, outmode, y);
 }
 
 /* Return sequence of instructions generated by if conversion.  This
@@ -3789,6 +3793,7 @@
   basic_block then_bb = then_edge->dest;
   basic_block else_bb = else_edge->dest;
   basic_block new_bb;
+  rtx else_target = NULL_RTX;
   int then_bb_index;
 
   /* If we are partitioning hot/cold basic blocks, we don't want to
@@ -3838,9 +3843,16 @@
 				    predictable_edge_p (then_edge)))))
     return FALSE;
 
+  if (else_bb == EXIT_BLOCK_PTR)
+    {
+      rtx jump = BB_END (else_edge->src);
+      gcc_assert (JUMP_P (jump));
+      else_target = JUMP_LABEL (jump);
+    }
+
   /* Registers set are dead, or are predicable.  */
   if (! dead_or_predicable (test_bb, then_bb, else_bb,
-			    single_succ (then_bb), 1))
+			    single_succ_edge (then_bb), 1))
     return FALSE;
 
   /* Conversion went ok, including moving the insns and fixing up the
@@ -3857,6 +3869,9 @@
       redirect_edge_succ (FALLTHRU_EDGE (test_bb), else_bb);
       new_bb = 0;
     }
+  else if (else_bb == EXIT_BLOCK_PTR)
+    new_bb = force_nonfallthru_and_redirect (FALLTHRU_EDGE (test_bb),
+					     else_bb, else_target);
   else
     new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb),
 					     else_bb);
@@ -3955,7 +3970,7 @@
     return FALSE;
 
   /* Registers set are dead, or are predicable.  */
-  if (! dead_or_predicable (test_bb, else_bb, then_bb, else_succ->dest, 0))
+  if (! dead_or_predicable (test_bb, else_bb, then_bb, else_succ, 0))
     return FALSE;
 
   /* Conversion went ok, including moving the insns and fixing up the
@@ -3984,12 +3999,34 @@
 
 static int
 dead_or_predicable (basic_block test_bb, basic_block merge_bb,
-		    basic_block other_bb, basic_block new_dest, int reversep)
+		    basic_block other_bb, edge dest_edge, int reversep)
 {
-  rtx head, end, jump, earliest = NULL_RTX, old_dest, new_label = NULL_RTX;
+  basic_block new_dest = dest_edge->dest;
+  rtx head, end, jump, earliest = NULL_RTX, old_dest;
   bitmap merge_set = NULL;
   /* Number of pending changes.  */
   int n_validated_changes = 0;
+  rtx new_dest_label;
+
+  jump = BB_END (dest_edge->src);
+  if (JUMP_P (jump))
+    {
+      new_dest_label = JUMP_LABEL (jump);
+      if (new_dest_label == NULL_RTX)
+	{
+	  new_dest_label = PATTERN (jump);
+	  gcc_assert (ANY_RETURN_P (new_dest_label));
+	}
+    }
+  else if (other_bb != new_dest)
+    {
+      if (new_dest == EXIT_BLOCK_PTR)
+	new_dest_label = ret_rtx;
+      else
+	new_dest_label = block_label (new_dest);
+    }
+  else
+    new_dest_label = NULL_RTX;
 
   jump = BB_END (test_bb);
 
@@ -4127,10 +4164,9 @@
   old_dest = JUMP_LABEL (jump);
   if (other_bb != new_dest)
     {
-      new_label = block_label (new_dest);
       if (reversep
-	  ? ! invert_jump_1 (jump, new_label)
-	  : ! redirect_jump_1 (jump, new_label))
+	  ? ! invert_jump_1 (jump, new_dest_label)
+	  : ! redirect_jump_1 (jump, new_dest_label))
 	goto cancel;
     }
 
@@ -4141,7 +4177,7 @@
 
   if (other_bb != new_dest)
     {
-      redirect_jump_2 (jump, old_dest, new_label, 0, reversep);
+      redirect_jump_2 (jump, old_dest, new_dest_label, 0, reversep);
 
       redirect_edge_succ (BRANCH_EDGE (test_bb), new_dest);
       if (reversep)
diff -ru ./gcc/incpath.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/incpath.c
--- ./gcc/incpath.c	2014-06-06 14:25:27.518150553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/incpath.c	2012-03-29 18:03:19.000000000 +1000
@@ -30,6 +30,9 @@
 #include "intl.h"
 #include "incpath.h"
 #include "cppdefault.h"
+#include "flags.h"
+#include "toplev.h"
+#include "diagnostic-core.h"
 
 /* Microsoft Windows does not natively support inodes.
    VMS has non-numeric inodes.  */
@@ -353,6 +356,24 @@
 	}
       fprintf (stderr, _("End of search list.\n"));
     }
+
+#ifdef ENABLE_POISON_SYSTEM_DIRECTORIES
+  if (flag_poison_system_directories)
+    {
+	struct cpp_dir *p;
+
+	for (p = heads[QUOTE]; p; p = p->next)
+	  {
+	   if ((!strncmp (p->name, "/usr/include", 12))
+	       || (!strncmp (p->name, "/usr/local/include", 18))
+	       || (!strncmp (p->name, "/usr/X11R6/include", 18)))
+	     warning (OPT_Wpoison_system_directories,
+		      "include location \"%s\" is unsafe for "
+		      "cross-compilation",
+		      p->name);
+	  }
+    }
+#endif
 }
 
 /* Use given -I paths for #include "..." but not #include <...>, and
diff -ru ./gcc/integrate.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/integrate.c
--- ./gcc/integrate.c	2014-06-06 11:50:17.511598676 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/integrate.c	2012-03-29 18:03:19.000000000 +1000
@@ -55,6 +55,7 @@
 typedef struct GTY(()) initial_value_pair {
   rtx hard_reg;
   rtx pseudo;
+  bool initialized;
 } initial_value_pair;
 typedef struct GTY(()) initial_value_struct {
   int num_entries;
@@ -238,6 +239,7 @@
 {
   struct initial_value_struct *ivs;
   rtx rv;
+  int entry;
 
   rv = has_hard_reg_initial_val (mode, regno);
   if (rv)
@@ -253,17 +255,19 @@
       crtl->hard_reg_initial_vals = ivs;
     }
 
-  if (ivs->num_entries >= ivs->max_entries)
+  entry = ivs->num_entries++;
+  if (entry >= ivs->max_entries)
     {
       ivs->max_entries += 5;
       ivs->entries = GGC_RESIZEVEC (initial_value_pair, ivs->entries,
 				    ivs->max_entries);
     }
 
-  ivs->entries[ivs->num_entries].hard_reg = gen_rtx_REG (mode, regno);
-  ivs->entries[ivs->num_entries].pseudo = gen_reg_rtx (mode);
+  ivs->entries[entry].hard_reg = gen_rtx_REG (mode, regno);
+  ivs->entries[entry].pseudo = gen_reg_rtx (mode);
+  ivs->entries[entry].initialized = false;
 
-  return ivs->entries[ivs->num_entries++].pseudo;
+  return ivs->entries[entry].pseudo;
 }
 
 /* See if get_hard_reg_initial_val has been used to create a pseudo
@@ -298,7 +302,16 @@
 
   start_sequence ();
   for (i = 0; i < ivs->num_entries; i++)
-    emit_move_insn (ivs->entries[i].pseudo, ivs->entries[i].hard_reg);
+    {
+      if (ivs->entries[i].initialized)
+	continue;
+      ivs->entries[i].initialized = true;
+      emit_move_insn (ivs->entries[i].pseudo, ivs->entries[i].hard_reg);
+#ifdef HAVE_use_initial_val
+      if (HAVE_use_initial_val)
+	emit_insn (gen_use_initial_val (ivs->entries[i].pseudo));
+#endif
+    }
   seq = get_insns ();
   end_sequence ();
 
diff -ru ./gcc/ira-build.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-build.c
--- ./gcc/ira-build.c	2014-06-06 11:50:17.531598677 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-build.c	2012-03-29 18:03:19.000000000 +1000
@@ -480,6 +480,7 @@
   ALLOCNO_HARD_REGNO (a) = -1;
   ALLOCNO_CALL_FREQ (a) = 0;
   ALLOCNO_CALLS_CROSSED_NUM (a) = 0;
+  CLEAR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));
 #ifdef STACK_REGS
   ALLOCNO_NO_STACK_REG_P (a) = false;
   ALLOCNO_TOTAL_NO_STACK_REG_P (a) = false;
@@ -877,6 +878,8 @@
   merge_hard_reg_conflicts (a, cap, false);
 
   ALLOCNO_CALLS_CROSSED_NUM (cap) = ALLOCNO_CALLS_CROSSED_NUM (a);
+  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (cap),
+		    ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));
   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)
     {
       fprintf (ira_dump_file, "    Creating cap ");
@@ -1668,6 +1671,9 @@
 	  merge_hard_reg_conflicts (a, parent_a, true);
 	  ALLOCNO_CALLS_CROSSED_NUM (parent_a)
 	    += ALLOCNO_CALLS_CROSSED_NUM (a);
+	  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a),
+			    ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));
+
 	  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)
 	    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);
 	  cover_class = ALLOCNO_COVER_CLASS (a);
@@ -2010,6 +2016,8 @@
   ALLOCNO_FREQ (a) += ALLOCNO_FREQ (from_a);
   ALLOCNO_CALL_FREQ (a) += ALLOCNO_CALL_FREQ (from_a);
   ALLOCNO_CALLS_CROSSED_NUM (a) += ALLOCNO_CALLS_CROSSED_NUM (from_a);
+  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a),
+		    ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (from_a));
   ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a)
     += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (from_a);
   if (! ALLOCNO_BAD_SPILL_P (from_a))
@@ -2634,6 +2642,8 @@
       ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);
       ALLOCNO_CALLS_CROSSED_NUM (parent_a)
 	+= ALLOCNO_CALLS_CROSSED_NUM (a);
+      IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (parent_a),
+			ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a));
       ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)
 	+= ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);
       merged_p = true;
diff -ru ./gcc/ira.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira.c
--- ./gcc/ira.c	2014-06-06 11:50:17.543598677 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira.c	2012-03-29 18:03:19.000000000 +1000
@@ -321,7 +321,7 @@
 #include "integrate.h"
 #include "ggc.h"
 #include "ira-int.h"
-
+#include "dbgcnt.h"
 
 struct target_ira default_target_ira;
 struct target_ira_int default_target_ira_int;
@@ -3051,6 +3051,520 @@
     print_insn_chains (dump_file);
 }
 
+/* Examine the rtx found in *LOC, which is read or written to as determined
+   by TYPE.  Return false if we find a reason why an insn containing this
+   rtx should not be moved (such as accesses to non-constant memory), true
+   otherwise.  */
+static bool
+rtx_moveable_p (rtx *loc, enum op_type type)
+{
+  const char *fmt;
+  rtx x = *loc;
+  enum rtx_code code = GET_CODE (x);
+  int i, j;
+
+  code = GET_CODE (x);
+  switch (code)
+    {
+    case CONST:
+    case CONST_INT:
+    case CONST_DOUBLE:
+    case CONST_FIXED:
+    case CONST_VECTOR:
+    case SYMBOL_REF:
+    case LABEL_REF:
+      return true;
+
+    case PC:
+      return type == OP_IN;
+
+    case CC0:
+      return false;
+
+    case REG:
+      if (x == frame_pointer_rtx)
+	return true;
+      if (HARD_REGISTER_P (x))
+	return false;
+      
+      return true;
+
+    case MEM:
+      if (type == OP_IN && MEM_READONLY_P (x))
+	return rtx_moveable_p (&XEXP (x, 0), OP_IN);
+      return false;
+
+    case SET:
+      return (rtx_moveable_p (&SET_SRC (x), OP_IN)
+	      && rtx_moveable_p (&SET_DEST (x), OP_OUT));
+
+    case STRICT_LOW_PART:
+      return rtx_moveable_p (&XEXP (x, 0), OP_OUT);
+
+    case ZERO_EXTRACT:
+    case SIGN_EXTRACT:
+      return (rtx_moveable_p (&XEXP (x, 0), type)
+	      && rtx_moveable_p (&XEXP (x, 1), OP_IN)
+	      && rtx_moveable_p (&XEXP (x, 2), OP_IN));
+
+    case CLOBBER:
+      return rtx_moveable_p (&SET_DEST (x), OP_OUT);
+
+    default:
+      break;
+    }
+
+  fmt = GET_RTX_FORMAT (code);
+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)
+    {
+      if (fmt[i] == 'e')
+	{
+	  if (!rtx_moveable_p (&XEXP (x, i), type))
+	    return false;
+	}
+      else if (fmt[i] == 'E')
+	for (j = XVECLEN (x, i) - 1; j >= 0; j--)
+	  {
+	    if (!rtx_moveable_p (&XVECEXP (x, i, j), type))
+	      return false;
+	  }
+    }
+  return true;
+}
+
+/* A wrapper around dominated_by_p, which uses the information in UID_LUID
+   to give dominance relationships between two insns I1 and I2.  */
+static bool
+insn_dominated_by_p (rtx i1, rtx i2, int *uid_luid)
+{
+  basic_block bb1 = BLOCK_FOR_INSN (i1);
+  basic_block bb2 = BLOCK_FOR_INSN (i2);
+
+  if (bb1 == bb2)
+    return uid_luid[INSN_UID (i2)] < uid_luid[INSN_UID (i1)];
+  return dominated_by_p (CDI_DOMINATORS, bb1, bb2);
+}
+
+/* Record the range of register numbers added by find_moveable_pseudos.  */
+int first_moveable_pseudo, last_moveable_pseudo;
+
+/* These two vectors hold data for every register added by
+   find_movable_pseudos, with index 0 holding data for the
+   first_moveable_pseudo.  */
+/* The original home register.  */
+static VEC (rtx, heap) *pseudo_replaced_reg;
+/* The move instruction we added to move the value to its original home
+   register.  */
+static VEC (rtx, heap) *pseudo_move_insn;
+
+/* Look for instances where we have an instruction that is known to increase
+   register pressure, and whose result is not used immediately.  If it is
+   possible to move the instruction downwards to just before its first use,
+   split its lifetime into two ranges.  We create a new pseudo to compute the
+   value, and emit a move instruction just before the first use.  If, after
+   register allocation, the new pseudo remains unallocated, the function
+   move_unallocated_pseudos then deletes the move instruction and places
+   the computation just before the first use.
+
+   Such a move is safe and profitable if all the input registers remain live
+   and unchanged between the original computation and its first use.  In such
+   a situation, the computation is known to increase register pressure, and
+   moving it is known to at least not worsen it.
+
+   We restrict moves to only those cases where a register remains unallocated,
+   in order to avoid interfering too much with the instruction schedule.  As
+   an exception, we may move insns which only modify their input register
+   (typically induction variables), as this increases the freedom for our
+   intended transformation, and does not limit the second instruction
+   scheduler pass.  */
+   
+static void
+find_moveable_pseudos (void)
+{
+  unsigned i;
+  int max_regs = max_reg_num ();
+  int max_uid = get_max_uid ();
+  basic_block bb;
+  int *uid_luid = XNEWVEC (int, max_uid);
+  rtx *closest_uses = XNEWVEC (rtx, max_regs);
+  /* A set of registers which are live but not modified throughout a block.  */
+  bitmap_head *bb_transp_live = XNEWVEC (bitmap_head, last_basic_block);
+  /* A set of registers which only exist in a given basic block.  */
+  bitmap_head *bb_local = XNEWVEC (bitmap_head, last_basic_block);
+  /* A set of registers which are set once, in an instruction that can be
+     moved freely downwards, but are otherwise transparent to a block.  */
+  bitmap_head *bb_moveable_reg_sets = XNEWVEC (bitmap_head, last_basic_block);
+  bitmap_head live, used, set, interesting, unusable_as_input;
+  bitmap_iterator bi;
+  bitmap_initialize (&interesting, 0);
+
+  first_moveable_pseudo = max_regs;
+  VEC_free (rtx, heap, pseudo_move_insn);
+  VEC_free (rtx, heap, pseudo_replaced_reg);
+  VEC_safe_grow (rtx, heap, pseudo_move_insn, max_regs);
+  VEC_safe_grow (rtx, heap, pseudo_replaced_reg, max_regs);
+
+  df_analyze ();
+  calculate_dominance_info (CDI_DOMINATORS);
+
+  i = 0;
+  bitmap_initialize (&live, 0);
+  bitmap_initialize (&used, 0);
+  bitmap_initialize (&set, 0);
+  bitmap_initialize (&unusable_as_input, 0);
+  FOR_EACH_BB (bb)
+    {
+      rtx insn;
+      bitmap transp = bb_transp_live + bb->index;
+      bitmap moveable = bb_moveable_reg_sets + bb->index;
+      bitmap local = bb_local + bb->index;
+
+      bitmap_initialize (local, 0);
+      bitmap_initialize (transp, 0);
+      bitmap_initialize (moveable, 0);
+      bitmap_copy (&live, df_get_live_out (bb));
+      bitmap_and_into (&live, df_get_live_in (bb));
+      bitmap_copy (transp, &live);
+      bitmap_clear (moveable);
+      bitmap_clear (&live);
+      bitmap_clear (&used);
+      bitmap_clear (&set);
+      FOR_BB_INSNS (bb, insn)
+	if (NONDEBUG_INSN_P (insn))
+	  {
+	    df_ref *u_rec, *d_rec;
+
+	    uid_luid[INSN_UID (insn)] = i++;
+	    
+	    u_rec = DF_INSN_USES (insn);
+	    d_rec = DF_INSN_DEFS (insn);
+	    if (d_rec[0] != NULL && d_rec[1] == NULL
+		&& u_rec[0] != NULL && u_rec[1] == NULL
+		&& DF_REF_REGNO (*u_rec) == DF_REF_REGNO (*d_rec)
+		&& !bitmap_bit_p (&set, DF_REF_REGNO (*u_rec))
+		&& rtx_moveable_p (&PATTERN (insn), OP_IN))
+	      {
+		unsigned regno = DF_REF_REGNO (*u_rec);
+		bitmap_set_bit (moveable, regno);
+		bitmap_set_bit (&set, regno);
+		bitmap_set_bit (&used, regno);
+		bitmap_clear_bit (transp, regno);
+		continue;
+	      }
+	    while (*u_rec)
+	      {
+		unsigned regno = DF_REF_REGNO (*u_rec);
+		bitmap_set_bit (&used, regno);
+		if (bitmap_clear_bit (moveable, regno))
+		  bitmap_clear_bit (transp, regno);
+		u_rec++;
+	      }
+
+	    while (*d_rec)
+	      {
+		unsigned regno = DF_REF_REGNO (*d_rec);
+		bitmap_set_bit (&set, regno);
+		bitmap_clear_bit (transp, regno);
+		bitmap_clear_bit (moveable, regno);
+		d_rec++;
+	      }
+	  }
+    }
+
+  bitmap_clear (&live);
+  bitmap_clear (&used);
+  bitmap_clear (&set);
+
+  FOR_EACH_BB (bb)
+    {
+      bitmap local = bb_local + bb->index;
+      rtx insn;
+
+      FOR_BB_INSNS (bb, insn)
+	if (NONDEBUG_INSN_P (insn))
+	  {
+	    rtx def_insn, closest_use, note;
+	    df_ref *def_rec, def, use;
+	    unsigned regno;
+	    bool all_dominated, all_local;
+	    enum machine_mode mode;
+
+	    def_rec = DF_INSN_DEFS (insn);
+	    /* There must be exactly one def in this insn.  */
+	    def = *def_rec;
+	    if (!def || def_rec[1] || !single_set (insn))
+	      continue;
+	    /* This must be the only definition of the reg.  We also limit
+	       which modes we deal with so that we can assume we can generate
+	       move instructions.  */
+	    regno = DF_REF_REGNO (def);
+	    mode = GET_MODE (DF_REF_REG (def));
+	    if (DF_REG_DEF_COUNT (regno) != 1
+		|| !DF_REF_INSN_INFO (def)
+		|| HARD_REGISTER_NUM_P (regno)
+		|| (!INTEGRAL_MODE_P (mode) && !FLOAT_MODE_P (mode)))
+	      continue;
+	    def_insn = DF_REF_INSN (def);
+
+	    for (note = REG_NOTES (def_insn); note; note = XEXP (note, 1))
+	      if (REG_NOTE_KIND (note) == REG_EQUIV && MEM_P (XEXP (note, 0)))
+		break;
+		
+	    if (note)
+	      {
+		if (dump_file)
+		  fprintf (dump_file, "Ignoring reg %d, has equiv memory\n",
+			   regno);
+		bitmap_set_bit (&unusable_as_input, regno);
+		continue;
+	      }
+
+	    use = DF_REG_USE_CHAIN (regno);
+	    all_dominated = true;
+	    all_local = true;
+	    closest_use = NULL_RTX;
+	    for (; use; use = DF_REF_NEXT_REG (use))
+	      {
+		rtx insn;
+		if (!DF_REF_INSN_INFO (use))
+		  {
+		    all_dominated = false;
+		    all_local = false;
+		    break;
+		  }
+		insn = DF_REF_INSN (use);
+		if (DEBUG_INSN_P (insn))
+		  continue;
+		if (BLOCK_FOR_INSN (insn) != BLOCK_FOR_INSN (def_insn))
+		  all_local = false;
+		if (!insn_dominated_by_p (insn, def_insn, uid_luid))
+		  all_dominated = false;
+		if (closest_use != insn && closest_use != const0_rtx)
+		  {
+		    if (closest_use == NULL_RTX)
+		      closest_use = insn;
+		    else if (insn_dominated_by_p (closest_use, insn, uid_luid))
+		      closest_use = insn;
+		    else if (!insn_dominated_by_p (insn, closest_use, uid_luid))
+		      closest_use = const0_rtx;
+		  }
+	      }
+	    if (!all_dominated)
+	      {
+		if (dump_file)
+		  fprintf (dump_file, "Reg %d not all uses dominated by set\n",
+			   regno);
+		continue;
+	      }
+	    if (all_local)
+	      bitmap_set_bit (local, regno);
+	    if (closest_use == const0_rtx || closest_use == NULL
+		|| next_nonnote_nondebug_insn (def_insn) == closest_use)
+	      {
+		if (dump_file)
+		  fprintf (dump_file, "Reg %d uninteresting%s\n", regno,
+			   closest_use == const0_rtx || closest_use == NULL
+			   ? " (no unique first use)" : "");
+		continue;
+	      }
+#ifdef HAVE_cc0
+	    if (reg_referenced_p (cc0_rtx, PATTERN (closest_use)))
+	      {
+		if (dump_file)
+		  fprintf (dump_file, "Reg %d: closest user uses cc0\n",
+			   regno);
+		continue;
+	      }
+#endif
+	    bitmap_set_bit (&interesting, regno);
+	    closest_uses[regno] = closest_use;
+
+	    if (dump_file && (all_local || all_dominated))
+	      {
+		fprintf (dump_file, "Reg %u:", regno);
+		if (all_local)
+		  fprintf (dump_file, " local to bb %d", bb->index);
+		if (all_dominated)
+		  fprintf (dump_file, " def dominates all uses");
+		if (closest_use != const0_rtx)
+		  fprintf (dump_file, " has unique first use");
+		fputs ("\n", dump_file);
+	      }
+	  }
+    }
+
+  EXECUTE_IF_SET_IN_BITMAP (&interesting, 0, i, bi)
+    {
+      df_ref def = DF_REG_DEF_CHAIN (i);
+      rtx def_insn = DF_REF_INSN (def);
+      basic_block def_block = BLOCK_FOR_INSN (def_insn);
+      bitmap def_bb_local = bb_local + def_block->index;
+      bitmap def_bb_moveable = bb_moveable_reg_sets + def_block->index;
+      bitmap def_bb_transp = bb_transp_live + def_block->index;
+      bool local_to_bb_p = bitmap_bit_p (def_bb_local, i);
+      rtx use_insn = closest_uses[i];
+      df_ref *def_insn_use_rec = DF_INSN_USES (def_insn);
+      bool all_ok = true;
+      bool all_transp = true;
+
+      if (!REG_P (DF_REF_REG (def)))
+	continue;
+
+      if (!local_to_bb_p)
+	{
+	  if (dump_file)
+	    fprintf (dump_file, "Reg %u not local to one basic block\n",
+		     i);
+	  continue;
+	}
+      if (reg_equiv_init[i] != NULL_RTX)
+	{
+	  if (dump_file)
+	    fprintf (dump_file, "Ignoring reg %u with equiv init insn\n",
+		     i);
+	  continue;
+	}
+      if (!rtx_moveable_p (&PATTERN (def_insn), OP_IN))
+	{
+	  if (dump_file)
+	    fprintf (dump_file, "Found def insn %d for %d to be not moveable\n",
+		     INSN_UID (def_insn), i);
+	  continue;
+	}
+      if (dump_file)
+	fprintf (dump_file, "Examining insn %d, def for %d\n",
+		 INSN_UID (def_insn), i);
+      while (*def_insn_use_rec != NULL)
+	{
+	  df_ref use = *def_insn_use_rec;
+	  unsigned regno = DF_REF_REGNO (use);
+	  if (bitmap_bit_p (&unusable_as_input, regno))
+	    {
+	      all_ok = false;
+	      if (dump_file)
+		fprintf (dump_file, "  found unusable input reg %u.\n", regno);
+	      break;
+	    }
+	  if (!bitmap_bit_p (def_bb_transp, regno))
+	    {
+	      if (bitmap_bit_p (def_bb_moveable, regno)
+		  && !control_flow_insn_p (use_insn)
+#ifdef HAVE_cc0
+		  && !sets_cc0_p (use_insn)
+#endif
+		  )
+		{
+		  if (modified_between_p (DF_REF_REG (use), def_insn, use_insn))
+		    {
+		      rtx x = NEXT_INSN (def_insn);
+		      while (!modified_in_p (DF_REF_REG (use), x))
+			{
+			  gcc_assert (x != use_insn);
+			  x = NEXT_INSN (x);
+			}
+		      if (dump_file)
+			fprintf (dump_file, "  input reg %u modified but insn %d moveable\n",
+				 regno, INSN_UID (x));
+		      emit_insn_after (PATTERN (x), use_insn);
+		      set_insn_deleted (x);
+		    }
+		  else
+		    {
+		      if (dump_file)
+			fprintf (dump_file, "  input reg %u modified between def and use\n",
+				 regno);
+		      all_transp = false;
+		    }
+		}
+	      else
+		all_transp = false;
+	    }
+
+	  def_insn_use_rec++;
+	}
+      if (!all_ok)
+	continue;
+      if (!dbg_cnt (ira_move))
+	break;
+      if (dump_file)
+	fprintf (dump_file, "  all ok%s\n", all_transp ? " and transp" : "");
+
+      if (all_transp)
+	{
+	  rtx def_reg = DF_REF_REG (def);
+	  rtx newreg = ira_create_new_reg (def_reg);
+	  if (validate_change (def_insn, DF_REF_LOC (def), newreg, 0))
+	    {
+	      unsigned nregno = REGNO (newreg);
+	      rtx move = emit_insn_before (gen_move_insn (def_reg, newreg),
+					   use_insn);
+	      nregno -= max_regs;
+	      VEC_replace (rtx, pseudo_move_insn, nregno, move);
+	      VEC_replace (rtx, pseudo_replaced_reg, nregno, def_reg);
+	    }
+	}
+    }
+  
+  FOR_EACH_BB (bb)
+    {
+      bitmap_clear (bb_local + bb->index);
+      bitmap_clear (bb_transp_live + bb->index);
+      bitmap_clear (bb_moveable_reg_sets + bb->index);
+    }
+  bitmap_clear (&interesting);
+  bitmap_clear (&unusable_as_input);
+  free (uid_luid);
+  free (closest_uses);
+  free (bb_local);
+  free (bb_transp_live);
+  free (bb_moveable_reg_sets);
+
+  last_moveable_pseudo = max_reg_num ();
+
+  fix_reg_equiv_init();
+  regstat_free_n_sets_and_refs ();
+  regstat_free_ri ();
+  regstat_init_n_sets_and_refs ();
+  regstat_compute_ri ();
+}
+
+/* Perform the second half of the transformation started in
+   find_moveable_pseudos.  We look for instances where the newly introduced
+   pseudo remains unallocated, and remove it by moving the definition to
+   just before its use, replacing the move instruction generated by
+   find_moveable_pseudos.  */
+static void
+move_unallocated_pseudos (void)
+{
+  int i;
+  for (i = first_moveable_pseudo; i < last_moveable_pseudo; i++)
+    if (reg_renumber[i] < 0)
+      {
+	df_ref def = DF_REG_DEF_CHAIN (i);
+	int idx = i - first_moveable_pseudo;
+	rtx other_reg = VEC_index (rtx, pseudo_replaced_reg, idx);
+	rtx def_insn = DF_REF_INSN (def);
+	rtx move_insn = VEC_index (rtx, pseudo_move_insn, idx);
+	rtx set;
+	rtx newinsn = emit_insn_after (PATTERN (def_insn), move_insn);
+	int success;
+
+	if (dump_file)
+	  fprintf (dump_file, "moving def of %d (insn %d now) ",
+		   REGNO (other_reg), INSN_UID (def_insn));
+
+	set = single_set (newinsn);
+	success = validate_change (newinsn, &SET_DEST (set), other_reg, 0);
+	gcc_assert (success);
+	if (dump_file)
+	  fprintf (dump_file, " %d) rather than keep unallocated replacement %d\n",
+		   INSN_UID (newinsn), i);
+	delete_insn (move_insn);
+	delete_insn (def_insn);
+	SET_REG_N_REFS (i, 0);
+      }
+}
+
 /* Allocate memory for reg_equiv_memory_loc.  */
 static void
 init_reg_equiv_memory_loc (void)
@@ -3064,6 +3578,89 @@
   reg_equiv_memory_loc = VEC_address (rtx, reg_equiv_memory_loc_vec);
 }
 
+/* Look for CALL_INSNS with a SET in their CALL_INSN_FUNCTION_USAGE.  Such
+   a SET indicates that a function returns one of its arguments.  If we
+   find such a case, we can look backwards from the call to see if the
+   argument hard register is set from a pseudo, and make that pseudo not
+   live across the call by inserting a copy from the return register after
+   the call.  If the pseudo is still allocated a call-saved register,
+   copy propagation will later eliminate the unnecessary copy.  */
+
+static void
+create_sets_for_returned_args (void)
+{
+  basic_block bb;
+  bitmap_head regs_live;
+
+  bitmap_initialize (&regs_live, 0);
+
+  FOR_EACH_BB (bb)
+    {
+      rtx insn;
+      bitmap_copy (&regs_live, DF_LR_OUT (bb));
+      df_simulate_initialize_backwards (bb, &regs_live);
+      FOR_BB_INSNS_REVERSE (bb, insn)
+	{
+	  if (CALL_P (insn))
+	    {
+	      rtx exp = CALL_INSN_FUNCTION_USAGE (insn);
+	      while (exp != NULL)
+		{
+		  rtx x = XEXP (exp, 0);
+		  if (GET_CODE (x) == SET)
+		    {
+		      exp = x;
+		      break;
+		    }
+		  exp = XEXP (exp, 1);
+		}
+	      if (exp != NULL)
+		{
+		  rtx reg = SET_SRC (exp);
+		  rtx exp_dest = SET_DEST (exp);
+		  rtx prev = PREV_INSN (insn);
+		  while (prev && !(INSN_P (prev)
+				   && BLOCK_FOR_INSN (prev) != bb))
+		    {
+		      if (NONDEBUG_INSN_P (prev))
+			{
+			  rtx set = single_set (prev);
+			  if (set && rtx_equal_p (SET_DEST (set), reg))
+			    {
+			      rtx src = SET_SRC (set);
+			      if (!REG_P (src) || HARD_REGISTER_P (src)
+				  || !bitmap_bit_p (&regs_live, REGNO (src)))
+				break;
+			      if (modified_between_p (src, prev, insn))
+				break;
+			      emit_insn_after (gen_move_insn (src, exp_dest),
+					       insn);
+			      break;
+			    }
+			  if (set && rtx_equal_p (SET_SRC (set), reg))
+			    {
+			      rtx dest = SET_DEST (set);
+			      if (!REG_P (dest) || HARD_REGISTER_P (dest)
+				  || !bitmap_bit_p (&regs_live, REGNO (dest)))
+				break;
+			      if (modified_between_p (dest, prev, insn))
+				break;
+			      emit_insn_after (gen_move_insn (dest, exp_dest),
+					       insn);
+			      break;
+			    }
+			  if (reg_overlap_mentioned_p (reg, PATTERN (prev)))
+			    break;
+			}
+		      prev = PREV_INSN (prev);
+		    }
+		}
+	    }
+	  df_simulate_one_insn_backwards (bb, insn, &regs_live);
+	}
+    }
+}
+
 /* All natural loops.  */
 struct loops ira_loops;
 
@@ -3113,6 +3710,9 @@
 #endif
   df_analyze ();
   df_clear_flags (DF_NO_INSN_RESCAN);
+
+  create_sets_for_returned_args ();
+
   regstat_init_n_sets_and_refs ();
   regstat_compute_ri ();
 
@@ -3156,6 +3756,8 @@
 	}
     }
 
+  find_moveable_pseudos ();
+
   max_regno_before_ira = allocated_reg_info_size = max_reg_num ();
   ira_setup_eliminable_regset ();
 
@@ -3265,6 +3867,7 @@
 	      max_regno * sizeof (struct ira_spilled_reg_stack_slot));
     }
 
+  move_unallocated_pseudos ();
   timevar_pop (TV_IRA);
 
   timevar_push (TV_RELOAD);
diff -ru ./gcc/ira-costs.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-costs.c
--- ./gcc/ira-costs.c	2014-06-06 11:50:17.539598677 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-costs.c	2012-03-29 18:03:19.000000000 +1000
@@ -724,11 +724,11 @@
 
 /* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudo registers.  */
 static inline bool
-ok_for_index_p_nonstrict (rtx reg)
+ok_for_index_p_nonstrict (rtx reg, enum machine_mode mode)
 {
   unsigned regno = REGNO (reg);
 
-  return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);
+  return regno >= FIRST_PSEUDO_REGISTER || ok_for_index_p_1 (regno, mode);
 }
 
 /* A version of regno_ok_for_base_p for use here, when all
@@ -766,7 +766,7 @@
   enum reg_class rclass;
 
   if (context == 1)
-    rclass = INDEX_REG_CLASS;
+    rclass = index_reg_class (mode);
   else
     rclass = base_reg_class (mode, outer_code, index_code);
 
@@ -813,7 +813,8 @@
 	   just record registers in any non-constant operands.  We
 	   assume here, as well as in the tests below, that all
 	   addresses are in canonical form.  */
-	else if (INDEX_REG_CLASS == base_reg_class (VOIDmode, PLUS, SCRATCH))
+	else if (index_reg_class (mode)
+		 == base_reg_class (mode, PLUS, SCRATCH))
 	  {
 	    record_address_regs (mode, arg0, context, PLUS, code1, scale);
 	    if (! CONSTANT_P (arg1))
@@ -834,7 +835,7 @@
 	else if (code0 == REG && code1 == REG
 		 && REGNO (arg0) < FIRST_PSEUDO_REGISTER
 		 && (ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)
-		     || ok_for_index_p_nonstrict (arg0)))
+		     || ok_for_index_p_nonstrict (arg0, mode)))
 	  record_address_regs (mode, arg1,
 			       ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)
 			       ? 1 : 0,
@@ -842,7 +843,7 @@
 	else if (code0 == REG && code1 == REG
 		 && REGNO (arg1) < FIRST_PSEUDO_REGISTER
 		 && (ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)
-		     || ok_for_index_p_nonstrict (arg1)))
+		     || ok_for_index_p_nonstrict (arg1, mode)))
 	  record_address_regs (mode, arg0,
 			       ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)
 			       ? 1 : 0,
@@ -1295,12 +1296,16 @@
 		      /* Propagate costs to upper levels in the region
 			 tree.  */
 		      parent_a_num = ALLOCNO_NUM (parent_a);
+		      if (i >= first_moveable_pseudo && i < last_moveable_pseudo)
+			COSTS (total_allocno_costs, parent_a_num)->mem_cost = 0;
 		      for (k = 0; k < cost_classes_num; k++)
 			COSTS (total_allocno_costs, parent_a_num)->cost[k]
 			  += COSTS (total_allocno_costs, a_num)->cost[k];
 		      COSTS (total_allocno_costs, parent_a_num)->mem_cost
 			+= COSTS (total_allocno_costs, a_num)->mem_cost;
 		    }
+		  if (i >= first_moveable_pseudo && i < last_moveable_pseudo)
+		    COSTS (costs, a_num)->mem_cost = 0;
 		  for (k = 0; k < cost_classes_num; k++)
 		    temp_costs->cost[k] += COSTS (costs, a_num)->cost[k];
 		  temp_costs->mem_cost += COSTS (costs, a_num)->mem_cost;
@@ -1310,7 +1315,9 @@
 #endif
 		}
 	    }
-	  if (equiv_savings < 0)
+	  if (i >= first_moveable_pseudo && i < last_moveable_pseudo)
+	    temp_costs->mem_cost = 0;
+	  else if (equiv_savings < 0)
 	    temp_costs->mem_cost = -equiv_savings;
 	  else if (equiv_savings > 0)
 	    {
@@ -1766,17 +1773,27 @@
 	      regno = ira_class_hard_regs[cover_class][j];
 	      rclass = REGNO_REG_CLASS (regno);
 	      cost = 0;
-	      if (! ira_hard_reg_not_in_set_p (regno, mode, call_used_reg_set)
-		  || HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))
-		cost += (ALLOCNO_CALL_FREQ (a)
-			 * (ira_memory_move_cost[mode][rclass][0]
+
+	      /* If regno is not clobbered by call set its cost to zero.
+		 This is to make this regno preferable choice for
+		 allocation.  */
+	      if (! ira_hard_reg_not_in_set_p
+		  (regno, mode, ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a)))
+		{
+		  if (! ira_hard_reg_not_in_set_p (regno, mode,
+						   call_used_reg_set)
+		      || HARD_REGNO_CALL_PART_CLOBBERED (regno, mode))
+		    cost += (ALLOCNO_CALL_FREQ (a)
+			     * (ira_memory_move_cost[mode][rclass][0]
 			    + ira_memory_move_cost[mode][rclass][1]));
 #ifdef IRA_HARD_REGNO_ADD_COST_MULTIPLIER
-	      cost += ((ira_memory_move_cost[mode][rclass][0]
-			+ ira_memory_move_cost[mode][rclass][1])
-		       * ALLOCNO_FREQ (a)
-		       * IRA_HARD_REGNO_ADD_COST_MULTIPLIER (regno) / 2);
+		  cost += ((ira_memory_move_cost[mode][rclass][0]
+			    + ira_memory_move_cost[mode][rclass][1])
+			   * ALLOCNO_FREQ (a)
+			   * IRA_HARD_REGNO_ADD_COST_MULTIPLIER (regno) / 2);
 #endif
+		}
+
 	      reg_costs[j] += cost;
 	      if (min_cost > reg_costs[j])
 		min_cost = reg_costs[j];
diff -ru ./gcc/ira-emit.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-emit.c
--- ./gcc/ira-emit.c	2014-06-06 11:50:17.539598677 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-emit.c	2012-03-29 18:03:19.000000000 +1000
@@ -217,8 +217,8 @@
 
 /* Create and return new pseudo-register with the same attributes as
    ORIGINAL_REG.  */
-static rtx
-create_new_reg (rtx original_reg)
+rtx
+ira_create_new_reg (rtx original_reg)
 {
   rtx new_reg;
 
@@ -506,7 +506,7 @@
 		fprintf (ira_dump_file, "  %i vs parent %i:",
 			 ALLOCNO_HARD_REGNO (allocno),
 			 ALLOCNO_HARD_REGNO (parent_allocno));
-	      set_allocno_reg (allocno, create_new_reg (original_reg));
+	      set_allocno_reg (allocno, ira_create_new_reg (original_reg));
 	    }
 	}
     }
@@ -527,7 +527,7 @@
       if (! used_p)
 	continue;
       bitmap_set_bit (renamed_regno_bitmap, regno);
-      set_allocno_reg (allocno, create_new_reg (ALLOCNO_REG (allocno)));
+      set_allocno_reg (allocno, ira_create_new_reg (ALLOCNO_REG (allocno)));
     }
 }
 
@@ -733,7 +733,7 @@
 		ALLOCNO_ASSIGNED_P (new_allocno) = true;
 		ALLOCNO_HARD_REGNO (new_allocno) = -1;
 		ALLOCNO_REG (new_allocno)
-		  = create_new_reg (ALLOCNO_REG (set_move->to));
+		  = ira_create_new_reg (ALLOCNO_REG (set_move->to));
 
 		/* Make it possibly conflicting with all earlier
 		   created allocnos.  Cases where temporary allocnos
diff -ru ./gcc/ira-int.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-int.h
--- ./gcc/ira-int.h	2014-06-06 14:25:27.518150553 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-int.h	2012-03-29 18:03:19.000000000 +1000
@@ -359,6 +359,8 @@
   int call_freq;
   /* Accumulated number of the intersected calls.  */
   int calls_crossed_num;
+  /* Registers clobbered by intersected calls.  */
+  HARD_REG_SET crossed_calls_clobbered_regs;
   /* TRUE if the allocno assigned to memory was a destination of
      removed move (see ira-emit.c) at loop exit because the value of
      the corresponding pseudo-register is not changed inside the
@@ -453,6 +455,8 @@
 #define ALLOCNO_HARD_REGNO(A) ((A)->hard_regno)
 #define ALLOCNO_CALL_FREQ(A) ((A)->call_freq)
 #define ALLOCNO_CALLS_CROSSED_NUM(A) ((A)->calls_crossed_num)
+#define ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS(A) \
+  ((A)->crossed_calls_clobbered_regs)
 #define ALLOCNO_MEM_OPTIMIZED_DEST(A) ((A)->mem_optimized_dest)
 #define ALLOCNO_MEM_OPTIMIZED_DEST_P(A) ((A)->mem_optimized_dest_p)
 #define ALLOCNO_SOMEWHERE_RENAMED_P(A) ((A)->somewhere_renamed_p)
@@ -1383,3 +1387,6 @@
 	reg_costs[i] = val;
     }
 }
+
+extern rtx ira_create_new_reg (rtx);
+extern int first_moveable_pseudo, last_moveable_pseudo;
diff -ru ./gcc/ira-lives.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-lives.c
--- ./gcc/ira-lives.c	2014-06-06 11:50:17.539598677 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/ira-lives.c	2012-03-29 18:03:19.000000000 +1000
@@ -1168,6 +1168,10 @@
 		  ira_object_t obj = ira_object_id_map[i];
 		  ira_allocno_t a = OBJECT_ALLOCNO (obj);
 		  int num = ALLOCNO_NUM (a);
+		  HARD_REG_SET this_call_used_reg_set;
+
+		  get_call_reg_set_usage (insn, &this_call_used_reg_set,
+					  call_used_reg_set);
 
 		  /* Don't allocate allocnos that cross setjmps or any
 		     call, if this function receives a nonlocal
@@ -1182,9 +1186,9 @@
 		  if (can_throw_internal (insn))
 		    {
 		      IOR_HARD_REG_SET (OBJECT_CONFLICT_HARD_REGS (obj),
-					call_used_reg_set);
+					this_call_used_reg_set);
 		      IOR_HARD_REG_SET (OBJECT_TOTAL_CONFLICT_HARD_REGS (obj),
-					call_used_reg_set);
+					this_call_used_reg_set);
 		    }
 
 		  if (sparseset_bit_p (allocnos_processed, num))
@@ -1201,6 +1205,9 @@
 		  /* Mark it as saved at the next call.  */
 		  allocno_saved_at_call[num] = last_call_num + 1;
 		  ALLOCNO_CALLS_CROSSED_NUM (a)++;
+		  IOR_HARD_REG_SET (ALLOCNO_CROSSED_CALLS_CLOBBERED_REGS (a),
+				    this_call_used_reg_set);
+
 		}
 	    }
 
diff -ru ./gcc/java/Make-lang.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/java/Make-lang.in
--- ./gcc/java/Make-lang.in	2014-06-06 11:50:17.559598678 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/java/Make-lang.in	2012-03-29 17:55:09.000000000 +1000
@@ -333,7 +333,7 @@
 java/jcf-path.o: java/jcf-path.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
   java/jcf.h
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
-	  -DLIBGCJ_ZIP_FILE='"$(datadir)/java/libgcj-$(version).jar"' \
+	  -DLIBGCJ_ZIP_FILE='"$(jardir)/java/libgcj-$(version).jar"' \
 	  -DDEFAULT_TARGET_VERSION=\"$(version)\" \
 	  $(srcdir)/java/jcf-path.c $(OUTPUT_OPTION)
 
diff -ru ./gcc/jump.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/jump.c
--- ./gcc/jump.c	2014-06-06 11:50:18.319598707 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/jump.c	2012-03-29 18:03:19.000000000 +1000
@@ -29,7 +29,8 @@
    JUMP_LABEL internal field.  With this we can detect labels that
    become unused because of the deletion of all the jumps that
    formerly used them.  The JUMP_LABEL info is sometimes looked
-   at by later passes.
+   at by later passes.  For return insns, it contains either a
+   RETURN or a SIMPLE_RETURN rtx.
 
    The subroutines redirect_jump and invert_jump are used
    from other passes as well.  */
@@ -741,10 +742,10 @@
     return (GET_CODE (x) == IF_THEN_ELSE
 	    && ((GET_CODE (XEXP (x, 2)) == PC
 		 && (GET_CODE (XEXP (x, 1)) == LABEL_REF
-		     || GET_CODE (XEXP (x, 1)) == RETURN))
+		     || ANY_RETURN_P (XEXP (x, 1))))
 		|| (GET_CODE (XEXP (x, 1)) == PC
 		    && (GET_CODE (XEXP (x, 2)) == LABEL_REF
-			|| GET_CODE (XEXP (x, 2)) == RETURN))));
+			|| ANY_RETURN_P (XEXP (x, 2))))));
 }
 
 /* Return nonzero if INSN is a (possibly) conditional jump inside a
@@ -773,11 +774,11 @@
     return 0;
   if (XEXP (SET_SRC (x), 2) == pc_rtx
       && (GET_CODE (XEXP (SET_SRC (x), 1)) == LABEL_REF
-	  || GET_CODE (XEXP (SET_SRC (x), 1)) == RETURN))
+	  || ANY_RETURN_P (XEXP (SET_SRC (x), 1)) == RETURN))
     return 1;
   if (XEXP (SET_SRC (x), 1) == pc_rtx
       && (GET_CODE (XEXP (SET_SRC (x), 2)) == LABEL_REF
-	  || GET_CODE (XEXP (SET_SRC (x), 2)) == RETURN))
+	  || ANY_RETURN_P (XEXP (SET_SRC (x), 2))))
     return 1;
   return 0;
 }
@@ -839,8 +840,9 @@
   a = GET_CODE (XEXP (SET_SRC (x), 1));
   b = GET_CODE (XEXP (SET_SRC (x), 2));
 
-  return ((b == PC && (a == LABEL_REF || a == RETURN))
-	  || (a == PC && (b == LABEL_REF || b == RETURN)));
+  return ((b == PC && (a == LABEL_REF || a == RETURN || a == SIMPLE_RETURN))
+	  || (a == PC
+	      && (b == LABEL_REF || b == RETURN || b == SIMPLE_RETURN)));
 }
 
 /* Return the label of a conditional jump.  */
@@ -877,6 +879,7 @@
   switch (GET_CODE (x))
     {
     case RETURN:
+    case SIMPLE_RETURN:
     case EH_RETURN:
       return true;
 
@@ -1199,7 +1202,7 @@
   /* If deleting a jump, decrement the count of the label,
      and delete the label if it is now unused.  */
 
-  if (JUMP_P (insn) && JUMP_LABEL (insn))
+  if (JUMP_P (insn) && JUMP_LABEL (insn) && !ANY_RETURN_P (JUMP_LABEL (insn)))
     {
       rtx lab = JUMP_LABEL (insn), lab_next;
 
@@ -1330,6 +1333,18 @@
      is also an unconditional jump in that case.  */
 }
 
+/* A helper function for redirect_exp_1; examines its input X and returns
+   either a LABEL_REF around a label, or a RETURN if X was NULL.  */
+static rtx
+redirect_target (rtx x)
+{
+  if (x == NULL_RTX)
+    return ret_rtx;
+  if (!ANY_RETURN_P (x))
+    return gen_rtx_LABEL_REF (Pmode, x);
+  return x;
+}
+
 /* Throughout LOC, redirect OLABEL to NLABEL.  Treat null OLABEL or
    NLABEL as a return.  Accrue modifications into the change group.  */
 
@@ -1341,37 +1356,19 @@
   int i;
   const char *fmt;
 
-  if (code == LABEL_REF)
-    {
-      if (XEXP (x, 0) == olabel)
-	{
-	  rtx n;
-	  if (nlabel)
-	    n = gen_rtx_LABEL_REF (Pmode, nlabel);
-	  else
-	    n = gen_rtx_RETURN (VOIDmode);
-
-	  validate_change (insn, loc, n, 1);
-	  return;
-	}
-    }
-  else if (code == RETURN && olabel == 0)
+  if ((code == LABEL_REF && XEXP (x, 0) == olabel)
+      || x == olabel)
     {
-      if (nlabel)
-	x = gen_rtx_LABEL_REF (Pmode, nlabel);
-      else
-	x = gen_rtx_RETURN (VOIDmode);
-      if (loc == &PATTERN (insn))
-	x = gen_rtx_SET (VOIDmode, pc_rtx, x);
-      validate_change (insn, loc, x, 1);
+      validate_change (insn, loc, redirect_target (nlabel), 1);
       return;
     }
 
-  if (code == SET && nlabel == 0 && SET_DEST (x) == pc_rtx
+  if (code == SET && SET_DEST (x) == pc_rtx
+      && ANY_RETURN_P (nlabel)
       && GET_CODE (SET_SRC (x)) == LABEL_REF
       && XEXP (SET_SRC (x), 0) == olabel)
     {
-      validate_change (insn, loc, gen_rtx_RETURN (VOIDmode), 1);
+      validate_change (insn, loc, nlabel, 1);
       return;
     }
 
@@ -1408,6 +1405,7 @@
   int ochanges = num_validated_changes ();
   rtx *loc, asmop;
 
+  gcc_assert (nlabel);
   asmop = extract_asm_operands (PATTERN (jump));
   if (asmop)
     {
@@ -1429,17 +1427,20 @@
    jump target label is unused as a result, it and the code following
    it may be deleted.
 
-   If NLABEL is zero, we are to turn the jump into a (possibly conditional)
-   RETURN insn.
+   Normally, NLABEL will be a label, but it may also be a RETURN or
+   SIMPLE_RETURN rtx; in that case we are to turn the jump into a
+   (possibly conditional) return insn.
 
    The return value will be 1 if the change was made, 0 if it wasn't
-   (this can only occur for NLABEL == 0).  */
+   (this can only occur when trying to produce return insns).  */
 
 int
 redirect_jump (rtx jump, rtx nlabel, int delete_unused)
 {
   rtx olabel = JUMP_LABEL (jump);
 
+  gcc_assert (nlabel != NULL_RTX);
+
   if (nlabel == olabel)
     return 1;
 
@@ -1451,7 +1452,7 @@
 }
 
 /* Fix up JUMP_LABEL and label ref counts after OLABEL has been replaced with
-   NLABEL in JUMP.
+   NEW_DEST in JUMP.
    If DELETE_UNUSED is positive, delete related insn to OLABEL if its ref
    count has dropped to zero.  */
 void
@@ -1467,13 +1468,14 @@
      about this.  */
   gcc_assert (delete_unused >= 0);
   JUMP_LABEL (jump) = nlabel;
-  if (nlabel)
+  if (nlabel && !ANY_RETURN_P (nlabel))
     ++LABEL_NUSES (nlabel);
 
   /* Update labels in any REG_EQUAL note.  */
   if ((note = find_reg_note (jump, REG_EQUAL, NULL_RTX)) != NULL_RTX)
     {
-      if (!nlabel || (invert && !invert_exp_1 (XEXP (note, 0), jump)))
+      if (ANY_RETURN_P (nlabel)
+	  || (invert && !invert_exp_1 (XEXP (note, 0), jump)))
 	remove_note (jump, note);
       else
 	{
@@ -1482,7 +1484,8 @@
 	}
     }
 
-  if (olabel && --LABEL_NUSES (olabel) == 0 && delete_unused > 0
+  if (olabel && !ANY_RETURN_P (olabel)
+      && --LABEL_NUSES (olabel) == 0 && delete_unused > 0
       /* Undefined labels will remain outside the insn stream.  */
       && INSN_UID (olabel))
     delete_related_insns (olabel);
diff -ru ./gcc/libfuncs.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/libfuncs.h
--- ./gcc/libfuncs.h	2014-06-06 11:50:18.323598707 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/libfuncs.h	2012-03-29 18:03:19.000000000 +1000
@@ -40,6 +40,10 @@
   LTI_profile_function_entry,
   LTI_profile_function_exit,
 
+  LTI_profile_call_entry,
+  LTI_profile_call_inside,
+  LTI_profile_call_exit,
+
   LTI_synchronize,
 
   LTI_gcov_flush,
@@ -94,6 +98,10 @@
 #define profile_function_entry_libfunc	(libfunc_table[LTI_profile_function_entry])
 #define profile_function_exit_libfunc	(libfunc_table[LTI_profile_function_exit])
 
+#define profile_call_entry_libfunc	(libfunc_table[LTI_profile_call_entry])
+#define profile_call_inside_libfunc	(libfunc_table[LTI_profile_call_inside])
+#define profile_call_exit_libfunc	(libfunc_table[LTI_profile_call_exit])
+
 #define synchronize_libfunc	(libfunc_table[LTI_synchronize])
 
 #define gcov_flush_libfunc	(libfunc_table[LTI_gcov_flush])
diff -ru ./gcc/libgcc2.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/libgcc2.h
--- ./gcc/libgcc2.h	2014-06-06 11:50:18.327598707 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/libgcc2.h	2012-03-29 18:03:19.000000000 +1000
@@ -193,8 +193,13 @@
 #define UHWtype	UDItype
 #define DWtype	TItype
 #define UDWtype	UTItype
+#ifdef LIBGCC2_GNU_PREFIX
+#define __NW(a,b)	__gnu_ ## a ## di ## b
+#define __NDW(a,b)	__gnu_ ## a ## ti ## b
+#else
 #define __NW(a,b)	__ ## a ## di ## b
 #define __NDW(a,b)	__ ## a ## ti ## b
+#endif
 #define COMPAT_SIMODE_TRAPPING_ARITHMETIC
 #elif LIBGCC2_UNITS_PER_WORD == 4
 #define W_TYPE_SIZE (4 * BITS_PER_UNIT)
@@ -204,8 +209,13 @@
 #define UHWtype	USItype
 #define DWtype	DItype
 #define UDWtype	UDItype
+#ifdef LIBGCC2_GNU_PREFIX
+#define __NW(a,b)	__gnu_ ## a ## si ## b
+#define __NDW(a,b)	__gnu_ ## a ## di ## b
+#else
 #define __NW(a,b)	__ ## a ## si ## b
 #define __NDW(a,b)	__ ## a ## di ## b
+#endif
 #elif LIBGCC2_UNITS_PER_WORD == 2
 #define W_TYPE_SIZE (2 * BITS_PER_UNIT)
 #define Wtype	HItype
@@ -214,8 +224,13 @@
 #define UHWtype	UHItype
 #define DWtype	SItype
 #define UDWtype	USItype
+#ifdef LIBGCC2_GNU_PREFIX
+#define __NW(a,b)	__gnu_ ## a ## hi ## b
+#define __NDW(a,b)	__gnu_ ## a ## si ## b
+#else
 #define __NW(a,b)	__ ## a ## hi ## b
 #define __NDW(a,b)	__ ## a ## si ## b
+#endif
 #else
 #define W_TYPE_SIZE BITS_PER_UNIT
 #define Wtype	QItype
@@ -224,10 +239,20 @@
 #define UHWtype	UQItype
 #define DWtype	HItype
 #define UDWtype	UHItype
+#ifdef LIBGCC2_GNU_PREFIX
+#define __NW(a,b)	__gnu_ ## a ## qi ## b
+#define __NDW(a,b)	__gnu_ ## a ## hi ## b
+#else
 #define __NW(a,b)	__ ## a ## qi ## b
 #define __NDW(a,b)	__ ## a ## hi ## b
 #endif
+#endif
 
+#ifdef LIBGCC2_GNU_PREFIX
+#define __N(a)	__gnu_ ## a
+#else
+#define __N(a)	__ ## a
+#endif
 #define Wtype_MAX ((Wtype)(((UWtype)1 << (W_TYPE_SIZE - 1)) - 1))
 #define Wtype_MIN (- Wtype_MAX - 1)
 
@@ -298,6 +323,50 @@
 #define __popcountDI2	__NDW(popcount,2)
 #define __parityDI2	__NDW(parity,2)
 
+#define __clz_tab		__N(clz_tab)
+#define __bswapsi2		__N(bswapsi2)
+#define __bswapdi2		__N(bswapdi2)
+#define __udiv_w_sdiv		__N(udiv_w_sdiv)
+#define __clear_cache		__N(clear_cache)
+#define __enable_execute_stack	__N(enable_execute_stack)
+
+#ifndef __powisf2
+#define __powisf2		__N(powisf2)
+#endif
+#ifndef __powidf2
+#define __powidf2		__N(powidf2)
+#endif
+#ifndef __powitf2
+#define __powitf2		__N(powitf2)
+#endif
+#ifndef __powixf2
+#define __powixf2		__N(powixf2)
+#endif
+#ifndef __mulsc3
+#define __mulsc3		__N(mulsc3)
+#endif
+#ifndef __muldc3
+#define __muldc3		__N(muldc3)
+#endif
+#ifndef __mulxc3
+#define __mulxc3		__N(mulxc3)
+#endif
+#ifndef __multc3
+#define __multc3		__N(multc3)
+#endif
+#ifndef __divsc3
+#define __divsc3		__N(divsc3)
+#endif
+#ifndef __divdc3
+#define __divdc3		__N(divdc3)
+#endif
+#ifndef __divxc3
+#define __divxc3		__N(divxc3)
+#endif
+#ifndef __divtc3
+#define __divtc3		__N(divtc3)
+#endif
+
 extern DWtype __muldi3 (DWtype, DWtype);
 extern DWtype __divdi3 (DWtype, DWtype);
 extern UDWtype __udivdi3 (UDWtype, UDWtype);
@@ -347,6 +416,12 @@
 extern DWtype __negvDI2 (DWtype);
 
 #ifdef COMPAT_SIMODE_TRAPPING_ARITHMETIC
+#define __absvsi2	__N(absvsi2)
+#define __negvsi2	__N(negvsi2)
+#define __addvsi3	__N(addvsi3)
+#define __subvsi3	__N(subvsi3)
+#define __mulvsi3	__N(mulvsi3)
+
 extern SItype __absvsi2 (SItype);
 extern SItype __addvsi3 (SItype, SItype);
 extern SItype __subvsi3 (SItype, SItype);
Only in ./gcc: libgcc-std.ver
diff -ru ./gcc/lists.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/lists.c
--- ./gcc/lists.c	2014-06-06 11:50:18.331598707 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/lists.c	2012-03-29 18:03:19.000000000 +1000
@@ -164,6 +164,37 @@
   free_list (listp, &unused_insn_list);
 }
 
+/* Make a copy of the INSN_LIST list LINK and return it.  */
+rtx
+copy_INSN_LIST (rtx link)
+{
+  rtx new_queue;
+  rtx *pqueue = &new_queue;
+
+  for (; link; link = XEXP (link, 1))
+    {
+      rtx x = XEXP (link, 0);
+      rtx newlink = alloc_INSN_LIST (x, NULL);
+      *pqueue = newlink;
+      pqueue = &XEXP (newlink, 1);
+    }
+  *pqueue = NULL_RTX;
+  return new_queue;
+}
+
+/* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */
+rtx
+concat_INSN_LIST (rtx copy, rtx old)
+{
+  rtx new_rtx = old;
+  for (; copy ; copy = XEXP (copy, 1))
+    {
+      new_rtx = alloc_INSN_LIST (XEXP (copy, 0), new_rtx);
+      PUT_REG_NOTE_KIND (new_rtx, REG_NOTE_KIND (copy));
+    }
+  return new_rtx;
+}
+
 /* This function will free up an individual EXPR_LIST node.  */
 void
 free_EXPR_LIST_node (rtx ptr)
diff -ru ./gcc/lto/lto-lang.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/lto/lto-lang.c
--- ./gcc/lto/lto-lang.c	2014-06-06 11:50:18.399598710 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/lto/lto-lang.c	2012-03-29 18:02:38.000000000 +1000
@@ -47,6 +47,7 @@
 static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);
 static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);
 static tree handle_format_attribute (tree *, tree, tree, int, bool *);
+static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);
 static tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);
 
 /* Table of machine-independent attributes supported in GIMPLE.  */
@@ -74,6 +75,8 @@
 			      handle_sentinel_attribute },
   { "type generic",           0, 0, false, true, true,
 			      handle_type_generic_attribute },
+  { "fn spec",	 	      1, 1, false, true, true,
+			      handle_fnspec_attribute },
   { NULL,                     0, 0, false, false, false, NULL }
 };
 
@@ -94,11 +97,13 @@
 {
 #define DEF_ATTR_NULL_TREE(ENUM) ENUM,
 #define DEF_ATTR_INT(ENUM, VALUE) ENUM,
+#define DEF_ATTR_STRING(ENUM, VALUE) ENUM,
 #define DEF_ATTR_IDENT(ENUM, STRING) ENUM,
 #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN) ENUM,
 #include "builtin-attrs.def"
 #undef DEF_ATTR_NULL_TREE
 #undef DEF_ATTR_INT
+#undef DEF_ATTR_STRING
 #undef DEF_ATTR_IDENT
 #undef DEF_ATTR_TREE_LIST
   ATTR_LAST
@@ -438,6 +443,20 @@
 }
 
 
+/* Handle a "fn spec" attribute; arguments as in
+   struct attribute_spec.handler.  */
+
+static tree
+handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),
+			 tree args, int ARG_UNUSED (flags),
+			 bool *no_add_attrs ATTRIBUTE_UNUSED)
+{
+  gcc_assert (args
+	      && TREE_CODE (TREE_VALUE (args)) == STRING_CST
+	      && !TREE_CHAIN (args));
+  return NULL_TREE;
+}
+
 /* Cribbed from c-common.c.  */
 
 static void
@@ -524,6 +543,8 @@
   built_in_attributes[(int) ENUM] = NULL_TREE;
 #define DEF_ATTR_INT(ENUM, VALUE)				\
   built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);
+#define DEF_ATTR_STRING(ENUM, VALUE)				\
+  built_in_attributes[(int) ENUM] = build_string (strlen (VALUE), VALUE);
 #define DEF_ATTR_IDENT(ENUM, STRING)				\
   built_in_attributes[(int) ENUM] = get_identifier (STRING);
 #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)	\
diff -ru ./gcc/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/Makefile.in
--- ./gcc/Makefile.in	2014-06-06 14:25:27.206150542 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/Makefile.in	2012-03-29 18:03:19.000000000 +1000
@@ -378,6 +378,8 @@
 # It also specifies -isystem ./include to find, e.g., stddef.h.
 GCC_CFLAGS=$(CFLAGS_FOR_TARGET) $(INTERNAL_CFLAGS) $(T_CFLAGS) $(LOOSE_WARN) $(C_LOOSE_WARN) -Wold-style-definition $($@-warn) -isystem ./include $(TCFLAGS)
 
+EGLIBC_CONFIGS = @EGLIBC_CONFIGS@
+
 # ---------------------------------------------------
 # Programs which produce files for the target machine
 # ---------------------------------------------------
@@ -604,6 +606,23 @@
 exeext = @host_exeext@
 build_exeext = @build_exeext@
 
+licensedir = @licensedir@
+ifneq ($(licensedir),) 
+# Header files for licensing.
+CSL_LICENSEINC = -I $(licensedir)/include
+# Libraries for licensing.
+CSL_LICENSELIB = -L$(licensedir)/lib -lcsllicense
+# The licensing program.  If the program does not exist, assume that
+# it is not needed.
+CSL_LICENSE_PROG = cs-license$(exeext)
+$(CSL_LICENSE_PROG):
+	if [ -f "$(licensedir)/libexec/cs-license$(exeext)" ] ; then \
+	  $(LN_S) $(licensedir)/libexec/cs-license$(exeext) . ;  \
+        else \
+	  touch $@; \
+	fi
+endif
+
 # Directory in which to put man pages.
 mandir = @mandir@
 man1dir = $(mandir)/man1
@@ -667,10 +686,12 @@
 
 # Additional sources to handle exceptions; overridden by targets as needed.
 LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \
+   $(srcdir)/unwind-compact.c \
    $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
 LIB2ADDEHSTATIC = $(LIB2ADDEH)
 LIB2ADDEHSHARED = $(LIB2ADDEH)
-LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h
+LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h \
+  unwind-compact.h unwind-dw2.h
 
 # Don't build libunwind by default.
 LIBUNWIND =
@@ -751,7 +772,7 @@
 
 # List of things which should already be built whenever we try to use xgcc
 # to compile anything (without linking).
-GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
+GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES) $(CSL_LICENSE_PROG)
 
 # Directory to link to, when using the target `maketest'.
 DIR = ../gcc
@@ -1036,7 +1057,7 @@
 # How to link with both our special library facilities
 # and the system's installed libraries.
 LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) \
-	$(HOST_LIBS)
+	$(CSL_LICENSELIB) $(HOST_LIBS)
 BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \
 	$(ZLIB)
 # Any system libraries needed just for GNAT.
@@ -1069,7 +1090,8 @@
 INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
 	   -I$(srcdir)/../include @INCINTL@ \
 	   $(CPPINC) $(GMPINC) $(DECNUMINC) \
-	   $(PPLINC) $(CLOOGINC)
+	   $(PPLINC) $(CLOOGINC) \
+	   $(CSL_LICENSEINC)
 
 .c.o:
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
@@ -1226,6 +1248,7 @@
 	dse.o \
 	dwarf2asm.o \
 	dwarf2out.o \
+	ee.o \
 	ebitmap.o \
 	emit-rtl.o \
 	et-forest.o \
@@ -1387,6 +1410,7 @@
 	tree-profile.o \
 	tree-scalar-evolution.o \
 	tree-sra.o \
+	tree-if-switch-conversion.o \
 	tree-switch-conversion.o \
 	tree-ssa-address.o \
 	tree-ssa-alias.o \
@@ -1407,6 +1431,7 @@
 	tree-ssa-loop-manip.o \
 	tree-ssa-loop-niter.o \
 	tree-ssa-loop-prefetch.o \
+	tree-ssa-loop-promote.o \
 	tree-ssa-loop-unswitch.o \
 	tree-ssa-loop.o \
 	tree-ssa-math-opts.o \
@@ -1416,6 +1441,7 @@
 	tree-ssa-pre.o \
 	tree-ssa-propagate.o \
 	tree-ssa-reassoc.o \
+	tree-ssa-remove-local-statics.o \
 	tree-ssa-sccvn.o \
 	tree-ssa-sink.o \
 	tree-ssa-structalias.o \
@@ -1860,11 +1886,16 @@
 LIB2ADD = $(LIB2FUNCS_EXTRA)
 LIB2ADD_ST = $(LIB2FUNCS_STATIC_EXTRA)
 
-# All source files for libgcc are either in the source directory (in
-# which case they will start with $(srcdir)), or generated into the build
-# directory (in which case they will be relative paths).
-srcdirify = $(patsubst $(srcdir)%,$$(gcc_srcdir)%,$(filter $(srcdir)%,$(1))) \
-            $(patsubst %,$$(gcc_objdir)/%,$(filter-out $(srcdir)%,$(1)))
+# All source files for libgcc are either generated in the libgcc build
+# directory which will be substituted for $$(libgcc_objdir), in the
+# source directory (in which case they will start with $(srcdir)), or
+# generated into the build directory (in which case they will be
+# relative paths).
+srcdirify = $(patsubst $$(libgcc_objdir)/%,%, \
+		$(filter $$(libgcc_objdir)%,$(1))) \
+	    $(patsubst $(srcdir)%,$$(gcc_srcdir)%,$(filter $(srcdir)%,$(1))) \
+	    $(patsubst %,$$(gcc_objdir)/%, \
+		$(filter-out $(srcdir)% $$(libgcc_objdir)%,$(1)))
 
 # The distinction between these two variables is no longer relevant,
 # so we combine them.  Sort removes duplicates.
@@ -1941,10 +1972,11 @@
 	    "$(MULTILIB_EXTRA_OPTS)" \
 	    "$(MULTILIB_EXCLUSIONS)" \
 	    "$(MULTILIB_OSDIRNAMES)" \
+	    "$(MULTILIB_ALIASES)" \
 	    "@enable_multilib@" \
 	    > tmp-mlib.h; \
 	else \
-	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
+	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' '' no \
 	    > tmp-mlib.h; \
 	fi
 	$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h
@@ -2179,7 +2211,7 @@
 
 incpath.o: incpath.c incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \
 		intl.h prefix.h coretypes.h $(TM_H) cppdefault.h $(TARGET_H) \
-		$(MACHMODE_H)
+		$(MACHMODE_H) $(FLAGS_H) toplev.h
 
 prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) prefix.h \
 	Makefile $(BASEVER)
@@ -2577,6 +2609,12 @@
    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) \
    $(DIAGNOSTIC_CORE_H) langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H) \
    $(OPTABS_H) tree-pretty-print.h
+tree-ssa-loop-promote.o: tree-ssa-loop-promote.c \
+   coretypes.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \
+   $(RTL_H) $(TM_P_H) hard-reg-set.h $(OBSTACK_H) $(BASIC_BLOCK_H) \
+   pointer-set.h intl.h $(TREE_H) $(GIMPLE_H) $(HASHTAB_H) $(DIAGNOSTIC_H) \
+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(FLAGS_H) $(TIMEVAR_H) \
+   tree-pass.h $(TM_H) tree-pretty-print.h
 tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \
    $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) \
    $(PARAMS_H) $(DIAGNOSTIC_H) $(TREE_PASS_H) $(TM_H) coretypes.h \
@@ -3084,6 +3122,11 @@
    $(DF_H) $(TIMEVAR_H) tree-pass.h $(RECOG_H) $(EXPR_H) \
    $(REGS_H) $(TREE_H) $(TM_P_H) insn-config.h $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) \
    $(TARGET_H) $(OPTABS_H) insn-codes.h rtlhooks-def.h $(PARAMS_H) $(CGRAPH_H)
+ee.o : ee.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h \
+   $(DF_H) $(TIMEVAR_H) tree-pass.h $(RECOG_H) $(EXPR_H) \
+   $(REGS_H) $(TREE_H) $(TM_P_H) insn-config.h $(INSN_ATTR_H) $(TOPLEV_H) $(DIAGNOSTIC_CORE_H) \
+   $(TARGET_H) $(OPTABS_H) insn-codes.h rtlhooks-def.h $(PARAMS_H) $(CGRAPH_H)
 gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(GGC_H) \
    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h toplev.h $(DIAGNOSTIC_CORE_H) \
@@ -3104,7 +3147,8 @@
 mode-switching.o : mode-switching.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(INSN_ATTR_H) $(RECOG_H) $(BASIC_BLOCK_H) $(TM_P_H) $(FUNCTION_H) \
-   output.h $(TREE_PASS_H) $(TIMEVAR_H) $(DF_H) $(TARGET_H) $(EMIT_RTL_H)
+   output.h $(TREE_PASS_H) $(TIMEVAR_H) $(DF_H) $(TARGET_H) $(EMIT_RTL_H) \
+   integrate.h
 tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \
     $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) \
     coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(FLAGS_H) $(BASIC_BLOCK_H) \
@@ -3125,6 +3169,11 @@
    $(IPA_PROP_H) $(DIAGNOSTIC_H) statistics.h $(TREE_DUMP_H) $(TIMEVAR_H) \
    $(PARAMS_H) $(TARGET_H) $(FLAGS_H) $(EXPR_H) tree-pretty-print.h \
    $(DBGCNT_H) $(TREE_INLINE_H) gimple-pretty-print.h
+tree-if-switch-conversion.o : tree-if-switch-conversion.c $(CONFIG_H) \
+    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) \
+    $(TREE_INLINE_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
+    $(GIMPLE_H) $(TREE_PASS_H) $(FLAGS_H) $(EXPR_H) $(BASIC_BLOCK_H) output.h \
+    $(GGC_H) $(OBSTACK_H) $(PARAMS_H) $(CPPLIB_H) $(PARAMS_H)
 tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \
     $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \
     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(GIMPLE_H) \
@@ -3281,7 +3330,7 @@
    $(RTL_H) $(FLAGS_H) $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) \
    hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(RECOG_H) output.h \
    $(FUNCTION_H) $(DIAGNOSTIC_CORE_H) cselib.h $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(MACHMODE_H) \
-   $(OBSTACK_H) $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)
+   $(OBSTACK_H) $(TARGET_H) $(TIMEVAR_H) $(TREE_PASS_H) addresses.h $(DF_H) $(DBGCNT_H)
 postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(DIAGNOSTIC_CORE_H) \
@@ -3338,7 +3387,7 @@
    $(DF_H) sparseset.h $(IRA_INT_H)
 ira.o: ira.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) $(REGS_H) $(RTL_H) $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(OBSTACK_H) \
-   $(BITMAP_H) hard-reg-set.h $(BASIC_BLOCK_H) \
+   $(BITMAP_H) hard-reg-set.h $(BASIC_BLOCK_H) $(DBGCNT_H) \
    $(EXPR_H) $(RECOG_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) output.h \
    $(EXCEPT_H) reload.h toplev.h $(DIAGNOSTIC_CORE_H) $(INTEGRATE_H) $(DF_H) $(GGC_H) $(IRA_INT_H)
 regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
@@ -3367,7 +3416,7 @@
 haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \
    $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) $(TARGET_H) output.h \
-   $(PARAMS_H) $(DBGCNT_H) $(CFGLOOP_H) ira.h $(EMIT_RTL_H)
+   $(PARAMS_H) $(DBGCNT_H) $(CFGLOOP_H) ira.h $(EMIT_RTL_H) $(HASHTAB_H)
 sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) cselib.h \
@@ -3445,7 +3494,7 @@
 timevar.o : timevar.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TIMEVAR_H) $(FLAGS_H) intl.h toplev.h $(DIAGNOSTIC_CORE_H) $(RTL_H) timevar.def
 regcprop.o : regcprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
-   $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \
+   $(RTL_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h dce.h \
    output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \
    addresses.h reload.h $(DIAGNOSTIC_CORE_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)
 regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
@@ -3750,6 +3799,7 @@
   $(srcdir)/ipa-prop.h \
   $(srcdir)/lto-streamer.h \
   $(srcdir)/target-globals.h \
+  $(srcdir)/final.c \
   @all_gtfiles@
 
 # Compute the list of GT header files from the corresponding C sources,
diff -ru ./gcc/mode-switching.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/mode-switching.c
--- ./gcc/mode-switching.c	2014-06-06 11:50:18.411598710 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/mode-switching.c	2012-03-29 18:03:19.000000000 +1000
@@ -33,6 +33,7 @@
 #include "output.h"
 #include "tm_p.h"
 #include "function.h"
+#include "integrate.h"
 #include "tree-pass.h"
 #include "timevar.h"
 #include "df.h"
@@ -751,6 +752,7 @@
 {
 #ifdef OPTIMIZE_MODE_SWITCHING
   optimize_mode_switching ();
+  emit_initial_value_sets ();
 #endif /* OPTIMIZE_MODE_SWITCHING */
   return 0;
 }
diff -ru ./gcc/modulo-sched.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/modulo-sched.c
--- ./gcc/modulo-sched.c	2014-06-06 11:50:18.411598710 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/modulo-sched.c	2012-03-29 18:03:19.000000000 +1000
@@ -1,5 +1,5 @@
 /* Swing Modulo Scheduling implementation.
-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010
+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>
 
@@ -245,9 +245,7 @@
 
 static void
 compute_jump_reg_dependencies (rtx insn ATTRIBUTE_UNUSED,
-			       regset cond_exec ATTRIBUTE_UNUSED,
-			       regset used ATTRIBUTE_UNUSED,
-			       regset set ATTRIBUTE_UNUSED)
+			       regset used ATTRIBUTE_UNUSED)
 {
 }
 
@@ -275,7 +273,8 @@
   NULL, NULL,
   0, 0,
 
-  NULL, NULL, NULL,
+  NULL, NULL, NULL, NULL,
+  NULL, NULL,
   0
 };
 
diff -ru ./gcc/optabs.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/optabs.c
--- ./gcc/optabs.c	2014-06-06 11:50:18.443598711 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/optabs.c	2012-03-29 18:03:19.000000000 +1000
@@ -4169,11 +4169,13 @@
 	 result against 1 in the biased case, and zero in the unbiased
 	 case. For unsigned comparisons always compare against 1 after
 	 biasing the unbiased result by adding 1. This gives us a way to
-	 represent LTU. */
+	 represent LTU.
+	 The comparisons in the fixed-point helper library are always
+	 biased.  */
       x = result;
       y = const1_rtx;
 
-      if (!TARGET_LIB_INT_CMP_BIASED)
+      if (!TARGET_LIB_INT_CMP_BIASED && !ALL_FIXED_POINT_MODE_P (mode))
 	{
 	  if (unsignedp)
 	    x = plus_constant (result, 1);
@@ -5454,13 +5456,22 @@
   unsigned opname_len = strlen (opname);
   const char *mname = GET_MODE_NAME (mode);
   unsigned mname_len = strlen (mname);
-  char *libfunc_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);
+  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;
+  int len = prefix_len + opname_len + mname_len + 1 + 1;
+  char *libfunc_name = XALLOCAVEC (char, len);
   char *p;
   const char *q;
 
   p = libfunc_name;
   *p++ = '_';
   *p++ = '_';
+  if (targetm.libfunc_gnu_prefix)
+    {
+      *p++ = 'g';
+      *p++ = 'n';
+      *p++ = 'u';
+      *p++ = '_';
+    }
   for (q = opname; *q; )
     *p++ = *q++;
   for (q = mname; *q; q++)
@@ -5664,6 +5675,7 @@
 
   const char *fname, *tname;
   const char *q;
+  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;
   char *libfunc_name, *suffix;
   char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;
   char *p;
@@ -5674,11 +5686,19 @@
 
   mname_len = strlen (GET_MODE_NAME (tmode)) + strlen (GET_MODE_NAME (fmode));
 
-  nondec_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);
+  nondec_name = XALLOCAVEC (char, prefix_len + opname_len + mname_len + 1 + 1);
   nondec_name[0] = '_';
   nondec_name[1] = '_';
-  memcpy (&nondec_name[2], opname, opname_len);
-  nondec_suffix = nondec_name + opname_len + 2;
+  if (targetm.libfunc_gnu_prefix)
+    {
+      nondec_name[2] = 'g';
+      nondec_name[3] = 'n';
+      nondec_name[4] = 'u';
+      nondec_name[5] = '_';
+    }
+
+  memcpy (&nondec_name[prefix_len], opname, opname_len);
+  nondec_suffix = nondec_name + opname_len + prefix_len;
 
   dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);
   dec_name[0] = '_';
@@ -5789,6 +5809,7 @@
 
   const char *fname, *tname;
   const char *q;
+  int prefix_len = targetm.libfunc_gnu_prefix ? 6 : 2;
   char *nondec_name, *dec_name, *nondec_suffix, *dec_suffix;
   char *libfunc_name, *suffix;
   char *p;
@@ -5802,8 +5823,15 @@
   nondec_name = XALLOCAVEC (char, 2 + opname_len + mname_len + 1 + 1);
   nondec_name[0] = '_';
   nondec_name[1] = '_';
-  memcpy (&nondec_name[2], opname, opname_len);
-  nondec_suffix = nondec_name + opname_len + 2;
+  if (targetm.libfunc_gnu_prefix)
+    {
+      nondec_name[2] = 'g';
+      nondec_name[3] = 'n';
+      nondec_name[4] = 'u';
+      nondec_name[5] = '_';
+    }
+  memcpy (&nondec_name[prefix_len], opname, opname_len);
+  nondec_suffix = nondec_name + opname_len + prefix_len;
 
   dec_name = XALLOCAVEC (char, 2 + dec_len + opname_len + mname_len + 1 + 1);
   dec_name[0] = '_';
@@ -6533,8 +6561,16 @@
 
   /* Explicitly initialize the bswap libfuncs since we need them to be
      valid for things other than word_mode.  */
-  set_optab_libfunc (bswap_optab, SImode, "__bswapsi2");
-  set_optab_libfunc (bswap_optab, DImode, "__bswapdi2");
+  if (targetm.libfunc_gnu_prefix)
+    {
+      set_optab_libfunc (bswap_optab, SImode, "__gnu_bswapsi2");
+      set_optab_libfunc (bswap_optab, DImode, "__gnu_bswapdi2");
+    }
+  else
+    {
+      set_optab_libfunc (bswap_optab, SImode, "__bswapsi2");
+      set_optab_libfunc (bswap_optab, DImode, "__bswapdi2");
+    }
 
   /* Use cabs for double complex abs, since systems generally have cabs.
      Don't define any libcall for float complex, so that cabs will be used.  */
@@ -6565,6 +6601,14 @@
   profile_function_exit_libfunc
     = init_one_libfunc ("__cyg_profile_func_exit");
 
+  /* For call entry/exit instrumentation.  */
+  profile_call_entry_libfunc
+    = init_one_libfunc ("__cyg_profile_call_enter");
+  profile_call_inside_libfunc
+    = init_one_libfunc ("__cyg_profile_call_inside");
+  profile_call_exit_libfunc
+    = init_one_libfunc ("__cyg_profile_call_exit");
+
   gcov_flush_libfunc = init_one_libfunc ("__gcov_flush");
 
   /* Allow the target to add more libcalls or rename some, etc.  */
diff -ru ./gcc/opts.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/opts.c
--- ./gcc/opts.c	2014-06-06 11:50:18.451598712 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/opts.c	2012-03-29 18:03:19.000000000 +1000
@@ -481,6 +481,7 @@
     { OPT_LEVELS_2_PLUS, OPT_fstrict_overflow, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_freorder_blocks, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_freorder_functions, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_ftree_if_to_switch_conversion, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_ftree_vrp, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_ftree_builtin_call_dce, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_ftree_pre, NULL, 1 },
@@ -492,6 +493,7 @@
     { OPT_LEVELS_2_PLUS, OPT_falign_jumps, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_falign_labels, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_falign_functions, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_fextension_elimination, NULL, 1 },
 
     /* -O3 optimizations.  */
     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },
@@ -503,6 +505,7 @@
     { OPT_LEVELS_3_PLUS, OPT_fgcse_after_reload, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_ftree_vectorize, NULL, 1 },
     { OPT_LEVELS_3_PLUS, OPT_fipa_cp_clone, NULL, 1 },
+    { OPT_LEVELS_3_PLUS, OPT_ftree_pre_partial_partial, NULL, 1 },
 
     /* -Ofast adds optimizations to -O3.  */
     { OPT_LEVELS_FAST, OPT_ffast_math, NULL, 1 },
@@ -1696,6 +1699,10 @@
       /* No-op. Used by the driver and passed to us because it starts with f.*/
       break;
 
+    case OPT_feglibc_:
+      /* This is a no-op at the moment.  */
+      break;
+
     default:
       /* If the flag was handled in a standard way, assume the lack of
 	 processing here is intentional.  */
diff -ru ./gcc/params.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/params.def
--- ./gcc/params.def	2014-06-06 11:50:18.455598712 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/params.def	2012-03-29 18:03:19.000000000 +1000
@@ -175,6 +175,13 @@
 	 "The maximum length of scheduling's pending operations list",
 	 32, 0, 0)
 
+/* This parameter limits the number of backtracking attempts when using the
+   haifa scheduler for modulo scheduling.  */
+DEFPARAM(PARAM_MAX_MODULO_BACKTRACK_ATTEMPTS,
+	 "max-modulo-backtrack-attempts",
+	 "The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop",
+	 40, 0, 0)
+
 DEFPARAM(PARAM_LARGE_FUNCTION_INSNS,
 	 "large-function-insns",
 	 "The size of function body to be considered large",
@@ -604,6 +611,11 @@
          "The minimal probability of speculation success (in percents), so that speculative insn will be scheduled.",
          40, 0, 100)
 
+DEFPARAM(PARAM_SCHED_STATE_EDGE_PROB_CUTOFF,
+         "sched-state-edge-prob-cutoff",
+         "The minimum probability an edge must have for the scheduler to save its state across it.",
+         10, 0, 100)
+
 DEFPARAM(PARAM_SELSCHED_MAX_LOOKAHEAD,
          "selsched-max-lookahead",
          "The maximum size of the lookahead window of selective scheduling",
@@ -883,6 +895,11 @@
 	  "name lookup fails",
 	  1000, 0, 0)
 
+DEFPARAM (PARAM_IF_TO_SWITCH_THRESHOLD,
+	  "if-to-switch-threshold",
+	  "Threshold for converting an if-chain into a switch",
+	  3, 0, 0)
+
 /*
 Local variables:
 mode:c
diff -ru ./gcc/passes.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/passes.c
--- ./gcc/passes.c	2014-06-06 11:50:18.459598712 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/passes.c	2012-03-29 18:03:19.000000000 +1000
@@ -767,6 +767,7 @@
 	  NEXT_PASS (pass_cd_dce);
 	  NEXT_PASS (pass_early_ipa_sra);
 	  NEXT_PASS (pass_tail_recursion);
+	  NEXT_PASS (pass_if_to_switch);
 	  NEXT_PASS (pass_convert_switch);
           NEXT_PASS (pass_cleanup_eh);
           NEXT_PASS (pass_profile);
@@ -822,6 +823,7 @@
       NEXT_PASS (pass_rename_ssa_copies);
       NEXT_PASS (pass_complete_unrolli);
       NEXT_PASS (pass_ccp);
+      NEXT_PASS (pass_promote_indices);
       NEXT_PASS (pass_forwprop);
       NEXT_PASS (pass_call_cdce);
       /* pass_build_alias is a dummy pass that ensures that we
@@ -829,10 +831,12 @@
 	 alias information also rewrites no longer addressed
 	 locals into SSA form if possible.  */
       NEXT_PASS (pass_build_alias);
+      NEXT_PASS (pass_remove_local_statics);
       NEXT_PASS (pass_return_slot);
       NEXT_PASS (pass_phiprop);
       NEXT_PASS (pass_fre);
       NEXT_PASS (pass_copy_prop);
+      NEXT_PASS (pass_if_to_switch);
       NEXT_PASS (pass_merge_phi);
       NEXT_PASS (pass_vrp);
       NEXT_PASS (pass_dce);
@@ -996,6 +1000,7 @@
       NEXT_PASS (pass_initialize_regs);
       NEXT_PASS (pass_ud_rtl_dce);
       NEXT_PASS (pass_combine);
+      NEXT_PASS (pass_ee);
       NEXT_PASS (pass_if_after_combine);
       NEXT_PASS (pass_partition_blocks);
       NEXT_PASS (pass_regmove);
@@ -1014,6 +1019,7 @@
 	  struct opt_pass **p = &pass_postreload.pass.sub;
 	  NEXT_PASS (pass_postreload_cse);
 	  NEXT_PASS (pass_gcse2);
+	  NEXT_PASS (pass_cprop_hardreg);
 	  NEXT_PASS (pass_split_after_reload);
 	  NEXT_PASS (pass_implicit_zee);
 	  NEXT_PASS (pass_compare_elim_after_reload);
@@ -1024,13 +1030,14 @@
 	  NEXT_PASS (pass_peephole2);
 	  NEXT_PASS (pass_if_after_reload);
 	  NEXT_PASS (pass_regrename);
-	  NEXT_PASS (pass_cprop_hardreg);
+	  NEXT_PASS (pass_cprop_hardreg2);
 	  NEXT_PASS (pass_fast_rtl_dce);
 	  NEXT_PASS (pass_reorder_blocks);
 	  NEXT_PASS (pass_branch_target_load_optimize2);
 	  NEXT_PASS (pass_leaf_regs);
 	  NEXT_PASS (pass_split_before_sched2);
 	  NEXT_PASS (pass_sched2);
+	  NEXT_PASS (pass_peephole2);
 	  NEXT_PASS (pass_stack_regs);
 	    {
 	      struct opt_pass **p = &pass_stack_regs.pass.sub;
diff -ru ./gcc/pointer-set.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/pointer-set.c
--- ./gcc/pointer-set.c	2014-06-06 11:50:19.455598750 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/pointer-set.c	2012-03-29 18:03:19.000000000 +1000
@@ -181,6 +181,23 @@
       break;
 }
 
+/* Return the number of elements in PSET.  */
+
+size_t
+pointer_set_n_elements (struct pointer_set_t *pset)
+{
+  return pset->n_elements;
+}
+
+/* Remove all entries from PSET.  */
+
+void
+pointer_set_clear (struct pointer_set_t *pset)
+{
+  pset->n_elements = 0;
+  memset (pset->slots, 0, sizeof (pset->slots[0]) * pset->n_slots);
+}
+
 
 /* A pointer map is represented the same way as a pointer_set, so
    the hash code is based on the address of the key, rather than
@@ -301,3 +318,20 @@
     if (pmap->keys[i] && !fn (pmap->keys[i], &pmap->values[i], data))
       break;
 }
+
+/* Return the number of elements in PMAP.  */
+
+size_t
+pointer_map_n_elements (struct pointer_map_t *pmap)
+{
+  return pmap->n_elements;
+}
+
+/* Remove all entries from PMAP.  */
+
+void pointer_map_clear (struct pointer_map_t *pmap)
+{
+  pmap->n_elements = 0;
+  memset (pmap->keys, 0, sizeof (pmap->keys[0]) * pmap->n_slots);
+  memset (pmap->values, 0, sizeof (pmap->values[0]) * pmap->n_slots);
+}
diff -ru ./gcc/pointer-set.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/pointer-set.h
--- ./gcc/pointer-set.h	2014-06-06 11:50:19.463598750 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/pointer-set.h	2012-03-29 18:03:19.000000000 +1000
@@ -29,6 +29,8 @@
 void pointer_set_traverse (const struct pointer_set_t *,
 			   bool (*) (const void *, void *),
 			   void *);
+size_t pointer_set_n_elements (struct pointer_set_t *);
+void pointer_set_clear (struct pointer_set_t *);
 
 struct pointer_map_t;
 struct pointer_map_t *pointer_map_create (void);
@@ -38,5 +40,7 @@
 void **pointer_map_insert (struct pointer_map_t *pmap, const void *p);
 void pointer_map_traverse (const struct pointer_map_t *,
 			   bool (*) (const void *, void **, void *), void *);
+size_t pointer_map_n_elements (struct pointer_map_t *);
+void pointer_map_clear (struct pointer_map_t *);
 
 #endif  /* POINTER_SET_H  */
diff -ru ./gcc/postreload.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/postreload.c
--- ./gcc/postreload.c	2014-06-06 11:50:19.479598751 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/postreload.c	2012-03-29 18:03:19.000000000 +1000
@@ -46,6 +46,7 @@
 #include "target.h"
 #include "timevar.h"
 #include "tree-pass.h"
+#include "addresses.h"
 #include "df.h"
 #include "dbgcnt.h"
 
@@ -1122,6 +1123,7 @@
       && reg_state[regno].use_index < RELOAD_COMBINE_MAX_USES
       && last_label_ruid < reg_state[regno].use_ruid)
     {
+      enum reg_class index_regs = index_reg_class (VOIDmode);
       rtx base = XEXP (src, 1);
       rtx prev = prev_nonnote_nondebug_insn (insn);
       rtx prev_set = prev ? single_set (prev) : NULL_RTX;
@@ -1134,8 +1136,8 @@
 	 register+register that we want to use to substitute uses of REG
 	 (typically in MEMs) with.  First check REG and BASE for being
 	 index registers; we can use them even if they are not dead.  */
-      if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], regno)
-	  || TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],
+      if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], regno)
+	  || TEST_HARD_REG_BIT (reg_class_contents[index_regs],
 				REGNO (base)))
 	{
 	  index_reg = reg;
@@ -1149,7 +1151,7 @@
 	     two registers.  */
 	  for (i = first_index_reg; i <= last_index_reg; i++)
 	    {
-	      if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i)
+	      if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], i)
 		  && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES
 		  && reg_state[i].store_ruid <= reg_state[regno].use_ruid
 		  && (call_used_regs[i] || df_regs_ever_live_p (i))
@@ -1237,15 +1239,17 @@
   unsigned int r;
   int min_labelno, n_labels;
   HARD_REG_SET ever_live_at_start, *label_live;
+  enum reg_class index_regs;
 
   /* To avoid wasting too much time later searching for an index register,
      determine the minimum and maximum index register numbers.  */
-  if (INDEX_REG_CLASS == NO_REGS)
+  index_regs = index_reg_class (VOIDmode);
+  if (index_regs == NO_REGS)
     last_index_reg = -1;
   else if (first_index_reg == -1 && last_index_reg == 0)
     {
       for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)
-	if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], r))
+	if (TEST_HARD_REG_BIT (reg_class_contents[index_regs], r))
 	  {
 	    if (first_index_reg == -1)
 	      first_index_reg = r;
@@ -1344,8 +1348,10 @@
 	  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;
 	       link = XEXP (link, 1))
 	    {
-	      rtx usage_rtx = XEXP (XEXP (link, 0), 0);
-	      if (REG_P (usage_rtx))
+	      rtx setuse = XEXP (link, 0);
+	      rtx usage_rtx = XEXP (setuse, 0);
+	      if ((GET_CODE (setuse) == USE || GET_CODE (setuse) == CLOBBER)
+		  && REG_P (usage_rtx))
 	        {
 		  unsigned int i;
 		  unsigned int start_reg = REGNO (usage_rtx);
diff -ru ./gcc/print-rtl.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/print-rtl.c
--- ./gcc/print-rtl.c	2014-06-06 11:50:19.487598751 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/print-rtl.c	2012-03-29 18:03:19.000000000 +1000
@@ -313,9 +313,16 @@
 	      }
 	  }
 	else if (i == 8 && JUMP_P (in_rtx) && JUMP_LABEL (in_rtx) != NULL)
-	  /* Output the JUMP_LABEL reference.  */
-	  fprintf (outfile, "\n%s%*s -> %d", print_rtx_head, indent * 2, "",
-		   INSN_UID (JUMP_LABEL (in_rtx)));
+	  {
+	    /* Output the JUMP_LABEL reference.  */
+	    fprintf (outfile, "\n%s%*s -> ", print_rtx_head, indent * 2, "");
+	    if (GET_CODE (JUMP_LABEL (in_rtx)) == RETURN)
+	      fprintf (outfile, "return");
+	    else if (GET_CODE (JUMP_LABEL (in_rtx)) == SIMPLE_RETURN)
+	      fprintf (outfile, "simple_return");
+	    else
+	      fprintf (outfile, "%d", INSN_UID (JUMP_LABEL (in_rtx)));
+	  }
 	else if (i == 0 && GET_CODE (in_rtx) == VALUE)
 	  {
 #ifndef GENERATOR_FILE
diff -ru ./gcc/regcprop.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/regcprop.c
--- ./gcc/regcprop.c	2014-06-06 11:50:19.539598753 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/regcprop.c	2012-03-29 18:03:19.000000000 +1000
@@ -39,6 +39,7 @@
 #include "timevar.h"
 #include "tree-pass.h"
 #include "df.h"
+#include "dce.h"
 
 /* The following code does forward propagation of hard register copies.
    The object is to eliminate as many dependencies as possible, so that
@@ -254,18 +255,27 @@
     kill_value (x, vd);
 }
 
+/* A structure passed as data to kill_set_value through note_stores.  */
+struct kill_set_value_data
+{
+  struct value_data *vd;
+  rtx ignore_set_reg;
+};
+  
 /* Called through note_stores.  If X is set, not clobbered, kill its
    current value and install it as the root of its own value list.  */
 
 static void
 kill_set_value (rtx x, const_rtx set, void *data)
 {
-  struct value_data *const vd = (struct value_data *) data;
+  struct kill_set_value_data *ksvd = (struct kill_set_value_data *) data;
+  if (rtx_equal_p (x, ksvd->ignore_set_reg))
+    return;
   if (GET_CODE (set) != CLOBBER)
     {
-      kill_value (x, vd);
+      kill_value (x, ksvd->vd);
       if (REG_P (x))
-	set_value_regno (REGNO (x), GET_MODE (x), vd);
+	set_value_regno (REGNO (x), GET_MODE (x), ksvd->vd);
     }
 }
 
@@ -585,14 +595,14 @@
 	    int index_op;
 	    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);
 
-	    if (REGNO_OK_FOR_INDEX_P (regno1)
+	    if (regno_ok_for_index_p (regno1, mode)
 		&& regno_ok_for_base_p (regno0, mode, PLUS, REG))
 	      index_op = 1;
-	    else if (REGNO_OK_FOR_INDEX_P (regno0)
+	    else if (regno_ok_for_index_p (regno0, mode)
 		     && regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
 	    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)
-		     || REGNO_OK_FOR_INDEX_P (regno1))
+		     || regno_ok_for_index_p (regno1, mode))
 	      index_op = 1;
 	    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
@@ -617,8 +627,8 @@
 	  }
 
 	if (locI)
-	  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,
-						insn, vd);
+	  changed |= replace_oldest_value_addr (locI, index_reg_class(mode), 
+						mode, insn, vd);
 	if (locB)
 	  changed |= replace_oldest_value_addr (locB,
 						base_reg_class (mode, PLUS,
@@ -743,6 +753,7 @@
       rtx set;
       bool replaced[MAX_RECOG_OPERANDS];
       bool changed = false;
+      struct kill_set_value_data ksvd;
 
       if (!NONDEBUG_INSN_P (insn))
 	{
@@ -955,14 +966,39 @@
 	    note_uses (&PATTERN (insn), cprop_find_used_regs, vd);
 	}
 
+      ksvd.vd = vd;
+      ksvd.ignore_set_reg = NULL_RTX;
+
       /* Clobber call-clobbered registers.  */
       if (CALL_P (insn))
-	for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
-	  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))
-	    kill_value_regno (i, 1, vd);
+	{
+	  int set_regno = INVALID_REGNUM;
+	  int set_nregs = 0;
+	  rtx exp;
+	  for (exp = CALL_INSN_FUNCTION_USAGE (insn); exp; exp = XEXP (exp, 1))
+	    {
+	      rtx x = XEXP (exp, 0);
+	      if (GET_CODE (x) == SET)
+		{
+		  rtx dest = SET_DEST (x);
+		  kill_value (dest, vd);
+		  set_value_regno (REGNO (dest), GET_MODE (dest), vd);
+		  copy_value (dest, SET_SRC (x), vd);
+		  ksvd.ignore_set_reg = dest;
+		  set_regno = REGNO (dest);
+		  set_nregs
+		    = hard_regno_nregs[set_regno][GET_MODE (dest)];
+		  break;
+		}
+	    }
+	  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
+	    if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)
+		&& (i < set_regno || i >= set_regno + set_nregs))
+	      kill_value_regno (i, 1, vd);
+	}
 
       /* Notice stores.  */
-      note_stores (PATTERN (insn), kill_set_value, vd);
+      note_stores (PATTERN (insn), kill_set_value, &ksvd);
 
       /* Notice copies.  */
       if (set && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))
@@ -1166,12 +1202,28 @@
 }
 #endif
 
+/* An early cprop pass, intended to make it easier for prepare_shrink_wrap
+   to move register moves downwards through the CFG.  */
 static bool
 gate_handle_cprop (void)
 {
-  return (optimize > 0 && (flag_cprop_registers));
+#ifdef HAVE_simple_return
+  return (optimize > 0 && flag_cprop_registers && HAVE_simple_return);
+#else
+  return 0;
+#endif
 }
 
+static unsigned int
+early_copyprop_hardreg_forward (void)
+{
+  unsigned int retval;
+
+  split_all_insns ();
+  retval = copyprop_hardreg_forward ();
+  run_fast_dce ();
+  return retval;
+}
 
 struct rtl_opt_pass pass_cprop_hardreg =
 {
@@ -1179,6 +1231,33 @@
   RTL_PASS,
   "cprop_hardreg",                      /* name */
   gate_handle_cprop,                    /* gate */
+  early_copyprop_hardreg_forward,       /* execute */
+  NULL,                                 /* sub */
+  NULL,                                 /* next */
+  0,                                    /* static_pass_number */
+  TV_CPROP_REGISTERS,                   /* tv_id */
+  0,                                    /* properties_required */
+  0,                                    /* properties_provided */
+  0,                                    /* properties_destroyed */
+  0,                                    /* todo_flags_start */
+  TODO_dump_func | TODO_df_finish
+  | TODO_verify_rtl_sharing		/* todo_flags_finish */
+ }
+};
+
+static bool
+gate_handle_cprop2 (void)
+{
+  return (optimize > 0 && (flag_cprop_registers));
+}
+
+
+struct rtl_opt_pass pass_cprop_hardreg2 =
+{
+ {
+  RTL_PASS,
+  "cprop_hardreg2",                     /* name */
+  gate_handle_cprop2,                   /* gate */
   copyprop_hardreg_forward,             /* execute */
   NULL,                                 /* sub */
   NULL,                                 /* next */
diff -ru ./gcc/reg-notes.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reg-notes.def
--- ./gcc/reg-notes.def	2014-06-06 11:50:19.531598753 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reg-notes.def	2012-03-29 18:03:19.000000000 +1000
@@ -92,6 +92,7 @@
    respectively.  */
 REG_NOTE (DEP_OUTPUT)
 REG_NOTE (DEP_ANTI)
+REG_NOTE (DEP_CONTROL)
 
 /* REG_BR_PROB is attached to JUMP_INSNs and CALL_INSNs.  It has an
    integer value.  For jumps, it is the probability that this is a
diff -ru ./gcc/regrename.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/regrename.c
--- ./gcc/regrename.c	2014-06-06 11:50:19.547598753 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/regrename.c	2012-03-29 18:03:19.000000000 +1000
@@ -868,14 +868,14 @@
 	    int index_op;
 	    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);
 
-	    if (REGNO_OK_FOR_INDEX_P (regno1)
+	    if (regno_ok_for_index_p (regno1, mode)
 		&& regno_ok_for_base_p (regno0, mode, PLUS, REG))
 	      index_op = 1;
-	    else if (REGNO_OK_FOR_INDEX_P (regno0)
+	    else if (regno_ok_for_index_p (regno0, mode)
 		     && regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
 	    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)
-		     || REGNO_OK_FOR_INDEX_P (regno1))
+		     || regno_ok_for_index_p (regno1, mode))
 	      index_op = 1;
 	    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))
 	      index_op = 0;
@@ -900,7 +900,7 @@
 	  }
 
 	if (locI)
-	  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);
+	  scan_rtx_address (insn, locI, index_reg_class (mode), action, mode);
 	if (locB)
 	  scan_rtx_address (insn, locB, base_reg_class (mode, PLUS, index_code),
 			    action, mode);
diff -ru ./gcc/regs.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/regs.h
--- ./gcc/regs.h	2014-06-06 11:50:19.547598753 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/regs.h	2012-03-29 18:03:19.000000000 +1000
@@ -397,4 +397,8 @@
   return false;
 }
 
+/* Get registers used by given function call instruction.  */
+void get_call_reg_set_usage (rtx insn, HARD_REG_SET *reg_set,
+			     HARD_REG_SET default_set);
+
 #endif /* GCC_REGS_H */
diff -ru ./gcc/reload1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reload1.c
--- ./gcc/reload1.c	2014-06-06 11:50:19.575598754 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reload1.c	2012-03-29 18:03:19.000000000 +1000
@@ -2352,6 +2352,19 @@
 
       if (! offsets_known_at[CODE_LABEL_NUMBER (x) - first_label_num])
 	{
+	  if (x == insn)
+	    {
+	      basic_block bb;
+
+	      bb = BLOCK_FOR_INSN (insn);
+
+	      /* If the label is the target of a non-local GOTO, we must use
+	         the initial elimination offsets.  */
+	      if (bb && BB_HEAD (bb) == insn
+		  && (bb->flags & BB_NON_LOCAL_GOTO_TARGET))
+		initial_p = true;
+	    }
+	  
 	  for (i = 0; i < NUM_ELIMINABLE_REGS; i++)
 	    offsets_at[CODE_LABEL_NUMBER (x) - first_label_num][i]
 	      = (initial_p ? reg_eliminate[i].initial_offset
diff -ru ./gcc/reload.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reload.c
--- ./gcc/reload.c	2014-06-06 11:50:19.567598754 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reload.c	2012-03-29 18:03:19.000000000 +1000
@@ -5086,7 +5086,8 @@
 
       if (double_reg_address_ok
 	  && regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode,
-				  PLUS, CONST_INT))
+				  PLUS, CONST_INT)
+	  && index_reg_class (mode) != NO_REGS)
 	{
 	  /* Unshare the sum as well.  */
 	  *loc = ad = copy_rtx (ad);
@@ -5094,8 +5095,8 @@
 	  /* Reload the displacement into an index reg.
 	     We assume the frame pointer or arg pointer is a base reg.  */
 	  find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),
-				     INDEX_REG_CLASS, GET_MODE (ad), opnum,
-				     type, ind_levels);
+				     index_reg_class (mode), GET_MODE (ad),
+				     opnum, type, ind_levels);
 	  return 0;
 	}
       else
@@ -5489,13 +5490,13 @@
 #define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, OUTER, INDEX)		\
   ((CONTEXT) == 0							\
    ? regno_ok_for_base_p (REGNO, MODE, OUTER, INDEX)			\
-   : REGNO_OK_FOR_INDEX_P (REGNO))
+   : regno_ok_for_index_p (REGNO, MODE))
 
   enum reg_class context_reg_class;
   RTX_CODE code = GET_CODE (x);
 
   if (context == 1)
-    context_reg_class = INDEX_REG_CLASS;
+    context_reg_class = index_reg_class (mode);
   else
     context_reg_class = base_reg_class (mode, outer_code, index_code);
 
@@ -5587,17 +5588,17 @@
 
 	else if (code0 == REG && code1 == REG)
 	  {
-	    if (REGNO_OK_FOR_INDEX_P (REGNO (op1))
+	    if (regno_ok_for_index_p (REGNO (op1), mode)
 		&& regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))
 	      return 0;
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0))
+	    else if (regno_ok_for_index_p (REGNO (op0), mode)
 		     && regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))
 	      return 0;
 	    else if (regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))
 	      find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,
 				      &XEXP (x, 1), opnum, type, ind_levels,
 				      insn);
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op1)))
+	    else if (regno_ok_for_index_p (REGNO (op1), mode))
 	      find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,
 				      &XEXP (x, 0), opnum, type, ind_levels,
 				      insn);
@@ -5605,7 +5606,7 @@
 	      find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,
 				      &XEXP (x, 0), opnum, type, ind_levels,
 				      insn);
-	    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0)))
+	    else if (regno_ok_for_index_p (REGNO (op0), mode))
 	      find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,
 				      &XEXP (x, 1), opnum, type, ind_levels,
 				      insn);
@@ -5675,7 +5676,7 @@
 	   need to live longer than a TYPE reload normally would, so be
 	   conservative and class it as RELOAD_OTHER.  */
 	if ((REG_P (XEXP (op1, 1))
-	     && !REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))
+	     && !regno_ok_for_index_p (REGNO (XEXP (op1, 1)), mode))
 	    || GET_CODE (XEXP (op1, 1)) == PLUS)
 	  find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,
 				  &XEXP (op1, 1), opnum, RELOAD_OTHER,
diff -ru ./gcc/reorg.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reorg.c
--- ./gcc/reorg.c	2014-06-06 11:50:19.587598755 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/reorg.c	2012-03-29 18:03:19.000000000 +1000
@@ -161,8 +161,11 @@
 #define unfilled_slots_next	\
   ((rtx *) obstack_next_free (&unfilled_slots_obstack))
 
-/* Points to the label before the end of the function.  */
-static rtx end_of_function_label;
+/* Points to the label before the end of the function, or before a
+   return insn.  */
+static rtx function_return_label;
+/* Likewise for a simple_return.  */
+static rtx function_simple_return_label;
 
 /* Mapping between INSN_UID's and position in the code since INSN_UID's do
    not always monotonically increase.  */
@@ -175,7 +178,7 @@
 static int resource_conflicts_p (struct resources *, struct resources *);
 static int insn_references_resource_p (rtx, struct resources *, bool);
 static int insn_sets_resource_p (rtx, struct resources *, bool);
-static rtx find_end_label (void);
+static rtx find_end_label (rtx);
 static rtx emit_delay_sequence (rtx, rtx, int);
 static rtx add_to_delay_list (rtx, rtx);
 static rtx delete_from_delay_slot (rtx);
@@ -195,8 +198,8 @@
 static rtx steal_delay_list_from_target (rtx, rtx, rtx, rtx,
 					 struct resources *,
 					 struct resources *,
-					 struct resources *,
-					 int, int *, int *, rtx *);
+					 struct resources *, rtx,
+					 int, int, int *, int *, rtx *);
 static rtx steal_delay_list_from_fallthrough (rtx, rtx, rtx, rtx,
 					      struct resources *,
 					      struct resources *,
@@ -212,7 +215,7 @@
 static void update_reg_unused_notes (rtx, rtx);
 static void fill_simple_delay_slots (int);
 static rtx fill_slots_from_thread (rtx, rtx, rtx, rtx,
-				   int, int, int, int,
+				   int, int, int, int, int,
 				   int *, rtx);
 static void fill_eager_delay_slots (void);
 static void relax_delay_slots (rtx);
@@ -220,6 +223,15 @@
 static void make_return_insns (rtx);
 #endif
 
+/* Return true iff INSN is a simplejump, or any kind of return insn.  */
+
+static bool
+simplejump_or_return_p (rtx insn)
+{
+  return (JUMP_P (insn)
+	  && (simplejump_p (insn) || ANY_RETURN_P (PATTERN (insn))));
+}
+
 /* Return TRUE if this insn should stop the search for insn to fill delay
    slots.  LABELS_P indicates that labels should terminate the search.
    In all cases, jumps terminate the search.  */
@@ -335,23 +347,29 @@
 
    ??? There may be a problem with the current implementation.  Suppose
    we start with a bare RETURN insn and call find_end_label.  It may set
-   end_of_function_label just before the RETURN.  Suppose the machinery
+   function_return_label just before the RETURN.  Suppose the machinery
    is able to fill the delay slot of the RETURN insn afterwards.  Then
-   end_of_function_label is no longer valid according to the property
+   function_return_label is no longer valid according to the property
    described above and find_end_label will still return it unmodified.
    Note that this is probably mitigated by the following observation:
-   once end_of_function_label is made, it is very likely the target of
+   once function_return_label is made, it is very likely the target of
    a jump, so filling the delay slot of the RETURN will be much more
    difficult.  */
 
 static rtx
-find_end_label (void)
+find_end_label (rtx kind)
 {
   rtx insn;
+  rtx *plabel;
+
+  if (kind == ret_rtx)
+    plabel = &function_return_label;
+  else
+    plabel = &function_simple_return_label;
 
   /* If we found one previously, return it.  */
-  if (end_of_function_label)
-    return end_of_function_label;
+  if (*plabel)
+    return *plabel;
 
   /* Otherwise, see if there is a label at the end of the function.  If there
      is, it must be that RETURN insns aren't needed, so that is our return
@@ -366,44 +384,44 @@
 
   /* When a target threads its epilogue we might already have a
      suitable return insn.  If so put a label before it for the
-     end_of_function_label.  */
+     function_return_label.  */
   if (BARRIER_P (insn)
       && JUMP_P (PREV_INSN (insn))
-      && GET_CODE (PATTERN (PREV_INSN (insn))) == RETURN)
+      && PATTERN (PREV_INSN (insn)) == kind)
     {
       rtx temp = PREV_INSN (PREV_INSN (insn));
-      end_of_function_label = gen_label_rtx ();
-      LABEL_NUSES (end_of_function_label) = 0;
+      rtx label = gen_label_rtx ();
+      LABEL_NUSES (label) = 0;
 
       /* Put the label before an USE insns that may precede the RETURN insn.  */
       while (GET_CODE (temp) == USE)
 	temp = PREV_INSN (temp);
 
-      emit_label_after (end_of_function_label, temp);
+      emit_label_after (label, temp);
+      *plabel = label;
     }
 
   else if (LABEL_P (insn))
-    end_of_function_label = insn;
+    *plabel = insn;
   else
     {
-      end_of_function_label = gen_label_rtx ();
-      LABEL_NUSES (end_of_function_label) = 0;
+      rtx label = gen_label_rtx ();
+      LABEL_NUSES (label) = 0;
       /* If the basic block reorder pass moves the return insn to
 	 some other place try to locate it again and put our
-	 end_of_function_label there.  */
-      while (insn && ! (JUMP_P (insn)
-		        && (GET_CODE (PATTERN (insn)) == RETURN)))
+	 function_return_label there.  */
+      while (insn && ! (JUMP_P (insn) && (PATTERN (insn) == kind)))
 	insn = PREV_INSN (insn);
       if (insn)
 	{
 	  insn = PREV_INSN (insn);
 
-	  /* Put the label before an USE insns that may proceed the
+	  /* Put the label before an USE insns that may precede the
 	     RETURN insn.  */
 	  while (GET_CODE (insn) == USE)
 	    insn = PREV_INSN (insn);
 
-	  emit_label_after (end_of_function_label, insn);
+	  emit_label_after (label, insn);
 	}
       else
 	{
@@ -413,19 +431,16 @@
 	      && ! HAVE_return
 #endif
 	      )
-	    {
-	      /* The RETURN insn has its delay slot filled so we cannot
-		 emit the label just before it.  Since we already have
-		 an epilogue and cannot emit a new RETURN, we cannot
-		 emit the label at all.  */
-	      end_of_function_label = NULL_RTX;
-	      return end_of_function_label;
-	    }
+	    /* The RETURN insn has its delay slot filled so we cannot
+	       emit the label just before it.  Since we already have
+	       an epilogue and cannot emit a new RETURN, we cannot
+	       emit the label at all.  */
+	    return NULL_RTX;
 #endif /* HAVE_epilogue */
 
 	  /* Otherwise, make a new label and emit a RETURN and BARRIER,
 	     if needed.  */
-	  emit_label (end_of_function_label);
+	  emit_label (label);
 #ifdef HAVE_return
 	  /* We don't bother trying to create a return insn if the
 	     epilogue has filled delay-slots; we would have to try and
@@ -437,19 +452,21 @@
 	      /* The return we make may have delay slots too.  */
 	      rtx insn = gen_return ();
 	      insn = emit_jump_insn (insn);
+	      JUMP_LABEL (insn) = ret_rtx;
 	      emit_barrier ();
 	      if (num_delay_slots (insn) > 0)
 		obstack_ptr_grow (&unfilled_slots_obstack, insn);
 	    }
 #endif
 	}
+      *plabel = label;
     }
 
   /* Show one additional use for this label so it won't go away until
      we are done.  */
-  ++LABEL_NUSES (end_of_function_label);
+  ++LABEL_NUSES (*plabel);
 
-  return end_of_function_label;
+  return *plabel;
 }
 
 /* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace
@@ -529,6 +546,9 @@
       PREV_INSN (tem) = XVECEXP (seq, 0, i - 1);
       NEXT_INSN (XVECEXP (seq, 0, i - 1)) = tem;
 
+      if (LABEL_P (tem))
+        continue;
+
       /* SPARC assembler, for instance, emit warning when debug info is output
          into the delay slot.  */
       if (INSN_LOCATOR (tem) && !INSN_LOCATOR (seq_insn))
@@ -623,7 +643,7 @@
      PREV_INSN (NEXT_INSN (TRIAL)) != TRIAL.  */
 
   for (trial = insn;
-       PREV_INSN (NEXT_INSN (trial)) == trial;
+       PREV_INSN (NEXT_INSN (trial)) == trial || LABEL_P (trial);
        trial = NEXT_INSN (trial))
     ;
 
@@ -658,6 +678,9 @@
   else if (INSN_P (trial))
     INSN_ANNULLED_BRANCH_P (trial) = 0;
 
+  if (LABEL_P (insn))
+    return trial;
+
   INSN_FROM_TARGET_P (insn) = 0;
 
   /* Show we need to fill this insn again.  */
@@ -797,10 +820,8 @@
   if ((next_trial == next_active_insn (JUMP_LABEL (insn))
        && ! (next_trial == 0 && crtl->epilogue_delay_list != 0))
       || (next_trial != 0
-	  && JUMP_P (next_trial)
-	  && JUMP_LABEL (insn) == JUMP_LABEL (next_trial)
-	  && (simplejump_p (next_trial)
-	      || GET_CODE (PATTERN (next_trial)) == RETURN)))
+	  && simplejump_or_return_p (next_trial)
+	  && JUMP_LABEL (insn) == JUMP_LABEL (next_trial)))
     {
       if (eligible_for_annul_false (insn, 0, trial, flags))
 	{
@@ -819,13 +840,11 @@
 	 branch, thread our jump to the target of that branch.  Don't
 	 change this into a RETURN here, because it may not accept what
 	 we have in the delay slot.  We'll fix this up later.  */
-      if (next_trial && JUMP_P (next_trial)
-	  && (simplejump_p (next_trial)
-	      || GET_CODE (PATTERN (next_trial)) == RETURN))
+      if (next_trial && simplejump_or_return_p (next_trial))
 	{
 	  rtx target_label = JUMP_LABEL (next_trial);
-	  if (target_label == 0)
-	    target_label = find_end_label ();
+	  if (ANY_RETURN_P (target_label))
+	    target_label = find_end_label (target_label);
 
 	  if (target_label)
 	    {
@@ -866,7 +885,7 @@
   if (JUMP_P (insn)
       && (condjump_p (insn) || condjump_in_parallel_p (insn))
       && INSN_UID (insn) <= max_uid
-      && label != 0
+      && label != 0 && !ANY_RETURN_P (label)
       && INSN_UID (label) <= max_uid)
     flags
       = (uid_to_ruid[INSN_UID (label)] > uid_to_ruid[INSN_UID (insn)])
@@ -1038,7 +1057,7 @@
     pat = XVECEXP (pat, 0, 0);
 
   if (GET_CODE (pat) == RETURN)
-    return target == 0 ? const_true_rtx : 0;
+    return ANY_RETURN_P (target) ? const_true_rtx : 0;
 
   else if (GET_CODE (pat) != SET || SET_DEST (pat) != pc_rtx)
     return 0;
@@ -1186,6 +1205,55 @@
 
   return 1;
 }
+
+/* TRIAL is an insn from a thread.  See if we can find a duplicate of trial in
+   the OPPOSITE_THREAD that we can hoist to before OPPOSITE_THREAD.  */
+
+static bool
+has_opposite_duplicate (rtx trial, rtx opposite_thread, rtx *duplicate)
+{
+  rtx pat;
+  rtx scan, prev;
+  struct resources prev_needed, prev_set;
+
+  pat = PATTERN (trial);
+
+  /* Initialize prev_needed and prev_set.  */
+  CLEAR_RESOURCE (&prev_needed);
+  CLEAR_RESOURCE (&prev_set);
+
+  /* Be conservative with respect to cc.  */
+  prev_set.cc = 1;
+
+  for ((prev = NULL_RTX), (scan = opposite_thread); !stop_search_p (scan, 1);
+       (prev = scan), (scan = next_nonnote_insn (scan)))
+    {
+      if (prev != NULL_RTX)
+        {
+          /* Mark any register set or referenced by a previous insn in
+             prev_set and prev_needed.  */
+          mark_set_resources (prev, &prev_set, 0, MARK_SRC_DEST_CALL);
+          mark_referenced_resources (prev, &prev_needed, true);
+        }
+
+      /* We're looking for a duplicate of trial.  */
+      if (!rtx_equal_p (pat, PATTERN (scan)))
+        continue;
+
+      /* If the duplicate conflicts with any previous insn, give up.  Testing
+         for anti-dependence, output dependence and true dependence.  */
+      if (insn_sets_resource_p (scan, &prev_needed, true)
+          || insn_sets_resource_p (scan, &prev_set, true)
+          || insn_references_resource_p (scan, &prev_set, true))
+        break;
+
+      *duplicate = scan;
+      return true;
+    }
+
+  return false;
+}
+
 
 /* INSN branches to an insn whose pattern SEQ is a SEQUENCE.  Given that
    the condition tested by INSN is CONDITION and the resources shown in
@@ -1212,6 +1280,7 @@
 			      rtx delay_list, struct resources *sets,
 			      struct resources *needed,
 			      struct resources *other_needed,
+			      rtx other_thread, int own_opposite_thread,
 			      int slots_to_fill, int *pslots_filled,
 			      int *pannul_p, rtx *pnew_thread)
 {
@@ -1223,6 +1292,7 @@
   int used_annul = 0;
   int i;
   struct resources cc_set;
+  rtx duplicate;
 
   /* We can't do anything if there are more delay slots in SEQ than we
      can handle, or if we don't know that it will be a taken branch.
@@ -1252,7 +1322,8 @@
 
   if (XVECLEN (seq, 0) - 1 > slots_remaining
       || ! condition_dominates_p (condition, XVECEXP (seq, 0, 0))
-      || ! single_set (XVECEXP (seq, 0, 0)))
+      || ! (single_set (XVECEXP (seq, 0, 0))
+            || GET_CODE (PATTERN (XVECEXP (seq, 0, 0))) == RETURN))
     return delay_list;
 
 #ifdef MD_CAN_REDIRECT_BRANCH
@@ -1291,9 +1362,14 @@
 	 based on jumping to the new label.  */
       flags = get_jump_flags (insn, JUMP_LABEL (XVECEXP (seq, 0, 0)));
 
+      duplicate = NULL_RTX;
+
       if (! must_annul
 	  && ((condition == const_true_rtx
-	       || (! insn_sets_resource_p (trial, other_needed, false)
+	       || ((! insn_sets_resource_p (trial, other_needed, false)
+                    || (own_opposite_thread
+                        && has_opposite_duplicate (trial, other_thread,
+                                                   &duplicate)))
 		   && ! may_trap_or_fault_p (PATTERN (trial)))))
 	  ? eligible_for_delay (insn, total_slots_filled, trial, flags)
 	  : (must_annul || (delay_list == NULL && new_delay_list == NULL))
@@ -1310,6 +1386,9 @@
 	  new_delay_list = add_to_delay_list (temp, new_delay_list);
 	  total_slots_filled++;
 
+          if (!must_annul && duplicate != NULL_RTX)
+            delete_related_insns (duplicate);
+
 	  if (--slots_remaining == 0)
 	    break;
 	}
@@ -1318,7 +1397,11 @@
     }
 
   /* Show the place to which we will be branching.  */
-  *pnew_thread = next_active_insn (JUMP_LABEL (XVECEXP (seq, 0, 0)));
+  temp = JUMP_LABEL (XVECEXP (seq, 0, 0));
+  if (ANY_RETURN_P (temp))
+    *pnew_thread = temp;
+  else
+    *pnew_thread = next_active_insn (temp);
 
   /* Add any new insns to the delay list and update the count of the
      number of slots filled.  */
@@ -1358,8 +1441,7 @@
   /* We can't do anything if SEQ's delay insn isn't an
      unconditional branch.  */
 
-  if (! simplejump_p (XVECEXP (seq, 0, 0))
-      && GET_CODE (PATTERN (XVECEXP (seq, 0, 0))) != RETURN)
+  if (! simplejump_or_return_p (XVECEXP (seq, 0, 0)))
     return delay_list;
 
   for (i = 1; i < XVECLEN (seq, 0); i++)
@@ -1522,6 +1604,9 @@
 	{
 	  rtx dtrial = XVECEXP (pat, 0, i);
 
+          if (LABEL_P (dtrial) || DELETED_NOTE_P (dtrial))
+            return;
+
 	  if (! insn_references_resource_p (dtrial, &set, true)
 	      && ! insn_sets_resource_p (dtrial, &set, true)
 	      && ! insn_sets_resource_p (dtrial, &needed, true)
@@ -1615,17 +1700,22 @@
 redundant_insn (rtx insn, rtx target, rtx delay_list)
 {
   rtx target_main = target;
-  rtx ipat = PATTERN (insn);
+  rtx ipat;
   rtx trial, pat;
   struct resources needed, set;
   int i;
   unsigned insns_to_search;
 
+  if (LABEL_P (insn) || DELETED_NOTE_P (insn))
+    return NULL_RTX;
+
   /* If INSN has any REG_UNUSED notes, it can't match anything since we
      are allowed to not actually assign to such a register.  */
   if (find_reg_note (insn, REG_UNUSED, NULL_RTX) != 0)
     return 0;
 
+  ipat = PATTERN (insn);
+
   /* Scan backwards looking for a match.  */
   for (trial = PREV_INSN (target),
 	 insns_to_search = MAX_DELAY_SLOT_INSN_SEARCH;
@@ -1772,6 +1862,9 @@
 	    {
 	      rtx candidate = XVECEXP (pat, 0, i);
 
+	      if (LABEL_P (candidate) || DELETED_NOTE_P (candidate))
+		return NULL_RTX;
+
 	      /* If an insn will be annulled if the branch is false, it isn't
 		 considered as a possible duplicate insn.  */
 	      if (rtx_equal_p (PATTERN (candidate), ipat)
@@ -1780,6 +1873,7 @@
 		{
 		  /* Show that this insn will be used in the sequel.  */
 		  INSN_FROM_TARGET_P (candidate) = 0;
+		  incr_ticks_for_insn (candidate);
 		  return candidate;
 		}
 
@@ -1827,7 +1921,7 @@
   rtx insn;
 
   /* We don't own the function end.  */
-  if (thread == 0)
+  if (ANY_RETURN_P (thread))
     return 0;
 
   /* Get the first active insn, or THREAD, if it is an active insn.  */
@@ -2005,6 +2099,17 @@
   return label;
 }
 
+/* Determine whether a delay list contains a label or not.  */
+
+static int
+delay_list_has_label (rtx list)
+{
+  for (;list != NULL_RTX; list = XEXP (list, 1))
+    if (LABEL_P (XEXP (list, 0)))
+      return 1;
+  return 0;
+}
+
 /* Scan a function looking for insns that need a delay slot and find insns to
    put into the delay slot.
 
@@ -2245,7 +2350,8 @@
 	  && (!JUMP_P (insn)
 	      || ((condjump_p (insn) || condjump_in_parallel_p (insn))
 		  && ! simplejump_p (insn)
-		  && JUMP_LABEL (insn) != 0)))
+		  && JUMP_LABEL (insn) != 0
+		  && !ANY_RETURN_P (JUMP_LABEL (insn)))))
 	{
 	  /* Invariant: If insn is a JUMP_INSN, the insn's jump
 	     label.  Otherwise, zero.  */
@@ -2270,7 +2376,7 @@
 		target = JUMP_LABEL (insn);
 	    }
 
-	  if (target == 0)
+	  if (target == 0 || ANY_RETURN_P (target))
 	    for (trial = next_nonnote_insn (insn); !stop_search_p (trial, 1);
 		 trial = next_trial)
 	      {
@@ -2346,6 +2452,7 @@
 	      && JUMP_P (trial)
 	      && simplejump_p (trial)
 	      && (target == 0 || JUMP_LABEL (trial) == target)
+	      && !ANY_RETURN_P (JUMP_LABEL (trial))
 	      && (next_trial = next_active_insn (JUMP_LABEL (trial))) != 0
 	      && ! (NONJUMP_INSN_P (next_trial)
 		    && GET_CODE (PATTERN (next_trial)) == SEQUENCE)
@@ -2368,7 +2475,7 @@
 	      if (new_label != 0)
 		new_label = get_label_before (new_label);
 	      else
-		new_label = find_end_label ();
+		new_label = find_end_label (simple_return_rtx);
 
 	      if (new_label)
 	        {
@@ -2396,12 +2503,15 @@
 				    NULL, 1, 1,
 				    own_thread_p (JUMP_LABEL (insn),
 						  JUMP_LABEL (insn), 0),
+                                    0,
 				    slots_to_fill, &slots_filled,
 				    delay_list);
 
       if (delay_list)
 	unfilled_slots_base[i]
-	  = emit_delay_sequence (insn, delay_list, slots_filled);
+	  = emit_delay_sequence (insn, delay_list,
+                                 (slots_filled
+                                  + delay_list_has_label (delay_list)));
 
       if (slots_to_fill == slots_filled)
 	unfilled_slots_base[i] = 0;
@@ -2500,7 +2610,8 @@
 
 /* Follow any unconditional jump at LABEL;
    return the ultimate label reached by any such chain of jumps.
-   Return null if the chain ultimately leads to a return instruction.
+   Return a suitable return rtx if the chain ultimately leads to a
+   return instruction.
    If LABEL is not followed by a jump, return LABEL.
    If the chain loops or we can't find end, return LABEL,
    since that tells caller to avoid changing the insn.  */
@@ -2515,6 +2626,7 @@
 
   for (depth = 0;
        (depth < 10
+	&& !ANY_RETURN_P (value)
 	&& (insn = next_active_insn (value)) != 0
 	&& JUMP_P (insn)
 	&& ((JUMP_LABEL (insn) != 0 && any_uncondjump_p (insn)
@@ -2524,24 +2636,50 @@
 	&& BARRIER_P (next));
        depth++)
     {
-      rtx tem;
+      rtx this_label = JUMP_LABEL (insn);
 
       /* If we have found a cycle, make the insn jump to itself.  */
-      if (JUMP_LABEL (insn) == label)
+      if (this_label == label)
 	return label;
 
-      tem = next_active_insn (JUMP_LABEL (insn));
-      if (tem && (GET_CODE (PATTERN (tem)) == ADDR_VEC
+      if (!ANY_RETURN_P (this_label))
+	{
+	  rtx tem = next_active_insn (this_label);
+	  if (tem
+	      && (GET_CODE (PATTERN (tem)) == ADDR_VEC
 		  || GET_CODE (PATTERN (tem)) == ADDR_DIFF_VEC))
-	break;
+	    break;
+	}
 
-      value = JUMP_LABEL (insn);
+      value = this_label;
     }
   if (depth == 10)
     return label;
   return value;
 }
 
+/* Update LABEL_NUSES of labels in INSN and its notes with UPDATE.  */
+
+static void
+update_label_uses (rtx insn, int update)
+{
+  rtx note;
+
+  for (note = REG_NOTES (insn); note != NULL_RTX; note = XEXP (note, 1))
+    if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND
+        || REG_NOTE_KIND (note) == REG_LABEL_TARGET)
+      {
+        /* REG_LABEL_OPERAND could be NOTE_INSN_DELETED_LABEL too.  */
+        if (LABEL_P (XEXP (note, 0)))
+          LABEL_NUSES (XEXP (note, 0)) += update;
+        else
+          gcc_assert (REG_NOTE_KIND (note) == REG_LABEL_OPERAND);
+      }
+
+  if (JUMP_P (insn) && JUMP_LABEL (insn) && LABEL_P (JUMP_LABEL (insn)))
+    LABEL_NUSES (JUMP_LABEL (insn)) += update;
+}
+
 /* Try to find insns to place in delay slots.
 
    INSN is the jump needing SLOTS_TO_FILL delay slots.  It tests CONDITION
@@ -2569,8 +2707,8 @@
 static rtx
 fill_slots_from_thread (rtx insn, rtx condition, rtx thread,
 			rtx opposite_thread, int likely, int thread_if_true,
-			int own_thread, int slots_to_fill,
-			int *pslots_filled, rtx delay_list)
+			int own_thread, int own_opposite_thread,
+			int slots_to_fill, int *pslots_filled, rtx delay_list)
 {
   rtx new_thread;
   struct resources opposite_needed, set, needed;
@@ -2578,6 +2716,8 @@
   int lose = 0;
   int must_annul = 0;
   int flags;
+  rtx duplicate;
+  int align_insns = targetm.target_align.align_insns ();
 
   /* Validate our arguments.  */
   gcc_assert(condition != const_true_rtx || thread_if_true);
@@ -2622,6 +2762,8 @@
        trial = next_nonnote_insn (trial))
     {
       rtx pat, old_trial;
+      rtx label;
+      bool insert_label = false;
 
       /* If we have passed a label, we no longer own this thread.  */
       if (LABEL_P (trial))
@@ -2674,8 +2816,13 @@
 	      continue;
 	    }
 
-	  /* There are two ways we can win:  If TRIAL doesn't set anything
-	     needed at the opposite thread and can't trap, or if it can
+          label = prev_nonnote_insn (opposite_thread);
+          if (label != NULL_RTX && !LABEL_P (label))
+            label = NULL_RTX;
+
+	  /* There are three ways we can win:  If TRIAL doesn't set anything
+	     needed at the opposite thread and can't trap, or if it has a
+	     duplicate in the opposite thread and can't trap, or if it can
 	     go into an annulled delay slot.  */
 	  if (!must_annul
 	      && (condition == const_true_rtx
@@ -2692,6 +2839,38 @@
 	      if (eligible_for_delay (insn, *pslots_filled, trial, flags))
 		goto winner;
 	    }
+          /* In case TRIAL sets a reg needed at the opposite thread, it's
+             possible that the insn needing that reg is a duplicate of TRIAL, in
+             which case we can remove the duplicate in the fallthrough thread,
+             and use TRIAL for the delay slot.
+             A special case is if we don't own the fallthrough thread.  In that
+             case, we also need to move the label of the fallthrough thread into
+             the delay slot.  That is only safe, if the label aligment is not
+             bigger than the insn aligment.  Otherwise, the assembler might
+             insert a nop in the delay slot to guarantee the label alignment.
+          */
+	  else if (!must_annul
+                   && condition != const_true_rtx
+                   && insn_sets_resource_p (trial, &opposite_needed, true)
+                   && !may_trap_or_fault_p (pat)
+                   && thread_if_true
+                   && (own_opposite_thread ||
+                       (label != NULL_RTX && align_insns != 0
+                        && (label_to_alignment (label) <= align_insns)))
+                   && eligible_for_delay (insn, *pslots_filled, trial, flags)
+                   && has_opposite_duplicate (trial, opposite_thread,
+                                              &duplicate))
+            {
+              if (!own_opposite_thread)
+                insert_label = true;
+
+              update_block (duplicate, opposite_thread);
+              update_label_uses (duplicate, +1);
+              delete_related_insns (duplicate);
+              update_label_uses (duplicate, -1);
+
+              goto winner;
+            }
 	  else if (0
 #ifdef ANNUL_IFTRUE_SLOTS
 		   || ! thread_if_true
@@ -2730,8 +2909,6 @@
 		     starting point of this thread.  */
 		  if (own_thread)
 		    {
-		      rtx note;
-
 		      update_block (trial, thread);
 		      if (trial == thread)
 			{
@@ -2743,48 +2920,36 @@
 		      /* We are moving this insn, not deleting it.  We must
 			 temporarily increment the use count on any referenced
 			 label lest it be deleted by delete_related_insns.  */
-		      for (note = REG_NOTES (trial);
-			   note != NULL_RTX;
-			   note = XEXP (note, 1))
-			if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND
-			    || REG_NOTE_KIND (note) == REG_LABEL_TARGET)
-			  {
-			    /* REG_LABEL_OPERAND could be
-			       NOTE_INSN_DELETED_LABEL too.  */
-			    if (LABEL_P (XEXP (note, 0)))
-			      LABEL_NUSES (XEXP (note, 0))++;
-			    else
-			      gcc_assert (REG_NOTE_KIND (note)
-					  == REG_LABEL_OPERAND);
-			  }
-		      if (JUMP_P (trial) && JUMP_LABEL (trial))
-			LABEL_NUSES (JUMP_LABEL (trial))++;
-
+		      update_label_uses (trial, +1);
 		      delete_related_insns (trial);
-
-		      for (note = REG_NOTES (trial);
-			   note != NULL_RTX;
-			   note = XEXP (note, 1))
-			if (REG_NOTE_KIND (note) == REG_LABEL_OPERAND
-			    || REG_NOTE_KIND (note) == REG_LABEL_TARGET)
-			  {
-			    /* REG_LABEL_OPERAND could be
-			       NOTE_INSN_DELETED_LABEL too.  */
-			    if (LABEL_P (XEXP (note, 0)))
-			      LABEL_NUSES (XEXP (note, 0))--;
-			    else
-			      gcc_assert (REG_NOTE_KIND (note)
-					  == REG_LABEL_OPERAND);
-			  }
-		      if (JUMP_P (trial) && JUMP_LABEL (trial))
-			LABEL_NUSES (JUMP_LABEL (trial))--;
+		      update_label_uses (trial, -1);
 		    }
 		  else
 		    new_thread = next_active_insn (trial);
 
-		  temp = own_thread ? trial : copy_rtx (trial);
-		  if (thread_if_true)
-		    INSN_FROM_TARGET_P (temp) = 1;
+                  if (insert_label)
+                    {
+                      remove_insn (label);
+                      INSN_DELETED_P (label) = 1;
+
+                      /* Add label to delay list.  */
+                      delay_list = add_to_delay_list (label, delay_list);
+
+                      /* If !own_thread and we use copy_rtx (trial) here, the
+                         caching mechanism of mark_target_live_regs gets
+                         confused.  It assumes that each target uid has a unique
+                         bb.  If trial is a target, and we add the copy after
+                         the label in the delay slot, the copy is a new target
+                         with the same uid, but in a different bb.  Instead we
+                         use duplicate, also if own_thread.  */
+                      temp = duplicate;
+                    }
+                  else
+                    {
+                      temp = own_thread ? trial : copy_rtx (trial);
+                      if (thread_if_true)
+                        INSN_FROM_TARGET_P (temp) = 1;
+                    }
 
 		  delay_list = add_to_delay_list (temp, delay_list);
 
@@ -2874,7 +3039,8 @@
 	  delay_list
 	    = steal_delay_list_from_target (insn, condition, PATTERN (trial),
 					    delay_list, &set, &needed,
-					    &opposite_needed, slots_to_fill,
+					    &opposite_needed, opposite_thread,
+					    own_opposite_thread, slots_to_fill,
 					    pslots_filled, &must_annul,
 					    &new_thread);
 	  /* If we owned the thread and are told that it branched
@@ -2898,6 +3064,7 @@
      arithmetic insn after the jump insn and put the arithmetic insn in the
      delay slot.  If we can't do this, return.  */
   if (delay_list == 0 && likely && new_thread
+      && !ANY_RETURN_P (new_thread)
       && NONJUMP_INSN_P (new_thread)
       && GET_CODE (PATTERN (new_thread)) != ASM_INPUT
       && asm_noperands (PATTERN (new_thread)) < 0)
@@ -2982,16 +3149,14 @@
 
       gcc_assert (thread_if_true);
 
-      if (new_thread && JUMP_P (new_thread)
-	  && (simplejump_p (new_thread)
-	      || GET_CODE (PATTERN (new_thread)) == RETURN)
+      if (new_thread && simplejump_or_return_p (new_thread)
 	  && redirect_with_delay_list_safe_p (insn,
 					      JUMP_LABEL (new_thread),
 					      delay_list))
 	new_thread = follow_jumps (JUMP_LABEL (new_thread));
 
-      if (new_thread == 0)
-	label = find_end_label ();
+      if (ANY_RETURN_P (new_thread))
+	label = find_end_label (new_thread);
       else if (LABEL_P (new_thread))
 	label = new_thread;
       else
@@ -3088,7 +3253,7 @@
 	  delay_list
 	    = fill_slots_from_thread (insn, condition, insn_at_target,
 				      fallthrough_insn, prediction == 2, 1,
-				      own_target,
+				      own_target, own_fallthrough,
 				      slots_to_fill, &slots_filled, delay_list);
 
 	  if (delay_list == 0 && own_fallthrough)
@@ -3096,14 +3261,15 @@
 	      /* Even though we didn't find anything for delay slots,
 		 we might have found a redundant insn which we deleted
 		 from the thread that was filled.  So we have to recompute
-		 the next insn at the target.  */
+		 (a) the insn at the target, and (b) whether we own it.  */
 	      target_label = JUMP_LABEL (insn);
 	      insn_at_target = next_active_insn (target_label);
+	      own_target = own_thread_p (target_label, target_label, 0);
 
 	      delay_list
 		= fill_slots_from_thread (insn, condition, fallthrough_insn,
 					  insn_at_target, 0, 0,
-					  own_fallthrough,
+					  own_fallthrough, own_target,
 					  slots_to_fill, &slots_filled,
 					  delay_list);
 	    }
@@ -3114,22 +3280,32 @@
 	    delay_list
 	      = fill_slots_from_thread (insn, condition, fallthrough_insn,
 					insn_at_target, 0, 0,
-					own_fallthrough,
+					own_fallthrough, own_target,
 					slots_to_fill, &slots_filled,
 					delay_list);
 
 	  if (delay_list == 0)
-	    delay_list
-	      = fill_slots_from_thread (insn, condition, insn_at_target,
-					next_active_insn (insn), 0, 1,
-					own_target,
-					slots_to_fill, &slots_filled,
-					delay_list);
+	    {
+	      /* In case we found a redundant insn which we deleted from the
+		 fallthrough thread, we have to recompute (a) the insn at the
+		 fallthrough, and (b) whether we own it.  */
+	      fallthrough_insn = next_active_insn (insn);
+	      own_fallthrough = own_thread_p (NEXT_INSN (insn), NULL_RTX, 1);
+
+	      delay_list
+		= fill_slots_from_thread (insn, condition, insn_at_target,
+					  next_active_insn (insn), 0, 1,
+					  own_target, own_fallthrough,
+					  slots_to_fill, &slots_filled,
+					  delay_list);
+	    }
 	}
 
       if (delay_list)
 	unfilled_slots_base[i]
-	  = emit_delay_sequence (insn, delay_list, slots_filled);
+	  = emit_delay_sequence (insn, delay_list,
+                                 (slots_filled
+                                  + delay_list_has_label (delay_list)));
 
       if (slots_to_fill == slots_filled)
 	unfilled_slots_base[i] = 0;
@@ -3314,6 +3490,19 @@
     delete_computation (insn);
 }
 
+/* Returns first real insn in SEQ.  */
+
+static rtx
+first_real_insn_in_seq (rtx seq)
+{
+  rtx pat = PATTERN (seq);
+  rtx first = XVECEXP (pat, 0, 1);
+  if (DELETED_NOTE_P (first) || LABEL_P (first))
+    first = XVECEXP (pat, 0, 2);
+  gcc_assert (INSN_P (first));
+  return first;
+}
+
 
 /* Once we have tried two ways to fill a delay slot, make a pass over the
    code to try to improve the results and to do such things as more jump
@@ -3337,11 +3526,12 @@
 	 group of consecutive labels.  */
       if (JUMP_P (insn)
 	  && (condjump_p (insn) || condjump_in_parallel_p (insn))
-	  && (target_label = JUMP_LABEL (insn)) != 0)
+	  && (target_label = JUMP_LABEL (insn)) != 0
+	  && !ANY_RETURN_P (target_label))
 	{
 	  target_label = skip_consecutive_labels (follow_jumps (target_label));
-	  if (target_label == 0)
-	    target_label = find_end_label ();
+	  if (ANY_RETURN_P (target_label))
+	    target_label = find_end_label (target_label);
 
 	  if (target_label && next_active_insn (target_label) == next
 	      && ! condjump_in_parallel_p (insn))
@@ -3356,9 +3546,8 @@
 	  /* See if this jump conditionally branches around an unconditional
 	     jump.  If so, invert this jump and point it to the target of the
 	     second jump.  */
-	  if (next && JUMP_P (next)
+	  if (next && simplejump_or_return_p (next)
 	      && any_condjump_p (insn)
-	      && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)
 	      && target_label
 	      && next_active_insn (target_label) == next_active_insn (next)
 	      && no_labels_between_p (insn, next))
@@ -3373,7 +3562,7 @@
 		 invert_jump fails.  */
 
 	      ++LABEL_NUSES (target_label);
-	      if (label)
+	      if (label && LABEL_P (label))
 		++LABEL_NUSES (label);
 
 	      if (invert_jump (insn, label, 1))
@@ -3382,7 +3571,7 @@
 		  next = insn;
 		}
 
-	      if (label)
+	      if (label && LABEL_P (label))
 		--LABEL_NUSES (label);
 
 	      if (--LABEL_NUSES (target_label) == 0)
@@ -3400,8 +3589,7 @@
 	 Don't do this if we expect the conditional branch to be true, because
 	 we would then be making the more common case longer.  */
 
-      if (JUMP_P (insn)
-	  && (simplejump_p (insn) || GET_CODE (PATTERN (insn)) == RETURN)
+      if (simplejump_or_return_p (insn)
 	  && (other = prev_active_insn (insn)) != 0
 	  && any_condjump_p (other)
 	  && no_labels_between_p (other, insn)
@@ -3424,6 +3612,17 @@
       pat = PATTERN (insn);
       delay_insn = XVECEXP (pat, 0, 0);
 
+      /* Removed unused label from delay slot.  */
+      if (LABEL_P (XVECEXP (pat, 0, 1)))
+        {
+          if (LABEL_NUSES (XVECEXP (pat, 0, 1)) == 0)
+            {
+              delete_from_delay_slot (XVECEXP (pat, 0, 1));
+              next = prev_active_insn (next);
+            }
+          continue;
+        }
+
       /* See if the first insn in the delay slot is redundant with some
 	 previous insn.  Remove it from the delay slot if so; then set up
 	 to reprocess this insn.  */
@@ -3442,10 +3641,10 @@
 	 Only do so if optimizing for size since this results in slower, but
 	 smaller code.  */
       if (optimize_function_for_size_p (cfun)
-	  && GET_CODE (PATTERN (delay_insn)) == RETURN
+	  && ANY_RETURN_P (PATTERN (delay_insn))
 	  && next
 	  && JUMP_P (next)
-	  && GET_CODE (PATTERN (next)) == RETURN)
+	  && PATTERN (next) == PATTERN (delay_insn))
 	{
 	  rtx after;
 	  int i;
@@ -3484,14 +3683,16 @@
 	continue;
 
       target_label = JUMP_LABEL (delay_insn);
+      if (target_label && ANY_RETURN_P (target_label))
+	continue;
 
       if (target_label)
 	{
 	  /* If this jump goes to another unconditional jump, thread it, but
 	     don't convert a jump into a RETURN here.  */
 	  trial = skip_consecutive_labels (follow_jumps (target_label));
-	  if (trial == 0)
-	    trial = find_end_label ();
+	  if (ANY_RETURN_P (trial))
+	    trial = find_end_label (trial);
 
 	  if (trial && trial != target_label
 	      && redirect_with_delay_slots_safe_p (delay_insn, trial, insn))
@@ -3514,7 +3715,7 @@
 		 later incorrectly compute register live/death info.  */
 	      rtx tmp = next_active_insn (trial);
 	      if (tmp == 0)
-		tmp = find_end_label ();
+		tmp = find_end_label (simple_return_rtx);
 
 	      if (tmp)
 	        {
@@ -3534,14 +3735,12 @@
 	     delay list and that insn is redundant, thread the jump.  */
 	  if (trial && GET_CODE (PATTERN (trial)) == SEQUENCE
 	      && XVECLEN (PATTERN (trial), 0) == 2
-	      && JUMP_P (XVECEXP (PATTERN (trial), 0, 0))
-	      && (simplejump_p (XVECEXP (PATTERN (trial), 0, 0))
-		  || GET_CODE (PATTERN (XVECEXP (PATTERN (trial), 0, 0))) == RETURN)
+	      && simplejump_or_return_p (XVECEXP (PATTERN (trial), 0, 0))
 	      && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))
 	    {
 	      target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));
-	      if (target_label == 0)
-		target_label = find_end_label ();
+	      if (ANY_RETURN_P (target_label))
+		target_label = find_end_label (target_label);
 
 	      if (target_label
 	          && redirect_with_delay_slots_safe_p (delay_insn, target_label,
@@ -3621,16 +3820,15 @@
 	 a RETURN here.  */
       if (! INSN_ANNULLED_BRANCH_P (delay_insn)
 	  && any_condjump_p (delay_insn)
-	  && next && JUMP_P (next)
-	  && (simplejump_p (next) || GET_CODE (PATTERN (next)) == RETURN)
+	  && next && simplejump_or_return_p (next)
 	  && next_active_insn (target_label) == next_active_insn (next)
 	  && no_labels_between_p (insn, next))
 	{
 	  rtx label = JUMP_LABEL (next);
 	  rtx old_label = JUMP_LABEL (delay_insn);
 
-	  if (label == 0)
-	    label = find_end_label ();
+	  if (ANY_RETURN_P (label))
+	    label = find_end_label (label);
 
 	  /* find_end_label can generate a new label. Check this first.  */
 	  if (label
@@ -3668,10 +3866,10 @@
 
       /* If we own the thread opposite the way this insn branches, see if we
 	 can merge its delay slots with following insns.  */
-      if (INSN_FROM_TARGET_P (XVECEXP (pat, 0, 1))
+      if (INSN_FROM_TARGET_P (first_real_insn_in_seq (insn))
 	  && own_thread_p (NEXT_INSN (insn), 0, 1))
 	try_merge_delay_insns (insn, next);
-      else if (! INSN_FROM_TARGET_P (XVECEXP (pat, 0, 1))
+      else if (! INSN_FROM_TARGET_P (first_real_insn_in_seq (insn))
 	       && own_thread_p (target_label, target_label, 0))
 	try_merge_delay_insns (insn, next_active_insn (target_label));
 
@@ -3691,7 +3889,8 @@
 make_return_insns (rtx first)
 {
   rtx insn, jump_insn, pat;
-  rtx real_return_label = end_of_function_label;
+  rtx real_return_label = function_return_label;
+  rtx real_simple_return_label = function_simple_return_label;
   int slots, i;
 
 #ifdef DELAY_SLOTS_FOR_EPILOGUE
@@ -3709,15 +3908,22 @@
      made for END_OF_FUNCTION_LABEL.  If so, set up anything we can't change
      into a RETURN to jump to it.  */
   for (insn = first; insn; insn = NEXT_INSN (insn))
-    if (JUMP_P (insn) && GET_CODE (PATTERN (insn)) == RETURN)
+    if (JUMP_P (insn) && ANY_RETURN_P (PATTERN (insn)))
       {
-	real_return_label = get_label_before (insn);
+	rtx t = get_label_before (insn);
+	if (PATTERN (insn) == ret_rtx)
+	  real_return_label = t;
+	else
+	  real_simple_return_label = t;
 	break;
       }
 
   /* Show an extra usage of REAL_RETURN_LABEL so it won't go away if it
      was equal to END_OF_FUNCTION_LABEL.  */
-  LABEL_NUSES (real_return_label)++;
+  if (real_return_label)
+    LABEL_NUSES (real_return_label)++;
+  if (real_simple_return_label)
+    LABEL_NUSES (real_simple_return_label)++;
 
   /* Clear the list of insns to fill so we can use it.  */
   obstack_free (&unfilled_slots_obstack, unfilled_firstobj);
@@ -3725,13 +3931,27 @@
   for (insn = first; insn; insn = NEXT_INSN (insn))
     {
       int flags;
+      rtx kind, real_label;
 
       /* Only look at filled JUMP_INSNs that go to the end of function
 	 label.  */
       if (!NONJUMP_INSN_P (insn)
 	  || GET_CODE (PATTERN (insn)) != SEQUENCE
-	  || !JUMP_P (XVECEXP (PATTERN (insn), 0, 0))
-	  || JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0)) != end_of_function_label)
+	  || !JUMP_P (XVECEXP (PATTERN (insn), 0, 0)))
+	continue;
+
+      if (JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0)) == function_return_label)
+	{
+	  kind = ret_rtx;
+	  real_label = real_return_label;
+	}
+      else if (JUMP_LABEL (XVECEXP (PATTERN (insn), 0, 0))
+	       == function_simple_return_label)
+	{
+	  kind = simple_return_rtx;
+	  real_label = real_simple_return_label;
+	}
+      else
 	continue;
 
       pat = PATTERN (insn);
@@ -3739,14 +3959,12 @@
 
       /* If we can't make the jump into a RETURN, try to redirect it to the best
 	 RETURN and go on to the next insn.  */
-      if (! reorg_redirect_jump (jump_insn, NULL_RTX))
+      if (! reorg_redirect_jump (jump_insn, kind))
 	{
 	  /* Make sure redirecting the jump will not invalidate the delay
 	     slot insns.  */
-	  if (redirect_with_delay_slots_safe_p (jump_insn,
-						real_return_label,
-						insn))
-	    reorg_redirect_jump (jump_insn, real_return_label);
+	  if (redirect_with_delay_slots_safe_p (jump_insn, real_label, insn))
+	    reorg_redirect_jump (jump_insn, real_label);
 	  continue;
 	}
 
@@ -3786,7 +4004,7 @@
 	 RETURN, delete the SEQUENCE and output the individual insns,
 	 followed by the RETURN.  Then set things up so we try to find
 	 insns for its delay slots, if it needs some.  */
-      if (GET_CODE (PATTERN (jump_insn)) == RETURN)
+      if (ANY_RETURN_P (PATTERN (jump_insn)))
 	{
 	  rtx prev = PREV_INSN (insn);
 
@@ -3803,13 +4021,16 @@
       else
 	/* It is probably more efficient to keep this with its current
 	   delay slot as a branch to a RETURN.  */
-	reorg_redirect_jump (jump_insn, real_return_label);
+	reorg_redirect_jump (jump_insn, real_label);
     }
 
   /* Now delete REAL_RETURN_LABEL if we never used it.  Then try to fill any
      new delay slots we have created.  */
-  if (--LABEL_NUSES (real_return_label) == 0)
+  if (real_return_label != NULL_RTX && --LABEL_NUSES (real_return_label) == 0)
     delete_related_insns (real_return_label);
+  if (real_simple_return_label != NULL_RTX
+      && --LABEL_NUSES (real_simple_return_label) == 0)
+    delete_related_insns (real_simple_return_label);
 
   fill_simple_delay_slots (1);
   fill_simple_delay_slots (0);
@@ -3877,7 +4098,7 @@
   init_resource_info (epilogue_insn);
 
   /* Show we haven't computed an end-of-function label yet.  */
-  end_of_function_label = 0;
+  function_return_label = function_simple_return_label = NULL_RTX;
 
   /* Initialize the statistics for this function.  */
   memset (num_insns_needing_delays, 0, sizeof num_insns_needing_delays);
@@ -3899,11 +4120,23 @@
   /* If we made an end of function label, indicate that it is now
      safe to delete it by undoing our prior adjustment to LABEL_NUSES.
      If it is now unused, delete it.  */
-  if (end_of_function_label && --LABEL_NUSES (end_of_function_label) == 0)
-    delete_related_insns (end_of_function_label);
+  if (function_return_label && --LABEL_NUSES (function_return_label) == 0)
+    delete_related_insns (function_return_label);
+  if (function_simple_return_label
+      && --LABEL_NUSES (function_simple_return_label) == 0)
+    delete_related_insns (function_simple_return_label);
 
+#if defined HAVE_return || defined HAVE_simple_return
+  if (
 #ifdef HAVE_return
-  if (HAVE_return && end_of_function_label != 0)
+      (HAVE_return && function_return_label != 0)
+#else
+      0
+#endif
+#ifdef HAVE_simple_return
+      || (HAVE_simple_return && function_simple_return_label != 0)
+#endif
+      )
     make_return_insns (first);
 #endif
 
diff -ru ./gcc/resource.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/resource.c
--- ./gcc/resource.c	2014-06-06 11:50:19.591598755 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/resource.c	2012-03-29 18:03:19.000000000 +1000
@@ -47,6 +47,7 @@
   struct target_info *next;	/* Next info for same hash bucket.  */
   HARD_REG_SET live_regs;	/* Registers live at target.  */
   int block;			/* Basic block number containing target.  */
+  rtx label;			/* Label corresponding to block.  */
   int bb_tick;			/* Generation count of basic block info.  */
 };
 
@@ -79,7 +80,7 @@
 static HARD_REG_SET pending_dead_regs;
 
 static void update_live_status (rtx, const_rtx, void *);
-static int find_basic_block (rtx, int);
+static int find_basic_block (rtx, int, rtx *);
 static rtx next_insn_no_annul (rtx);
 static rtx find_dead_or_set_registers (rtx, struct resources*,
 				       rtx*, int, struct resources,
@@ -133,8 +134,11 @@
    correct.  */
 
 static int
-find_basic_block (rtx insn, int search_limit)
+find_basic_block (rtx insn, int search_limit, rtx *label)
 {
+  if (label)
+    *label = NULL_RTX;
+
   /* Scan backwards to the previous BARRIER.  Then see if we can find a
      label that starts a basic block.  Return the basic block number.  */
   for (insn = prev_nonnote_insn (insn);
@@ -156,7 +160,11 @@
        insn && LABEL_P (insn);
        insn = next_nonnote_insn (insn))
     if (BLOCK_FOR_INSN (insn))
-      return BLOCK_FOR_INSN (insn)->index;
+      {
+        if (label)
+          *label = insn;
+        return BLOCK_FOR_INSN (insn)->index;
+      }
 
   return -1;
 }
@@ -495,6 +503,8 @@
 		  || GET_CODE (PATTERN (this_jump_insn)) == RETURN)
 		{
 		  next = JUMP_LABEL (this_jump_insn);
+		  if (next && ANY_RETURN_P (next))
+		    next = NULL_RTX;
 		  if (jump_insn == 0)
 		    {
 		      jump_insn = insn;
@@ -562,9 +572,10 @@
 		  AND_COMPL_HARD_REG_SET (scratch, needed.regs);
 		  AND_COMPL_HARD_REG_SET (fallthrough_res.regs, scratch);
 
-		  find_dead_or_set_registers (JUMP_LABEL (this_jump_insn),
-					      &target_res, 0, jump_count,
-					      target_set, needed);
+		  if (!ANY_RETURN_P (JUMP_LABEL (this_jump_insn)))
+		    find_dead_or_set_registers (JUMP_LABEL (this_jump_insn),
+						&target_res, 0, jump_count,
+						target_set, needed);
 		  find_dead_or_set_registers (next,
 					      &fallthrough_res, 0, jump_count,
 					      set, needed);
@@ -653,10 +664,12 @@
       if (mark_type == MARK_SRC_DEST_CALL)
 	{
 	  rtx link;
+	  HARD_REG_SET regs;
 
 	  res->cc = res->memory = 1;
 
-	  IOR_HARD_REG_SET (res->regs, regs_invalidated_by_call);
+	  get_call_reg_set_usage (x, &regs, regs_invalidated_by_call);
+	  IOR_HARD_REG_SET (res->regs, regs);
 
 	  for (link = CALL_INSN_FUNCTION_USAGE (x);
 	       link; link = XEXP (link, 1))
@@ -826,7 +839,39 @@
 
   return false;
 }
+
+/* Get the block field from TINFO, if valid.  */
+
+static int
+get_block (struct target_info *tinfo)
+{
+  int b, check_b;
+  rtx label, check_label;
+
+  b = tinfo->block;
+
+  /* Invalid block.  */
+  if (b == -1 || INSN_DELETED_P (BB_HEAD (BASIC_BLOCK (b))))
+    return -1;
+  
+  label = tinfo->label;
+
+  /* Barrier is start of function.  */
+  if (label == NULL_RTX)
+    return b;
 
+  /* Check if label is still valid.  */
+  if (!LABEL_P (label) || INSN_DELETED_P (label))
+    return -1;
+
+  /* Check if find_basic_block still finds the same label.  */
+  check_b = find_basic_block (label, MAX_DELAY_SLOT_LIVE_SEARCH, &check_label);
+  if (b != check_b || label != check_label)
+    return -1;
+
+  return b;
+}
+
 /* Set the resources that are live at TARGET.
 
    If TARGET is zero, we refer to the end of the current function and can
@@ -873,7 +918,7 @@
   struct target_info *tinfo = NULL;
   rtx insn;
   rtx jump_insn = 0;
-  rtx jump_target;
+  rtx jump_target, label;
   HARD_REG_SET scratch;
   struct resources set, needed;
 
@@ -906,15 +951,18 @@
 	  break;
 
       /* Start by getting the basic block number.  If we have saved
-	 information, we can get it from there unless the insn at the
-	 start of the basic block has been deleted.  */
-      if (tinfo && tinfo->block != -1
-	  && ! INSN_DELETED_P (BB_HEAD (BASIC_BLOCK (tinfo->block))))
-	b = tinfo->block;
+	 information, we can get it from there if unless the information is not
+         valid anymore.  */
+      if (tinfo)
+        {
+          b = get_block (tinfo);
+          if (b == -1 && tinfo->block != -1)
+            tinfo->block = -1;
+        }
     }
 
   if (b == -1)
-    b = find_basic_block (target, MAX_DELAY_SLOT_LIVE_SEARCH);
+    b = find_basic_block (target, MAX_DELAY_SLOT_LIVE_SEARCH, &label);
 
   if (target_hash_table != NULL)
     {
@@ -935,6 +983,7 @@
 	  tinfo = XNEW (struct target_info);
 	  tinfo->uid = INSN_UID (target);
 	  tinfo->block = b;
+	  tinfo->label = label;
 	  tinfo->next
 	    = target_hash_table[INSN_UID (target) % TARGET_HASH_PRIME];
 	  target_hash_table[INSN_UID (target) % TARGET_HASH_PRIME] = tinfo;
@@ -994,11 +1043,16 @@
 
 	  if (CALL_P (real_insn))
 	    {
+	      HARD_REG_SET regs_invalidated_by_this_call;
 	      /* CALL clobbers all call-used regs that aren't fixed except
 		 sp, ap, and fp.  Do this before setting the result of the
 		 call live.  */
-	      AND_COMPL_HARD_REG_SET (current_live_regs,
+
+	      get_call_reg_set_usage (real_insn,
+				      &regs_invalidated_by_this_call,
 				      regs_invalidated_by_call);
+	      AND_COMPL_HARD_REG_SET (current_live_regs,
+				      regs_invalidated_by_this_call);
 
 	      /* A CALL_INSN sets any global register live, since it may
 		 have been modified by the call.  */
@@ -1072,6 +1126,8 @@
       COPY_HARD_REG_SET (res->regs, current_live_regs);
       if (tinfo != NULL)
 	{
+	  if (tinfo->block != b)
+	    tinfo->label = label;
 	  tinfo->block = b;
 	  tinfo->bb_tick = bb_ticks[b];
 	}
@@ -1097,6 +1153,8 @@
       struct resources new_resources;
       rtx stop_insn = next_active_insn (jump_insn);
 
+      if (jump_target && ANY_RETURN_P (jump_target))
+	jump_target = NULL_RTX;
       mark_target_live_regs (insns, next_active_insn (jump_target),
 			     &new_resources);
       CLEAR_RESOURCE (&set);
@@ -1269,7 +1327,7 @@
 void
 incr_ticks_for_insn (rtx insn)
 {
-  int b = find_basic_block (insn, MAX_DELAY_SLOT_LIVE_SEARCH);
+  int b = find_basic_block (insn, MAX_DELAY_SLOT_LIVE_SEARCH, NULL);
 
   if (b != -1)
     bb_ticks[b]++;
diff -ru ./gcc/rtlanal.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtlanal.c
--- ./gcc/rtlanal.c	2014-06-06 11:50:19.631598756 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtlanal.c	2012-03-29 18:03:19.000000000 +1000
@@ -999,6 +999,56 @@
   note_stores (INSN_P (insn) ? PATTERN (insn) : insn, set_of_1, &data);
   return data.found;
 }
+
+/* This function, called through note_stores, collects sets and
+   clobbers of hard registers in a HARD_REG_SET, which is pointed to
+   by DATA.  */
+void
+record_hard_reg_sets (rtx x, const_rtx pat ATTRIBUTE_UNUSED, void *data)
+{
+  HARD_REG_SET *pset = (HARD_REG_SET *)data;
+  if (REG_P (x) && HARD_REGISTER_P (x))
+    add_to_hard_reg_set (pset, GET_MODE (x), REGNO (x));
+}
+
+/* Examine INSN, and compute the set of hard registers written by it.
+   Store it in *PSET.  Should only be called after reload.  */
+void
+find_all_hard_reg_sets (const_rtx insn, HARD_REG_SET *pset)
+{
+  rtx link;
+
+  CLEAR_HARD_REG_SET (*pset);
+  note_stores (PATTERN (insn), record_hard_reg_sets, pset);
+  if (CALL_P (insn))
+    IOR_HARD_REG_SET (*pset, call_used_reg_set);
+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+    if (REG_NOTE_KIND (link) == REG_INC)
+      record_hard_reg_sets (XEXP (link, 0), NULL, pset);
+}
+
+/* A for_each_rtx subroutine of record_hard_reg_uses.  */
+static int
+record_hard_reg_uses_1 (rtx *px, void *data)
+{
+  rtx x = *px;
+  HARD_REG_SET *pused = (HARD_REG_SET *)data;
+
+  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)
+    {
+      int nregs = hard_regno_nregs[REGNO (x)][GET_MODE (x)];
+      while (nregs-- > 0)
+	SET_HARD_REG_BIT (*pused, REGNO (x) + nregs);
+    }
+  return 0;
+}
+
+/* Like record_hard_reg_sets, but called through note_uses.  */
+void
+record_hard_reg_uses (rtx *px, void *data)
+{
+  for_each_rtx (px, record_hard_reg_uses_1, data);
+}
 
 /* Given an INSN, return a SET expression if this insn has only a single SET.
    It may also have CLOBBERs, USEs, or SET whose output
@@ -2662,6 +2712,7 @@
 
   if (JUMP_P (insn)
       && (label = JUMP_LABEL (insn)) != NULL_RTX
+      && !ANY_RETURN_P (label)
       && (table = next_active_insn (label)) != NULL_RTX
       && JUMP_TABLE_DATA_P (table))
     {
diff -ru ./gcc/rtl.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtl.c
--- ./gcc/rtl.c	2014-06-06 11:50:19.595598755 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtl.c	2012-03-29 18:03:19.000000000 +1000
@@ -255,6 +255,8 @@
     case CODE_LABEL:
     case PC:
     case CC0:
+    case RETURN:
+    case SIMPLE_RETURN:
     case SCRATCH:
       /* SCRATCH must be shared because they represent distinct values.  */
       return orig;
diff -ru ./gcc/rtl.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtl.def
--- ./gcc/rtl.def	2014-06-06 11:50:19.599598755 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtl.def	2012-03-29 18:03:19.000000000 +1000
@@ -296,6 +296,10 @@
 
 DEF_RTL_EXPR(RETURN, "return", "", RTX_EXTRA)
 
+/* A plain return, to be used on paths that are reached without going
+   through the function prologue.  */
+DEF_RTL_EXPR(SIMPLE_RETURN, "simple_return", "", RTX_EXTRA)
+
 /* Special for EH return from subroutine.  */
 
 DEF_RTL_EXPR(EH_RETURN, "eh_return", "", RTX_EXTRA)
diff -ru ./gcc/rtl.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtl.h
--- ./gcc/rtl.h	2014-06-06 11:50:19.615598756 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/rtl.h	2012-03-29 18:03:19.000000000 +1000
@@ -412,6 +412,10 @@
   (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \
 		     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))
 
+/* Predicate yielding nonzero iff X is a return or simple_preturn.  */
+#define ANY_RETURN_P(X) \
+  (GET_CODE (X) == RETURN || GET_CODE (X) == SIMPLE_RETURN)
+
 /* 1 if X is a unary operator.  */
 
 #define UNARY_P(X)   \
@@ -971,6 +975,11 @@
 #define GET_NOTE_INSN_NAME(NOTE_CODE) \
   (note_insn_name[(NOTE_CODE)])
 
+/* Predicate yielding nonzero iff X is a deleted insn note.  */
+#define DELETED_NOTE_P(X)					\
+  (NOTE_P (X) && (NOTE_KIND (X) == NOTE_INSN_DELETED		\
+		  || NOTE_KIND (X) == NOTE_INSN_DELETED_LABEL))
+
 /* The name of a label, in case it corresponds to an explicit label
    in the input source code.  */
 #define LABEL_NAME(RTX) XCSTR (RTX, 7, CODE_LABEL)
@@ -1862,6 +1871,11 @@
 extern int refers_to_regno_p (unsigned int, unsigned int, const_rtx, rtx *);
 extern int reg_overlap_mentioned_p (const_rtx, const_rtx);
 extern const_rtx set_of (const_rtx, const_rtx);
+extern void record_hard_reg_sets (rtx, const_rtx, void *);
+extern void record_hard_reg_uses (rtx *, void *);
+#ifdef HARD_CONST
+extern void find_all_hard_reg_sets (const_rtx, HARD_REG_SET *);
+#endif
 extern void note_stores (const_rtx, void (*) (rtx, const_rtx, void *), void *);
 extern void note_uses (rtx *, void (*) (rtx *, void *), void *);
 extern int dead_or_set_p (const_rtx, const_rtx);
@@ -1957,12 +1971,14 @@
 
 /* lists.c */
 
-extern void free_EXPR_LIST_list		(rtx *);
-extern void free_INSN_LIST_list		(rtx *);
-extern void free_EXPR_LIST_node		(rtx);
-extern void free_INSN_LIST_node		(rtx);
-extern rtx alloc_INSN_LIST			(rtx, rtx);
-extern rtx alloc_EXPR_LIST			(int, rtx, rtx);
+extern void free_EXPR_LIST_list (rtx *);
+extern void free_INSN_LIST_list (rtx *);
+extern void free_EXPR_LIST_node (rtx);
+extern void free_INSN_LIST_node (rtx);
+extern rtx alloc_INSN_LIST (rtx, rtx);
+extern rtx copy_INSN_LIST (rtx);
+extern rtx concat_INSN_LIST (rtx, rtx);
+extern rtx alloc_EXPR_LIST (int, rtx, rtx);
 extern void remove_free_INSN_LIST_elem (rtx, rtx *);
 extern rtx remove_list_elem (rtx, rtx *);
 extern rtx remove_free_INSN_LIST_node (rtx *);
@@ -2041,6 +2057,8 @@
 {
   GR_PC,
   GR_CC0,
+  GR_RETURN,
+  GR_SIMPLE_RETURN,
   GR_STACK_POINTER,
   GR_FRAME_POINTER,
 /* For register elimination to work properly these hard_frame_pointer_rtx,
@@ -2130,6 +2148,8 @@
 
 /* Standard pieces of rtx, to be substituted directly into things.  */
 #define pc_rtx                  (global_rtl[GR_PC])
+#define ret_rtx                 (global_rtl[GR_RETURN])
+#define simple_return_rtx       (global_rtl[GR_SIMPLE_RETURN])
 #define cc0_rtx                 (global_rtl[GR_CC0])
 
 /* All references to certain hard regs, except those created
diff -ru ./gcc/sched-deps.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-deps.c
--- ./gcc/sched-deps.c	2014-06-06 11:50:19.651598757 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-deps.c	2012-03-29 18:03:19.000000000 +1000
@@ -51,12 +51,6 @@
 #define CHECK (false)
 #endif
 
-/* In deps->last_pending_memory_flush marks JUMP_INSNs that weren't
-   added to the list because of flush_pending_lists, stands just
-   for itself and not for any other pending memory reads/writes.  */
-#define NON_FLUSH_JUMP_KIND REG_DEP_ANTI
-#define NON_FLUSH_JUMP_P(x) (REG_NOTE_KIND (x) == NON_FLUSH_JUMP_KIND)
-
 /* Holds current parameters for the dependency analyzer.  */
 struct sched_deps_info_def *sched_deps_info;
 
@@ -73,6 +67,9 @@
   if (ds & DEP_OUTPUT)
     return REG_DEP_OUTPUT;
 
+  if (ds & DEP_CONTROL)
+    return REG_DEP_CONTROL;
+
   gcc_assert (ds & DEP_ANTI);
 
   return REG_DEP_ANTI;
@@ -90,6 +87,9 @@
     case REG_DEP_OUTPUT:
       return DEP_OUTPUT;
 
+    case REG_DEP_CONTROL:
+      return DEP_CONTROL;
+
     default:
       gcc_assert (dk == REG_DEP_ANTI);
       return DEP_ANTI;
@@ -106,6 +106,7 @@
   DEP_CON (dep) = con;
   DEP_TYPE (dep) = type;
   DEP_STATUS (dep) = ds;
+  DEP_COST (dep) = UNKNOWN_DEP_COST;
 }
 
 /* Init DEP with the arguments.
@@ -119,7 +120,7 @@
   if ((current_sched_info->flags & USE_DEPS_LIST))
     ds = dk_to_ds (kind);
   else
-    ds = -1;
+    ds = 0;
 
   init_dep_1 (dep, pro, con, kind, ds);
 }
@@ -185,6 +186,10 @@
 	  t = 'o';
 	  break;
 
+	case REG_DEP_CONTROL:
+	  t = 'c';
+	  break;
+
 	case REG_DEP_ANTI:
 	  t = 'a';
 	  break;
@@ -412,9 +417,28 @@
   while (1);
 }
 
+/* Decide whether a dependency should be treated as a hard or a speculative
+   dependency.  */
+static bool
+dep_spec_p (dep_t dep)
+{
+  if (current_sched_info->flags & DO_SPECULATION)
+    {
+      if (DEP_STATUS (dep) & SPECULATIVE)
+	return true;
+    }
+  if (current_sched_info->flags & DO_PREDICATION)
+    {
+      if (DEP_TYPE (dep) == REG_DEP_CONTROL)
+	return true;
+    }
+  return false;
+}
+
 static regset reg_pending_sets;
 static regset reg_pending_clobbers;
 static regset reg_pending_uses;
+static regset reg_pending_control_uses;
 static enum reg_pending_barrier_mode reg_pending_barrier;
 
 /* Hard registers implicitly clobbered or used (or may be implicitly
@@ -442,10 +466,12 @@
 static bitmap_head *true_dependency_cache = NULL;
 static bitmap_head *output_dependency_cache = NULL;
 static bitmap_head *anti_dependency_cache = NULL;
+static bitmap_head *control_dependency_cache = NULL;
 static bitmap_head *spec_dependency_cache = NULL;
 static int cache_size;
 
 static int deps_may_trap_p (const_rtx);
+static void add_dependence_1 (rtx, rtx, enum reg_note);
 static void add_dependence_list (rtx, rtx, int, enum reg_note);
 static void add_dependence_list_and_free (struct deps_desc *, rtx,
 					  rtx *, int, enum reg_note);
@@ -489,7 +515,7 @@
    it is set to TRUE when the returned comparison should be reversed
    to get the actual condition.  */
 static rtx
-sched_get_condition_with_rev (const_rtx insn, bool *rev)
+sched_get_condition_with_rev_uncached (const_rtx insn, bool *rev)
 {
   rtx pat = PATTERN (insn);
   rtx src;
@@ -526,6 +552,62 @@
   return 0;
 }
 
+/* Return the condition under which INSN does not execute (i.e.  the
+   not-taken condition for a conditional branch), or NULL if we cannot
+   find such a condition.  The caller should make a copy of the condition
+   before using it.  */
+rtx
+sched_get_reverse_condition_uncached (const_rtx insn)
+{
+  bool rev;
+  rtx cond = sched_get_condition_with_rev_uncached (insn, &rev);
+  if (cond == NULL_RTX)
+    return cond;
+  if (!rev)
+    {
+      enum rtx_code revcode = reversed_comparison_code (cond, insn);
+      cond = gen_rtx_fmt_ee (revcode, GET_MODE (cond),
+			     XEXP (cond, 0),
+			     XEXP (cond, 1));
+    }
+  return cond;
+}
+
+/* Caching variant of sched_get_condition_with_rev_uncached.
+   We only do actual work the first time we come here for an insn; the
+   results are cached in INSN_CACHED_COND and INSN_REVERSE_COND.  */
+static rtx
+sched_get_condition_with_rev (const_rtx insn, bool *rev)
+{
+  bool tmp;
+
+  if (INSN_LUID (insn) == 0)
+    return sched_get_condition_with_rev_uncached (insn, rev);
+
+  if (INSN_CACHED_COND (insn) == const_true_rtx)
+    return NULL_RTX;
+
+  if (INSN_CACHED_COND (insn) != NULL_RTX)
+    {
+      if (rev)
+	*rev = INSN_REVERSE_COND (insn);
+      return INSN_CACHED_COND (insn);
+    }
+
+  INSN_CACHED_COND (insn) = sched_get_condition_with_rev_uncached (insn, &tmp);
+  INSN_REVERSE_COND (insn) = tmp;
+
+  if (INSN_CACHED_COND (insn) == NULL_RTX)
+    {
+      INSN_CACHED_COND (insn) = const_true_rtx;
+      return NULL_RTX;
+    }
+
+  if (rev)
+    *rev = INSN_REVERSE_COND (insn);
+  return INSN_CACHED_COND (insn);
+}
+
 /* True when we can find a condition under which INSN is executed.  */
 static bool
 sched_has_condition_p (const_rtx insn)
@@ -545,7 +627,7 @@
 	  (rev1==rev2
 	  ? reversed_comparison_code (cond2, NULL)
 	  : GET_CODE (cond2))
-      && XEXP (cond1, 0) == XEXP (cond2, 0)
+      && rtx_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))
       && XEXP (cond1, 1) == XEXP (cond2, 1))
     return 1;
   return 0;
@@ -814,12 +896,10 @@
       int elem_luid = INSN_LUID (pro);
       int insn_luid = INSN_LUID (con);
 
-      gcc_assert (output_dependency_cache != NULL
-		  && anti_dependency_cache != NULL);
-
       if (!bitmap_bit_p (&true_dependency_cache[insn_luid], elem_luid)
 	  && !bitmap_bit_p (&output_dependency_cache[insn_luid], elem_luid)
-	  && !bitmap_bit_p (&anti_dependency_cache[insn_luid], elem_luid))
+	  && !bitmap_bit_p (&anti_dependency_cache[insn_luid], elem_luid)
+	  && !bitmap_bit_p (&control_dependency_cache[insn_luid], elem_luid))
 	return NULL;
     }
 
@@ -872,7 +952,8 @@
 
   gcc_assert (true_dependency_cache != NULL
 	      && output_dependency_cache != NULL
-	      && anti_dependency_cache != NULL);
+	      && anti_dependency_cache != NULL
+	      && control_dependency_cache != NULL);
 
   if (!(current_sched_info->flags & USE_DEPS_LIST))
     {
@@ -884,6 +965,8 @@
 	present_dep_type = REG_DEP_OUTPUT;
       else if (bitmap_bit_p (&anti_dependency_cache[insn_luid], elem_luid))
 	present_dep_type = REG_DEP_ANTI;
+      else if (bitmap_bit_p (&control_dependency_cache[insn_luid], elem_luid))
+	present_dep_type = REG_DEP_CONTROL;
       else
 	/* There is no existing dep so it should be created.  */
 	return DEP_CREATED;
@@ -902,6 +985,8 @@
 	present_dep_types |= DEP_OUTPUT;
       if (bitmap_bit_p (&anti_dependency_cache[insn_luid], elem_luid))
 	present_dep_types |= DEP_ANTI;
+      if (bitmap_bit_p (&control_dependency_cache[insn_luid], elem_luid))
+	present_dep_types |= DEP_CONTROL;
 
       if (present_dep_types == 0)
 	/* There is no existing dep so it should be created.  */
@@ -955,6 +1040,10 @@
 	  bitmap_set_bit (&anti_dependency_cache[insn_luid], elem_luid);
 	  break;
 
+	case REG_DEP_CONTROL:
+	  bitmap_set_bit (&control_dependency_cache[insn_luid], elem_luid);
+	  break;
+
 	default:
 	  gcc_unreachable ();
 	}
@@ -969,6 +1058,8 @@
 	bitmap_set_bit (&output_dependency_cache[insn_luid], elem_luid);
       if (ds & DEP_ANTI)
 	bitmap_set_bit (&anti_dependency_cache[insn_luid], elem_luid);
+      if (ds & DEP_CONTROL)
+	bitmap_set_bit (&control_dependency_cache[insn_luid], elem_luid);
 
       if (ds & SPECULATIVE)
 	{
@@ -1000,6 +1091,10 @@
 	  bitmap_clear_bit (&anti_dependency_cache[insn_luid], elem_luid);
 	  break;
 
+	case REG_DEP_CONTROL:
+	  bitmap_clear_bit (&control_dependency_cache[insn_luid], elem_luid);
+	  break;
+
 	default:
 	  gcc_unreachable ();
 	}
@@ -1040,6 +1135,7 @@
 {
   enum DEPS_ADJUST_RESULT res = DEP_PRESENT;
   enum reg_note old_type = DEP_TYPE (dep);
+  bool was_spec = dep_spec_p (dep);
 
   /* If this is a more restrictive type of dependence than the
      existing one, then change the existing dependence to this
@@ -1058,20 +1154,13 @@
       ds_t new_status = ds | dep_status;
 
       if (new_status & SPECULATIVE)
-	/* Either existing dep or a dep we're adding or both are
-	   speculative.  */
 	{
+	  /* Either existing dep or a dep we're adding or both are
+	     speculative.  */
 	  if (!(ds & SPECULATIVE)
 	      || !(dep_status & SPECULATIVE))
 	    /* The new dep can't be speculative.  */
-	    {
-	      new_status &= ~SPECULATIVE;
-
-	      if (dep_status & SPECULATIVE)
-		/* The old dep was speculative, but now it
-		   isn't.  */
-		change_spec_dep_to_hard (sd_it);
-	    }
+	    new_status &= ~SPECULATIVE;
 	  else
 	    {
 	      /* Both are speculative.  Merge probabilities.  */
@@ -1096,6 +1185,10 @@
 	}
     }
 
+  if (was_spec && !dep_spec_p (dep))
+    /* The old dep was speculative, but now it isn't.  */
+    change_spec_dep_to_hard (sd_it);
+
   if (true_dependency_cache != NULL
       && res == DEP_CHANGED)
     update_dependency_caches (dep, old_type);
@@ -1196,8 +1289,7 @@
 
   if (!resolved_p)
     {
-      if ((current_sched_info->flags & DO_SPECULATION)
-	  && (DEP_STATUS (dep) & SPECULATIVE))
+      if (dep_spec_p (dep))
 	*back_list_ptr = INSN_SPEC_BACK_DEPS (con);
       else
 	*back_list_ptr = INSN_HARD_BACK_DEPS (con);
@@ -1224,8 +1316,8 @@
 
   gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);
 
-  if ((current_sched_info->flags & DO_SPECULATION)
-      && !sched_insn_is_legitimate_for_speculation_p (insn, DEP_STATUS (dep)))
+  if ((current_sched_info->flags & DO_SPECULATION) == 0
+      || !sched_insn_is_legitimate_for_speculation_p (insn, DEP_STATUS (dep)))
     DEP_STATUS (dep) &= ~SPECULATIVE;
 
   copy_dep (DEP_NODE_DEP (n), dep);
@@ -1265,8 +1357,7 @@
   rtx pro = DEP_PRO (dep);
   rtx con = DEP_CON (dep);
 
-  if ((current_sched_info->flags & DO_SPECULATION)
-      && (DEP_STATUS (dep) & SPECULATIVE))
+  if (dep_spec_p (dep))
     move_dep_link (DEP_NODE_BACK (node), INSN_SPEC_BACK_DEPS (con),
 		   INSN_RESOLVED_BACK_DEPS (con));
   else
@@ -1277,6 +1368,27 @@
 		 INSN_RESOLVED_FORW_DEPS (pro));
 }
 
+/* Perform the inverse operation of sd_resolve_dep.  Restore the dependence
+   pointed to by SD_IT to unresolved state.  */
+void
+sd_unresolve_dep (sd_iterator_def sd_it)
+{
+  dep_node_t node = DEP_LINK_NODE (*sd_it.linkp);
+  dep_t dep = DEP_NODE_DEP (node);
+  rtx pro = DEP_PRO (dep);
+  rtx con = DEP_CON (dep);
+
+  if (dep_spec_p (dep))
+    move_dep_link (DEP_NODE_BACK (node), INSN_RESOLVED_BACK_DEPS (con),
+		   INSN_SPEC_BACK_DEPS (con));
+  else
+    move_dep_link (DEP_NODE_BACK (node), INSN_RESOLVED_BACK_DEPS (con),
+		   INSN_HARD_BACK_DEPS (con));
+
+  move_dep_link (DEP_NODE_FORW (node), INSN_RESOLVED_FORW_DEPS (pro),
+		 INSN_FORW_DEPS (pro));
+}
+
 /* Make TO depend on all the FROM's producers.
    If RESOLVED_P is true add dependencies to the resolved lists.  */
 void
@@ -1317,6 +1429,7 @@
 
       bitmap_clear_bit (&true_dependency_cache[insn_luid], elem_luid);
       bitmap_clear_bit (&anti_dependency_cache[insn_luid], elem_luid);
+      bitmap_clear_bit (&control_dependency_cache[insn_luid], elem_luid);
       bitmap_clear_bit (&output_dependency_cache[insn_luid], elem_luid);
 
       if (current_sched_info->flags & DO_SPECULATION)
@@ -1382,6 +1495,57 @@
   fprintf (stderr, "\n");
 }
 
+/* A wrapper around add_dependence_1, to add a dependence of CON on
+   PRO, with type DEP_TYPE.  This function implements special handling
+   for REG_DEP_CONTROL dependencies.  For these, we optionally promote
+   the type to REG_DEP_ANTI if we can determine that predication is
+   impossible; otherwise we add additional true dependencies on the
+   INSN_COND_DEPS list of the jump (which PRO must be).  */
+void
+add_dependence (rtx con, rtx pro, enum reg_note dep_type)
+{
+  if (dep_type == REG_DEP_CONTROL
+      && !(current_sched_info->flags & DO_PREDICATION))
+    dep_type = REG_DEP_ANTI;
+
+  /* A REG_DEP_CONTROL dependence may be eliminated through predication,
+     so we must also make the insn dependent on the setter of the
+     condition.  */
+  if (dep_type == REG_DEP_CONTROL)
+    {
+      rtx real_pro = pro;
+      rtx other = real_insn_for_shadow (real_pro);
+      rtx cond;
+
+      if (other != NULL_RTX)
+	real_pro = other;
+      cond = sched_get_reverse_condition_uncached (real_pro);
+      /* Verify that the insn does not use a different value in
+	 the condition register than the one that was present at
+	 the jump.  */
+      if (cond == NULL_RTX)
+	dep_type = REG_DEP_ANTI;
+      else if (INSN_CACHED_COND (real_pro) == const_true_rtx)
+	{
+	  HARD_REG_SET uses;
+	  CLEAR_HARD_REG_SET (uses);
+	  note_uses (&PATTERN (con), record_hard_reg_uses, &uses);
+	  if (TEST_HARD_REG_BIT (uses, REGNO (XEXP (cond, 0))))
+	    dep_type = REG_DEP_ANTI;
+	}
+      if (dep_type == REG_DEP_CONTROL)
+	{
+	  if (sched_verbose >= 5)
+	    fprintf (sched_dump, "making DEP_CONTROL for %d\n",
+		     INSN_UID (real_pro));
+	  add_dependence_list (con, INSN_COND_DEPS (real_pro), 0,
+			       REG_DEP_TRUE);
+	}
+    }
+	  
+  add_dependence_1 (con, pro, dep_type);
+}
+
 /* A convenience wrapper to operate on an entire list.  */
 
 static void
@@ -1597,6 +1761,10 @@
   add_dependence_list_and_free (deps, insn,
                                 &deps->last_pending_memory_flush, 1,
                                 for_read ? REG_DEP_ANTI : REG_DEP_OUTPUT);
+
+  add_dependence_list_and_free (deps, insn, &deps->pending_jump_insns, 1,
+				REG_DEP_ANTI);
+
   if (!deps->readonly)
     {
       free_EXPR_LIST_list (&deps->pending_write_mems);
@@ -1659,7 +1827,7 @@
     dep_def _dep, *dep = &_dep;
 
     init_dep_1 (dep, pending_insn, cur_insn, ds_to_dt (ds),
-                current_sched_info->flags & USE_DEPS_LIST ? ds : -1);
+                current_sched_info->flags & USE_DEPS_LIST ? ds : 0);
     maybe_add_or_update_dep_1 (dep, false, pending_mem, mem);
   }
 
@@ -1718,10 +1886,12 @@
     return REG_DEP_TRUE;
   else if (ds & DEP_OUTPUT)
     return REG_DEP_OUTPUT;
+  else if (ds & DEP_ANTI)
+    return REG_DEP_ANTI;
   else
     {
-      gcc_assert (ds & DEP_ANTI);
-      return REG_DEP_ANTI;
+      gcc_assert (ds & DEP_CONTROL);
+      return REG_DEP_CONTROL;
     }
 }
 
@@ -2333,6 +2503,8 @@
 
 	  add_dependence_list (insn, deps->last_pending_memory_flush, 1,
 			       REG_DEP_ANTI);
+	  add_dependence_list (insn, deps->pending_jump_insns, 1,
+			       REG_DEP_CONTROL);
 
           if (!deps->readonly)
             add_insn_mem_dependence (deps, false, insn, dest);
@@ -2480,23 +2652,22 @@
 	      }
 
 	    for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))
-	      {
-		if (! NON_FLUSH_JUMP_P (u))
-		  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);
-		else if (deps_may_trap_p (x))
-		  {
-		    if ((sched_deps_info->generate_spec_deps)
-			&& sel_sched_p () && (spec_info->mask & BEGIN_CONTROL))
-		      {
-			ds_t ds = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,
-						MAX_DEP_WEAK);
-
-			note_dep (XEXP (u, 0), ds);
-		      }
-		    else
-		      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);
-		  }
-	      }
+	      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);
+
+	    for (u = deps->pending_jump_insns; u; u = XEXP (u, 1))
+	      if (deps_may_trap_p (x))
+		{
+		  if ((sched_deps_info->generate_spec_deps)
+		      && sel_sched_p () && (spec_info->mask & BEGIN_CONTROL))
+		    {
+		      ds_t ds = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,
+					      MAX_DEP_WEAK);
+		      
+		      note_dep (XEXP (u, 0), ds);
+		    }
+		  else
+		    add_dependence (insn, XEXP (u, 0), REG_DEP_CONTROL);
+		}
 	  }
 
 	/* Always add these dependencies to pending_reads, since
@@ -2635,6 +2806,18 @@
     add_dependence_list (insn, deps->last_function_call_may_noreturn,
 			 1, REG_DEP_ANTI);
 
+  /* We must avoid creating a situation in which two successors of the
+     current block have different unwind info after scheduling.  If at any
+     point the two paths re-join this leads to incorrect unwind info.  */
+  /* ??? There are certain situations involving a forced frame pointer in
+     which, with extra effort, we could fix up the unwind info at a later
+     CFG join.  However, it seems better to notice these cases earlier
+     during prologue generation and avoid marking the frame pointer setup
+     as frame-related at all.  */
+  if (RTX_FRAME_RELATED_P (insn))
+    deps->sched_before_next_jump
+      = alloc_INSN_LIST (insn, deps->sched_before_next_jump);
+
   if (code == COND_EXEC)
     {
       sched_analyze_2 (deps, COND_EXEC_TEST (x), insn);
@@ -2684,7 +2867,7 @@
 	{
 	  if (GET_CODE (XEXP (link, 0)) == CLOBBER)
 	    sched_analyze_1 (deps, XEXP (link, 0), insn);
-	  else
+	  else if (GET_CODE (XEXP (link, 0)) != SET)
 	    sched_analyze_2 (deps, XEXP (link, 0), insn);
 	}
       /* Don't schedule anything after a tail call, tail call needs
@@ -2707,14 +2890,11 @@
 
           if (sched_deps_info->compute_jump_reg_dependencies)
             {
-              regset_head tmp_uses, tmp_sets;
-              INIT_REG_SET (&tmp_uses);
-              INIT_REG_SET (&tmp_sets);
-
               (*sched_deps_info->compute_jump_reg_dependencies)
-                (insn, &deps->reg_conditional_sets, &tmp_uses, &tmp_sets);
+		(insn, reg_pending_control_uses);
+
               /* Make latency of jump equal to 0 by using anti-dependence.  */
-              EXECUTE_IF_SET_IN_REG_SET (&tmp_uses, 0, i, rsi)
+              EXECUTE_IF_SET_IN_REG_SET (reg_pending_control_uses, 0, i, rsi)
                 {
                   struct deps_reg *reg_last = &deps->reg_last[i];
                   add_dependence_list (insn, reg_last->sets, 0, REG_DEP_ANTI);
@@ -2722,17 +2902,7 @@
 				       0, REG_DEP_ANTI);
                   add_dependence_list (insn, reg_last->clobbers, 0,
 				       REG_DEP_ANTI);
-
-                  if (!deps->readonly)
-                    {
-                      reg_last->uses_length++;
-                      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);
-                    }
                 }
-              IOR_REG_SET (reg_pending_sets, &tmp_sets);
-
-              CLEAR_REG_SET (&tmp_uses);
-              CLEAR_REG_SET (&tmp_sets);
             }
 
 	  /* All memory writes and volatile reads must happen before the
@@ -2762,6 +2932,8 @@
 
 	  add_dependence_list (insn, deps->last_pending_memory_flush, 1,
 			       REG_DEP_ANTI);
+	  add_dependence_list (insn, deps->pending_jump_insns, 1,
+			       REG_DEP_ANTI);
 	}
     }
 
@@ -2797,13 +2969,15 @@
 			   REG_DEP_ANTI);
 
       for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))
-	if (! NON_FLUSH_JUMP_P (u) || !sel_sched_p ())
+	if (!sel_sched_p ())
 	  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);
 
       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)
 	{
 	  struct deps_reg *reg_last = &deps->reg_last[i];
 	  add_dependence_list (insn, reg_last->sets, 1, REG_DEP_ANTI);
+	  /* There's no point in making REG_DEP_CONTROL dependencies for
+	     debug insns.  */
 	  add_dependence_list (insn, reg_last->clobbers, 1, REG_DEP_ANTI);
 
 	  if (!deps->readonly)
@@ -2825,6 +2999,8 @@
     }
   else
     {
+      regset_head set_or_clobbered;
+
       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)
 	{
 	  struct deps_reg *reg_last = &deps->reg_last[i];
@@ -2855,6 +3031,25 @@
 	      }
 	  }
 
+      if (targetm.sched.exposed_pipeline)
+	{
+	  INIT_REG_SET (&set_or_clobbered);
+	  bitmap_ior (&set_or_clobbered, reg_pending_clobbers,
+		      reg_pending_sets);
+	  EXECUTE_IF_SET_IN_REG_SET (&set_or_clobbered, 0, i, rsi)
+	    {
+	      struct deps_reg *reg_last = &deps->reg_last[i];
+	      rtx list;
+	      for (list = reg_last->uses; list; list = XEXP (list, 1))
+		{
+		  rtx other = XEXP (list, 0);
+		  if (INSN_CACHED_COND (other) != const_true_rtx
+		      && refers_to_regno_p (i, i + 1, INSN_CACHED_COND (other), NULL))
+		    INSN_CACHED_COND (other) = const_true_rtx;
+		}
+	    }
+	}
+
       /* If the current insn is conditional, we can't free any
 	 of the lists.  */
       if (sched_has_condition_p (insn))
@@ -2866,6 +3061,8 @@
 	      add_dependence_list (insn, reg_last->implicit_sets, 0,
 				   REG_DEP_ANTI);
 	      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);
+	      add_dependence_list (insn, reg_last->control_uses, 0,
+				   REG_DEP_CONTROL);
 
 	      if (!deps->readonly)
 		{
@@ -2882,12 +3079,11 @@
 				   REG_DEP_ANTI);
 	      add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_OUTPUT);
 	      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);
+	      add_dependence_list (insn, reg_last->control_uses, 0,
+				   REG_DEP_CONTROL);
 
 	      if (!deps->readonly)
-		{
-		  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);
-		  SET_REGNO_REG_SET (&deps->reg_conditional_sets, i);
-		}
+		reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);
 	    }
 	}
       else
@@ -2905,6 +3101,9 @@
 						REG_DEP_ANTI);
 		  add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,
 						REG_DEP_ANTI);
+		  add_dependence_list_and_free (deps, insn,
+						&reg_last->control_uses, 0,
+						REG_DEP_ANTI);
 		  add_dependence_list_and_free
 		    (deps, insn, &reg_last->clobbers, 0, REG_DEP_OUTPUT);
 
@@ -2921,6 +3120,8 @@
 		  add_dependence_list (insn, reg_last->implicit_sets, 0,
 				       REG_DEP_ANTI);
 		  add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);
+		  add_dependence_list (insn, reg_last->control_uses, 0,
+				       REG_DEP_CONTROL);
 		}
 
 	      if (!deps->readonly)
@@ -2943,16 +3144,26 @@
 					    REG_DEP_OUTPUT);
 	      add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,
 					    REG_DEP_ANTI);
+	      add_dependence_list (insn, reg_last->control_uses, 0,
+				   REG_DEP_CONTROL);
 
 	      if (!deps->readonly)
 		{
 		  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);
 		  reg_last->uses_length = 0;
 		  reg_last->clobbers_length = 0;
-		  CLEAR_REGNO_REG_SET (&deps->reg_conditional_sets, i);
 		}
 	    }
 	}
+      if (!deps->readonly)
+	{
+	  EXECUTE_IF_SET_IN_REG_SET (reg_pending_control_uses, 0, i, rsi)
+	    {
+	      struct deps_reg *reg_last = &deps->reg_last[i];
+	      reg_last->control_uses
+		= alloc_INSN_LIST (insn, reg_last->control_uses);
+	    }
+	}
     }
 
   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)
@@ -2962,6 +3173,7 @@
 	add_dependence_list (insn, reg_last->sets, 0, REG_DEP_ANTI);
 	add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_ANTI);
 	add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);
+	add_dependence_list (insn, reg_last->control_uses, 0, REG_DEP_ANTI);
 
 	if (!deps->readonly)
 	  reg_last->implicit_sets
@@ -2985,6 +3197,7 @@
   CLEAR_REG_SET (reg_pending_uses);
   CLEAR_REG_SET (reg_pending_clobbers);
   CLEAR_REG_SET (reg_pending_sets);
+  CLEAR_REG_SET (reg_pending_control_uses);
   CLEAR_HARD_REG_SET (implicit_reg_pending_clobbers);
   CLEAR_HARD_REG_SET (implicit_reg_pending_uses);
 
@@ -3016,6 +3229,9 @@
 	      struct deps_reg *reg_last = &deps->reg_last[i];
 	      add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,
 					    REG_DEP_ANTI);
+	      add_dependence_list_and_free (deps, insn,
+					    &reg_last->control_uses, 0,
+					    REG_DEP_CONTROL);
 	      add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,
 					    reg_pending_barrier == TRUE_BARRIER
 					    ? REG_DEP_TRUE : REG_DEP_ANTI);
@@ -3047,8 +3263,6 @@
                              && sel_insn_is_speculation_check (insn)))
 	flush_pending_lists (deps, insn, true, true);
 
-      if (!deps->readonly)
-        CLEAR_REG_SET (&deps->reg_conditional_sets);
       reg_pending_barrier = NOT_A_BARRIER;
     }
 
@@ -3229,12 +3443,41 @@
   if (sched_deps_info->start_insn)
     sched_deps_info->start_insn (insn);
 
-  if (NONJUMP_INSN_P (insn) || DEBUG_INSN_P (insn) || JUMP_P (insn))
+  /* Record the condition for this insn.  */
+  if (NONDEBUG_INSN_P (insn))
+    {
+      rtx t;
+      sched_get_condition_with_rev (insn, NULL);
+      t = INSN_CACHED_COND (insn);
+      INSN_COND_DEPS (insn) = NULL_RTX;
+      if (reload_completed
+	  && (current_sched_info->flags & DO_PREDICATION)
+	  && COMPARISON_P (t)
+	  && REG_P (XEXP (t, 0))
+	  && CONSTANT_P (XEXP (t, 1)))
+	{
+	  unsigned int regno;
+	  int nregs;
+	  t = XEXP (t, 0);
+	  regno = REGNO (t);
+	  nregs = hard_regno_nregs[regno][GET_MODE (t)];
+	  t = NULL_RTX;
+	  while (nregs-- > 0)
+	    {
+	      struct deps_reg *reg_last = &deps->reg_last[regno + nregs];
+	      t = concat_INSN_LIST (reg_last->sets, t);
+	      t = concat_INSN_LIST (reg_last->clobbers, t);
+	      t = concat_INSN_LIST (reg_last->implicit_sets, t);
+	    }
+	  INSN_COND_DEPS (insn) = t;
+	}
+    }
+
+  if (JUMP_P (insn))
     {
       /* Make each JUMP_INSN (but not a speculative check)
          a scheduling barrier for memory references.  */
       if (!deps->readonly
-          && JUMP_P (insn)
           && !(sel_sched_p ()
                && sel_insn_is_speculation_check (insn)))
         {
@@ -3242,17 +3485,19 @@
           if (deps->pending_flush_length++ > MAX_PENDING_LIST_LENGTH)
             flush_pending_lists (deps, insn, true, true);
           else
-	    {
-	      deps->last_pending_memory_flush
-		= alloc_INSN_LIST (insn, deps->last_pending_memory_flush);
-	      /* Signal to sched_analyze_insn that this jump stands
-		 just for its own, not any other pending memory
-		 reads/writes flush_pending_lists had to flush.  */
-	      PUT_REG_NOTE_KIND (deps->last_pending_memory_flush,
-				 NON_FLUSH_JUMP_KIND);
-	    }
+	    deps->pending_jump_insns
+              = alloc_INSN_LIST (insn, deps->pending_jump_insns);
         }
 
+      /* For each insn which shouldn't cross a jump, add a dependence.  */
+      add_dependence_list_and_free (deps, insn,
+				    &deps->sched_before_next_jump, 1,
+				    REG_DEP_ANTI);
+
+      sched_analyze_insn (deps, PATTERN (insn), insn);
+    }
+  else if (NONJUMP_INSN_P (insn) || DEBUG_INSN_P (insn))
+    {
       sched_analyze_insn (deps, PATTERN (insn), insn);
     }
   else if (CALL_P (insn))
@@ -3449,18 +3694,23 @@
   rtx insn;
   rtx next_tail = NEXT_INSN (tail);
 
+  /* We make two passes since some insns may be scheduled before their
+     dependencies are resolved.  */
   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))
     if (INSN_P (insn) && INSN_LUID (insn) > 0)
       {
-	/* Clear resolved back deps together with its dep_nodes.  */
-	delete_dep_nodes_in_back_deps (insn, resolved_p);
-
 	/* Clear forward deps and leave the dep_nodes to the
 	   corresponding back_deps list.  */
 	if (resolved_p)
 	  clear_deps_list (INSN_RESOLVED_FORW_DEPS (insn));
 	else
 	  clear_deps_list (INSN_FORW_DEPS (insn));
+      }
+  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))
+    if (INSN_P (insn) && INSN_LUID (insn) > 0)
+      {
+	/* Clear resolved back deps together with its dep_nodes.  */
+	delete_dep_nodes_in_back_deps (insn, resolved_p);
 
 	sd_finish_insn (insn);
       }
@@ -3481,12 +3731,12 @@
   else
     deps->reg_last = XCNEWVEC (struct deps_reg, max_reg);
   INIT_REG_SET (&deps->reg_last_in_use);
-  INIT_REG_SET (&deps->reg_conditional_sets);
 
   deps->pending_read_insns = 0;
   deps->pending_read_mems = 0;
   deps->pending_write_insns = 0;
   deps->pending_write_mems = 0;
+  deps->pending_jump_insns = 0;
   deps->pending_read_list_length = 0;
   deps->pending_write_list_length = 0;
   deps->pending_flush_length = 0;
@@ -3494,6 +3744,7 @@
   deps->last_function_call = 0;
   deps->last_function_call_may_noreturn = 0;
   deps->sched_before_next_call = 0;
+  deps->sched_before_next_jump = 0;
   deps->in_post_call_group_p = not_post_call;
   deps->last_debug_insn = 0;
   deps->last_reg_pending_barrier = NOT_A_BARRIER;
@@ -3546,11 +3797,12 @@
 	free_INSN_LIST_list (&reg_last->sets);
       if (reg_last->implicit_sets)
 	free_INSN_LIST_list (&reg_last->implicit_sets);
+      if (reg_last->control_uses)
+	free_INSN_LIST_list (&reg_last->control_uses);
       if (reg_last->clobbers)
 	free_INSN_LIST_list (&reg_last->clobbers);
     }
   CLEAR_REG_SET (&deps->reg_last_in_use);
-  CLEAR_REG_SET (&deps->reg_conditional_sets);
 
   /* As we initialize reg_last lazily, it is possible that we didn't allocate
      it at all.  */
@@ -3561,8 +3813,7 @@
   deps = NULL;
 }
 
-/* Remove INSN from dependence contexts DEPS.  Caution: reg_conditional_sets
-   is not handled.  */
+/* Remove INSN from dependence contexts DEPS.  */
 void
 remove_from_deps (struct deps_desc *deps, rtx insn)
 {
@@ -3577,6 +3828,9 @@
   removed = remove_from_both_dependence_lists (insn, &deps->pending_write_insns,
                                                &deps->pending_write_mems);
   deps->pending_write_list_length -= removed;
+
+  removed = remove_from_dependence_list (insn, &deps->pending_jump_insns);
+  deps->pending_flush_length -= removed;
   removed = remove_from_dependence_list (insn, &deps->last_pending_memory_flush);
   deps->pending_flush_length -= removed;
 
@@ -3671,6 +3925,8 @@
 					    output_dependency_cache, luid);
       anti_dependency_cache = XRESIZEVEC (bitmap_head, anti_dependency_cache,
 					  luid);
+      control_dependency_cache = XRESIZEVEC (bitmap_head, control_dependency_cache,
+					  luid);
 
       if (current_sched_info->flags & DO_SPECULATION)
         spec_dependency_cache = XRESIZEVEC (bitmap_head, spec_dependency_cache,
@@ -3681,6 +3937,7 @@
 	  bitmap_initialize (&true_dependency_cache[i], 0);
 	  bitmap_initialize (&output_dependency_cache[i], 0);
 	  bitmap_initialize (&anti_dependency_cache[i], 0);
+	  bitmap_initialize (&control_dependency_cache[i], 0);
 
           if (current_sched_info->flags & DO_SPECULATION)
             bitmap_initialize (&spec_dependency_cache[i], 0);
@@ -3710,6 +3967,7 @@
 	  bitmap_clear (&true_dependency_cache[i]);
 	  bitmap_clear (&output_dependency_cache[i]);
 	  bitmap_clear (&anti_dependency_cache[i]);
+	  bitmap_clear (&control_dependency_cache[i]);
 
           if (sched_deps_info->generate_spec_deps)
             bitmap_clear (&spec_dependency_cache[i]);
@@ -3720,6 +3978,8 @@
       output_dependency_cache = NULL;
       free (anti_dependency_cache);
       anti_dependency_cache = NULL;
+      free (control_dependency_cache);
+      control_dependency_cache = NULL;
 
       if (sched_deps_info->generate_spec_deps)
         {
@@ -3741,6 +4001,7 @@
   reg_pending_sets = ALLOC_REG_SET (&reg_obstack);
   reg_pending_clobbers = ALLOC_REG_SET (&reg_obstack);
   reg_pending_uses = ALLOC_REG_SET (&reg_obstack);
+  reg_pending_control_uses = ALLOC_REG_SET (&reg_obstack);
   reg_pending_barrier = NOT_A_BARRIER;
 
   if (!sel_sched_p () || sched_emulate_haifa_p)
@@ -3765,6 +4026,7 @@
   FREE_REG_SET (reg_pending_sets);
   FREE_REG_SET (reg_pending_clobbers);
   FREE_REG_SET (reg_pending_uses);
+  FREE_REG_SET (reg_pending_control_uses);
 }
 
 /* Estimate the weakness of dependence between MEM1 and MEM2.  */
@@ -3798,8 +4060,8 @@
 /* Add or update backward dependence between INSN and ELEM with type DEP_TYPE.
    This function can handle same INSN and ELEM (INSN == ELEM).
    It is a convenience wrapper.  */
-void
-add_dependence (rtx insn, rtx elem, enum reg_note dep_type)
+static void
+add_dependence_1 (rtx insn, rtx elem, enum reg_note dep_type)
 {
   ds_t ds;
   bool internal;
@@ -3808,6 +4070,8 @@
     ds = DEP_TRUE;
   else if (dep_type == REG_DEP_OUTPUT)
     ds = DEP_OUTPUT;
+  else if (dep_type == REG_DEP_CONTROL)
+    ds = DEP_CONTROL;
   else
     {
       gcc_assert (dep_type == REG_DEP_ANTI);
@@ -4074,10 +4338,12 @@
 
   if (s & DEP_TRUE)
     fprintf (f, "DEP_TRUE; ");
-  if (s & DEP_ANTI)
-    fprintf (f, "DEP_ANTI; ");
   if (s & DEP_OUTPUT)
     fprintf (f, "DEP_OUTPUT; ");
+  if (s & DEP_ANTI)
+    fprintf (f, "DEP_ANTI; ");
+  if (s & DEP_CONTROL)
+    fprintf (f, "DEP_CONTROL; ");
 
   fprintf (f, "}");
 }
@@ -4102,7 +4368,7 @@
 
   if (!(current_sched_info->flags & USE_DEPS_LIST))
     {
-      gcc_assert (ds == -1);
+      gcc_assert (ds == 0);
       return;
     }
 
@@ -4112,10 +4378,13 @@
   else if (dt == REG_DEP_OUTPUT)
     gcc_assert ((ds & DEP_OUTPUT)
 		&& !(ds & DEP_TRUE));
-  else
-    gcc_assert ((dt == REG_DEP_ANTI)
-		&& (ds & DEP_ANTI)
+  else if (dt == REG_DEP_ANTI)
+    gcc_assert ((ds & DEP_ANTI)
 		&& !(ds & (DEP_OUTPUT | DEP_TRUE)));
+  else
+    gcc_assert (dt == REG_DEP_CONTROL
+		&& (ds & DEP_CONTROL)
+		&& !(ds & (DEP_OUTPUT | DEP_ANTI | DEP_TRUE)));
 
   /* HARD_DEP can not appear in dep_status of a link.  */
   gcc_assert (!(ds & HARD_DEP));
diff -ru ./gcc/sched-ebb.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-ebb.c
--- ./gcc/sched-ebb.c	2014-06-06 11:50:19.651598757 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-ebb.c	2012-03-29 18:03:19.000000000 +1000
@@ -59,7 +59,7 @@
 
 /* Implementations of the sched_info functions for region scheduling.  */
 static void init_ready_list (void);
-static void begin_schedule_ready (rtx, rtx);
+static void begin_schedule_ready (rtx);
 static int schedule_more_p (void);
 static const char *ebb_print_insn (const_rtx, int);
 static int rank (rtx, rtx);
@@ -74,6 +74,25 @@
 static basic_block advance_target_bb (basic_block, rtx);
 static void ebb_fix_recovery_cfg (int, int, int);
 
+/* Allocate memory and store the state of the frontend.  Return the allocated
+   memory.  */
+static void *
+save_ebb_state (void)
+{
+  int *p = XNEW (int);
+  *p = sched_rgn_n_insns;
+  return p;
+}
+
+/* Restore the state of the frontend from P_, then free it.  */
+static void
+restore_ebb_state (void *p_)
+{
+  int *p = (int *)p_;
+  sched_rgn_n_insns = *p;
+  free (p_);
+}
+
 /* Return nonzero if there are more insns that should be scheduled.  */
 
 static int
@@ -125,10 +144,15 @@
 
 /* INSN is being scheduled after LAST.  Update counters.  */
 static void
-begin_schedule_ready (rtx insn, rtx last)
+begin_schedule_ready (rtx insn ATTRIBUTE_UNUSED)
 {
   sched_rgn_n_insns++;
+}
 
+/* INSN is being moved to its place in the schedule, after LAST.  */
+static void
+begin_move_insn (rtx insn, rtx last)
+{
   if (BLOCK_FOR_INSN (insn) == last_bb
       /* INSN is a jump in the last block, ...  */
       && control_flow_insn_p (insn)
@@ -233,28 +257,18 @@
   return 1;
 }
 
- /* INSN is a JUMP_INSN, COND_SET is the set of registers that are
-    conditionally set before INSN.  Store the set of registers that
-    must be considered as used by this jump in USED and that of
-    registers that must be considered as set in SET.  */
+ /* INSN is a JUMP_INSN.  Store the set of registers that
+    must be considered as used by this jump in USED.  */
 
 void
-ebb_compute_jump_reg_dependencies (rtx insn, regset cond_set, regset used,
-				   regset set)
+ebb_compute_jump_reg_dependencies (rtx insn, regset used)
 {
   basic_block b = BLOCK_FOR_INSN (insn);
   edge e;
   edge_iterator ei;
 
   FOR_EACH_EDGE (e, ei, b->succs)
-    if (e->flags & EDGE_FALLTHRU)
-      /* The jump may be a by-product of a branch that has been merged
-	 in the main codepath after being conditionalized.  Therefore
-	 it may guard the fallthrough block from using a value that has
-	 conditionally overwritten that of the main codepath.  So we
-	 consider that it restores the value of the main codepath.  */
-      bitmap_and (set, df_get_live_in (e->dest), cond_set);
-    else
+    if ((e->flags & EDGE_FALLTHRU) == 0)
       bitmap_ior_into (used, df_get_live_in (e->dest));
 }
 
@@ -288,7 +302,12 @@
 
   ebb_add_remove_insn,
   begin_schedule_ready,
+  begin_move_insn,
   advance_target_bb,
+
+  save_ebb_state,
+  restore_ebb_state,
+
   SCHED_EBB
   /* We can create new blocks in begin_schedule_ready ().  */
   | NEW_BBS
@@ -371,76 +390,71 @@
   basic_block last_block = NULL, bb;
 
   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))
-    if (control_flow_insn_p (insn))
-      {
-	bb = BLOCK_FOR_INSN (insn);
-	bb->aux = last_block;
-	last_block = bb;
-	last_jump = insn;
-      }
-    else if (INSN_P (insn) && last_jump != NULL_RTX)
-      {
-	classification = haifa_classify_insn (insn);
-	prev = last_jump;
-	switch (classification)
-	  {
-	  case PFREE_CANDIDATE:
-	    if (flag_schedule_speculative_load)
-	      {
-		bb = earliest_block_with_similiar_load (last_block, insn);
-		if (bb)
-		  {
-		    bb = (basic_block) bb->aux;
-		    if (!bb)
-		      break;
-		    prev = BB_END (bb);
-		  }
-	      }
-	    /* Fall through.  */
-	  case TRAP_RISKY:
-	  case IRISKY:
-	  case PRISKY_CANDIDATE:
-	    /* ??? We could implement better checking PRISKY_CANDIDATEs
-	       analogous to sched-rgn.c.  */
-	    /* We can not change the mode of the backward
-	       dependency because REG_DEP_ANTI has the lowest
-	       rank.  */
-	    if (! sched_insns_conditions_mutex_p (insn, prev))
-	      {
-		dep_def _dep, *dep = &_dep;
-
-		init_dep (dep, prev, insn, REG_DEP_ANTI);
-
-		if (!(current_sched_info->flags & USE_DEPS_LIST))
-		  {
-		    enum DEPS_ADJUST_RESULT res;
-
-		    res = sd_add_or_update_dep (dep, false);
-
-		    /* We can't change an existing dependency with
-		       DEP_ANTI.  */
-		    gcc_assert (res != DEP_CHANGED);
-		  }
-		else
-		  {
-		    if ((current_sched_info->flags & DO_SPECULATION)
-			&& (spec_info->mask & BEGIN_CONTROL))
-		      DEP_STATUS (dep) = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,
-						       MAX_DEP_WEAK);
-
-		    sd_add_or_update_dep (dep, false);
-
-		    /* Dep_status could have been changed.
-		       No assertion here.  */
-		  }
-	      }
-
-            break;
-
-          default:
-            break;
-	  }
-      }
+    {
+      add_delay_dependencies (insn);
+      if (control_flow_insn_p (insn))
+	{
+	  bb = BLOCK_FOR_INSN (insn);
+	  bb->aux = last_block;
+	  last_block = bb;
+	  last_jump = insn;
+	}
+      else if (INSN_P (insn) && last_jump != NULL_RTX)
+	{
+	  classification = haifa_classify_insn (insn);
+	  prev = last_jump;
+
+	  switch (classification)
+	    {
+	    case PFREE_CANDIDATE:
+	      if (flag_schedule_speculative_load)
+		{
+		  bb = earliest_block_with_similiar_load (last_block, insn);
+		  if (bb)
+		    {
+		      bb = (basic_block) bb->aux;
+		      if (!bb)
+			break;
+		      prev = BB_END (bb);
+		    }
+		}
+	      /* Fall through.  */
+	    case TRAP_RISKY:
+	    case IRISKY:
+	    case PRISKY_CANDIDATE:
+	      /* ??? We could implement better checking PRISKY_CANDIDATEs
+		 analogous to sched-rgn.c.  */
+	      /* We can not change the mode of the backward
+		 dependency because REG_DEP_ANTI has the lowest
+		 rank.  */
+	      if (! sched_insns_conditions_mutex_p (insn, prev))
+		{
+		  if ((current_sched_info->flags & DO_SPECULATION)
+		      && (spec_info->mask & BEGIN_CONTROL))
+		    {
+		      dep_def _dep, *dep = &_dep;
+
+		      init_dep (dep, prev, insn, REG_DEP_ANTI);
+
+		      if (current_sched_info->flags & USE_DEPS_LIST)
+			{
+			  DEP_STATUS (dep) = set_dep_weak (DEP_ANTI, BEGIN_CONTROL,
+							   MAX_DEP_WEAK);
+
+			}
+		      sd_add_or_update_dep (dep, false);
+		    }
+		  else
+		    add_dependence (insn, prev, REG_DEP_CONTROL);
+		}
+
+	      break;
+
+	    default:
+	      break;
+	    }
+	}
+    }
   /* Maintain the invariant that bb->aux is clear after use.  */
   while (last_block)
     {
@@ -504,7 +518,7 @@
 
   /* Make ready list big enough to hold all the instructions from the ebb.  */
   sched_extend_ready_list (rgn_n_insns);
-  schedule_block (&target_bb);
+  schedule_block (&target_bb, NULL);
   /* Free ready list.  */
   sched_finish_ready_list ();
 
diff -ru ./gcc/sched-int.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-int.h
--- ./gcc/sched-int.h	2014-06-06 11:50:19.651598757 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-int.h	2012-03-29 18:03:19.000000000 +1000
@@ -197,7 +197,7 @@
 
 extern int max_issue (struct ready_list *, int, state_t, bool, int *);
 
-extern void ebb_compute_jump_reg_dependencies (rtx, regset, regset, regset);
+extern void ebb_compute_jump_reg_dependencies (rtx, regset);
 
 extern edge find_fallthru_edge_from (basic_block);
 
@@ -239,6 +239,9 @@
   /* Dependency status.  This field holds all dependency types and additional
      information for speculative dependencies.  */
   ds_t status;
+
+  /* Cached cost of the dependency.  */
+  int cost;
 };
 
 typedef struct _dep dep_def;
@@ -248,6 +251,9 @@
 #define DEP_CON(D) ((D)->con)
 #define DEP_TYPE(D) ((D)->type)
 #define DEP_STATUS(D) ((D)->status)
+#define DEP_COST(D) ((D)->cost)
+
+#define UNKNOWN_DEP_COST INT_MIN
 
 /* Functions to work with dep.  */
 
@@ -442,6 +448,7 @@
   rtx uses;
   rtx sets;
   rtx implicit_sets;
+  rtx control_uses;
   rtx clobbers;
   int uses_length;
   int clobbers_length;
@@ -471,6 +478,9 @@
   /* An EXPR_LIST containing all MEM rtx's which are pending writes.  */
   rtx pending_write_mems;
 
+  /* An INSN_LIST containing all jump insns.  */
+  rtx pending_jump_insns;
+
   /* We must prevent the above lists from ever growing too large since
      the number of dependencies produced is at least O(N*N),
      and execution time is at least O(4*N*N), as a function of the
@@ -482,8 +492,9 @@
   /* Indicates the length of the pending_write list.  */
   int pending_write_list_length;
 
-  /* Length of the pending memory flush list. Large functions with no
-     calls may build up extremely large lists.  */
+  /* Length of the pending memory flush list plus the length of the pending
+     jump insn list.  Large functions with no calls may build up extremely
+     large lists.  */
   int pending_flush_length;
 
   /* The last insn upon which all memory references must depend.
@@ -514,6 +525,9 @@
      scheduling is done.  */
   rtx sched_before_next_call;
 
+  /* Similarly, a list of insns which should not cross a branch.  */
+  rtx sched_before_next_jump;
+
   /* Used to keep post-call pseudo/hard reg movements together with
      the call.  */
   enum post_call_group in_post_call_group_p;
@@ -535,9 +549,6 @@
      in reg_last[N].{uses,sets,clobbers}.  */
   regset_head reg_last_in_use;
 
-  /* Element N is set for each register that is conditionally set.  */
-  regset_head reg_conditional_sets;
-
   /* Shows the last value of reg_pending_barrier associated with the insn.  */
   enum reg_pending_barrier_mode last_reg_pending_barrier;
 
@@ -605,10 +616,15 @@
      parameter == 0) or removed (second parameter == 1).  */
   void (*add_remove_insn) (rtx, int);
 
-  /* Called to notify frontend that instruction is being scheduled.
-     The first parameter - instruction to scheduled, the second parameter -
-     last scheduled instruction.  */
-  void (*begin_schedule_ready) (rtx, rtx);
+  /* Called to notify the frontend that instruction INSN is being
+     scheduled.  */
+  void (*begin_schedule_ready) (rtx insn);
+
+  /* Called to notify the frontend that an instruction INSN is about to be
+     moved to its correct place in the final schedule.  This is done for all
+     insns in order of the schedule.  LAST indicates the last scheduled
+     instruction.  */
+  void (*begin_move_insn) (rtx insn, rtx last);
 
   /* If the second parameter is not NULL, return nonnull value, if the
      basic block should be advanced.
@@ -616,6 +632,13 @@
      The first parameter is the current basic block in EBB.  */
   basic_block (*advance_target_bb) (basic_block, rtx);
 
+  /* Allocate memory, store the frontend scheduler state in it, and
+     return it.  */
+  void *(*save_state) (void);
+  /* Restore frontend scheduler state from the argument, and free the
+     memory.  */
+  void (*restore_state) (void *);
+
   /* ??? FIXME: should use straight bitfields inside sched_info instead of
      this flag field.  */
   unsigned int flags;
@@ -698,6 +721,21 @@
      search in 'forw_deps'.  */
   deps_list_t resolved_forw_deps;
 
+  /* If the insn is conditional (either through COND_EXEC, or because
+     it is a conditional branch), this records the condition.  NULL
+     for insns that haven't been seen yet or don't have a condition;
+     const_true_rtx to mark an insn without a condition, or with a
+     condition that has been clobbered by a subsequent insn.  */
+  rtx cond;
+
+  /* For a conditional insn, a list of insns that could set the condition
+     register.  Used when generating control dependencies.  */
+  rtx cond_deps;
+
+  /* True if the condition in 'cond' should be reversed to get the actual
+     condition.  */
+  unsigned int reverse_cond : 1;
+
   /* Some insns (e.g. call) are not allowed to move across blocks.  */
   unsigned int cant_move : 1;
 };
@@ -764,10 +802,18 @@
      used to note timing constraints for the insns in the pending list.  */
   int tick;
 
+  /* For insns that are scheduled at a fixed difference from another,
+     this records the tick in which they must be ready.  */
+  int exact_tick;
+
   /* INTER_TICK is used to adjust INSN_TICKs of instructions from the
      subsequent blocks in a region.  */
   int inter_tick;
 
+  /* Used temporarily to estimate an INSN_TICK value for an insn given
+     current knowledge.  */
+  int tick_estimate;
+
   /* See comment on QUEUE_INDEX macro in haifa-sched.c.  */
   int queue_index;
 
@@ -777,6 +823,18 @@
      moved load insn and this one.  */
   unsigned int fed_by_spec_load : 1;
   unsigned int is_load_insn : 1;
+  /* Nonzero if this insn has negative-cost forward dependencies against
+     an already scheduled insn.  */
+  unsigned int feeds_backtrack_insn : 1;
+
+  /* Nonzero if this insn is a shadow of another, scheduled after a fixed
+     delay.  We only emit shadows at the end of a cycle, with no other
+     real insns following them.  */
+  unsigned int shadow_p : 1;
+
+  /* Used internally in unschedule_insns_until to mark insns that must have
+     their TODO_SPEC recomputed.  */
+  unsigned int must_recompute_spec : 1;
 
   /* '> 0' if priority is valid,
      '== 0' if priority was not yet computed,
@@ -798,6 +856,10 @@
   /* Original pattern of the instruction.  */
   rtx orig_pat;
 
+  /* For insns with DEP_CONTROL dependencies, the predicated pattern if it
+     was ever successfully constructed.  */
+  rtx predicated_pat;
+
   /* The following array contains info how the insn increases register
      pressure.  There is an element for each cover class of pseudos
      referenced in insns.  */
@@ -857,6 +919,9 @@
 #define INSN_RESOLVED_FORW_DEPS(INSN) (HDID (INSN)->resolved_forw_deps)
 #define INSN_HARD_BACK_DEPS(INSN) (HDID (INSN)->hard_back_deps)
 #define INSN_SPEC_BACK_DEPS(INSN) (HDID (INSN)->spec_back_deps)
+#define INSN_CACHED_COND(INSN)	(HDID (INSN)->cond)
+#define INSN_REVERSE_COND(INSN) (HDID (INSN)->reverse_cond)
+#define INSN_COND_DEPS(INSN)	(HDID (INSN)->cond_deps)
 #define CANT_MOVE(INSN)	(HDID (INSN)->cant_move)
 #define CANT_MOVE_BY_LUID(LUID)	(VEC_index (haifa_deps_insn_data_def, h_d_i_d, \
                                             LUID)->cant_move)
@@ -870,6 +935,7 @@
 #define CHECK_SPEC(INSN) (HID (INSN)->check_spec)
 #define RECOVERY_BLOCK(INSN) (HID (INSN)->recovery_block)
 #define ORIG_PAT(INSN) (HID (INSN)->orig_pat)
+#define PREDICATED_PAT(INSN) (HID (INSN)->predicated_pat)
 
 /* INSN is either a simple or a branchy speculation check.  */
 #define IS_SPECULATION_CHECK_P(INSN) \
@@ -909,10 +975,11 @@
 /* We exclude sign bit.  */
 #define BITS_PER_DEP_STATUS (HOST_BITS_PER_INT - 1)
 
-/* First '4' stands for 3 dep type bits and HARD_DEP bit.
+/* First '6' stands for 4 dep type bits and the HARD_DEP and DEP_CANCELLED
+   bits.
    Second '4' stands for BEGIN_{DATA, CONTROL}, BE_IN_{DATA, CONTROL}
    dep weakness.  */
-#define BITS_PER_DEP_WEAK ((BITS_PER_DEP_STATUS - 4) / 4)
+#define BITS_PER_DEP_WEAK ((BITS_PER_DEP_STATUS - 6) / 4)
 
 /* Mask of speculative weakness in dep_status.  */
 #define DEP_WEAK_MASK ((1 << BITS_PER_DEP_WEAK) - 1)
@@ -986,13 +1053,16 @@
 #define DEP_TRUE (((ds_t) 1) << (BE_IN_CONTROL_BITS_OFFSET + BITS_PER_DEP_WEAK))
 #define DEP_OUTPUT (DEP_TRUE << 1)
 #define DEP_ANTI (DEP_OUTPUT << 1)
+#define DEP_CONTROL (DEP_ANTI << 1)
 
-#define DEP_TYPES (DEP_TRUE | DEP_OUTPUT | DEP_ANTI)
+#define DEP_TYPES (DEP_TRUE | DEP_OUTPUT | DEP_ANTI | DEP_CONTROL)
 
 /* Instruction has non-speculative dependence.  This bit represents the
    property of an instruction - not the one of a dependence.
    Therefore, it can appear only in TODO_SPEC field of an instruction.  */
-#define HARD_DEP (DEP_ANTI << 1)
+#define HARD_DEP (DEP_CONTROL << 1)
+
+#define DEP_CANCELLED (HARD_DEP << 1)
 
 /* This represents the results of calling sched-deps.c functions,
    which modify dependencies.  */
@@ -1017,7 +1087,9 @@
      Results in generation of data and control speculative dependencies.
      Requires USE_DEPS_LIST set.  */
   DO_SPECULATION = USE_DEPS_LIST << 1,
-  SCHED_RGN = DO_SPECULATION << 1,
+  DO_BACKTRACKING = DO_SPECULATION << 1,
+  DO_PREDICATION = DO_BACKTRACKING << 1,
+  SCHED_RGN = DO_PREDICATION << 1,
   SCHED_EBB = SCHED_RGN << 1,
   /* Scheduler can possibly create new basic blocks.  Used for assertions.  */
   NEW_BBS = SCHED_EBB << 1,
@@ -1123,7 +1195,7 @@
   /* Called when computing dependencies for a JUMP_INSN.  This function
      should store the set of registers that must be considered as set by
      the jump in the regset.  */
-  void (*compute_jump_reg_dependencies) (rtx, regset, regset, regset);
+  void (*compute_jump_reg_dependencies) (rtx, regset);
 
   /* Start analyzing insn.  */
   void (*start_insn) (rtx);
@@ -1178,6 +1250,7 @@
 
 
 /* Functions in sched-deps.c.  */
+extern rtx sched_get_reverse_condition_uncached (const_rtx);
 extern bool sched_insns_conditions_mutex_p (const_rtx, const_rtx);
 extern bool sched_insn_is_legitimate_for_speculation_p (const_rtx, ds_t);
 extern void add_dependence (rtx, rtx, enum reg_note);
@@ -1232,7 +1305,7 @@
 extern int set_priorities (rtx, rtx);
 
 extern void sched_setup_bb_reg_pressure_info (basic_block, rtx);
-extern void schedule_block (basic_block *);
+extern bool schedule_block (basic_block *, state_t);
 
 extern int cycle_issued_insns;
 extern int issue_rate;
@@ -1303,7 +1376,14 @@
 extern int current_nr_blocks;
 extern int current_blocks;
 extern int target_bb;
+extern bool sched_no_dce;
 
+extern void set_modulo_params (int, int, int, int);
+extern void record_delay_slot_pair (rtx, rtx, int, int);
+extern rtx real_insn_for_shadow (rtx);
+extern void discard_delay_pairs_above (int);
+extern void free_delay_pairs (void);
+extern void add_delay_dependencies (rtx);
 extern bool sched_is_disabled_for_current_region_p (void);
 extern void sched_rgn_init (bool);
 extern void sched_rgn_finish (void);
@@ -1477,6 +1557,7 @@
 extern void sd_add_dep (dep_t, bool);
 extern enum DEPS_ADJUST_RESULT sd_add_or_update_dep (dep_t, bool);
 extern void sd_resolve_dep (sd_iterator_def);
+extern void sd_unresolve_dep (sd_iterator_def);
 extern void sd_copy_back_deps (rtx, rtx, bool);
 extern void sd_delete_dep (sd_iterator_def);
 extern void sd_debug_lists (rtx, sd_list_types_def);
@@ -1490,3 +1571,4 @@
 extern void print_value (char *, const_rtx, int);
 
 #endif /* GCC_SCHED_INT_H */
+
diff -ru ./gcc/sched-rgn.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-rgn.c
--- ./gcc/sched-rgn.c	2014-06-06 11:50:19.655598757 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-rgn.c	2012-03-29 18:03:19.000000000 +1000
@@ -126,6 +126,9 @@
 static basic_block *bblst_table;
 static int bblst_size, bblst_last;
 
+static char *bb_state_array;
+static state_t *bb_state;
+
 /* Target info declarations.
 
    The block currently being scheduled is referred to as the "target" block,
@@ -234,7 +237,6 @@
 static void compute_block_dependences (int);
 
 static void schedule_region (int);
-static rtx concat_INSN_LIST (rtx, rtx);
 static void concat_insn_mem_list (rtx, rtx, rtx *, rtx *);
 static void propagate_deps (int, struct deps_desc *);
 static void free_pending_lists (void);
@@ -2068,12 +2070,12 @@
 /* Implementations of the sched_info functions for region scheduling.  */
 static void init_ready_list (void);
 static int can_schedule_ready_p (rtx);
-static void begin_schedule_ready (rtx, rtx);
+static void begin_schedule_ready (rtx);
 static ds_t new_ready (rtx, ds_t);
 static int schedule_more_p (void);
 static const char *rgn_print_insn (const_rtx, int);
 static int rgn_rank (rtx, rtx);
-static void compute_jump_reg_dependencies (rtx, regset, regset, regset);
+static void compute_jump_reg_dependencies (rtx, regset);
 
 /* Functions for speculative scheduling.  */
 static void rgn_add_remove_insn (rtx, int);
@@ -2163,7 +2165,7 @@
    can_schedule_ready_p () differs from the one passed to
    begin_schedule_ready ().  */
 static void
-begin_schedule_ready (rtx insn, rtx last ATTRIBUTE_UNUSED)
+begin_schedule_ready (rtx insn)
 {
   /* An interblock motion?  */
   if (INSN_BB (insn) != target_bb)
@@ -2306,16 +2308,12 @@
   return BLOCK_TO_BB (BLOCK_NUM (next)) == BLOCK_TO_BB (BLOCK_NUM (insn));
 }
 
-/* INSN is a JUMP_INSN, COND_SET is the set of registers that are
-   conditionally set before INSN.  Store the set of registers that
-   must be considered as used by this jump in USED and that of
-   registers that must be considered as set in SET.  */
+/* INSN is a JUMP_INSN.  Store the set of registers that must be
+   considered as used by this jump in USED.  */
 
 static void
 compute_jump_reg_dependencies (rtx insn ATTRIBUTE_UNUSED,
-			       regset cond_exec ATTRIBUTE_UNUSED,
-			       regset used ATTRIBUTE_UNUSED,
-			       regset set ATTRIBUTE_UNUSED)
+			       regset used ATTRIBUTE_UNUSED)
 {
   /* Nothing to do here, since we postprocess jumps in
      add_branch_dependences.  */
@@ -2380,7 +2378,9 @@
 
   rgn_add_remove_insn,
   begin_schedule_ready,
+  NULL,
   advance_target_bb,
+  NULL, NULL,
   SCHED_RGN
 };
 
@@ -2565,20 +2565,6 @@
 
 static struct deps_desc *bb_deps;
 
-/* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */
-
-static rtx
-concat_INSN_LIST (rtx copy, rtx old)
-{
-  rtx new_rtx = old;
-  for (; copy ; copy = XEXP (copy, 1))
-    {
-      new_rtx = alloc_INSN_LIST (XEXP (copy, 0), new_rtx);
-      PUT_REG_NOTE_KIND (new_rtx, REG_NOTE_KIND (copy));
-    }
-  return new_rtx;
-}
-
 static void
 concat_insn_mem_list (rtx copy_insns, rtx copy_mems, rtx *old_insns_p,
 		      rtx *old_mems_p)
@@ -2632,6 +2618,9 @@
                         &succ_deps->pending_write_insns,
                         &succ_deps->pending_write_mems);
 
+  succ_deps->pending_jump_insns
+    = concat_INSN_LIST (pred_deps->pending_jump_insns,
+                        succ_deps->pending_jump_insns);
   succ_deps->last_pending_memory_flush
     = concat_INSN_LIST (pred_deps->last_pending_memory_flush,
                         succ_deps->last_pending_memory_flush);
@@ -2683,12 +2672,14 @@
   bb_deps[bb].pending_read_mems = pred_deps->pending_read_mems;
   bb_deps[bb].pending_write_insns = pred_deps->pending_write_insns;
   bb_deps[bb].pending_write_mems = pred_deps->pending_write_mems;
+  bb_deps[bb].pending_jump_insns = pred_deps->pending_jump_insns;
 
   /* Can't allow these to be freed twice.  */
   pred_deps->pending_read_insns = 0;
   pred_deps->pending_read_mems = 0;
   pred_deps->pending_write_insns = 0;
   pred_deps->pending_write_mems = 0;
+  pred_deps->pending_jump_insns = 0;
 }
 
 /* Compute dependences inside bb.  In a multiple blocks region:
@@ -2767,6 +2758,7 @@
       free_INSN_LIST_list (&bb_deps[bb].pending_write_insns);
       free_EXPR_LIST_list (&bb_deps[bb].pending_read_mems);
       free_EXPR_LIST_list (&bb_deps[bb].pending_write_mems);
+      free_INSN_LIST_list (&bb_deps[bb].pending_jump_insns);
     }
 }
 
@@ -2997,9 +2989,21 @@
       curr_bb = first_bb;
       if (dbg_cnt (sched_block))
         {
-          schedule_block (&curr_bb);
+	  edge f;
+
+          schedule_block (&curr_bb, bb_state[first_bb->index]);
           gcc_assert (EBB_FIRST_BB (bb) == first_bb);
           sched_rgn_n_insns += sched_n_insns;
+	  f = find_fallthru_edge (last_bb->succs);
+	  if (f && f->probability * 100 / REG_BR_PROB_BASE >=
+	      PARAM_VALUE (PARAM_SCHED_STATE_EDGE_PROB_CUTOFF))
+	    {
+	      memcpy (bb_state[f->dest->index], curr_state,
+		      dfa_state_size);
+	      if (sched_verbose >= 5)
+		fprintf (sched_dump, "saving state for edge %d->%d\n",
+			 f->src->index, f->dest->index);
+	    }
         }
       else
         {
@@ -3032,6 +3036,8 @@
 void
 sched_rgn_init (bool single_blocks_p)
 {
+  int i;
+
   min_spec_prob = ((PARAM_VALUE (PARAM_MIN_SPEC_PROB) * REG_BR_PROB_BASE)
 		    / 100);
 
@@ -3043,6 +3049,15 @@
   CONTAINING_RGN (ENTRY_BLOCK) = -1;
   CONTAINING_RGN (EXIT_BLOCK) = -1;
 
+  bb_state_array = (char *) xmalloc (last_basic_block * dfa_state_size);
+  bb_state = XNEWVEC (state_t, last_basic_block);
+  for (i = 0; i < last_basic_block; i++)
+    {
+      bb_state[i] = (state_t) (bb_state_array + i * dfa_state_size);
+      
+      state_reset (bb_state[i]);
+    }
+
   /* Compute regions for scheduling.  */
   if (single_blocks_p
       || n_basic_blocks == NUM_FIXED_BLOCKS + 1
@@ -3079,6 +3094,9 @@
 void
 sched_rgn_finish (void)
 {
+  free (bb_state_array);
+  free (bb_state);
+
   /* Reposition the prologue and epilogue notes in case we moved the
      prologue/epilogue insns.  */
   if (reload_completed)
diff -ru ./gcc/sched-vis.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-vis.c
--- ./gcc/sched-vis.c	2014-06-06 11:50:19.663598758 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sched-vis.c	2012-03-29 18:03:19.000000000 +1000
@@ -554,6 +554,9 @@
     case RETURN:
       sprintf (buf, "return");
       break;
+    case SIMPLE_RETURN:
+      sprintf (buf, "simple_return");
+      break;
     case CALL:
       print_exp (buf, x, verbose);
       break;
diff -ru ./gcc/sel-sched.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sel-sched.c
--- ./gcc/sel-sched.c	2014-06-06 14:25:27.534150554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sel-sched.c	2012-03-29 18:03:19.000000000 +1000
@@ -7616,8 +7616,8 @@
   sel_setup_sched_infos ();
   setup_sched_dump ();
 
-  sched_rgn_init (false);
   sched_init ();
+  sched_rgn_init (false);
 
   sched_init_bbs ();
   /* Reset AFTER_RECOVERY if it has been set by the 1st scheduler pass.  */
diff -ru ./gcc/sel-sched-ir.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sel-sched-ir.c
--- ./gcc/sel-sched-ir.c	2014-06-06 14:25:27.530150554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/sel-sched-ir.c	2012-03-29 18:03:19.000000000 +1000
@@ -1,5 +1,6 @@
 /* Instruction scheduling pass.  Selective scheduler and pipeliner.
-   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
+   Free Software Foundation, Inc.
 
 This file is part of GCC.
 
@@ -5650,7 +5651,12 @@
 
   NULL, /* add_remove_insn */
   NULL, /* begin_schedule_ready */
+  NULL, /* begin_move_insn */
   NULL, /* advance_target_bb */
+
+  NULL,
+  NULL,
+
   SEL_SCHED | NEW_BBS
 };
 
diff -ru ./gcc/stmt.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/stmt.c
--- ./gcc/stmt.c	2014-06-06 11:50:19.719598760 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/stmt.c	2012-03-29 18:03:19.000000000 +1000
@@ -119,7 +119,8 @@
 static int estimate_case_costs (case_node_ptr);
 static bool lshift_cheap_p (void);
 static int case_bit_test_cmp (const void *, const void *);
-static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, rtx);
+static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, tree,
+                                 rtx, basic_block);
 static void balance_case_nodes (case_node_ptr *, case_node_ptr);
 static int node_has_low_bound (case_node_ptr, tree);
 static int node_has_high_bound (case_node_ptr, tree);
@@ -1757,7 +1758,8 @@
 
 	  /* Use bitpos for the source extraction (left justified) and
 	     xbitpos for the destination store (right justified).  */
-	  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD, word_mode,
+	  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD, false,
+			   word_mode,
 			   extract_bit_field (src, bitsize,
 					      bitpos % BITS_PER_WORD, 1, false,
 					      NULL_RTX, word_mode, word_mode));
@@ -2111,8 +2113,11 @@
 {
   HOST_WIDE_INT hi;
   HOST_WIDE_INT lo;
+  HOST_WIDE_INT rev_hi;
+  HOST_WIDE_INT rev_lo;
   rtx label;
   int bits;
+  int prob;
 };
 
 /* Determine whether "1 << x" is relatively cheap in word_mode.  */
@@ -2154,10 +2159,195 @@
   return CODE_LABEL_NUMBER (d2->label) - CODE_LABEL_NUMBER (d1->label);
 }
 
+/* Emit a bit test and a conditional jump.  */
+
+static void
+emit_case_bit_test_jump (unsigned int count, rtx index, rtx label,
+                         unsigned int method, HOST_WIDE_INT hi,
+                         HOST_WIDE_INT lo, HOST_WIDE_INT rev_hi,
+                         HOST_WIDE_INT rev_lo)
+{
+  rtx expr;
+
+  if (method == 1)
+    {
+      /* (1 << index). */
+      if (count == 0)
+        index = expand_binop (word_mode, ashl_optab, const1_rtx,
+                              index, NULL_RTX, 1, OPTAB_WIDEN);
+      /* CST.  */
+      expr = immed_double_const (lo, hi, word_mode);
+      /* ((1 << index) & CST).  */
+      expr = expand_binop (word_mode, and_optab, index, expr,
+                           NULL_RTX, 1, OPTAB_WIDEN);
+      /* if (((1 << index) & CST)).   */
+      emit_cmp_and_jump_insns (expr, const0_rtx, NE, NULL_RTX,
+                               word_mode, 1, label);
+    }
+  else if (method == 2)
+    {
+      /* (bit_reverse (CST)) */
+      expr = immed_double_const (rev_lo, rev_hi, word_mode);
+      /* ((bit_reverse (CST)) << index) */
+      expr = expand_binop (word_mode, ashl_optab, expr,
+                           index, NULL_RTX, 1, OPTAB_WIDEN);
+      /* if (((bit_reverse (CST)) << index) < 0).  */
+      emit_cmp_and_jump_insns (expr, const0_rtx, LT, NULL_RTX,
+                               word_mode, 0, label);
+    }
+  else
+    gcc_unreachable ();
+}
+
+/* Return the cost of rtx sequence SEQ.  The sequence is supposed to contain one
+   jump, which has no effect in the cost.  */
+
+static unsigned int
+rtx_seq_cost (rtx seq)
+{
+  rtx one;
+  unsigned int nr_branches = 0;
+  unsigned int sum = 0, cost;
+
+  for (one = seq; one != NULL_RTX; one = NEXT_INSN (one))
+    if (JUMP_P (one))
+      nr_branches++;
+    else
+      {
+        cost = insn_rtx_cost (PATTERN (one), optimize_insn_for_speed_p ());
+        if (dump_file)
+          {
+            print_rtl_single (dump_file, one);
+            fprintf (dump_file, "cost: %u\n", cost);
+          }
+        sum += cost;
+      }
+
+  gcc_assert (nr_branches == 1);
+
+  if (dump_file)
+    fprintf (dump_file, "total cost: %u\n", sum);
+  return sum;
+}
+
+/* Generate the rtx sequences for 2 bit test expansion methods, measure the cost
+   and choose the cheapest.  */
+
+static unsigned int
+choose_case_bit_test_expand_method (rtx label)
+{
+  rtx seq, index;
+  unsigned int cost[2];
+  static bool method_known = false;
+  static unsigned int method;
+
+  /* If already known, return the method.  */
+  if (method_known)
+    return method;
+
+  index = gen_rtx_REG (word_mode, 10000);
+
+  for (method = 1; method <= 2; ++method)
+    {
+      start_sequence ();
+      emit_case_bit_test_jump (0, index, label, method, 0, 0x0f0f0f0f, 0,
+                               0x0f0f0f0f);
+      seq = get_insns ();
+      end_sequence ();
+      cost[method - 1] = rtx_seq_cost (seq);
+    }
+
+  /* Determine method based on heuristic.  */
+  method = ((cost[1] < cost[0]) ? 1 : 0) + 1;
+
+  /* Save and return method.  */
+  method_known = true;
+  return method;
+}
+
+/* Get the edge probability of the edge from SRC to LABEL_DECL.  */
+
+static int
+get_label_prob (basic_block src, tree label_decl)
+{
+  basic_block dest;
+  int prob = 0, nr_prob = 0;
+  unsigned int i;
+  edge e;
+
+  if (label_decl == NULL_TREE)
+    return 0;
+
+  dest = VEC_index (basic_block, label_to_block_map,
+                    LABEL_DECL_UID (label_decl));
+
+  for (i = 0; i < EDGE_COUNT (src->succs); ++i)
+    {
+      e = EDGE_SUCC (src, i);
+
+      if (e->dest != dest)
+        continue;
+
+      prob += e->probability;
+      nr_prob++;
+    }
+
+  gcc_assert (nr_prob == 1);
+
+  return prob;
+}
+
+/* Add probability note with scaled PROB to JUMP and update INV_SCALE.  This
+   function is intended to be used with a series of conditional jumps to L[i]
+   where the probabilities p[i] to get to L[i] are known, and the jump
+   probabilities j[i] need to be computed.
+
+   The algorithm to calculate the probabilities is
+
+   scale = REG_BR_PROB_BASE;
+   for (i = 0; i < n; ++i)
+     {
+       j[i] = p[i] * scale / REG_BR_PROB_BASE;
+       f[i] = REG_BR_PROB_BASE - j[i];
+       scale = scale / (f[i] / REG_BR_PROB_BASE);
+     }
+
+   The implementation uses inv_scale (REG_BR_PROB_BASE / scale) instead of
+   scale, because scale tends to grow bigger than REG_BR_PROB_BASE.  */
+
+static void
+set_jump_prob (rtx jump, int prob, int *inv_scale)
+{
+  /* j[i] = p[i] * scale / REG_BR_PROB_BASE.  */
+  int jump_prob = (*inv_scale > 0
+                   ? prob * REG_BR_PROB_BASE / *inv_scale
+                   : REG_BR_PROB_BASE / 2);
+  /* f[i] = REG_BR_PROB_BASE - j[i].  */
+  int fallthrough_prob = REG_BR_PROB_BASE - jump_prob;
+
+  gcc_assert (jump_prob <= REG_BR_PROB_BASE);
+  add_reg_note (jump, REG_BR_PROB, GEN_INT (jump_prob));
+
+  /* scale = scale / (f[i] / REG_BR_PROB_BASE).  */
+  *inv_scale = *inv_scale * fallthrough_prob / REG_BR_PROB_BASE;
+}
+
+/* Set bit in hwi hi/lo pair.  */
+
+static void
+set_bit (HOST_WIDE_INT *hi, HOST_WIDE_INT *lo, unsigned int j)
+{
+  if (j >= HOST_BITS_PER_WIDE_INT)
+    *hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);
+  else
+    *lo |= (HOST_WIDE_INT) 1 << j;
+}
+
 /*  Expand a switch statement by a short sequence of bit-wise
     comparisons.  "switch(x)" is effectively converted into
-    "if ((1 << (x-MINVAL)) & CST)" where CST and MINVAL are
-    integer constants.
+    "if ((1 << (x-MINVAL)) & CST)" or
+    "if (((bit_reverse (CST)) << (x-MINVAL)) < 0)", where CST
+    and MINVAL are integer constants.
 
     INDEX_EXPR is the value being switched on, which is of
     type INDEX_TYPE.  MINVAL is the lowest case value of in
@@ -2171,14 +2361,18 @@
 
 static void
 emit_case_bit_tests (tree index_type, tree index_expr, tree minval,
-		     tree range, case_node_ptr nodes, rtx default_label)
+		     tree range, case_node_ptr nodes, tree default_label_decl,
+		     rtx default_label, basic_block bb)
 {
   struct case_bit_test test[MAX_CASE_BIT_TESTS];
   enum machine_mode mode;
   rtx expr, index, label;
   unsigned int i,j,lo,hi;
   struct case_node *n;
-  unsigned int count;
+  unsigned int count, method;
+  int inv_scale = REG_BR_PROB_BASE;
+  int default_prob = get_label_prob (bb, default_label_decl);
+  int total_prob = default_prob;
 
   count = 0;
   for (n = nodes; n; n = n->right)
@@ -2193,8 +2387,12 @@
 	  gcc_assert (count < MAX_CASE_BIT_TESTS);
 	  test[i].hi = 0;
 	  test[i].lo = 0;
+	  test[i].rev_hi = 0;
+	  test[i].rev_lo = 0;
 	  test[i].label = label;
 	  test[i].bits = 1;
+	  test[i].prob = get_label_prob (bb, n->code_label);
+	  total_prob += test[i].prob;
 	  count++;
 	}
       else
@@ -2205,10 +2403,11 @@
       hi = tree_low_cst (fold_build2 (MINUS_EXPR, index_type,
 				      n->high, minval), 1);
       for (j = lo; j <= hi; j++)
-        if (j >= HOST_BITS_PER_WIDE_INT)
-	  test[i].hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);
-	else
-	  test[i].lo |= (HOST_WIDE_INT) 1 << j;
+        {
+          set_bit (&test[i].hi, &test[i].lo, j);
+          set_bit (&test[i].rev_hi, &test[i].rev_lo,
+                   GET_MODE_BITSIZE (word_mode) - j - 1);
+        }
     }
 
   qsort (test, count, sizeof(*test), case_bit_test_cmp);
@@ -2222,20 +2421,28 @@
   mode = TYPE_MODE (index_type);
   expr = expand_normal (range);
   if (default_label)
-    emit_cmp_and_jump_insns (index, expr, GTU, NULL_RTX, mode, 1,
-			     default_label);
+    {
+      emit_cmp_and_jump_insns (index, expr, GTU, NULL_RTX, mode, 1,
+                               default_label);
+      if (profile_status_for_function (cfun) != PROFILE_ABSENT)
+	{
+	  default_prob = default_prob * REG_BR_PROB_BASE / total_prob;
+	  set_jump_prob (get_last_insn (), default_prob / 2, &inv_scale);
+	}
+    }
 
   index = convert_to_mode (word_mode, index, 0);
-  index = expand_binop (word_mode, ashl_optab, const1_rtx,
-			index, NULL_RTX, 1, OPTAB_WIDEN);
 
+  method = choose_case_bit_test_expand_method (test[0].label);
   for (i = 0; i < count; i++)
     {
-      expr = immed_double_const (test[i].lo, test[i].hi, word_mode);
-      expr = expand_binop (word_mode, and_optab, index, expr,
-			   NULL_RTX, 1, OPTAB_WIDEN);
-      emit_cmp_and_jump_insns (expr, const0_rtx, NE, NULL_RTX,
-			       word_mode, 1, test[i].label);
+      emit_case_bit_test_jump (i, index, test[i].label, method, test[i].hi,
+                               test[i].lo, test[i].rev_hi, test[i].rev_lo);
+      if (profile_status_for_function (cfun) != PROFILE_ABSENT)
+	{
+	  test[i].prob = test[i].prob * REG_BR_PROB_BASE / total_prob;
+	  set_jump_prob (get_last_insn (), test[i].prob, &inv_scale);
+	}
     }
 
   if (default_label)
@@ -2415,7 +2622,8 @@
 	      range = maxval;
 	    }
 	  emit_case_bit_tests (index_type, index_expr, minval, range,
-			       case_list, default_label);
+			       case_list, default_label_decl, default_label,
+			       gimple_bb (stmt));
 	}
 
       /* If range of values is much bigger than number of values,
diff -ru ./gcc/stor-layout.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/stor-layout.c
--- ./gcc/stor-layout.c	2014-06-06 14:25:27.534150554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/stor-layout.c	2012-03-29 18:03:19.000000000 +1000
@@ -660,12 +660,13 @@
 	  /* See if we can use an ordinary integer mode for a bit-field.
 	     Conditions are: a fixed size that is correct for another mode,
 	     occupying a complete byte or bytes on proper boundary,
-	     and not volatile or not -fstrict-volatile-bitfields.  */
+	     and not -fstrict-volatile-bitfields.  If the latter is set,
+	     we unfortunately can't check TREE_THIS_VOLATILE, as a cast
+	     may make a volatile object later.  */
 	  if (TYPE_SIZE (type) != 0
 	      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
 	      && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT
-	      && !(TREE_THIS_VOLATILE (decl)
-		   && flag_strict_volatile_bitfields > 0))
+	      && flag_strict_volatile_bitfields <= 0)
 	    {
 	      enum machine_mode xmode
 		= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);
diff -ru ./gcc/target.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/target.def
--- ./gcc/target.def	2014-06-06 14:25:27.534150554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/target.def	2012-03-29 18:03:19.000000000 +1000
@@ -949,6 +949,13 @@
 bool, (rtx insn, int x),
 hook_bool_rtx_int_false)
 
+DEFHOOKPOD
+(exposed_pipeline,
+"True if the processor has an exposed pipeline, which means that not just\n\
+the order of instructions is important for correctness when scheduling, but\n\
+also the latencies of operations.",
+bool, false)
+
 HOOK_VECTOR_END (sched)
 
 /* Functions relating to vectorization.  */
@@ -1295,6 +1302,17 @@
  void, (void),
  hook_void_void)
 
+ /* Add a __gnu_ prefix to library functions rather than just __.  */
+DEFHOOKPOD
+(libfunc_gnu_prefix,
+ "If false (the default), internal library routines start with two\n\
+underscores.  If set to true, these routines start with @code{__gnu_}\n\
+instead.  E.g., @code{__muldi3} changes to @code{__gnu_muldi3}.  This\n\
+currently only affects functions defined in @file{libgcc2.c}.  If this\n\
+is set to true, the @file{tm.h} file must also\n\
+@code{#define LIBGCC2_GNU_PREFIX}.",
+  bool, false)
+
 /* Given a decl, a section name, and whether the decl initializer
    has relocs, choose attributes for the section.  */
 /* ??? Should be merged with SELECT_SECTION and UNIQUE_SECTION.  */
@@ -1791,6 +1809,15 @@
  const char *, (const void *data, size_t sz),
  default_pch_valid_p)
 
+DEFHOOK
+(prepare_pch_save,
+ "Called before writing out a PCH file.  If the target has some\n\
+garbage-collected data that needs to be in a particular state on PCH loads,\n\
+it can use this hook to enforce that state.  Very few targets need\n\
+to do anything here.",
+ void, (void),
+ hook_void_void)
+
 /* If nonnull, this function checks whether a PCH file with the
    given set of target flags can be used.  It returns NULL if so,
    otherwise it returns an error message.  */
@@ -2615,6 +2642,17 @@
 
 HOOK_VECTOR_END (target_option)
 
+HOOK_VECTOR (TARGET_ALIGN_HOOKS, target_align_hooks)
+
+/* Function that returns the log2 of the instruction alignment in bytes.  */
+DEFHOOK
+(align_insns,
+ "Return the log2 of the instruction alignment in bytes.",
+ int, (void),
+ hook_int_void_0)
+
+HOOK_VECTOR_END (target_align)
+
 /* For targets that need to mark extra registers as live on entry to
    the function, they should define this target hook and set their
    bits in the bitmap passed in. */
@@ -2624,6 +2662,15 @@
  void, (bitmap regs),
  hook_void_bitmap)
 
+/* For targets that have attributes that can affect whether a
+   function's return statements need checking.  For instance a 'naked'
+   function attribute.  */
+DEFHOOK
+(warn_func_result,
+ "True if a function's return statements should be checked for matching the function's return type.  This includes checking for falling off the end of a non-void function.  Return false if no such check should be made.",
+ bool, (void),
+ hook_bool_void_true)
+
 /* Determine the type of unwind info to emit for debugging.  */
 DEFHOOK
 (debug_unwind_info,
diff -ru ./gcc/targhooks.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/targhooks.c
--- ./gcc/targhooks.c	2014-06-06 14:25:27.538150554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/targhooks.c	2012-03-29 18:03:19.000000000 +1000
@@ -124,7 +124,7 @@
 			       const_tree funtype ATTRIBUTE_UNUSED,
 			       int for_return ATTRIBUTE_UNUSED)
 {
-  if (for_return == 2)
+  if (type != NULL_TREE && for_return == 2)
     return promote_mode (type, mode, punsignedp);
   return mode;
 }
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/c-c++-common: abi-bf.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/compile: 20110322-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/compile: 20110907.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/compile: pr50380.c
diff -ru ./gcc/testsuite/gcc.c-torture/execute/20101011-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/20101011-1.c
--- ./gcc/testsuite/gcc.c-torture/execute/20101011-1.c	2014-06-06 11:50:21.591598831 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/20101011-1.c	2012-03-29 17:57:48.000000000 +1000
@@ -22,6 +22,26 @@
   /* Not all Linux kernels deal correctly the breakpoints generated by
      MIPS16 divisions by zero.  They show up as a SIGTRAP instead.  */
 # define DO_TEST 0
+#elif defined (__arm__) && defined (__ARM_EABI__)
+# ifdef __ARM_ARCH_EXT_IDIV__
+  /* Hardware division instructions may not trap, and handle trapping
+     differently anyway.  Skip the test if we have those instructions.  */
+#  define DO_TEST 0
+# else
+#  include <signal.h>
+  /* ARM division-by-zero behaviour is to call a helper function, which
+     can do several different things, depending on requirements.  Emulate
+     the behaviour of other targets here by raising SIGFPE.  */
+int
+__aeabi_idiv0 (int return_value)
+{
+  raise (SIGFPE);
+  return return_value;
+}
+#  define DO_TEST 1
+# endif
+#elif defined (__m68k__) && !defined(__linux__)
+# define DO_TEST 0
 #else
 # define DO_TEST 1
 #endif
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute: 990208-1.x
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute: bcp-1.x
diff -ru ./gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp
--- ./gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp	2014-06-06 11:50:21.615598832 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/ieee/ieee.exp	2012-03-29 17:57:45.000000000 +1000
@@ -54,6 +54,9 @@
      || [istarget "sh*-*-*"] } then {
   lappend additional_flags "-mieee"
 }
+if [istarget "mips*-sde-*"] then {
+  lappend additional_flags "-Wl,--defsym=__cs3_mips_float_type=2" "-lcs3-mips-cp1" "-lcs3-mips-fpemu"
+}
 
 # load support procs
 load_lib c-torture.exp
diff -ru ./gcc/testsuite/gcc.c-torture/execute/loop-2f.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2f.c
--- ./gcc/testsuite/gcc.c-torture/execute/loop-2f.c	2014-06-06 11:50:21.619598832 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2f.c	2012-03-29 17:57:48.000000000 +1000
@@ -1,6 +1,5 @@
 #include <limits.h>
 
-#ifdef __unix__ /* ??? Is that good enough? */
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
@@ -18,7 +17,6 @@
 #ifndef MAP_FIXED
 #define MAP_FIXED 0
 #endif
-#endif
 
 #define MAP_START (void *)0x7fff8000
 #define MAP_LEN 0x10000
diff -ru ./gcc/testsuite/gcc.c-torture/execute/loop-2f.x /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2f.x
--- ./gcc/testsuite/gcc.c-torture/execute/loop-2f.x	2014-06-06 11:50:21.619598832 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2f.x	2012-03-29 17:57:48.000000000 +1000
@@ -1,3 +1,9 @@
+load_lib target-supports.exp
+
+if { ! [check_effective_target_mmap] } {
+        return 1
+}
+
 if [istarget "m68k-*-linux*"] {
     # the executable is at the same position the test tries to remap
     return 1
diff -ru ./gcc/testsuite/gcc.c-torture/execute/loop-2g.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2g.c
--- ./gcc/testsuite/gcc.c-torture/execute/loop-2g.c	2014-06-06 11:50:21.619598832 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2g.c	2012-03-29 17:57:48.000000000 +1000
@@ -1,6 +1,5 @@
 #include <limits.h>
 
-#ifdef __unix__ /* ??? Is that good enough? */
 #include <sys/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
@@ -18,7 +17,6 @@
 #ifndef MAP_FIXED
 #define MAP_FIXED 0
 #endif
-#endif
 
 #define MAP_START (void *)0x7fff8000
 #define MAP_LEN 0x10000
diff -ru ./gcc/testsuite/gcc.c-torture/execute/loop-2g.x /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2g.x
--- ./gcc/testsuite/gcc.c-torture/execute/loop-2g.x	2014-06-06 11:50:21.619598832 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.c-torture/execute/loop-2g.x	2012-03-29 17:57:48.000000000 +1000
@@ -1,3 +1,9 @@
+load_lib target-supports.exp
+
+if { ! [check_effective_target_mmap] } {
+        return 1
+}
+
 if [istarget "m68k-*-linux*"] {
     # the executable is at the same position the test tries to remap
     return 1
diff -ru ./gcc/testsuite/gcc.dg/20030711-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/20030711-1.c
--- ./gcc/testsuite/gcc.dg/20030711-1.c	2014-06-06 11:50:21.655598833 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/20030711-1.c	2012-03-29 17:59:56.000000000 +1000
@@ -1,6 +1,6 @@
 /* Test whether strncmp has not been "optimized" into memcmp
    nor any code with memcmp semantics.  */
-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* *-*-darwin* } } */
+/* { dg-do run { target mmap } } */
 /* { dg-options "-O2" } */
 #include <stddef.h>
 #include <stdio.h>
@@ -8,6 +8,9 @@
 #ifndef MAP_ANONYMOUS
 #define MAP_ANONYMOUS MAP_ANON
 #endif
+#ifndef MAP_ANON
+#define MAP_ANON 0
+#endif
 #include <stdlib.h>
 
 void __attribute__((noinline)) test (const char *p)
diff -ru ./gcc/testsuite/gcc.dg/20050826-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/20050826-1.c
--- ./gcc/testsuite/gcc.dg/20050826-1.c	2014-06-06 11:50:21.659598834 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/20050826-1.c	2012-03-29 17:59:56.000000000 +1000
@@ -1,6 +1,6 @@
 /* Test whether strncmp has not been "optimized" into memcmp
    nor any code with memcmp semantics.  */
-/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* *-*-darwin* } } */
+/* { dg-do run { target mmap } } */
 /* { dg-options "-O2" } */
 #include <stddef.h>
 #include <stdio.h>
@@ -9,6 +9,9 @@
 #ifndef MAP_ANONYMOUS
 #define MAP_ANONYMOUS MAP_ANON
 #endif
+#ifndef MAP_ANON
+#define MAP_ANON 0
+#endif
 #include <stdlib.h>
 
     struct Flags {
diff -ru ./gcc/testsuite/gcc.dg/20100906-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/20100906-1.c
--- ./gcc/testsuite/gcc.dg/20100906-1.c	2014-06-06 11:50:21.667598834 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/20100906-1.c	2012-03-29 17:59:56.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O2" } */
+/* { dg-options "-O2 -fno-short-enums -Wl,--no-enum-size-warning" {target arm_eabi} } */
 
 /* This testcase got misoptimized by combine due to a wrong setting of
    subst_low_luid in try_combine.  */
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: constructor-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: extend-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: extend-2-64.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: extend-2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: extend-3.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: extend-4.c
diff -ru ./gcc/testsuite/gcc.dg/format/ms_c90-printf-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/format/ms_c90-printf-1.c
--- ./gcc/testsuite/gcc.dg/format/ms_c90-printf-1.c	2014-06-06 11:50:21.847598841 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/format/ms_c90-printf-1.c	2012-03-29 17:59:55.000000000 +1000
@@ -167,7 +167,7 @@
   */
   printf ("%d", u);
   /* Wrong number of arguments.  */
-  printf ("%d%d", i); /* { dg-warning "arguments" "wrong number of args" } */
+  printf ("%d%d", i); /* { dg-warning "matching" "wrong number of args" } */
   printf ("%d", i, i); /* { dg-warning "arguments" "wrong number of args" } */
   /* Miscellaneous bogus constructions.  */
   printf (""); /* { dg-warning "zero-length" "warning for empty format" } */
diff -ru ./gcc/testsuite/gcc.dg/format/ms_c90-scanf-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/format/ms_c90-scanf-1.c
--- ./gcc/testsuite/gcc.dg/format/ms_c90-scanf-1.c	2014-06-06 11:50:21.847598841 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/format/ms_c90-scanf-1.c	2012-03-29 17:59:55.000000000 +1000
@@ -106,7 +106,7 @@
   scanf ("%s", cs); /* { dg-warning "constant" "%s writing into const" } */
   scanf ("%p", pcp); /* { dg-warning "constant" "%p writing into const" } */
   /* Wrong number of arguments.  */
-  scanf ("%d%d", ip); /* { dg-warning "arguments" "wrong number of args" } */
+  scanf ("%d%d", ip); /* { dg-warning "matching" "wrong number of args" } */
   scanf ("%d", ip, ip); /* { dg-warning "arguments" "wrong number of args" } */
   /* Miscellaneous bogus constructions.  */
   scanf (""); /* { dg-warning "zero-length" "warning for empty format" } */
diff -ru ./gcc/testsuite/gcc.dg/graphite/id-pr46845.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/graphite/id-pr46845.c
--- ./gcc/testsuite/gcc.dg/graphite/id-pr46845.c	2014-06-06 11:50:21.887598842 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/graphite/id-pr46845.c	2012-03-29 17:59:03.000000000 +1000
@@ -1,4 +1,4 @@
-/* { dg-options "-O2 -ffast-math -fgraphite-identity -w -Wno-psabi" { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-options "-O2 -ffast-math -fgraphite-identity -w -Wno-psabi" { target { i?86-*-* x86_64-*-* powerpc*-*-* } } } */
 
 typedef float V2SF __attribute__ ((vector_size (128)));
 
diff -ru ./gcc/testsuite/gcc.dg/graphite/interchange-7.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/graphite/interchange-7.c
--- ./gcc/testsuite/gcc.dg/graphite/interchange-7.c	2014-06-06 11:50:21.887598842 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/graphite/interchange-7.c	2012-03-29 17:59:03.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-require-effective-target size32plus } */
+/* { dg-add-options large_stack } */
 
 /* Formerly known as ltrans-8.c */
 
diff -ru ./gcc/testsuite/gcc.dg/graphite/run-id-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/graphite/run-id-1.c
--- ./gcc/testsuite/gcc.dg/graphite/run-id-1.c	2014-06-06 11:50:21.891598842 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/graphite/run-id-1.c	2012-03-29 17:59:03.000000000 +1000
@@ -1,3 +1,4 @@
+/* { dg-options "-Wl,--stack,12582912" { target *-*-mingw* *-*-cygwin* } } */
 /* { dg-require-effective-target size32plus } */
 
 void abort (void);
diff -ru ./gcc/testsuite/gcc.dg/lto/20081222_1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/lto/20081222_1.c
--- ./gcc/testsuite/gcc.dg/lto/20081222_1.c	2014-06-06 11:50:21.991598846 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/lto/20081222_1.c	2012-03-29 17:59:16.000000000 +1000
@@ -1,8 +1,12 @@
 #include "20081222_0.h"
 
+#define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+#define ASMNAME2(prefix, cname) STRING (prefix) cname
+#define STRING(x)    #x
+
 /* Actually, call "x" "INT_X", and make it hidden.  */
 extern __typeof (x) x
-	__asm__ ("INT_x")
+	__asm__ (ASMNAME ("INT_x"))
 	__attribute__ ((__visibility__ ("hidden")));
 
 int x ()
@@ -12,5 +16,5 @@
 
 /* Make an externally-visible symbol "X" that's an alias for INT_x.  */
 extern __typeof (x) EXT_x
-	__asm__ ("x")
+	__asm__ (ASMNAME ("x"))
 	__attribute__ ((__alias__ ("INT_x")));
diff -ru ./gcc/testsuite/gcc.dg/lto/20090210_0.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/lto/20090210_0.c
--- ./gcc/testsuite/gcc.dg/lto/20090210_0.c	2014-06-06 11:50:21.991598846 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/lto/20090210_0.c	2012-03-29 17:59:16.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-lto-do run }  */
 /* { dg-suppress-ld-options {-fPIC} }  */
-/* { dg-require-effective-target tls } */
+/* { dg-require-effective-target tls_runtime } */
 /* { dg-extra-ld-options "-pthread" { target *-*-solaris2.[89] } } */
 int foo (int x)
 {
diff -ru ./gcc/testsuite/gcc.dg/lto/pr46940_0.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/lto/pr46940_0.c
--- ./gcc/testsuite/gcc.dg/lto/pr46940_0.c	2014-06-06 11:50:21.995598846 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/lto/pr46940_0.c	2012-03-29 17:59:16.000000000 +1000
@@ -2,10 +2,14 @@
 /* { dg-extra-ld-options "-fuse-linker-plugin" } */
 #include <stdio.h>
 
+#define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+#define ASMNAME2(prefix, cname) STRING (prefix) cname
+#define STRING(x)    #x
+
 extern __attribute__((visibility("hidden"))) void _moz_foo (void);
-extern __typeof (_moz_foo) _moz_foo __asm__ ("" "INT__foo") __attribute__((__visibility__("hidden"))) ;
+extern __typeof (_moz_foo) _moz_foo __asm__ (ASMNAME ("INT__foo")) __attribute__((__visibility__("hidden"))) ;
 void _moz_foo(void)
 {
   printf ("blah\n");
 }
-extern __typeof (_moz_foo) EXT__foo __asm__("" "_moz_foo") __attribute__((__alias__("" "INT__foo")));
+extern __typeof (_moz_foo) EXT__foo __asm__(ASMNAME ("_moz_foo")) __attribute__((__alias__("" "INT__foo")));
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: m68k-fp-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: memcpy-3.c
diff -ru ./gcc/testsuite/gcc.dg/pr47276.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/pr47276.c
--- ./gcc/testsuite/gcc.dg/pr47276.c	2014-06-06 11:50:22.087598850 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/pr47276.c	2012-03-29 17:59:56.000000000 +1000
@@ -1,6 +1,11 @@
 /* { dg-do compile } */
 /* { dg-require-alias "" } */
 /* { dg-require-visibility "" } */
+
+#define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+#define ASMNAME2(prefix, cname) STRING (prefix) cname
+#define STRING(x)    #x
+
 extern void syslog (int __pri, __const char *__fmt, ...)
      __attribute__ ((__format__ (__printf__, 2, 3)));
 extern void vsyslog (int __pri, __const char *__fmt, int __ap)
@@ -17,15 +22,15 @@
 __vsyslog_chk(int pri, int flag, const char *fmt, int ap)
 {
 }
-extern __typeof (__vsyslog_chk) __EI___vsyslog_chk __asm__("" "__vsyslog_chk"); extern __typeof (__vsyslog_chk) __EI___vsyslog_chk __attribute__((alias ("" "__GI___vsyslog_chk")));
+extern __typeof (__vsyslog_chk) __EI___vsyslog_chk __asm__("" ASMNAME ("__vsyslog_chk")); extern __typeof (__vsyslog_chk) __EI___vsyslog_chk __attribute__((alias ("" "__GI___vsyslog_chk")));
 void
 __syslog(int pri, const char *fmt, ...)
 {
 }
 extern __typeof (__syslog) syslog __attribute__ ((alias ("__syslog")));
-extern __typeof (syslog) __EI_syslog __asm__("" "syslog"); extern __typeof (syslog) __EI_syslog __attribute__((alias ("" "__GI_syslog")));
+extern __typeof (syslog) __EI_syslog __asm__("" ASMNAME ("syslog")); extern __typeof (syslog) __EI_syslog __attribute__((alias ("" "__GI_syslog")));
 extern __typeof (__vsyslog) vsyslog __attribute__ ((alias ("__vsyslog")));
-extern __typeof (vsyslog) __EI_vsyslog __asm__("" "vsyslog"); extern __typeof (vsyslog) __EI_vsyslog __attribute__((alias ("" "__GI_vsyslog")));
-extern __typeof (syslog) syslog __asm__ ("" "__GI_syslog") __attribute__ ((visibility ("hidden")));
-extern __typeof (vsyslog) vsyslog __asm__ ("" "__GI_vsyslog") __attribute__ ((visibility ("hidden")));
-extern __typeof (__vsyslog_chk) __vsyslog_chk __asm__ ("" "__GI___vsyslog_chk") __attribute__ ((visibility ("hidden")));
+extern __typeof (vsyslog) __EI_vsyslog __asm__("" ASMNAME ("vsyslog")); extern __typeof (vsyslog) __EI_vsyslog __attribute__((alias ("" "__GI_vsyslog")));
+extern __typeof (syslog) syslog __asm__ ("" ASMNAME ("__GI_syslog")) __attribute__ ((visibility ("hidden")));
+extern __typeof (vsyslog) vsyslog __asm__ ("" ASMNAME ("__GI_vsyslog")) __attribute__ ((visibility ("hidden")));
+extern __typeof (__vsyslog_chk) __vsyslog_chk __asm__ ("" ASMNAME ("__GI___vsyslog_chk")) __attribute__ ((visibility ("hidden")));
diff -ru ./gcc/testsuite/gcc.dg/pr49948.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/pr49948.c
--- ./gcc/testsuite/gcc.dg/pr49948.c	2014-06-06 14:25:27.542150554 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/pr49948.c	2012-03-29 17:59:56.000000000 +1000
@@ -1,5 +1,6 @@
 /* PR tree-optimization/49948 */
 /* { dg-do compile } */
+/* { dg-require-effective-target pthread } */
 /* { dg-options "-O3 -ftree-parallelize-loops=2" } */
 
 extern int a, *b;
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: pr49994-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: pr49994-2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: pr49994-3.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-10.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-11.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-12.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-13.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-3.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-4.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-5.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-6.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-7.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-8.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: promote-short-9.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-10.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-11.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-12.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-13.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-14.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-15.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-16.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-17.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-18.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-3.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-4.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-5.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-6.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-7.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-8.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: remove-local-statics-9.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: stack-layout-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: switch-bittest.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: switch-prob.c
diff -ru ./gcc/testsuite/gcc.dg/tls/thr-cse-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tls/thr-cse-1.c
--- ./gcc/testsuite/gcc.dg/tls/thr-cse-1.c	2014-06-06 11:50:22.115598851 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tls/thr-cse-1.c	2012-03-29 17:59:37.000000000 +1000
@@ -15,9 +15,10 @@
   return a;
 }
 
-/* { dg-final { scan-assembler-not "emutls_get_address.*emutls_get_address.*" { target { ! { "*-wrs-vxworks"  "*-*-darwin8"  "hppa*-*-hpux*" "spu-*-*" } } } } } */
+/* { dg-final { scan-assembler-not "emutls_get_address.*emutls_get_address.*" { target { ! { "*-wrs-vxworks"  "*-*-darwin8"  "hppa*-*-hpux*" "spu-*-*" "i?86-*-mingw*" } } } } } */
 /* { dg-final { scan-assembler-not "call\tL___emutls_get_address.stub.*call\tL___emutls_get_address.stub.*" { target "*-*-darwin8" } } } */
 /* { dg-final { scan-assembler-not "(b,l|bl) __emutls_get_address.*(b,l|bl) __emutls_get_address.*" { target "hppa*-*-hpux*" } } } */
 /* { dg-final { scan-assembler-not "(brsl|brasl)\t__emutls_get_address.*(brsl|brasl)\t__emutls_get_address.*" { target spu-*-* } } } */
 /* { dg-final { scan-assembler-not "tls_lookup.*tls_lookup.*" { target *-wrs-vxworks } } } */
+/* { dg-final { scan-assembler-not "call\t___emutls_get_address.*call\t___emutls_get_address" { target "i?86-*-mingw*" } } } */
 
diff -ru ./gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c
--- ./gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c	2014-06-06 11:50:22.307598858 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-5.c	2012-03-29 17:59:23.000000000 +1000
@@ -13,3 +13,5 @@
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff -ru ./gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c
--- ./gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c	2014-06-06 11:50:22.307598858 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/arm-fp16-ops-6.c	2012-03-29 17:59:23.000000000 +1000
@@ -13,3 +13,5 @@
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff -ru ./gcc/testsuite/gcc.dg/torture/pr48044.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/pr48044.c
--- ./gcc/testsuite/gcc.dg/torture/pr48044.c	2014-06-06 11:50:22.323598859 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/pr48044.c	2012-03-29 17:59:23.000000000 +1000
@@ -2,6 +2,10 @@
 /* { dg-do compile } */
 /* { dg-require-alias "" } */
 
-int a __asm__ ("b") = 0;
-extern int c __asm__ ("a") __attribute__ ((alias ("b")));
+#define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+#define ASMNAME2(prefix, cname) STRING (prefix) cname
+#define STRING(x)    #x
+
+int a __asm__ (ASMNAME ("b")) = 0;
+extern int c __asm__ (ASMNAME ("a")) __attribute__ ((alias ("b")));
 extern int d __attribute__ ((weak, alias ("a")));
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture: pr49030.c
diff -ru ./gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c
--- ./gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c	2014-06-06 11:50:22.339598859 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c	2012-03-29 17:59:22.000000000 +1000
@@ -5,6 +5,8 @@
    with pre-pushed arguments (e.g. SPARC).  */
 
 /* { dg-do run } */
+
+/* { dg-skip-if "Variadic funcs use Base AAPCS.  Normal funcs use VFP variant." { "arm*-*-*" } { "-mfloat-abi=hard" } { "" } } */
    
 
 #define INTEGER_ARG  5
diff -ru ./gcc/testsuite/gcc.dg/torture/type-generic-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/type-generic-1.c
--- ./gcc/testsuite/gcc.dg/torture/type-generic-1.c	2014-06-06 11:50:22.343598860 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/torture/type-generic-1.c	2012-03-29 17:59:23.000000000 +1000
@@ -4,6 +4,7 @@
 /* { dg-do run } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
 /* { dg-add-options ieee } */
+/* { dg-options "-Wl,--defsym=__cs3_mips_float_type=2 -lcs3-mips-cp1 -lcs3-mips-fpemu" { target mips*-*sde*-* } } */
 
 #include "../tg-tests.h"
 
diff -ru ./gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c
--- ./gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c	2014-06-06 11:50:22.343598860 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-prof/val-prof-7.c	2012-03-29 17:59:41.000000000 +1000
@@ -1,7 +1,7 @@
 /* { dg-options "-O2 -fdump-ipa-tree_profile_ipa -mtune=core2" } */
 /* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } { "*" } { "" } } */
 
-#include <strings.h>
+extern void bzero (void *, __SIZE_TYPE__);
 
 int foo(int len)
 {
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c	2014-06-06 11:50:22.347598860 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/20040204-1.c	2012-03-29 17:59:36.000000000 +1000
@@ -33,5 +33,5 @@
    that the && should be emitted (based on BRANCH_COST).  Fix this
    by teaching dom to look through && and register all components
    as true.  */
-/* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* sparc*-*-* spu-*-* x86_64-*-*" } } } } */
+/* { dg-final { scan-tree-dump-times "link_error" 0 "optimized" { xfail { ! "alpha*-*-* powerpc*-*-* cris-*-* crisv32-*-* hppa*-*-* i?86-*-* mmix-*-* mips*-*-* m68k*-*-* moxie-*-* sparc*-*-* spu-*-* x86_64-*-* arm*-*-*" } } } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/foldconst-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/foldconst-3.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/foldconst-3.c	2014-06-06 11:50:22.359598860 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/foldconst-3.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fno-short-enums" } */
 typedef const union tree_node *const_tree;
 typedef struct
 {
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa: ivopts-lt.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa: ivopts-max.c
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/pr21559.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/pr21559.c	2014-06-06 11:50:22.371598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/pr21559.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-vrp1-details" } */
+/* { dg-options "-O2 -fdump-tree-vrp1-details -fno-remove-local-statics" } */
 
 static int blocksize = 4096;
 
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c	2014-06-06 11:50:22.379598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-1.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-do run } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -funroll-loops --param max-unroll-times=8 -fpredictive-com
+moning -fdump-tree-pcom-details" } */
 
 void abort (void);
 
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c	2014-06-06 11:50:22.379598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-2.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-do run } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -funroll-loops --param max-unroll-times=8 -fpredictive-com
+moning -fdump-tree-pcom-details" } */
 
 void abort (void);
 
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c	2014-06-06 11:50:22.379598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-3.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -funroll-loops --param max-unroll-times=8 -fpredictive-com
+moning -fdump-tree-pcom-details" } */
 
 int a[1000], b[1000];
 
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c	2014-06-06 11:50:22.379598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-4.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-do run } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -funroll-loops --param max-unroll-times=8 -fpredictive-com
+moning -fdump-tree-pcom-details" } */
 
 /* Test for predictive commoning of expressions, without reassociation.  */
 
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c	2014-06-06 11:50:22.379598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/predcom-5.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-do run } */
-/* { dg-options "-O2 -fpredictive-commoning -fdump-tree-pcom-details" } */
+/* { dg-options "-O2 -funroll-loops --param max-unroll-times=8 -fpredictive-com
+moning -fdump-tree-pcom-details" } */
 
 /* Test for predictive commoning of expressions, with reassociation.  */
 
diff -ru ./gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c
--- ./gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c	2014-06-06 11:50:22.383598861 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-6.c	2012-03-29 17:59:36.000000000 +1000
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-dse1" } */
+/* { dg-options "-O2 -fdump-tree-dse1 -fno-remove-local-statics" } */
 
 int foo11 (int c)
 {
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: uninit-pred-7_d.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg: uninit-pred-8_d.c
diff -ru ./gcc/testsuite/gcc.dg/vect/pr48172.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/pr48172.c
--- ./gcc/testsuite/gcc.dg/vect/pr48172.c	2014-06-06 11:50:22.435598863 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/pr48172.c	2012-03-29 17:59:54.000000000 +1000
@@ -1,5 +1,3 @@
-/* { dg-do run } */
-
 extern void *memset(void *s, int c, __SIZE_TYPE__ n);
 extern void abort (void);
 
diff -ru ./gcc/testsuite/gcc.dg/vect/pr48377.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/pr48377.c
--- ./gcc/testsuite/gcc.dg/vect/pr48377.c	2014-06-06 11:50:22.435598863 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/pr48377.c	2012-03-29 17:59:54.000000000 +1000
@@ -1,5 +1,4 @@
 /* PR tree-optimization/48377 */
-/* { dg-do run } */
 /* { dg-require-effective-target non_strict_align } */
 
 typedef unsigned int U __attribute__((__aligned__ (1), __may_alias__));
diff -ru ./gcc/testsuite/gcc.dg/vect/pr49038.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/pr49038.c
--- ./gcc/testsuite/gcc.dg/vect/pr49038.c	2014-06-06 11:50:22.435598863 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/pr49038.c	2012-03-29 17:59:54.000000000 +1000
@@ -1,3 +1,5 @@
+/* { dg-require-effective-target mmap } */
+ 
 #include <sys/mman.h>
 #include <stdio.h>
 
diff -ru ./gcc/testsuite/gcc.dg/vect/vect-16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/vect-16.c
--- ./gcc/testsuite/gcc.dg/vect/vect-16.c	2014-06-06 11:50:22.451598864 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/vect-16.c	2012-03-29 17:59:54.000000000 +1000
@@ -34,5 +34,5 @@
 }
 
 /* Requires fast-math.  */
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail { ! "arm*-*-*" } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
diff -ru ./gcc/testsuite/gcc.dg/vect/vect-shift-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/vect-shift-2.c
--- ./gcc/testsuite/gcc.dg/vect/vect-shift-2.c	2014-06-06 11:50:22.463598864 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect/vect-shift-2.c	2012-03-29 17:59:54.000000000 +1000
@@ -5,6 +5,7 @@
    correct value is generated.  */
 
 #ifdef TRACE
+#include <stdio.h>
 #endif
 
 #include <stdarg.h>
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect: vect-shift-3.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vect: vect-shift-4.c
diff -ru ./gcc/testsuite/gcc.dg/vmx/vmx.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vmx/vmx.exp
--- ./gcc/testsuite/gcc.dg/vmx/vmx.exp	2014-06-06 11:50:22.475598865 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/vmx/vmx.exp	2012-03-29 17:58:48.000000000 +1000
@@ -31,7 +31,7 @@
 # nothing but extensions.
 global DEFAULT_VMXCFLAGS
 if ![info exists DEFAULT_VMXCFLAGS] then {
-    set DEFAULT_VMXCFLAGS "-maltivec -mabi=altivec -std=gnu99 -mno-vsx"
+    set DEFAULT_VMXCFLAGS "-maltivec -std=gnu99 -mno-vsx"
 }
 
 # If the target system supports AltiVec instructions, the default action
diff -ru ./gcc/testsuite/gcc.dg/Warray-bounds-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/Warray-bounds-3.c
--- ./gcc/testsuite/gcc.dg/Warray-bounds-3.c	2014-06-06 11:50:21.667598834 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.dg/Warray-bounds-3.c	2012-03-29 17:59:56.000000000 +1000
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -Warray-bounds" } */
+/* { dg-options "-O2 -Warray-bounds -fno-unroll-loops" { target arm*-*-* } } */
+
 /* based on PR 31227 */
 
 typedef __SIZE_TYPE__ size_t;
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: cmp-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: cmp-2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: div64-unwinding.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: fixed-point-exec.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: naked-3.c
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabals16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabals16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabals16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabals16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vabal_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabals32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabals32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabals32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabals32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vabal_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabals8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabals8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabals8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabals8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vabal_s8 (arg0_int16x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabalu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabalu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabalu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabalu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vabal_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabalu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabalu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabalu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabalu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vabal_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabalu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabalu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabalu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabalu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vabal_u8 (arg0_uint16x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabaQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabaQs16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vabaq_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabaQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabaQs32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vabaq_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabaQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabaQs8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x16_t = vabaq_s8 (arg0_int8x16_t, arg1_int8x16_t, arg2_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabaQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabaQu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vabaq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabaQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabaQu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vabaq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabaQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabaQu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabaQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x16_t = vabaq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, arg2_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabas16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabas16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabas16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabas16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vaba_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabas32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabas32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabas32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabas32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vaba_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabas8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabas8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabas8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabas8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vaba_s8 (arg0_int8x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabau16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabau16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabau16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabau16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vaba_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabau32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabau32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabau32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabau32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vaba_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabau8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabau8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabau8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabau8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vaba_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vaba\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaba\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdf32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vabd_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdls16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vabdl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabdl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabdl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdls32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vabdl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabdl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabdl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdls8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vabdl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabdl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabdl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdlu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vabdl_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabdl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabdl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdlu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vabdl_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabdl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabdl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdlu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vabdl_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabdl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabdl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQf32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vabdq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQs16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vabdq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQs32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vabdq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQs8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vabdq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vabdq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vabdq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdQu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vabdq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabds16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabds16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabds16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabds16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vabd_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabds32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabds32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabds32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabds32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vabd_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabds8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabds8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabds8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabds8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vabd_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vabd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vabd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabdu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabdu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabdu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vabd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabsf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabsf32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vabs_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabsQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabsQf32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vabsq_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabsQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabsQs16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vabsq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabsQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabsQs32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vabsq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabsQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabsQs8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabsQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vabsq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabss16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabss16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabss16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabss16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vabs_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabss32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabss32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabss32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabss32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vabs_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vabss8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabss8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vabss8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vabss8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vabs_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vabs\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vabs\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddf32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vadd_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddhns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddhns16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vaddhn_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vaddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddhns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddhns32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vaddhn_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vaddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddhns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddhns64.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vaddhn_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vaddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vaddhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vaddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vaddhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vaddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddhnu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vaddhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vaddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddls16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vaddl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vaddl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddls32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vaddl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vaddl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddls8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vaddl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vaddl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddlu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vaddl_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vaddl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddlu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vaddl_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vaddl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddlu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vaddl_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vaddl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQf32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vaddq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQs16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vaddq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQs32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vaddq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQs64.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vaddq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQs8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vaddq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vaddq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vaddq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQu64.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vaddq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddQu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vaddq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vadds16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vadds16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vadds16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vadds16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vadd_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vadds32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vadds32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vadds32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vadds32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vadd_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vadds8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vadds8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vadds8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vadds8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vadd_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddu16.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddu32.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddu8.c	2014-06-06 11:50:22.683598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddws16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddws16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddws16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddws16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vaddw_s16 (arg0_int32x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vaddw\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddw\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddws32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddws32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddws32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddws32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vaddw_s32 (arg0_int64x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vaddw\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddw\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddws8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddws8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddws8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddws8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vaddw_s8 (arg0_int16x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vaddw\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddw\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddwu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddwu16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddwu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vaddw_u16 (arg0_uint32x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vaddw\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddw\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddwu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddwu32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddwu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vaddw_u32 (arg0_uint64x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vaddw\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddw\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vaddwu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vaddwu8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vaddwu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vaddw_u8 (arg0_uint16x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vaddw\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vaddw\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQs16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vandq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQs32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vandq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQs64.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vandq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQs8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vandq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQu16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vandq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQu32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vandq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQu64.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vandq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandQu8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vandq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vands16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vands16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vands16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vands16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vand_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vands32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vands32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vands32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vands32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vand_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vands8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vands8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vands8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vands8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vand_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandu16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vand_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandu32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vand_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vandu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vandu8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vandu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vand_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vand\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQs16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vbicq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQs32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vbicq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQs64.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vbicq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQs8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vbicq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQu16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vbicq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQu32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vbicq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQu64.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vbicq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicQu8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vbicq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbics16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbics16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbics16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbics16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vbic_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbics32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbics32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbics32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbics32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vbic_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbics8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbics8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbics8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbics8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vbic_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicu16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vbic_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicu32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vbic_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbicu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbicu8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbicu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vbic_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vbic\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vbsl_f32 (arg0_uint32x2_t, arg1_float32x2_t, arg2_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslp16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly16x4_t = vbsl_p16 (arg0_uint16x4_t, arg1_poly16x4_t, arg2_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslp8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly8x8_t = vbsl_p8 (arg0_uint8x8_t, arg1_poly8x8_t, arg2_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQf32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vbslq_f32 (arg0_uint32x4_t, arg1_float32x4_t, arg2_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQp16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly16x8_t = vbslq_p16 (arg0_uint16x8_t, arg1_poly16x8_t, arg2_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQp8.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly8x16_t = vbslq_p8 (arg0_uint8x16_t, arg1_poly8x16_t, arg2_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQs16.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vbslq_s16 (arg0_uint16x8_t, arg1_int16x8_t, arg2_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQs32.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vbslq_s32 (arg0_uint32x4_t, arg1_int32x4_t, arg2_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQs64.c	2014-06-06 11:50:22.687598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vbslq_s64 (arg0_uint64x2_t, arg1_int64x2_t, arg2_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQs8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x16_t = vbslq_s8 (arg0_uint8x16_t, arg1_int8x16_t, arg2_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQu16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vbslq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQu32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vbslq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQu64.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vbslq_u64 (arg0_uint64x2_t, arg1_uint64x2_t, arg2_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslQu8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x16_t = vbslq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, arg2_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbsls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbsls16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vbsl_s16 (arg0_uint16x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbsls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbsls32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vbsl_s32 (arg0_uint32x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbsls64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbsls64.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls64.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x1_t = vbsl_s64 (arg0_uint64x1_t, arg1_int64x1_t, arg2_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbsls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbsls8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbsls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vbsl_s8 (arg0_uint8x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslu16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vbsl_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslu32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vbsl_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslu64.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x1_t = vbsl_u64 (arg0_uint64x1_t, arg1_uint64x1_t, arg2_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vbslu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vbslu8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vbslu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vbsl_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "((vbsl)|(vbit)|(vbif))\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcagef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcagef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcagef32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcagef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcage_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcageQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcageQf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcageQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcageq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcagtf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcagtf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcagtf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcagt_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcagtQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcagtq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcalef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcalef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcalef32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcalef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcale_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcaleQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcaleq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcaltf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcaltf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcaltf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcalt_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcaltQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcaltq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vacgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vceq_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqp8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vceq_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vceqq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQp8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vceqq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQs16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vceqq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQs32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vceqq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQs8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vceqq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQu16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vceqq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQu32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vceqq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqQu8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vceqq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqs16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vceq_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqs32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vceq_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vceqs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vceqs8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vceqs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vceq_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcequ16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcequ16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcequ16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcequ16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vceq_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcequ32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcequ32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcequ32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcequ32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vceq_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcequ8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcequ8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcequ8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcequ8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vceq_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vceq\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgef32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcge_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcgeq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcgeq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcgeq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcgeq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcgeq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcgeq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcgeq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcges16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcges16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcges16.c	2014-06-06 11:50:22.691598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcges16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vcge_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcges32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcges32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcges32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcges32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcge_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcges8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcges8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcges8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcges8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vcge_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vcge_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcge_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgeu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgeu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgeu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vcge_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtf32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcgt_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcgtq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcgtq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcgtq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcgtq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcgtq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcgtq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcgtq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgts16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgts16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgts16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgts16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vcgt_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgts32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgts32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgts32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgts32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcgt_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgts8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgts8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgts8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgts8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vcgt_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vcgt_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcgt_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcgtu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcgtu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcgtu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vcgt_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclef32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcle_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQf32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcleq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQs16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcleq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQs32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcleq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcleq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcleq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcleq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleQu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcleq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcles16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcles16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcles16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcles16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vcle_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcles32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcles32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcles32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcles32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcle_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcles8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcles8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcles8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcles8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vcle_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vcle_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vcle_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcleu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcleu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcleu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vcle_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcge\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclsQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclsQs16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclsQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vclsq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcls\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcls\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclsQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclsQs32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclsQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vclsq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcls\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcls\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclsQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclsQs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclsQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vclsq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcls\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcls\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclss16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclss16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclss16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclss16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vcls_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcls\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcls\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclss32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclss32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclss32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclss32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vcls_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcls\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcls\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclss8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclss8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclss8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclss8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vcls_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcls\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcls\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltf32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vclt_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQf32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcltq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQs16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcltq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQs32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcltq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcltq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vcltq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vcltq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltQu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vcltq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclts16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclts16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclts16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclts16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vclt_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclts32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclts32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclts32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclts32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vclt_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclts8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclts8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclts8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclts8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vclt_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vclt_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vclt_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcltu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcltu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcltu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vclt_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcgt\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzQs16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vclzq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzQs32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vclzq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzQs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vclzq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzQu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vclzq_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzQu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vclzq_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzQu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vclzq_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzs16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vclz_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzs32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vclz_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vclz_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzu16.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vclz_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzu32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vclz_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vclzu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vclzu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vclzu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vclz_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vclz\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcntp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcntp8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vcnt_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcntQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcntQp8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vcntq_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcntQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcntQs8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vcntq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcntQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcntQu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vcntq_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcnts8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcnts8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcnts8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcnts8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vcnt_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcntu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcntu8.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcntu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vcnt_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcnt\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtf32_s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vcvt_f32_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtf32_u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vcvt_f32_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vcvt_n_f32_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_nf32_u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vcvt_n_f32_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_ns32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vcvt_n_s32_f32 (arg0_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvt_nu32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vcvt_n_u32_f32 (arg0_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vcvtq_f32_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQf32_u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vcvtq_f32_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vcvtq_n_f32_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nf32_u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vcvtq_n_f32_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.f32.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_ns32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vcvtq_n_s32_f32 (arg0_float32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQ_nu32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vcvtq_n_u32_f32 (arg0_float32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c	2014-06-06 11:50:22.695598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQs32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vcvtq_s32_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtQu32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vcvtq_u32_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvts32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vcvt_s32_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.s32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vcvtu32_f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vcvt_u32_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vcvt\.u32.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vdup_lane_f32 (arg0_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vdup_lane_p16 (arg0_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vdup_lane_p8 (arg0_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vdup_lane_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vdup_lane_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vdup_lane_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vdup_lane_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vdup_lane_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vdup_lane_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vdup_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_np16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vdup_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_np8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vdup_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vdup_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vdup_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vdup_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vdup_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vdup_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdup_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vdup_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vdupq_lane_f32 (arg0_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8_t = vdupq_lane_p16 (arg0_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vdupq_lane_p8 (arg0_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vdupq_lane_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vdupq_lane_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vdupq_lane_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vdupq_lane_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vdupq_lane_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vdupq_lane_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vdupq_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8_t = vdupq_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vdupq_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vdupq_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vdupq_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vdupq_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vdupq_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vdupq_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vdupQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vdupq_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQs16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = veorq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQs32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = veorq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQs64.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = veorq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQs8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = veorq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQu16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = veorq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQu32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = veorq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQu64.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = veorq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veorQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/veorQu8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veorQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = veorq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veors16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veors16.c
--- ./gcc/testsuite/gcc.target/arm/neon/veors16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veors16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = veor_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veors32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veors32.c
--- ./gcc/testsuite/gcc.target/arm/neon/veors32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veors32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = veor_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veors8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veors8.c
--- ./gcc/testsuite/gcc.target/arm/neon/veors8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veors8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = veor_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veoru16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veoru16.c
--- ./gcc/testsuite/gcc.target/arm/neon/veoru16.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veoru16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = veor_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veoru32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veoru32.c
--- ./gcc/testsuite/gcc.target/arm/neon/veoru32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veoru32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = veor_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/veoru8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veoru8.c
--- ./gcc/testsuite/gcc.target/arm/neon/veoru8.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/veoru8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = veor_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "veor\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextf32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vext_f32 (arg0_float32x2_t, arg1_float32x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextp16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4_t = vext_p16 (arg0_poly16x4_t, arg1_poly16x4_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextp8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vext_p8 (arg0_poly8x8_t, arg1_poly8x8_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQf32.c	2014-06-06 11:50:22.699598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vextq_f32 (arg0_float32x4_t, arg1_float32x4_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQp16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8_t = vextq_p16 (arg0_poly16x8_t, arg1_poly16x8_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQp8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16_t = vextq_p8 (arg0_poly8x16_t, arg1_poly8x16_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQs16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vextq_s16 (arg0_int16x8_t, arg1_int16x8_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQs32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vextq_s32 (arg0_int32x4_t, arg1_int32x4_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQs64.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vextq_s64 (arg0_int64x2_t, arg1_int64x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQs8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vextq_s8 (arg0_int8x16_t, arg1_int8x16_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQu16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vextq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQu32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vextq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQu64.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vextq_u64 (arg0_uint64x2_t, arg1_uint64x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextQu8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vextq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vexts16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vexts16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vext_s16 (arg0_int16x4_t, arg1_int16x4_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vexts32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vexts32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vext_s32 (arg0_int32x2_t, arg1_int32x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vexts64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vexts64.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vext_s64 (arg0_int64x1_t, arg1_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vexts8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vexts8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vexts8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vext_s8 (arg0_int8x8_t, arg1_int8x8_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextu16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vext_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextu32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vext_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextu64.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vext_u64 (arg0_uint64x1_t, arg1_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vextu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vextu8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vextu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vext_u8 (arg0_uint8x8_t, arg1_uint8x8_t, 0);
 }
 
-/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vext\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c
--- ./gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vfp-shift-a2t2.c	2012-03-29 17:55:19.000000000 +1000
@@ -22,7 +22,7 @@
     return vshll_n_u32(a, 32);
 }
 
-/* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32_t = vget_lane_f32 (arg0_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16_t = vget_lane_p16 (arg0_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8_t = vget_lane_p8 (arg0_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16_t = vget_lane_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.s16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.s16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32_t = vget_lane_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8_t = vget_lane_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.s8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.s8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16_t = vget_lane_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32_t = vget_lane_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8_t = vget_lane_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vget_low_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vget_low_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vget_low_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lows16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lows16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vget_low_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lows32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lows32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vget_low_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lows8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lows8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vget_low_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vget_low_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vget_low_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vget_lowu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vget_low_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32_t = vgetq_lane_f32 (arg0_float32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16_t = vgetq_lane_p16 (arg0_poly16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8_t = vgetq_lane_p8 (arg0_poly8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16_t = vgetq_lane_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.s16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.s16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32_t = vgetq_lane_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64_t = vgetq_lane_s64 (arg0_int64x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8_t = vgetq_lane_s8 (arg0_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.s8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.s8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16_t = vgetq_lane_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u16\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32_t = vgetq_lane_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64_t = vgetq_lane_u64 (arg0_uint64x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[rR\]\[0-9\]+, \[rR\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c	2014-06-06 11:50:22.703598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8_t = vgetq_lane_u8 (arg0_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.u8\[ 	\]+\[rR\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vhaddq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vhaddq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vhaddq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vhaddq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vhaddq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vhaddq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhadds16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhadds16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhadds16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhadds16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vhadd_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhadds32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhadds32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhadds32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhadds32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vhadd_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhadds8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhadds8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhadds8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhadds8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vhadd_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vhadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vhadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhaddu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhaddu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhaddu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vhadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vhadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vhsubq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vhsubq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vhsubq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vhsubq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vhsubq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vhsubq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubs16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vhsub_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubs32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vhsub_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubs8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vhsub_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vhsub_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vhsub_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vhsubu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vhsubu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vhsubu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vhsub_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vhsub\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vhsub\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2_t = vld1_dup_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4_t = vld1_dup_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8_t = vld1_dup_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4_t = vld1_dup_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2_t = vld1_dup_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1_t = vld1_dup_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dups8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8_t = vld1_dup_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4_t = vld1_dup_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2_t = vld1_dup_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1_t = vld1_dup_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_dupu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8_t = vld1_dup_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\\\]\\\})|(\[dD\]\[0-9\]+\\\[\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1f32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2_t = vld1_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vld1_lane_f32 (0, arg1_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vld1_lane_p16 (0, arg1_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vld1_lane_p8 (0, arg1_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vld1_lane_s16 (0, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vld1_lane_s32 (0, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x1_t = vld1_lane_s64 (0, arg1_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vld1_lane_s8 (0, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vld1_lane_u16 (0, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vld1_lane_u32 (0, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vld1_lane_u64 (0, arg1_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vld1_lane_u8 (0, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1p16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4_t = vld1_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1p8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8_t = vld1_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x4_t = vld1q_dup_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x8_t = vld1q_dup_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x16_t = vld1q_dup_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x8_t = vld1q_dup_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x4_t = vld1q_dup_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x2_t = vld1q_dup_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dups8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x16_t = vld1q_dup_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x8_t = vld1q_dup_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x4_t = vld1q_dup_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x2_t = vld1q_dup_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_dupu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x16_t = vld1q_dup_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x4_t = vld1q_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vld1q_lane_f32 (0, arg1_float32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8_t = vld1q_lane_p16 (0, arg1_poly16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vld1q_lane_p8 (0, arg1_poly8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vld1q_lane_s16 (0, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vld1q_lane_s32 (0, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vld1q_lane_s64 (0, arg1_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vld1q_lane_s8 (0, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vld1q_lane_u16 (0, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vld1q_lane_u32 (0, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vld1q_lane_u64 (0, arg1_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Q_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vld1q_lane_u8 (0, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x8_t = vld1q_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x16_t = vld1q_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x8_t = vld1q_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c	2014-06-06 11:50:22.707598873 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x4_t = vld1q_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x2_t = vld1q_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x16_t = vld1q_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x8_t = vld1q_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x4_t = vld1q_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x2_t = vld1q_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x16_t = vld1q_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1s16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4_t = vld1_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1s32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2_t = vld1_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1s64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1_t = vld1_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1s8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8_t = vld1_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1u16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4_t = vld1_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1u32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2_t = vld1_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1u64.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1_t = vld1_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld1u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld1u8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld1u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8_t = vld1_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2x2_t = vld2_dup_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4x2_t = vld2_dup_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8x2_t = vld2_dup_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4x2_t = vld2_dup_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2x2_t = vld2_dup_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1x2_t = vld2_dup_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dups8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8x2_t = vld2_dup_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4x2_t = vld2_dup_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2x2_t = vld2_dup_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1x2_t = vld2_dup_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_dupu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8x2_t = vld2_dup_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2f32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2x2_t = vld2_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2x2_t = vld2_lane_f32 (0, arg1_float32x2x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4x2_t = vld2_lane_p16 (0, arg1_poly16x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8x2_t = vld2_lane_p8 (0, arg1_poly8x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4x2_t = vld2_lane_s16 (0, arg1_int16x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2x2_t = vld2_lane_s32 (0, arg1_int32x2x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8x2_t = vld2_lane_s8 (0, arg1_int8x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4x2_t = vld2_lane_u16 (0, arg1_uint16x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2x2_t = vld2_lane_u32 (0, arg1_uint32x2x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8x2_t = vld2_lane_u8 (0, arg1_uint8x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2p16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4x2_t = vld2_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2p8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8x2_t = vld2_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_float32x4x2_t = vld2q_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4x2_t = vld2q_lane_f32 (0, arg1_float32x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8x2_t = vld2q_lane_p16 (0, arg1_poly16x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8x2_t = vld2q_lane_s16 (0, arg1_int16x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4x2_t = vld2q_lane_s32 (0, arg1_int32x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8x2_t = vld2q_lane_u16 (0, arg1_uint16x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4x2_t = vld2q_lane_u32 (0, arg1_uint32x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_poly16x8x2_t = vld2q_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_poly8x16x2_t = vld2q_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int16x8x2_t = vld2q_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int32x4x2_t = vld2q_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int8x16x2_t = vld2q_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint16x8x2_t = vld2q_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint32x4x2_t = vld2q_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c	2014-06-06 11:50:22.711598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint8x16x2_t = vld2q_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2s16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4x2_t = vld2_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2s32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2x2_t = vld2_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2s64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1x2_t = vld2_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2s8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8x2_t = vld2_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2u16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4x2_t = vld2_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2u32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2x2_t = vld2_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2u64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1x2_t = vld2_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld2u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld2u8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld2u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8x2_t = vld2_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2x3_t = vld3_dup_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4x3_t = vld3_dup_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8x3_t = vld3_dup_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4x3_t = vld3_dup_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2x3_t = vld3_dup_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1x3_t = vld3_dup_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dups8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8x3_t = vld3_dup_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4x3_t = vld3_dup_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2x3_t = vld3_dup_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1x3_t = vld3_dup_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_dupu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8x3_t = vld3_dup_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3f32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2x3_t = vld3_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2x3_t = vld3_lane_f32 (0, arg1_float32x2x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4x3_t = vld3_lane_p16 (0, arg1_poly16x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8x3_t = vld3_lane_p8 (0, arg1_poly8x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4x3_t = vld3_lane_s16 (0, arg1_int16x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2x3_t = vld3_lane_s32 (0, arg1_int32x2x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8x3_t = vld3_lane_s8 (0, arg1_int8x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4x3_t = vld3_lane_u16 (0, arg1_uint16x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2x3_t = vld3_lane_u32 (0, arg1_uint32x2x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8x3_t = vld3_lane_u8 (0, arg1_uint8x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3p16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4x3_t = vld3_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3p8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8x3_t = vld3_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_float32x4x3_t = vld3q_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4x3_t = vld3q_lane_f32 (0, arg1_float32x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8x3_t = vld3q_lane_p16 (0, arg1_poly16x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8x3_t = vld3q_lane_s16 (0, arg1_int16x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4x3_t = vld3q_lane_s32 (0, arg1_int32x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8x3_t = vld3q_lane_u16 (0, arg1_uint16x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4x3_t = vld3q_lane_u32 (0, arg1_uint32x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_poly16x8x3_t = vld3q_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_poly8x16x3_t = vld3q_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int16x8x3_t = vld3q_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int32x4x3_t = vld3q_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int8x16x3_t = vld3q_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint16x8x3_t = vld3q_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint32x4x3_t = vld3q_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint8x16x3_t = vld3q_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3s16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4x3_t = vld3_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3s32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2x3_t = vld3_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3s64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1x3_t = vld3_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3s8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8x3_t = vld3_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3u16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4x3_t = vld3_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3u32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2x3_t = vld3_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3u64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1x3_t = vld3_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld3u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld3u8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld3u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8x3_t = vld3_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2x4_t = vld4_dup_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4x4_t = vld4_dup_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8x4_t = vld4_dup_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4x4_t = vld4_dup_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2x4_t = vld4_dup_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1x4_t = vld4_dup_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dups8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8x4_t = vld4_dup_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4x4_t = vld4_dup_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2x4_t = vld4_dup_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1x4_t = vld4_dup_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_dupu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8x4_t = vld4_dup_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\\\]-\[dD\]\[0-9\]+\\\[\\\])|(\[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\], \[dD\]\[0-9\]+\\\[\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4f32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_float32x2x4_t = vld4_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2x4_t = vld4_lane_f32 (0, arg1_float32x2x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4x4_t = vld4_lane_p16 (0, arg1_poly16x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8x4_t = vld4_lane_p8 (0, arg1_poly8x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4x4_t = vld4_lane_s16 (0, arg1_int16x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2x4_t = vld4_lane_s32 (0, arg1_int32x2x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8x4_t = vld4_lane_s8 (0, arg1_int8x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4x4_t = vld4_lane_u16 (0, arg1_uint16x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2x4_t = vld4_lane_u32 (0, arg1_uint32x2x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8x4_t = vld4_lane_u8 (0, arg1_uint8x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4p16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly16x4x4_t = vld4_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4p8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_poly8x8x4_t = vld4_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_float32x4x4_t = vld4q_f32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4x4_t = vld4q_lane_f32 (0, arg1_float32x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8x4_t = vld4q_lane_p16 (0, arg1_poly16x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8x4_t = vld4q_lane_s16 (0, arg1_int16x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4x4_t = vld4q_lane_s32 (0, arg1_int32x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8x4_t = vld4q_lane_u16 (0, arg1_uint16x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4x4_t = vld4q_lane_u32 (0, arg1_uint32x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_poly16x8x4_t = vld4q_p16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_poly8x16x4_t = vld4q_p8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int16x8x4_t = vld4q_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int32x4x4_t = vld4q_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_int8x16x4_t = vld4q_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint16x8x4_t = vld4q_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint32x4x4_t = vld4q_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c	2014-06-06 11:50:22.715598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,6 +15,6 @@
   out_uint8x16x4_t = vld4q_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4s16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int16x4x4_t = vld4_s16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4s32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int32x2x4_t = vld4_s32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4s64.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int64x1x4_t = vld4_s64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4s8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_int8x8x4_t = vld4_s8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4u16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint16x4x4_t = vld4_u16 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4u32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint32x2x4_t = vld4_u32 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4u64.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint64x1x4_t = vld4_u64 (0);
 }
 
-/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vld4u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vld4u8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vld4u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -15,5 +15,5 @@
   out_uint8x8x4_t = vld4_u8 (0);
 }
 
-/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vld4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vmax_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vmaxq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vmaxq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmaxq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vmaxq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vmaxq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmaxq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vmaxq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxs16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vmax_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxs32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vmax_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxs8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vmax_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vmax_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vmax_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmaxu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmaxu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmaxu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vmax_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmax\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmax\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vmin_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vminq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQs16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vminq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQs32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vminq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQs8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vminq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vminq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vminq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminQu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vminq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmins16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmins16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmins16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmins16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vmin_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmins32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmins32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmins32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmins32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vmin_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmins8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmins8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmins8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmins8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vmin_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vmin_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vmin_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vminu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vminu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vminu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vmin_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmin\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmin\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vmla_f32 (arg0_float32x2_t, arg1_float32x2_t, arg2_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vmla_lane_f32 (arg0_float32x2_t, arg1_float32x2_t, arg2_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vmla_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vmla_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vmla_lane_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vmla_lane_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlal_lane_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vmlal_lane_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlal_lane_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vmlal_lane_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlal_n_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vmlal_n_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlal_n_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlal_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vmlal_n_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlals16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlals16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlals16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlals16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlal_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlals32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlals32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlals32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlals32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vmlal_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlals8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlals8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlals8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlals8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlal_s8 (arg0_int16x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlalu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlalu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlalu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlal_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlalu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlalu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlalu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vmlal_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlalu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlalu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlalu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlal_u8 (arg0_uint16x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmlal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vmla_n_f32 (arg0_float32x2_t, arg1_float32x2_t, arg2_float32_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vmla_n_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vmla_n_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vmla_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmla_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vmla_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vmlaq_f32 (arg0_float32x4_t, arg1_float32x4_t, arg2_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vmlaq_lane_f32 (arg0_float32x4_t, arg1_float32x4_t, arg2_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlaq_lane_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlaq_lane_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlaq_lane_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlaq_lane_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vmlaq_n_f32 (arg0_float32x4_t, arg1_float32x4_t, arg2_float32_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlaq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlaq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlaq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlaq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlaq_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlaq_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x16_t = vmlaq_s8 (arg0_int8x16_t, arg1_int8x16_t, arg2_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlaq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlaq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlaQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x16_t = vmlaq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, arg2_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlas16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlas16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlas16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlas16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vmla_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlas32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlas32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlas32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlas32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vmla_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlas8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlas8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlas8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlas8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vmla_s8 (arg0_int8x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlau16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlau16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlau16.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlau16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vmla_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlau32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlau32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlau32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlau32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vmla_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlau8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlau8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlau8.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlau8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vmla_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmla\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vmls_f32 (arg0_float32x2_t, arg1_float32x2_t, arg2_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vmls_lane_f32 (arg0_float32x2_t, arg1_float32x2_t, arg2_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vmls_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vmls_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vmls_lane_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vmls_lane_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlsl_lane_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vmlsl_lane_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlsl_lane_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vmlsl_lane_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlsl_n_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vmlsl_n_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlsl_n_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsl_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vmlsl_n_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsls16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlsl_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsls32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vmlsl_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsls8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlsl_s8 (arg0_int16x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlslu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlslu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlslu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlsl_u16 (arg0_uint32x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlslu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlslu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlslu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint64x2_t = vmlsl_u32 (arg0_uint64x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlslu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlslu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlslu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlsl_u8 (arg0_uint16x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmlsl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmlsl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x2_t = vmls_n_f32 (arg0_float32x2_t, arg1_float32x2_t, arg2_float32_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vmls_n_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vmls_n_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vmls_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmls_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vmls_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vmlsq_f32 (arg0_float32x4_t, arg1_float32x4_t, arg2_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c	2014-06-06 11:50:22.719598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vmlsq_lane_f32 (arg0_float32x4_t, arg1_float32x4_t, arg2_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlsq_lane_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlsq_lane_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlsq_lane_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlsq_lane_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_float32x4_t = vmlsq_n_f32 (arg0_float32x4_t, arg1_float32x4_t, arg2_float32_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlsq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlsq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlsq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlsq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x8_t = vmlsq_s16 (arg0_int16x8_t, arg1_int16x8_t, arg2_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vmlsq_s32 (arg0_int32x4_t, arg1_int32x4_t, arg2_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x16_t = vmlsq_s8 (arg0_int8x16_t, arg1_int8x16_t, arg2_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x8_t = vmlsq_u16 (arg0_uint16x8_t, arg1_uint16x8_t, arg2_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x4_t = vmlsq_u32 (arg0_uint32x4_t, arg1_uint32x4_t, arg2_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x16_t = vmlsq_u8 (arg0_uint8x16_t, arg1_uint8x16_t, arg2_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlss16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlss16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlss16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlss16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int16x4_t = vmls_s16 (arg0_int16x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlss32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlss32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlss32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlss32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x2_t = vmls_s32 (arg0_int32x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlss8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlss8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlss8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlss8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vmls_s8 (arg0_int8x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint16x4_t = vmls_u16 (arg0_uint16x4_t, arg1_uint16x4_t, arg2_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint32x2_t = vmls_u32 (arg0_uint32x2_t, arg1_uint32x2_t, arg2_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmlsu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmlsu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmlsu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vmls_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmls\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovls16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vmovl_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmovl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovls32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vmovl_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmovl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovls8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vmovl_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmovl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovlu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vmovl_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmovl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovlu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vmovl_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmovl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovlu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vmovl_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmovl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vmov_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_np16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vmov_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_np8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vmov_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vmov_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vmovn_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmovn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vmov_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vmovn_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmovn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovns64.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vmovn_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vmovn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vmov_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vmov_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovnu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vmovn_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmovn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vmov_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovnu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vmovn_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmovn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovnu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovnu64.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovnu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vmovn_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vmovn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmovn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmov_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vmov_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[dD\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vmovq_n_f32 (arg0_float32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8_t = vmovq_n_p16 (arg0_poly16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vmovq_n_p8 (arg0_poly8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vmovq_n_s16 (arg0_int16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vmovq_n_s32 (arg0_int32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vmovq_n_s8 (arg0_int8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vmovq_n_u16 (arg0_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.16\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vmovq_n_u32 (arg0_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.32\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmovQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vmovq_n_u8 (arg0_uint8_t);
 }
 
-/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vdup\.8\[ 	\]+\[qQ\]\[0-9\]+, (\[rR\]\[0-9\]+|\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulf32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vmul_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vmul_lane_f32 (arg0_float32x2_t, arg1_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vmul_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vmul_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vmul_lane_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vmul_lane_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmull_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vmull_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmull_lane_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vmull_lane_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmull_n_s16 (arg0_int16x4_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vmull_n_s32 (arg0_int32x2_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmull_n_u16 (arg0_uint16x4_t, arg1_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmull_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vmull_n_u32 (arg0_uint32x2_t, arg1_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmullp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmullp8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8_t = vmull_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.p8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.p8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulls16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmull_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulls32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vmull_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulls8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vmull_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmullu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmullu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmull_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmullu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmullu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vmull_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmullu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmullu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmullu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vmull_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmull\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmull\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vmul_n_f32 (arg0_float32x2_t, arg1_float32_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vmul_n_s16 (arg0_int16x4_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vmul_n_s32 (arg0_int32x2_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vmul_n_u16 (arg0_uint16x4_t, arg1_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmul_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vmul_n_u32 (arg0_uint32x2_t, arg1_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulp8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vmul_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.p8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.p8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vmulq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vmulq_lane_f32 (arg0_float32x4_t, arg1_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vmulq_lane_s16 (arg0_int16x8_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmulq_lane_s32 (arg0_int32x4_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vmulq_lane_u16 (arg0_uint16x8_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmulq_lane_u32 (arg0_uint32x4_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_nf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vmulq_n_f32 (arg0_float32x4_t, arg1_float32_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vmulq_n_s16 (arg0_int16x8_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmulq_n_s32 (arg0_int32x4_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vmulq_n_u16 (arg0_uint16x8_t, arg1_uint16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmulq_n_u32 (arg0_uint32x4_t, arg1_uint32_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQp8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16_t = vmulq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.p8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.p8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQs16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vmulq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQs32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vmulq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQs8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vmulq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQu16.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vmulq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQu32.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vmulq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulQu8.c	2014-06-06 11:50:22.723598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vmulq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmuls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmuls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmuls16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmuls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vmul_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmuls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmuls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmuls32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmuls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vmul_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmuls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmuls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmuls8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmuls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vmul_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vmul_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vmul_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmulu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmulu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmulu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vmul_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmul\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnp8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vmvn_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vmvnq_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vmvnq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vmvnq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vmvnq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vmvnq_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vmvnq_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vmvnq_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvns16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vmvn_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvns32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vmvn_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvns8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vmvn_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vmvn_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vmvn_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vmvnu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vmvnu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vmvnu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vmvn_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmvn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegf32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vneg_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegQf32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vnegq_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegQs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vnegq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegQs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vnegq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegQs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vnegq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vneg_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vneg_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vnegs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vnegs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vnegs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vneg_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vneg\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vneg\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vornq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vornq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQs64.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vornq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vornq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vornq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vornq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQu64.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vornq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornQu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vornq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorns16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vorn_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorns32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vorn_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorns8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vorn_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vorn_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vorn_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vornu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vornu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vornu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vorn_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorn\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vorrq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vorrq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQs64.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vorrq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vorrq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vorrq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vorrq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQu64.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vorrq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrQu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vorrq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vorr_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vorr_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorrs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorrs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorrs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vorr_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorru16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorru16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorru16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorru16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vorr_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorru32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorru32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorru32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorru32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vorr_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vorru8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorru8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vorru8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vorru8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vorr_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vorr\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vpadalq_s16 (arg0_int32x4_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vpadalq_s32 (arg0_int64x2_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vpadalq_s8 (arg0_int16x8_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vpadalq_u16 (arg0_uint32x4_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vpadalq_u32 (arg0_uint64x2_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vpadalq_u8 (arg0_uint16x8_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadals16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadals16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadals16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadals16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vpadal_s16 (arg0_int32x2_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadals32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadals32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadals32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadals32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vpadal_s32 (arg0_int64x1_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadals8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadals8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadals8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadals8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vpadal_s8 (arg0_int16x4_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalu16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vpadal_u16 (arg0_uint32x2_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalu32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vpadal_u32 (arg0_uint64x1_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadalu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadalu8.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadalu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vpadal_u8 (arg0_uint16x4_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpadal\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadal\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddf32.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vpadd_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c	2014-06-06 11:50:22.727598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vpaddlq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vpaddlq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vpaddlq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vpaddlq_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vpaddlq_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vpaddlq_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddls16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vpaddl_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddls32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x1_t = vpaddl_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddls8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vpaddl_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vpaddl_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vpaddl_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vpaddl_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpaddl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpaddl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadds16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadds16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadds16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadds16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vpadd_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadds32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadds32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadds32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadds32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vpadd_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpadds8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadds8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpadds8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpadds8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vpadd_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vpadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vpadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpaddu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpaddu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpaddu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vpadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpadd\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vpmax_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vpmax_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vpmax_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vpmax_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vpmax_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vpmax_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmaxu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vpmax_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpmax\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmax\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpminf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpminf32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vpmin_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmins16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmins16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmins16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmins16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vpmin_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmins32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmins32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmins32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmins32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vpmin_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpmins8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmins8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpmins8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpmins8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vpmin_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpminu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpminu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vpmin_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpminu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpminu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vpmin_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vpminu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vpminu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vpminu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vpmin_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vpmin\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vpmin\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabsQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vqabsq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqabs\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqabs\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabsQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vqabsq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqabs\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqabs\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabsQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vqabsq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqabs\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqabs\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqabss16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabss16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqabss16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabss16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vqabs_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqabs\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqabs\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqabss32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabss32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqabss32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabss32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vqabs_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqabs\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqabs\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqabss8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabss8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqabss8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqabss8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vqabs_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqabs\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqabs\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqaddq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqaddq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqaddq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vqaddq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vqaddq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vqaddq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vqaddq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vqaddq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqadds16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqadds16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqadd_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqadds32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqadds32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqadd_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqadds64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqadds64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vqadd_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqadds8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqadds8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqadds8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vqadd_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vqadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vqadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddu64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vqadd_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqaddu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqaddu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqaddu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vqadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vqdmlal_lane_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vqdmlal_lane_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vqdmlal_n_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlal_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vqdmlal_n_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlals16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vqdmlal_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlal\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlals32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vqdmlal_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlal\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vqdmlsl_lane_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vqdmlsl_lane_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vqdmlsl_n_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsl_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vqdmlsl_n_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int32x4_t = vqdmlsl_s16 (arg0_int32x4_t, arg1_int16x4_t, arg2_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlsl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmlsls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int64x2_t = vqdmlsl_s32 (arg0_int64x2_t, arg1_int32x2_t, arg2_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmlsl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqdmulh_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqdmulh_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqdmulh_n_s16 (arg0_int16x4_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulh_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqdmulh_n_s32 (arg0_int32x2_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqdmulhq_lane_s16 (arg0_int16x8_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqdmulhq_lane_s32 (arg0_int32x4_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqdmulhq_n_s16 (arg0_int16x8_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqdmulhq_n_s32 (arg0_int32x4_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqdmulhq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqdmulhq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqdmulh_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulhs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqdmulh_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqdmull_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqdmull_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqdmull_n_s16 (arg0_int16x4_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmull_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqdmull_n_s32 (arg0_int32x2_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqdmull_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmull\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqdmulls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqdmull_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqdmull\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vqmovn_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqmovn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vqmovn_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqmovn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vqmovn_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqmovn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqmovn_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqmovn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqmovn_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqmovn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovnu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqmovn_u64 (arg0_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqmovn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovuns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqmovun_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqmovun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovuns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqmovun_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqmovun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqmovuns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqmovun_s64 (arg0_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqmovun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqmovun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vqnegq_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqneg\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqneg\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vqnegq_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqneg\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqneg\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vqnegq_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqneg\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqneg\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqnegs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqnegs16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vqneg_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqneg\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqneg\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqnegs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqnegs32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vqneg_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqneg\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqneg\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqnegs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqnegs8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqnegs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vqneg_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqneg\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqneg\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqrdmulh_lane_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqrdmulh_lane_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqrdmulh_n_s16 (arg0_int16x4_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulh_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqrdmulh_n_s32 (arg0_int32x2_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqrdmulhq_lane_s16 (arg0_int16x8_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqrdmulhq_lane_s32 (arg0_int32x4_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqrdmulhq_n_s16 (arg0_int16x8_t, arg1_int16_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqrdmulhq_n_s32 (arg0_int32x4_t, arg1_int32_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqrdmulhq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqrdmulhq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqrdmulh_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRdmulhs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqrdmulh_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrdmulh\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqrshlq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqrshlq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqrshlq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vqrshlq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vqrshlq_u16 (arg0_uint16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vqrshlq_u32 (arg0_uint32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vqrshlq_u64 (arg0_uint64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vqrshlq_u8 (arg0_uint8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshls16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqrshl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshls32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqrshl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshls64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshls64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vqrshl_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshls8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vqrshl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vqrshl_u16 (arg0_uint16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vqrshl_u32 (arg0_uint32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vqrshl_u64 (arg0_uint64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vqrshl_u8 (arg0_uint8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqrshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vqrshrn_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vqrshrn_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vqrshrn_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqrshrn_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqrshrn_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrn_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqrshrn_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqrshrun_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqrshrun_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c	2014-06-06 11:50:22.731598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqRshrun_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqrshrun_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqrshrun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqrshrun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vqshl_n_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vqshl_n_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x1_t = vqshl_n_s64 (arg0_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vqshl_n_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqshl_n_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqshl_n_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vqshl_n_u64 (arg0_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshl_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqshl_n_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vqshlq_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vqshlq_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vqshlq_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vqshlq_n_s8 (arg0_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vqshlq_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vqshlq_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vqshlq_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vqshlq_n_u8 (arg0_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqshlq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqshlq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqshlq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vqshlq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vqshlq_u16 (arg0_uint16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vqshlq_u32 (arg0_uint32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vqshlq_u64 (arg0_uint64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vqshlq_u8 (arg0_uint8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshls16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqshl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshls32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqshl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshls64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshls64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vqshl_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshls8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vqshl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vqshl_u16 (arg0_uint16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vqshl_u32 (arg0_uint32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vqshl_u64 (arg0_uint64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vqshl_u8 (arg0_uint8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqshlu_n_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqshlu_n_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vqshlu_n_s64 (arg0_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshlu_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqshlu_n_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vqshluq_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vqshluq_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vqshluq_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshluQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vqshluq_n_s8 (arg0_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshlu\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshlu\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vqshrn_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrn\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vqshrn_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrn\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vqshrn_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrn\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqshrn_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrn\.u16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqshrn_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrn\.u32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrn_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqshrn_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrn\.u64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vqshrun_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrun\.s16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vqshrun_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrun\.s32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqshrun_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vqshrun_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vqshrun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqshrun\.s64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vqsubq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vqsubq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vqsubq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vqsubq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vqsubq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vqsubq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vqsubq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vqsubq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubs16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vqsub_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubs32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vqsub_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubs64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vqsub_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubs8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vqsub_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubu16.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vqsub_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vqsub_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubu64.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vqsub_u64 (arg0_uint64x1_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vqsubu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vqsubu8.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vqsubu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vqsub_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vqsub\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vqsub\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vraddhn_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vraddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vraddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vraddhn_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vraddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vraddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vraddhn_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vraddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vraddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vraddhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vraddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vraddhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vraddhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vraddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vraddhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRaddhnu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vraddhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vraddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vraddhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrecpef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrecpef32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vrecpe_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrecpe\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrecpe\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpeQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vrecpeq_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrecpe\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrecpe\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpeQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vrecpeq_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrecpe\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrecpe\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpeu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vrecpe_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrecpe\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrecpe\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpsf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vrecps_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrecps\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrecps\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c	2014-06-06 11:50:22.735598874 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrecpsQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vrecpsq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrecps\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrecps\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev16p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev16p8.c	2014-06-06 11:50:22.743598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vrev16_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c	2014-06-06 11:50:22.743598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vrev16q_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c	2014-06-06 11:50:22.743598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vrev16q_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c	2014-06-06 11:50:22.743598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vrev16q_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev16s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev16s8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vrev16_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev16u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev16u8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev16u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vrev16_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev16\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32p16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vrev32_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32p8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vrev32_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8_t = vrev32q_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vrev32q_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vrev32q_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vrev32q_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vrev32q_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vrev32q_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32s16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vrev32_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32s8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vrev32_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32u16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vrev32_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev32u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev32u8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev32u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vrev32_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev32\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64f32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vrev64_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64p16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x4_t = vrev64_p16 (arg0_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64p8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x8_t = vrev64_p8 (arg0_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vrev64q_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly16x8_t = vrev64q_p16 (arg0_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_poly8x16_t = vrev64q_p8 (arg0_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vrev64q_s16 (arg0_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vrev64q_s32 (arg0_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vrev64q_s8 (arg0_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vrev64q_u16 (arg0_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vrev64q_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vrev64q_u8 (arg0_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64s16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vrev64_s16 (arg0_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64s32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vrev64_s32 (arg0_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64s8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vrev64_s8 (arg0_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64u16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vrev64_u16 (arg0_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64u32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vrev64_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrev64u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrev64u8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrev64u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vrev64_u8 (arg0_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrev64\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vrhaddq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vrhaddq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vrhaddq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vrhaddq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vrhaddq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vrhaddq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhadds16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhadds16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhadds16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vrhadd_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhadds32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhadds32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhadds32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vrhadd_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhadds8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhadds8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhadds8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vrhadd_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vrhadd_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vrhadd_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRhaddu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vrhadd_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrhadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrhadd\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vrshlq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vrshlq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vrshlq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vrshlq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vrshlq_u16 (arg0_uint16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vrshlq_u32 (arg0_uint32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vrshlq_u64 (arg0_uint64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vrshlq_u8 (arg0_uint8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshls16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vrshl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshls32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vrshl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshls64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshls64.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vrshl_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshls8.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vrshl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlu16.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vrshl_u16 (arg0_uint16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlu32.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vrshl_u32 (arg0_uint32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlu64.c	2014-06-06 11:50:22.675598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vrshl_u64 (arg0_uint64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshlu8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vrshl_u8 (arg0_uint8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vrshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vrshrn_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vrshrn_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vrshrn_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vrshrn_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vrshrn_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrn_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vrshrn_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vrshr_n_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vrshr_n_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x1_t = vrshr_n_s64 (arg0_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vrshr_n_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vrshr_n_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vrshr_n_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vrshr_n_u64 (arg0_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshr_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vrshr_n_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vrshrq_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vrshrq_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vrshrq_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vrshrq_n_s8 (arg0_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vrshrq_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vrshrq_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vrshrq_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRshrQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vrshrq_n_u8 (arg0_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrshr\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrshr\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrtef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x2_t = vrsqrte_f32 (arg0_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrsqrte\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsqrte\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrteQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_float32x4_t = vrsqrteq_f32 (arg0_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrsqrte\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsqrte\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrteQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vrsqrteq_u32 (arg0_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrsqrte\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsqrte\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrteu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vrsqrte_u32 (arg0_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrsqrte\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsqrte\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrtsf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vrsqrts_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vrsqrts\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsqrts\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vrsqrtsQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vrsqrtsq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrsqrts\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsqrts\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vrsra_n_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vrsra_n_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vrsra_n_s64 (arg0_int64x1_t, arg1_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vrsra_n_s8 (arg0_int8x8_t, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vrsra_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vrsra_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vrsra_n_u64 (arg0_uint64x1_t, arg1_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsra_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vrsra_n_u8 (arg0_uint8x8_t, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vrsraq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vrsraq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vrsraq_n_s64 (arg0_int64x2_t, arg1_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vrsraq_n_s8 (arg0_int8x16_t, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vrsraq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vrsraq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vrsraq_n_u64 (arg0_uint64x2_t, arg1_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsraQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vrsraq_n_u8 (arg0_uint8x16_t, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vrsra\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsra\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vrsubhn_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vrsubhn_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vrsubhn_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vrsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vrsubhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vrsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vrsubhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vrsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c	2014-06-06 11:50:22.679598872 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vRsubhnu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vrsubhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vrsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vrsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vset_lane_f32 (arg0_float32_t, arg1_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4_t = vset_lane_p16 (arg0_poly16_t, arg1_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vset_lane_p8 (arg0_poly8_t, arg1_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vset_lane_s16 (arg0_int16_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vset_lane_s32 (arg0_int32_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vset_lane_s8 (arg0_int8_t, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vset_lane_u16 (arg0_uint16_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vset_lane_u32 (arg0_uint32_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vset_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vset_lane_u8 (arg0_uint8_t, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vsetq_lane_f32 (arg0_float32_t, arg1_float32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8_t = vsetq_lane_p16 (arg0_poly16_t, arg1_poly16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16_t = vsetq_lane_p8 (arg0_poly8_t, arg1_poly8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsetq_lane_s16 (arg0_int16_t, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsetq_lane_s32 (arg0_int32_t, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsetq_lane_s64 (arg0_int64_t, arg1_int64x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vsetq_lane_s8 (arg0_int8_t, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsetq_lane_u16 (arg0_uint16_t, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.16\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsetq_lane_u32 (arg0_uint32_t, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.32\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsetq_lane_u64 (arg0_uint64_t, arg1_uint64x2_t, 0);
 }
 
-/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\[ 	\]+\[dD\]\[0-9\]+, \[rR\]\[0-9\]+, \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsetQ_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vsetq_lane_u8 (arg0_uint8_t, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vmov\.8\[ 	\]+\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[rR\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vshll_n_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshll\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vshll_n_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshll\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vshll_n_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshll\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vshll_n_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vshll_n_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshll_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vshll_n_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshll\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vshl_n_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vshl_n_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x1_t = vshl_n_s64 (arg0_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vshl_n_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vshl_n_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vshl_n_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vshl_n_u64 (arg0_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshl_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vshl_n_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vshlq_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vshlq_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vshlq_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vshlq_n_s8 (arg0_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vshlq_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vshlq_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vshlq_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vshlq_n_u8 (arg0_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQs16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vshlq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQs32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vshlq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQs64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vshlq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQs8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vshlq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vshlq_u16 (arg0_uint16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vshlq_u32 (arg0_uint32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQu64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vshlq_u64 (arg0_uint64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlQu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vshlq_u8 (arg0_uint8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshls16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vshl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshls32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vshl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshls64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshls64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vshl_s64 (arg0_int64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshls8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vshl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlu16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vshl_u16 (arg0_uint16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlu32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vshl_u32 (arg0_uint32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlu64.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vshl_u64 (arg0_uint64x1_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshlu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshlu8.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshlu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vshl_u8 (arg0_uint8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshl\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vshrn_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vshrn_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vshrn_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vshrn_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshrn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vshrn_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshrn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrn_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vshrn_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshrn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x4_t = vshr_n_s16 (arg0_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x2_t = vshr_n_s32 (arg0_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x1_t = vshr_n_s64 (arg0_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x8_t = vshr_n_s8 (arg0_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x4_t = vshr_n_u16 (arg0_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x2_t = vshr_n_u32 (arg0_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x1_t = vshr_n_u64 (arg0_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshr_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x8_t = vshr_n_u8 (arg0_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int16x8_t = vshrq_n_s16 (arg0_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c	2014-06-06 11:50:22.747598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int32x4_t = vshrq_n_s32 (arg0_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int64x2_t = vshrq_n_s64 (arg0_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_int8x16_t = vshrq_n_s8 (arg0_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint16x8_t = vshrq_n_u16 (arg0_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint32x4_t = vshrq_n_u32 (arg0_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint64x2_t = vshrq_n_u64 (arg0_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vshrQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   out_uint8x16_t = vshrq_n_u8 (arg0_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vshr\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vshr\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_np16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4_t = vsli_n_p16 (arg0_poly16x4_t, arg1_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_np8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vsli_n_p8 (arg0_poly8x8_t, arg1_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vsli_n_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vsli_n_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vsli_n_s64 (arg0_int64x1_t, arg1_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vsli_n_s8 (arg0_int8x8_t, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vsli_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vsli_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vsli_n_u64 (arg0_uint64x1_t, arg1_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsli_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vsli_n_u8 (arg0_uint8x8_t, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8_t = vsliq_n_p16 (arg0_poly16x8_t, arg1_poly16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16_t = vsliq_n_p8 (arg0_poly8x16_t, arg1_poly8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsliq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsliq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsliq_n_s64 (arg0_int64x2_t, arg1_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vsliq_n_s8 (arg0_int8x16_t, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsliq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsliq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsliq_n_u64 (arg0_uint64x2_t, arg1_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsliQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vsliq_n_u8 (arg0_uint8x16_t, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsli\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vsra_n_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vsra_n_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vsra_n_s64 (arg0_int64x1_t, arg1_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vsra_n_s8 (arg0_int8x8_t, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vsra_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vsra_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vsra_n_u64 (arg0_uint64x1_t, arg1_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsra_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vsra_n_u8 (arg0_uint8x8_t, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsraq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsraq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsraq_n_s64 (arg0_int64x2_t, arg1_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vsraq_n_s8 (arg0_int8x16_t, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsraq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsraq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsraq_n_u64 (arg0_uint64x2_t, arg1_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsraQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vsraq_n_u8 (arg0_uint8x16_t, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsra\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsra\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_np16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4_t = vsri_n_p16 (arg0_poly16x4_t, arg1_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_np8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vsri_n_p8 (arg0_poly8x8_t, arg1_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vsri_n_s16 (arg0_int16x4_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vsri_n_s32 (arg0_int32x2_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x1_t = vsri_n_s64 (arg0_int64x1_t, arg1_int64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vsri_n_s8 (arg0_int8x8_t, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vsri_n_u16 (arg0_uint16x4_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vsri_n_u32 (arg0_uint32x2_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x1_t = vsri_n_u64 (arg0_uint64x1_t, arg1_uint64x1_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsri_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vsri_n_u8 (arg0_uint8x8_t, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_np16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8_t = vsriq_n_p16 (arg0_poly16x8_t, arg1_poly16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_np8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16_t = vsriq_n_p8 (arg0_poly8x16_t, arg1_poly8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsriq_n_s16 (arg0_int16x8_t, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsriq_n_s32 (arg0_int32x4_t, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsriq_n_s64 (arg0_int64x2_t, arg1_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_ns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vsriq_n_s8 (arg0_int8x16_t, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsriq_n_u16 (arg0_uint16x8_t, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsriq_n_u32 (arg0_uint32x4_t, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsriq_n_u64 (arg0_uint64x2_t, arg1_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsriQ_nu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vsriq_n_u8 (arg0_uint8x16_t, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsri\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, #\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1f32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_f32 (arg0_float32_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_f32 (arg0_float32_t, arg1_float32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_p16 (arg0_poly16_t, arg1_poly16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_p8 (arg0_poly8_t, arg1_poly8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_s16 (arg0_int16_t, arg1_int16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_s32 (arg0_int32_t, arg1_int32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_s64 (arg0_int64_t, arg1_int64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_s8 (arg0_int8_t, arg1_int8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_u16 (arg0_uint16_t, arg1_uint16x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_u32 (arg0_uint32_t, arg1_uint32x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_u64 (arg0_uint64_t, arg1_uint64x1_t, 0);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_lane_u8 (arg0_uint8_t, arg1_uint8x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1p16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_p16 (arg0_poly16_t, arg1_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1p8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_p8 (arg0_poly8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_f32 (arg0_float32_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_f32 (arg0_float32_t, arg1_float32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_p16 (arg0_poly16_t, arg1_poly16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_p8 (arg0_poly8_t, arg1_poly8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_s16 (arg0_int16_t, arg1_int16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_s32 (arg0_int32_t, arg1_int32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_s64 (arg0_int64_t, arg1_int64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_s8 (arg0_int8_t, arg1_int8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_u16 (arg0_uint16_t, arg1_uint16x8_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_u32 (arg0_uint32_t, arg1_uint32x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_u64 (arg0_uint64_t, arg1_uint64x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Q_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_lane_u8 (arg0_uint8_t, arg1_uint8x16_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]\\\})|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_p16 (arg0_poly16_t, arg1_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_p8 (arg0_poly8_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_s16 (arg0_int16_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_s32 (arg0_int32_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_s64 (arg0_int64_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_s8 (arg0_int8_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_u16 (arg0_uint16_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_u32 (arg0_uint32_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_u64 (arg0_uint64_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c	2014-06-06 11:50:22.751598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1q_u8 (arg0_uint8_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1s16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_s16 (arg0_int16_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1s32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_s32 (arg0_int32_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1s64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_s64 (arg0_int64_t, arg1_int64x1_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1s8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_s8 (arg0_int8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1u16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_u16 (arg0_uint16_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.16\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1u32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_u32 (arg0_uint32_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.32\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1u64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_u64 (arg0_uint64_t, arg1_uint64x1_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst1u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst1u8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst1u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst1_u8 (arg0_uint8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.8\[ 	\]+((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2f32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_f32 (arg0_float32_t, arg1_float32x2x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_f32 (arg0_float32_t, arg1_float32x2x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_p16 (arg0_poly16_t, arg1_poly16x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_p8 (arg0_poly8_t, arg1_poly8x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_s16 (arg0_int16_t, arg1_int16x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_s32 (arg0_int32_t, arg1_int32x2x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_s8 (arg0_int8_t, arg1_int8x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_u16 (arg0_uint16_t, arg1_uint16x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_u32 (arg0_uint32_t, arg1_uint32x2x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_lane_u8 (arg0_uint8_t, arg1_uint8x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2p16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_p16 (arg0_poly16_t, arg1_poly16x4x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2p8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_p8 (arg0_poly8_t, arg1_poly8x8x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_f32 (arg0_float32_t, arg1_float32x4x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2q_lane_f32 (arg0_float32_t, arg1_float32x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2q_lane_p16 (arg0_poly16_t, arg1_poly16x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2q_lane_s16 (arg0_int16_t, arg1_int16x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2q_lane_s32 (arg0_int32_t, arg1_int32x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2q_lane_u16 (arg0_uint16_t, arg1_uint16x8x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2q_lane_u32 (arg0_uint32_t, arg1_uint32x4x2_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_p16 (arg0_poly16_t, arg1_poly16x8x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_p8 (arg0_poly8_t, arg1_poly8x16x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_s16 (arg0_int16_t, arg1_int16x8x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_s32 (arg0_int32_t, arg1_int32x4x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_s8 (arg0_int8_t, arg1_int8x16x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_u16 (arg0_uint16_t, arg1_uint16x8x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_u32 (arg0_uint32_t, arg1_uint32x4x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst2q_u8 (arg0_uint8_t, arg1_uint8x16x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2s16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_s16 (arg0_int16_t, arg1_int16x4x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2s32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_s32 (arg0_int32_t, arg1_int32x2x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2s64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_s64 (arg0_int64_t, arg1_int64x1x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2s8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_s8 (arg0_int8_t, arg1_int8x8x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2u16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_u16 (arg0_uint16_t, arg1_uint16x4x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2u32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_u32 (arg0_uint32_t, arg1_uint32x2x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2u64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_u64 (arg0_uint64_t, arg1_uint64x1x2_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst2u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst2u8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst2u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst2_u8 (arg0_uint8_t, arg1_uint8x8x2_t);
 }
 
-/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst2\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3f32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_f32 (arg0_float32_t, arg1_float32x2x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_f32 (arg0_float32_t, arg1_float32x2x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_p16 (arg0_poly16_t, arg1_poly16x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_p8 (arg0_poly8_t, arg1_poly8x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_s16 (arg0_int16_t, arg1_int16x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_s32 (arg0_int32_t, arg1_int32x2x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_s8 (arg0_int8_t, arg1_int8x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_u16 (arg0_uint16_t, arg1_uint16x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_u32 (arg0_uint32_t, arg1_uint32x2x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_lane_u8 (arg0_uint8_t, arg1_uint8x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3p16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_p16 (arg0_poly16_t, arg1_poly16x4x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3p8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_p8 (arg0_poly8_t, arg1_poly8x8x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_f32 (arg0_float32_t, arg1_float32x4x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3q_lane_f32 (arg0_float32_t, arg1_float32x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3q_lane_p16 (arg0_poly16_t, arg1_poly16x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3q_lane_s16 (arg0_int16_t, arg1_int16x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3q_lane_s32 (arg0_int32_t, arg1_int32x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3q_lane_u16 (arg0_uint16_t, arg1_uint16x8x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3q_lane_u32 (arg0_uint32_t, arg1_uint32x4x3_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_p16 (arg0_poly16_t, arg1_poly16x8x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_p8 (arg0_poly8_t, arg1_poly8x16x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_s16 (arg0_int16_t, arg1_int16x8x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_s32 (arg0_int32_t, arg1_int32x4x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_s8 (arg0_int8_t, arg1_int8x16x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_u16 (arg0_uint16_t, arg1_uint16x8x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_u32 (arg0_uint32_t, arg1_uint32x4x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst3q_u8 (arg0_uint8_t, arg1_uint8x16x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3s16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_s16 (arg0_int16_t, arg1_int16x4x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3s32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_s32 (arg0_int32_t, arg1_int32x2x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3s64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_s64 (arg0_int64_t, arg1_int64x1x3_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3s8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_s8 (arg0_int8_t, arg1_int8x8x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3u16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_u16 (arg0_uint16_t, arg1_uint16x4x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3u32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_u32 (arg0_uint32_t, arg1_uint32x2x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3u64.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_u64 (arg0_uint64_t, arg1_uint64x1x3_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst3u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst3u8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst3u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst3_u8 (arg0_uint8_t, arg1_uint8x8x3_t);
 }
 
-/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst3\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4f32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4f32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4f32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4f32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_f32 (arg0_float32_t, arg1_float32x2x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_f32 (arg0_float32_t, arg1_float32x2x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_p16 (arg0_poly16_t, arg1_poly16x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanep8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_p8 (arg0_poly8_t, arg1_poly8x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_s16 (arg0_int16_t, arg1_int16x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_s32 (arg0_int32_t, arg1_int32x2x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_lanes8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_s8 (arg0_int8_t, arg1_int8x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_u16 (arg0_uint16_t, arg1_uint16x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_u32 (arg0_uint32_t, arg1_uint32x2x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4_laneu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_lane_u8 (arg0_uint8_t, arg1_uint8x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4p16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4p16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4p16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4p16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_p16 (arg0_poly16_t, arg1_poly16x4x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4p8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_p8 (arg0_poly8_t, arg1_poly8x8x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_f32 (arg0_float32_t, arg1_float32x4x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanef32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4q_lane_f32 (arg0_float32_t, arg1_float32x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanep16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4q_lane_p16 (arg0_poly16_t, arg1_poly16x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4q_lane_s16 (arg0_int16_t, arg1_int16x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_lanes32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4q_lane_s32 (arg0_int32_t, arg1_int32x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4q_lane_u16 (arg0_uint16_t, arg1_uint16x8x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Q_laneu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4q_lane_u32 (arg0_uint32_t, arg1_uint32x4x4_t, 1);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+\\\[\[0-9\]+\\\]-\[dD\]\[0-9\]+\\\[\[0-9\]+\\\])|(\[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\], \[dD\]\[0-9\]+\\\[\[0-9\]+\\\]))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_p16 (arg0_poly16_t, arg1_poly16x8x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_p8 (arg0_poly8_t, arg1_poly8x16x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_s16 (arg0_int16_t, arg1_int16x8x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_s32 (arg0_int32_t, arg1_int32x4x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_s8 (arg0_int8_t, arg1_int8x16x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_u16 (arg0_uint16_t, arg1_uint16x8x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_u32 (arg0_uint32_t, arg1_uint32x4x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4Qu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,6 +16,6 @@
   vst4q_u8 (arg0_uint8_t, arg1_uint8x16x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4s16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4s16.c	2014-06-06 11:50:22.755598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_s16 (arg0_int16_t, arg1_int16x4x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4s32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4s32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_s32 (arg0_int32_t, arg1_int32x2x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4s64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4s64.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_s64 (arg0_int64_t, arg1_int64x1x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_s8 (arg0_int8_t, arg1_int8x8x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4u16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4u16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u16.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_u16 (arg0_uint16_t, arg1_uint16x4x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.16\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4u32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4u32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u32.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_u32 (arg0_uint32_t, arg1_uint32x2x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.32\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4u64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4u64.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u64.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_u64 (arg0_uint64_t, arg1_uint64x1x4_t);
 }
 
-/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst1\.64\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vst4u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vst4u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vst4u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -16,5 +16,5 @@
   vst4_u8 (arg0_uint8_t, arg1_uint8x8x4_t);
 }
 
-/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vst4\.8\[ 	\]+\\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \\\[\[rR\]\[0-9\]+\\\]!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubf32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2_t = vsub_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.f32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubhns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubhns16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vsubhn_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubhns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubhns32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vsubhn_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubhns64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubhns64.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhns64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vsubhn_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vsubhn_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubhn\.i16\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vsubhn_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubhn\.i32\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubhnu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vsubhn_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubhn\.i64\[ 	\]+\[dD\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubls16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubls16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubls16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubls16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsubl_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vsubl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubl\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubls32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubls32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubls32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubls32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsubl_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsubl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubl\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubls8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubls8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubls8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubls8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsubl_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vsubl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubl\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsublu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsublu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsublu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsublu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsubl_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vsubl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubl\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsublu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsublu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsublu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsublu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsubl_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsubl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubl\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsublu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsublu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsublu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsublu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsubl_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vsubl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubl\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQf32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4_t = vsubq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.f32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQs16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsubq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQs32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsubq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQs64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQs64.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsubq_s64 (arg0_int64x2_t, arg1_int64x2_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQs8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16_t = vsubq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsubq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsubq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQu64.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQu64.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu64.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsubq_u64 (arg0_uint64x2_t, arg1_uint64x2_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i64\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubQu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vsubq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubs16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4_t = vsub_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubs32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2_t = vsub_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubs8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vsub_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vsub_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vsub_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vsub_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsub\.i8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubws16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubws16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubws16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubws16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4_t = vsubw_s16 (arg0_int32x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vsubw\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubw\.s16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubws32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubws32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubws32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubws32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int64x2_t = vsubw_s32 (arg0_int64x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsubw\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubw\.s32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubws8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubws8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubws8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubws8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8_t = vsubw_s8 (arg0_int16x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vsubw\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubw\.s8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubwu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubwu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubwu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vsubw_u16 (arg0_uint32x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vsubw\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubw\.u16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubwu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubwu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubwu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint64x2_t = vsubw_u32 (arg0_uint64x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vsubw\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubw\.u32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vsubwu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vsubwu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vsubwu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vsubw_u8 (arg0_uint16x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vsubw\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vsubw\.u8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl1p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vtbl1_p8 (arg0_poly8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl1s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vtbl1_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl1u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtbl1_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl2p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vtbl2_p8 (arg0_poly8x8x2_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl2s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vtbl2_s8 (arg0_int8x8x2_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl2u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtbl2_u8 (arg0_uint8x8x2_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl3p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vtbl3_p8 (arg0_poly8x8x3_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl3s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vtbl3_s8 (arg0_int8x8x3_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl3u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtbl3_u8 (arg0_uint8x8x3_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl4p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8_t = vtbl4_p8 (arg0_poly8x8x4_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl4s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8_t = vtbl4_s8 (arg0_int8x8x4_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbl4u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtbl4_u8 (arg0_uint8x8x4_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbl\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx1p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly8x8_t = vtbx1_p8 (arg0_poly8x8_t, arg1_poly8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx1s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vtbx1_s8 (arg0_int8x8_t, arg1_int8x8_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx1u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vtbx1_u8 (arg0_uint8x8_t, arg1_uint8x8_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, ((\\\{\[dD\]\[0-9\]+\\\})|(\[dD\]\[0-9\]+)), \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx2p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly8x8_t = vtbx2_p8 (arg0_poly8x8_t, arg1_poly8x8x2_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx2s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vtbx2_s8 (arg0_int8x8_t, arg1_int8x8x2_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx2u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vtbx2_u8 (arg0_uint8x8_t, arg1_uint8x8x2_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx3p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly8x8_t = vtbx3_p8 (arg0_poly8x8_t, arg1_poly8x8x3_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx3s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vtbx3_s8 (arg0_int8x8_t, arg1_int8x8x3_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx3u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vtbx3_u8 (arg0_uint8x8_t, arg1_uint8x8x3_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx4p8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_poly8x8_t = vtbx4_p8 (arg0_poly8x8_t, arg1_poly8x8x4_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx4s8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_int8x8_t = vtbx4_s8 (arg0_int8x8_t, arg1_int8x8x4_t, arg2_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtbx4u8.c	2012-03-29 17:55:19.000000000 +1000
@@ -18,5 +18,5 @@
   out_uint8x8_t = vtbx4_u8 (arg0_uint8x8_t, arg1_uint8x8x4_t, arg2_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtbx\.8\[ 	\]+\[dD\]\[0-9\]+, \\\{((\[dD\]\[0-9\]+-\[dD\]\[0-9\]+)|(\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+))\\\}, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnf32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2x2_t = vtrn_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnp16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4x2_t = vtrn_p16 (arg0_poly16x4_t, arg1_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnp8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8x2_t = vtrn_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4x2_t = vtrnq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8x2_t = vtrnq_p16 (arg0_poly16x8_t, arg1_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16x2_t = vtrnq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8x2_t = vtrnq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4x2_t = vtrnq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16x2_t = vtrnq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8x2_t = vtrnq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4x2_t = vtrnq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16x2_t = vtrnq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrns16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrns16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrns16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrns16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4x2_t = vtrn_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrns32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrns32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrns32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrns32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2x2_t = vtrn_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrns8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrns8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrns8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrns8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8x2_t = vtrn_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4x2_t = vtrn_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2x2_t = vtrn_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtrnu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtrnu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtrnu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8x2_t = vtrn_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtrn\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstp8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtst_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQp8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vtstq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQs16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vtstq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQs32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vtstq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQs8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vtstq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQu16.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8_t = vtstq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQu32.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4_t = vtstq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstQu8.c	2014-06-06 11:50:22.759598875 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16_t = vtstq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtsts16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtsts16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtsts16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtsts16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vtst_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtsts32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtsts32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtsts32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtsts32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vtst_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtsts8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtsts8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtsts8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtsts8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtst_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstu16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4_t = vtst_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstu32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2_t = vtst_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vtstu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vtstu8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vtstu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8_t = vtst_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vtst\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpf32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2x2_t = vuzp_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpp16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4x2_t = vuzp_p16 (arg0_poly16x4_t, arg1_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpp8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8x2_t = vuzp_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4x2_t = vuzpq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8x2_t = vuzpq_p16 (arg0_poly16x8_t, arg1_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16x2_t = vuzpq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8x2_t = vuzpq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4x2_t = vuzpq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16x2_t = vuzpq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8x2_t = vuzpq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4x2_t = vuzpq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16x2_t = vuzpq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzps16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzps16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzps16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzps16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4x2_t = vuzp_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzps32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzps32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzps32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzps32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2x2_t = vuzp_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzps8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzps8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzps8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzps8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8x2_t = vuzp_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpu16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4x2_t = vuzp_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpu32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2x2_t = vuzp_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vuzpu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vuzpu8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vuzpu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8x2_t = vuzp_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vuzp\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipf32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x2x2_t = vzip_f32 (arg0_float32x2_t, arg1_float32x2_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipp16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x4x2_t = vzip_p16 (arg0_poly16x4_t, arg1_poly16x4_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipp8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x8x2_t = vzip_p8 (arg0_poly8x8_t, arg1_poly8x8_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQf32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQf32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQf32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_float32x4x2_t = vzipq_f32 (arg0_float32x4_t, arg1_float32x4_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQp16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQp16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQp16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly16x8x2_t = vzipq_p16 (arg0_poly16x8_t, arg1_poly16x8_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQp8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQp8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQp8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_poly8x16x2_t = vzipq_p8 (arg0_poly8x16_t, arg1_poly8x16_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQs16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQs16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQs16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x8x2_t = vzipq_s16 (arg0_int16x8_t, arg1_int16x8_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQs32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQs32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQs32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x4x2_t = vzipq_s32 (arg0_int32x4_t, arg1_int32x4_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQs8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQs8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQs8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x16x2_t = vzipq_s8 (arg0_int8x16_t, arg1_int8x16_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQu16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x8x2_t = vzipq_u16 (arg0_uint16x8_t, arg1_uint16x8_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQu32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x4x2_t = vzipq_u32 (arg0_uint32x4_t, arg1_uint32x4_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipQu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipQu8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipQu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x16x2_t = vzipq_u8 (arg0_uint8x16_t, arg1_uint8x16_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[qQ\]\[0-9\]+, \[qQ\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzips16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzips16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzips16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzips16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int16x4x2_t = vzip_s16 (arg0_int16x4_t, arg1_int16x4_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzips32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzips32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzips32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzips32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int32x2x2_t = vzip_s32 (arg0_int32x2_t, arg1_int32x2_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzips8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzips8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzips8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzips8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_int8x8x2_t = vzip_s8 (arg0_int8x8_t, arg1_int8x8_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipu16.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipu16.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipu16.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipu16.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint16x4x2_t = vzip_u16 (arg0_uint16x4_t, arg1_uint16x4_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.16\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipu32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipu32.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipu32.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipu32.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint32x2x2_t = vzip_u32 (arg0_uint32x2_t, arg1_uint32x2_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.32\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
diff -ru ./gcc/testsuite/gcc.target/arm/neon/vzipu8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipu8.c
--- ./gcc/testsuite/gcc.target/arm/neon/vzipu8.c	2014-06-06 11:50:22.763598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon/vzipu8.c	2012-03-29 17:55:19.000000000 +1000
@@ -17,5 +17,5 @@
   out_uint8x8x2_t = vzip_u8 (arg0_uint8x8_t, arg1_uint8x8_t);
 }
 
-/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@\[a-zA-Z0-9 \]+\)?\n" } } */
+/* { dg-final { scan-assembler "vzip\.8\[ 	\]+\[dD\]\[0-9\]+, \[dD\]\[0-9\]+!?\(\[ 	\]+@.*\)?\n" } } */
 /* { dg-final { cleanup-saved-temps } } */
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-load-df0.c
diff -ru ./gcc/testsuite/gcc.target/arm/neon-thumb2-move.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon-thumb2-move.c
--- ./gcc/testsuite/gcc.target/arm/neon-thumb2-move.c	2014-06-06 11:50:22.591598869 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/neon-thumb2-move.c	2012-03-29 17:55:22.000000000 +1000
@@ -3,6 +3,7 @@
 /* { dg-require-effective-target arm_thumb2_ok } */
 /* { dg-options "-O2 -mthumb -march=armv7-a" } */
 /* { dg-add-options arm_neon } */
+/* { dg-prune-output "switch .* conflicts with" } */
 
 #include <arm_neon.h>
 #include <stddef.h>
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-10.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-11.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-12.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-13.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-14.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-15.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-16.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-17.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-18.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-19.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-1.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-3.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-4.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-5.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-6.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-7.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-8.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: neon-vdup-9.c
diff -ru ./gcc/testsuite/gcc.target/arm/pr43698.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/pr43698.c
--- ./gcc/testsuite/gcc.target/arm/pr43698.c	2014-06-06 11:50:22.771598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/pr43698.c	2012-03-29 17:55:22.000000000 +1000
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-Os -march=armv7-a" } */
+/* { dg-options "-Os" } */
 #include <stdint.h>
 #include <stdlib.h>
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: pr44557.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: pr46934.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: pr48183.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: pr50099.c
diff -ru ./gcc/testsuite/gcc.target/arm/sync-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/sync-1.c
--- ./gcc/testsuite/gcc.target/arm/sync-1.c	2014-06-06 11:50:22.771598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/sync-1.c	2012-03-29 17:55:22.000000000 +1000
@@ -1,5 +1,5 @@
-/* { dg-do run } */
-/* { dg-options "-O2 -march=armv7-a" } */
+/* { dg-do run { target sync_int_long } } */
+/* { dg-options "-O2" } */
 
 volatile int mem;
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: tlscall.c
diff -ru ./gcc/testsuite/gcc.target/arm/vfp-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/vfp-1.c
--- ./gcc/testsuite/gcc.target/arm/vfp-1.c	2014-06-06 11:50:22.775598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/vfp-1.c	2012-03-29 17:55:22.000000000 +1000
@@ -127,13 +127,13 @@
 
 void test_ldst (float f[], double d[]) {
   /* { dg-final { scan-assembler "flds.+ \\\[r0, #1020\\\]" } } */
-  /* { dg-final { scan-assembler "flds.+ \\\[r0, #-1020\\\]" } } */
+  /* { dg-final { scan-assembler "flds.+ \\\[r\[0-9\], #-1020\\\]" { target { arm32 && { ! arm_thumb2_ok } } } } } */
   /* { dg-final { scan-assembler "add.+ r0, #1024" } } */
-  /* { dg-final { scan-assembler "fsts.+ \\\[r0, #0\\\]\n" } } */
+  /* { dg-final { scan-assembler "fsts.+ \\\[r\[0-9\], #0\\\]\n" } } */
   f[256] = f[255] + f[-255];
 
   /* { dg-final { scan-assembler "fldd.+ \\\[r1, #1016\\\]" } } */
-  /* { dg-final { scan-assembler "fldd.+ \\\[r1, #-1016\\\]" } } */
+  /* { dg-final { scan-assembler "fldd.+ \\\[r\[1-9\], #-1016\\\]" { target { arm32 && { ! arm_thumb2_ok } } } } } */
   /* { dg-final { scan-assembler "fstd.+ \\\[r1, #256\\\]" } } */
   d[32] = d[127] + d[-127];
 }
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: volatile-bitfields-4.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm: volatile-bitfields-5.c
diff -ru ./gcc/testsuite/gcc.target/arm/wmul-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-1.c
--- ./gcc/testsuite/gcc.target/arm/wmul-1.c	2014-06-06 11:50:22.775598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-1.c	2012-03-29 17:55:22.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O2" } */
+/* { dg-options "-O1 -fexpensive-optimizations" } */
 
 int mac(const short *a, const short *b, int sqr, int *sum)
 {
diff -ru ./gcc/testsuite/gcc.target/arm/wmul-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-2.c
--- ./gcc/testsuite/gcc.target/arm/wmul-2.c	2014-06-06 11:50:22.775598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-2.c	2012-03-29 17:55:22.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O2" } */
+/* { dg-options "-O1 -fexpensive-optimizations" } */
 
 void vec_mpy(int y[], const short x[], short scaler)
 {
diff -ru ./gcc/testsuite/gcc.target/arm/wmul-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-3.c
--- ./gcc/testsuite/gcc.target/arm/wmul-3.c	2014-06-06 11:50:22.775598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-3.c	2012-03-29 17:55:22.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O2" } */
+/* { dg-options "-O1 -fexpensive-optimizations" } */
 
 int mac(const short *a, const short *b, int sqr, int *sum)
 {
diff -ru ./gcc/testsuite/gcc.target/arm/wmul-4.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-4.c
--- ./gcc/testsuite/gcc.target/arm/wmul-4.c	2014-06-06 11:50:22.775598876 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/arm/wmul-4.c	2012-03-29 17:55:22.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target arm_dsp } */
-/* { dg-options "-O2" } */
+/* { dg-options "-O1 -fexpensive-optimizations" } */
 
 int mac(const int *a, const int *b, long long sqr, long long *sum)
 {
diff -ru ./gcc/testsuite/gcc.target/i386/pad-10.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-10.c
--- ./gcc/testsuite/gcc.target/i386/pad-10.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-10.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-not "nop" } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-2.c
--- ./gcc/testsuite/gcc.target/i386/pad-2.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-2.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 8 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-3.c
--- ./gcc/testsuite/gcc.target/i386/pad-3.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-3.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom -fno-pic" } */
 /* { dg-final { scan-assembler-not "nop" } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-4.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-4.c
--- ./gcc/testsuite/gcc.target/i386/pad-4.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-4.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,6 +1,8 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
 /* { dg-require-effective-target fpic } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
+/* { dg-skip-if "No Windows PIC" { *-*-mingw* *-*-cygwin } { "*" } { "" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom -fPIC" } */
 /* { dg-final { scan-assembler-times "nop" 8 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-5a.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-5a.c
--- ./gcc/testsuite/gcc.target/i386/pad-5a.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-5a.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 2 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-5b.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-5b.c
--- ./gcc/testsuite/gcc.target/i386/pad-5b.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-5b.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 4 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-6a.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-6a.c
--- ./gcc/testsuite/gcc.target/i386/pad-6a.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-6a.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 4 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-6b.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-6b.c
--- ./gcc/testsuite/gcc.target/i386/pad-6b.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-6b.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 6 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-7.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-7.c
--- ./gcc/testsuite/gcc.target/i386/pad-7.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-7.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-not "nop" } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-8.c
--- ./gcc/testsuite/gcc.target/i386/pad-8.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-8.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 6 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pad-9.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-9.c
--- ./gcc/testsuite/gcc.target/i386/pad-9.c	2014-06-06 11:50:23.127598889 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pad-9.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=atom" } } */
 /* { dg-options "-O2 -fomit-frame-pointer -march=atom" } */
 /* { dg-final { scan-assembler-times "nop" 4 } } */
 /* { dg-final { scan-assembler-not "rep" } } */
diff -ru ./gcc/testsuite/gcc.target/i386/pr36533.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr36533.c
--- ./gcc/testsuite/gcc.target/i386/pr36533.c	2014-06-06 11:50:23.135598890 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr36533.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,5 @@
 /* PR target/36533 */
-/* { dg-do run { target { { i?86-*-linux* x86_64-*-linux* } && ilp32 } } } */
+/* { dg-do run { target { mmap && ilp32 } } } */
 /* { dg-options "-Os" } */
 #include <string.h>
 #include <sys/mman.h>
diff -ru ./gcc/testsuite/gcc.target/i386/pr37843-4.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr37843-4.c
--- ./gcc/testsuite/gcc.target/i386/pr37843-4.c	2014-06-06 11:50:23.135598890 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr37843-4.c	2012-03-29 17:55:43.000000000 +1000
@@ -3,8 +3,8 @@
 /* { dg-options "-O2 -msse2 -mpreferred-stack-boundary=4 -mstackrealign" } */
 /* { dg-require-effective-target sse2 } */
 /* { dg-final { scan-assembler-not "andl\[\\t \]*\\$-16,\[\\t \]*%\[re\]?sp" } } */
-/* { dg-final { scan-assembler-not "call\[\\t \]*foo" } } */
-/* { dg-final { scan-assembler "jmp\[\\t \]*foo" } } */
+/* { dg-final { scan-assembler-not "call\[\\t \]*_?foo" } } */
+/* { dg-final { scan-assembler "jmp\[\\t \]*_?foo" } } */
 
 extern int foo (void);
 
diff -ru ./gcc/testsuite/gcc.target/i386/pr40906-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr40906-1.c
--- ./gcc/testsuite/gcc.target/i386/pr40906-1.c	2014-06-06 11:50:24.215598931 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr40906-1.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target ilp32 } */
 /* { dg-options "-O2 -fomit-frame-pointer -fno-asynchronous-unwind-tables -mpush-args -mno-accumulate-outgoing-args" } */
+/* { dg-options "-O2 -fomit-frame-pointer -fno-asynchronous-unwind-tables -mpush-args" { target *-*-mingw* *-*-cygwin* } } */
 
 void abort (void);
 
diff -ru ./gcc/testsuite/gcc.target/i386/pr40906-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr40906-2.c
--- ./gcc/testsuite/gcc.target/i386/pr40906-2.c	2014-06-06 11:50:24.215598931 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr40906-2.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do run } */
 /* { dg-require-effective-target ilp32 } */
 /* { dg-options "-O2 -Wno-psabi -fomit-frame-pointer -fno-asynchronous-unwind-tables -mpush-args -mno-accumulate-outgoing-args -m128bit-long-double" } */
+/* { dg-options "-O2 -Wno-psabi -fomit-frame-pointer -fno-asynchronous-unwind-tables -mpush-args -m128bit-long-double" { target *-*-mingw* *-*-cygwin* } } */
 
 void abort (void);
 
diff -ru ./gcc/testsuite/gcc.target/i386/pr46226.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr46226.c
--- ./gcc/testsuite/gcc.target/i386/pr46226.c	2014-06-06 11:50:24.219598931 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/pr46226.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-Os -fomit-frame-pointer -mno-accumulate-outgoing-args -fno-asynchronous-unwind-tables" } */
+/* { dg-options "-Os -fomit-frame-pointer -fno-asynchronous-unwind-tables" { target *-*-mingw* *-*-cygwin* } } */
 
 extern void abort(void);
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386: sw-1.c
diff -ru ./gcc/testsuite/gcc.target/i386/vect-double-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/vect-double-1.c
--- ./gcc/testsuite/gcc.target/i386/vect-double-1.c	2014-06-06 11:50:24.607598946 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/i386/vect-double-1.c	2012-03-29 17:55:43.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "" { i?86-*-* x86_64-*-* } { "-march=*" } { "-march=core2" } } */
 /* { dg-options "-O2 -ftree-vectorize -mfpmath=sse -march=core2 -fdump-tree-vect-stats" } */
 
 extern void abort (void);
diff -ru ./gcc/testsuite/gcc.target/m68k/pr36134.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/m68k/pr36134.c
--- ./gcc/testsuite/gcc.target/m68k/pr36134.c	2014-06-06 11:50:24.623598946 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/m68k/pr36134.c	2012-03-29 17:55:28.000000000 +1000
@@ -1,10 +1,15 @@
 /* pr36134.c
 
    This test ensures that the shorter LEA instruction is used in preference
-   to the longer ADD instruction.  */
+   to the longer ADD instruction.
+
+   This preference is applicable to ColdFire only.  On CPU32, we can
+   use a sequence of two ADDQ instructions, which is faster than the
+   LEA instruction.  */
 
 /* { dg-do compile }  */
-/* { dg-options "-O2" }  */
+/* { dg-skip-if "" { *-*-* } { "-mcpu=*" } { "-mcpu=5208" } } */
+/* { dg-options "-O2 -mcpu=5208" }  */
 /* { dg-final { scan-assembler "lea" } } */
 /* { dg-final { scan-assembler-not "add" } } */
 
diff -ru ./gcc/testsuite/gcc.target/mips/atomic-memory-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/atomic-memory-2.c
--- ./gcc/testsuite/gcc.target/mips/atomic-memory-2.c	2014-06-06 11:50:24.627598946 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/atomic-memory-2.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 isa>=2 -mabi=32" } */
-/* { dg-final { scan-assembler "addiu" } } */
+/* { dg-final { scan-assembler "addiu|ldaddw" } } */
 /* { dg-final { scan-assembler-not "subu" } } */
 
 NOMIPS16 unsigned long
diff -ru ./gcc/testsuite/gcc.target/mips/call-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/call-1.c
--- ./gcc/testsuite/gcc.target/mips/call-1.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/call-1.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,7 +1,7 @@
 /* { dg-options "-O2 -mrelax-pic-calls -mshared" } */
-/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,normal\n1:\tjalr\t" } } */
-/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,normal2\n1:\tjalr\t" } } */
-/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,staticfunc\n1:\tjalr\t" } } */
+/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,normal\n1:\tjalrs?\t" } } */
+/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,normal2\n1:\tjalrs?\t" } } */
+/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,staticfunc\n1:\tjalrs?\t" } } */
 /* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,tail\n1:\tjr\t" } } */
 /* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,tail2\n1:\tjr\t" } } */
 
diff -ru ./gcc/testsuite/gcc.target/mips/call-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/call-2.c
--- ./gcc/testsuite/gcc.target/mips/call-2.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/call-2.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* See through some simple data-flow.  */
 /* { dg-options "-O2 -mrelax-pic-calls" } */
-/* { dg-final { scan-assembler-times "\\.reloc\t1f,R_MIPS_JALR,g\n1:\tjalr\t" 3 } } */
+/* { dg-final { scan-assembler-times "\\.reloc\t1f,R_MIPS_JALR,g\n1:\tjalrs?\t" 3 } } */
 
 NOMIPS16 f (int i)
 {
diff -ru ./gcc/testsuite/gcc.target/mips/call-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/call-3.c
--- ./gcc/testsuite/gcc.target/mips/call-3.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/call-3.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,5 +1,5 @@
 /* { dg-options "-O2 -mrelax-pic-calls -mno-shared" } */
-/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,g\n1:\tjalr\t" } } */
+/* { dg-final { scan-assembler "\\.reloc\t1f,R_MIPS_JALR,g\n1:\tjalrs?\t" } } */
 /* { dg-require-visibility "" } */
 
 __attribute__ ((visibility ("hidden"))) void g ();
diff -ru ./gcc/testsuite/gcc.target/mips/clear-cache-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/clear-cache-2.c
--- ./gcc/testsuite/gcc.target/mips/clear-cache-2.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/clear-cache-2.c	2012-03-29 17:55:51.000000000 +1000
@@ -2,7 +2,8 @@
 /* { dg-options "-O2 -mips32" } */
 /* { dg-final { scan-assembler-not "synci" } } */
 /* { dg-final { scan-assembler-not "jr.hb" } } */
-/* { dg-final { scan-assembler "_flush_cache" } } */
+/* { dg-final { scan-assembler "mips_sync_icache" { target { *-sde-* } } } } */
+/* { dg-final { scan-assembler "_flush_cache" { target { ! *-sde-* } } } } */
 
 void f()
 {
diff -ru ./gcc/testsuite/gcc.target/mips/fix-r10000-15.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-15.c
--- ./gcc/testsuite/gcc.target/mips/fix-r10000-15.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-15.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mfix-r10000" } */
-/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+/* { dg-final { scan-assembler-times "\tbeql\t|\tswapw\t|\tswapd\t" 3 } } */
 
 NOMIPS16 int
 f1 (int *z)
diff -ru ./gcc/testsuite/gcc.target/mips/fix-r10000-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-1.c
--- ./gcc/testsuite/gcc.target/mips/fix-r10000-1.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-1.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mfix-r10000" } */
-/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+/* { dg-final { scan-assembler-times "\tbeql\t|\tldaddw\t|\tldaddd\t" 3 } } */
 
 NOMIPS16 int
 f1 (int *z)
diff -ru ./gcc/testsuite/gcc.target/mips/fix-r10000-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-2.c
--- ./gcc/testsuite/gcc.target/mips/fix-r10000-2.c	2014-06-06 11:50:24.631598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-2.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mfix-r10000" } */
-/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+/* { dg-final { scan-assembler-times "\tbeql\t|\tldaddw\t|\tldaddd\t" 3 } } */
 
 NOMIPS16 int
 f1 (int *z, int amt)
diff -ru ./gcc/testsuite/gcc.target/mips/fix-r10000-7.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-7.c
--- ./gcc/testsuite/gcc.target/mips/fix-r10000-7.c	2014-06-06 11:50:24.635598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-7.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mfix-r10000" } */
-/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+/* { dg-final { scan-assembler-times "\tbeql\t|\tldaddw\t|\tldaddd\t" 3 } } */
 
 NOMIPS16 int
 f1 (int *z)
diff -ru ./gcc/testsuite/gcc.target/mips/fix-r10000-8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-8.c
--- ./gcc/testsuite/gcc.target/mips/fix-r10000-8.c	2014-06-06 11:50:24.635598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/fix-r10000-8.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mfix-r10000" } */
-/* { dg-final { scan-assembler-times "\tbeql\t" 3 } } */
+/* { dg-final { scan-assembler-times "\tbeql\t|\tldaddw\t|\tldaddd\t" 3 } } */
 
 NOMIPS16 int
 f1 (int *z, int amt)
diff -ru ./gcc/testsuite/gcc.target/mips/lazy-binding-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/lazy-binding-1.c
--- ./gcc/testsuite/gcc.target/mips/lazy-binding-1.c	2014-06-06 11:50:24.635598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/lazy-binding-1.c	2012-03-29 17:55:51.000000000 +1000
@@ -16,6 +16,6 @@
 /* There should be exactly five uses of $25: one to set up $gp, two to
    load the address of bar (), and two to call it.  */
 /* { dg-final { scan-assembler-times "\tl.\t\\\$25,%call16\\\(bar\\\)" 2 } } */
-/* { dg-final { scan-assembler-times "\tjalr\t\\\$25" 2 } } */
+/* { dg-final { scan-assembler-times "\tjalrs?\t\\\$25" 2 } } */
 /* { dg-final { scan-assembler "(\\\$28,|\t.cpload\t)\\\$25" } } */
 /* { dg-final { scan-assembler-times "\\\$25" 5 } } */
diff -ru ./gcc/testsuite/gcc.target/mips/loongson-simd.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/loongson-simd.c
--- ./gcc/testsuite/gcc.target/mips/loongson-simd.c	2014-06-06 11:50:24.635598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/loongson-simd.c	2012-03-29 17:55:51.000000000 +1000
@@ -19,10 +19,10 @@
 <http://www.gnu.org/licenses/>.  */
 
 /* { dg-do run } */
-/* loongson.h does not handle or check for MIPS16ness.  There doesn't
-   seem any good reason for it to, given that the Loongson processors
-   do not support MIPS16.  */
-/* { dg-options "isa=loongson -mhard-float -mno-mips16 -flax-vector-conversions" } */
+/* loongson.h does not handle or check for MIPS16ness or
+   microMIPSness.  There doesn't seem any good reason for it to, given
+   that the Loongson processors do not support either.  */
+/* { dg-options "isa=loongson -mhard-float -mno-micromips -mno-mips16 -flax-vector-conversions" } */
 
 #include "loongson.h"
 #include <stdio.h>
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips: micromips-lwp-swp-volatile.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips: mips16-fn-local.c
diff -ru ./gcc/testsuite/gcc.target/mips/mips.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/mips.exp
--- ./gcc/testsuite/gcc.target/mips/mips.exp	2014-06-06 11:50:24.639598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/mips.exp	2012-03-29 17:55:51.000000000 +1000
@@ -256,6 +256,7 @@
     gpopt
     local-sdata
     long-calls
+    octeon-useun
     paired-single
     plt
     shared
@@ -264,6 +265,8 @@
     synci
     relax-pic-calls
     mcount-ra-address
+    interlink-mips16
+    micromips
 } {
     lappend mips_option_groups $option "-m(no-|)$option"
 }
@@ -318,6 +321,18 @@
     .align 2
 1:
     ori $3,$31,1
+    jalr $3
+    move $31,$2
+}
+set mips_option_tests(-mmicromips) {
+    move $2,$31
+    bal 1f
+    .set micromips
+    jr $31
+    .set nomicromips
+    .align 2
+1:
+    ori $3,$31,1
     jalr $3
     move $31,$2
 }
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/mips-nonpic: main-msym32-mplt-1.c
diff -ru ./gcc/testsuite/gcc.target/mips/near-far-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/near-far-1.c
--- ./gcc/testsuite/gcc.target/mips/near-far-1.c	2014-06-06 11:50:24.639598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/near-far-1.c	2012-03-29 17:55:51.000000000 +1000
@@ -16,5 +16,5 @@
 
 /* { dg-final { scan-assembler-not "\tjal\tlong_call_func\n" } } */
 /* { dg-final { scan-assembler-not "\tjal\tfar_func\n" } } */
-/* { dg-final { scan-assembler     "\tjal\tnear_func\n" } } */
+/* { dg-final { scan-assembler     "\tjals?\tnear_func\n" } } */
 /* { dg-final { scan-assembler-not "\tjal\tnormal_func\n" } } */
diff -ru ./gcc/testsuite/gcc.target/mips/near-far-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/near-far-2.c
--- ./gcc/testsuite/gcc.target/mips/near-far-2.c	2014-06-06 11:50:24.639598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/near-far-2.c	2012-03-29 17:55:51.000000000 +1000
@@ -16,5 +16,5 @@
 
 /* { dg-final { scan-assembler-not "\tjal\tlong_call_func\n" } } */
 /* { dg-final { scan-assembler-not "\tjal\tfar_func\n" } } */
-/* { dg-final { scan-assembler     "\tjal\tnear_func\n" } } */
-/* { dg-final { scan-assembler     "\tjal\tnormal_func\n" } } */
+/* { dg-final { scan-assembler     "\tjals?\tnear_func\n" } } */
+/* { dg-final { scan-assembler     "\tjals?\tnormal_func\n" } } */
diff -ru ./gcc/testsuite/gcc.target/mips/octeon-bbit-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/octeon-bbit-2.c
--- ./gcc/testsuite/gcc.target/mips/octeon-bbit-2.c	2014-06-06 11:50:24.639598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips/octeon-bbit-2.c	2012-03-29 17:55:51.000000000 +1000
@@ -5,19 +5,19 @@
 /* { dg-final { scan-assembler "\tbnel\t" } } */
 /* { dg-final { scan-assembler-not "\tbne\t" } } */
 
-NOMIPS16 int
-f (int n, int i)
+NOMIPS16 long int
+f (long int n, long int i)
 {
-  int s = 0;
+  long int s = 0;
   for (; i & 1; i++)
     s += i;
   return s;
 }
 
-NOMIPS16 int
-g (int n, int i)
+NOMIPS16 long int
+g (long int n, long int i)
 {
-  int s = 0;
+  long int s = 0;
   for (i = 0; i < n; i++)
     s += i;
   return s;
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips: octeon-useun.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips: switch-peephole2.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/mips: sync.c
diff -ru ./gcc/testsuite/gcc.target/powerpc/altivec-34.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/altivec-34.c
--- ./gcc/testsuite/gcc.target/powerpc/altivec-34.c	2014-06-06 11:50:24.647598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/altivec-34.c	2012-03-29 17:55:27.000000000 +1000
@@ -22,3 +22,4 @@
 
   return 0;
 }
+
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc: altivec-35.c
diff -ru ./gcc/testsuite/gcc.target/powerpc/altivec-consts.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/altivec-consts.c
--- ./gcc/testsuite/gcc.target/powerpc/altivec-consts.c	2014-06-06 11:50:24.651598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/altivec-consts.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,7 +1,7 @@
 /* { dg-do run { target { powerpc*-*-* && vmx_hw } } } */
 /* { dg-do compile { target { powerpc*-*-* && { ! vmx_hw } } } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec -mabi=altivec -O2" } */
+/* { dg-options "-maltivec -O2" } */
 
 /* Check that "easy" AltiVec constants are correctly synthesized.  */
 
diff -ru ./gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c
--- ./gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c	2014-06-06 11:50:24.651598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/altivec-varargs-1.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,7 +1,7 @@
 /* { dg-do run { target { powerpc*-*-* && vmx_hw } } } */
 /* { dg-do compile { target { powerpc*-*-* && { ! vmx_hw } } } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
-/* { dg-options "-maltivec -mabi=altivec -fno-inline" } */
+/* { dg-options "-maltivec -fno-inline" } */
 
 #include <stdarg.h>
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc: builtin-isel64.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc: builtin-isel64-errors.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc: builtin-isel.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc: builtin-isel-errors.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc: builtin-isel.h
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fma-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-3.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fma-3.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-3.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -ftree-vectorize -mcpu=power6 -maltivec -ffast-math" } */
 /* { dg-final { scan-assembler-times "vmaddfp" 2 } } */
 /* { dg-final { scan-assembler-times "fmadd " 2 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fma-4.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-4.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fma-4.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-4.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -ftree-vectorize -mcpu=power6 -maltivec -ffast-math -ffp-contract=off" } */
 /* { dg-final { scan-assembler-times "vmaddfp" 1 } } */
 /* { dg-final { scan-assembler-times "fmadd " 1 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fma-5.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-5.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fma-5.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-5.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do run { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -mcpu=power5 -std=c99" } */
 
 #ifndef __FP_FAST_FMA
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fma-7.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-7.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fma-7.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fma-7.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -ftree-vectorize -mcpu=power6 -ffast-math" } */
 /* { dg-final { scan-assembler-times "fmadd" 1 } } */
 /* { dg-final { scan-assembler-times "fmsub " 1 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-11.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-11.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-11.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-11.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -mcpu=power5+ -ffast-math" } */
 /* { dg-final { scan-assembler-not "xsrdpiz" } } */
 /* { dg-final { scan-assembler "friz" } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-3.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-3.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-3.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -mcpu=power5 -ffast-math" } */
 /* { dg-final { scan-assembler-not "lfiwax" } } */
 /* { dg-final { scan-assembler-not "lfiwzx" } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-7.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-7.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-7.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-7.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -mcpu=power5 -ffast-math" } */
 /* { dg-final { scan-assembler-times "fctiwz" 2 } } */
 /* { dg-final { scan-assembler-not "fctiwuz" } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-8.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-8.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-fpconv-8.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-fpconv-8.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,7 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -mcpu=750 -ffast-math" } */
 /* { dg-final { scan-assembler-times "fctiwz" 6 } } */
 /* { dg-final { scan-assembler-not "fctiwuz" } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/ppc-pow.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-pow.c
--- ./gcc/testsuite/gcc.target/powerpc/ppc-pow.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/ppc-pow.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { { powerpc*-*-* } && { ! powerpc*-apple-darwin* } } } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -ffast-math -mcpu=power6" } */
 /* { dg-final { scan-assembler-times "fsqrt" 3 } } */
 /* { dg-final { scan-assembler-times "fmul" 1 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/pr47755-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/pr47755-2.c
--- ./gcc/testsuite/gcc.target/powerpc/pr47755-2.c	2014-06-06 11:50:24.655598947 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/pr47755-2.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,6 +1,6 @@
 /* { dg-do run { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
-/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-require-effective-target vsx_hw } */
 /* { dg-options "-O3 -mcpu=power7" } */
 
 /* PR 47755: Make sure compiler generates correct code for various
diff -ru ./gcc/testsuite/gcc.target/powerpc/recip-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-1.c
--- ./gcc/testsuite/gcc.target/powerpc/recip-1.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-1.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { { powerpc*-*-* } && { ! powerpc*-apple-darwin* } } } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -mrecip -ffast-math -mcpu=power6" } */
 /* { dg-final { scan-assembler-times "frsqrte" 2 } } */
 /* { dg-final { scan-assembler-times "fmsub" 2 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/recip-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-2.c
--- ./gcc/testsuite/gcc.target/powerpc/recip-2.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-2.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { { powerpc*-*-* } && { ! powerpc*-apple-darwin* } } } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -mrecip -ffast-math -mcpu=power5" } */
 /* { dg-final { scan-assembler-times "frsqrtes" 1 } } */
 /* { dg-final { scan-assembler-times "fmsubs" 1 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/recip-3.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-3.c
--- ./gcc/testsuite/gcc.target/powerpc/recip-3.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-3.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { { powerpc*-*-* } && { ! powerpc*-apple-darwin* } } } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O2 -mrecip -ffast-math -mcpu=power7" } */
 /* { dg-final { scan-assembler-times "xsrsqrtedp" 1 } } */
 /* { dg-final { scan-assembler-times "xsmsub.dp" 1 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/recip-4.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-4.c
--- ./gcc/testsuite/gcc.target/powerpc/recip-4.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-4.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -ftree-vectorize -mrecip -ffast-math -mcpu=power7 -fno-unroll-loops" } */
 /* { dg-final { scan-assembler-times "xvrsqrtedp" 1 } } */
 /* { dg-final { scan-assembler-times "xvmsub.dp" 1 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/recip-5.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-5.c
--- ./gcc/testsuite/gcc.target/powerpc/recip-5.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/recip-5.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-require-effective-target powerpc_fprs } */
 /* { dg-options "-O3 -ftree-vectorize -mrecip=all -ffast-math -mcpu=power7 -fno-unroll-loops" } */
 /* { dg-final { scan-assembler-times "xvredp" 4 } } */
 /* { dg-final { scan-assembler-times "xvresp" 5 } } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/warn-1.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/warn-1.c
--- ./gcc/testsuite/gcc.target/powerpc/warn-1.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/warn-1.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
 /* { dg-options "-O -mvsx -mno-altivec" } */
 
 /* { dg-warning "-mvsx and -mno-altivec are incompatible" "" { target *-*-* } 1 } */
diff -ru ./gcc/testsuite/gcc.target/powerpc/warn-2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/warn-2.c
--- ./gcc/testsuite/gcc.target/powerpc/warn-2.c	2014-06-06 11:50:24.659598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/powerpc/warn-2.c	2012-03-29 17:55:27.000000000 +1000
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
 /* { dg-options "-O -mcpu=power7 -mno-altivec" } */
 
 /* { dg-warning "-mno-altivec disables vsx" "" { target *-*-* } 1 } */
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh: crash-1.c
diff -ru ./gcc/testsuite/gcc.target/sh/mfmovd.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/mfmovd.c
--- ./gcc/testsuite/gcc.target/sh/mfmovd.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/mfmovd.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,7 +1,9 @@
+/* Verify that we generate fmov.d instructions to move doubles when -mfmovd 
+   option is enabled.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-mfmovd" } */
-/* { dg-skip-if "No double precision FPU support" { "sh*-*-*" } "-m2a-nofpu -m2a-single-only -m4-nofpu -m4-single-only -m4a-nofpu -m4a-single-only" { "" } }  */
-/* { dg-final { scan-assembler "fmov.d"} }  */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m2a" "-m2a-single" "-m4" "-m4-single" "-m4-100" "-m4-100-single" "-m4-200" "-m4-200-single" "-m4-300" "-m4-300-single" "-m4a" "-m4a-single" } }  */
+/* { dg-final { scan-assembler "fmov.d" } } */
 
 extern double g;
 
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-bitmovua.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,9 +1,9 @@
-/* Verify that we generate movua to load unaligned 32-bit values.  */
+/* Verify that we generate movua to load unaligned 32-bit values on SH4A.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O" } */
-/* { dg-final { scan-assembler-times "\tmovua\\.l\t" 6 } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" "-m4a-nofpu" } }  */
+/* { dg-final { scan-assembler-times "movua.l" 6 } } */
 
-#ifdef __SH4A__
 /* Aligned.  */
 struct s0 { long long d : 32; } x0;
 long long f0() {
@@ -63,11 +63,5 @@
 unsigned long long g4() {
   return y4.d;
 }
-#else
-asm ("movua.l\t");
-asm ("movua.l\t");
-asm ("movua.l\t");
-asm ("movua.l\t");
-asm ("movua.l\t");
-asm ("movua.l\t");
-#endif
+
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-cos.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-cos.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-cos.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-cos.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,13 +1,11 @@
 /* Verify that we generate single-precision sine and cosine approximate
-   (fsca) in fast math mode.  */
+   (fsca) in fast math mode on SH4A with FPU.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler "\tfsca\t" } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler "fsca" } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 double test(double f) { return cos(f); }
-#else
-asm ("fsca\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-cosf.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-cosf.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-cosf.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-cosf.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,13 +1,11 @@
 /* Verify that we generate single-precision sine and cosine approximate
-   (fsca) in fast math mode.  */
+   (fsca) in fast math mode on SH4A with FPU.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler "\tfsca\t" } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler "fsca" } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 float test(float f) { return cosf(f); }
-#else
-asm ("fsca\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-fsrra.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-fsrra.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-fsrra.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-fsrra.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,13 +1,11 @@
 /* Verify that we generate single-precision square root reciprocal
-   approximate (fsrra) in fast math mode.  */
+   approximate (fsrra) in fast math mode on SH4A with FPU.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler "\tfsrra\t" } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler "fsrra" } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 float test(float f) { return 1 / sqrtf(f); }
-#else
-asm ("fsrra\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-memmovua.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-memmovua.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-memmovua.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,17 +1,14 @@
 /* Verify that we generate movua to copy unaligned memory regions to
-   32-bit-aligned addresses.  */
+   32-bit-aligned addresses on SH4A.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O" } */
-/* { dg-final { scan-assembler-times "\tmovua\\.l\t" 2 } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" "-m4a-nofpu" } }  */
+/* { dg-final { scan-assembler-times "movua.l" 2 } } */
 
-#ifdef __SH4A__
 #include <string.h>
 
 struct s { int i; char a[10], b[10]; } x;
 int f() {
   memcpy(x.a, x.b, 10);
 }
-#else
-asm ("movua.l\t+");
-asm ("movua.l\t+");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-sin.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sin.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-sin.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sin.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,13 +1,11 @@
 /* Verify that we generate single-precision sine and cosine approximate
-   (fsca) in fast math mode.  */
+   (fsca) in fast math mode on SH4A with FPU.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler "\tfsca\t" } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler "fsca" } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 double test(double f) { return sin(f); }
-#else
-asm ("fsca\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-sincos.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sincos.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-sincos.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sincos.c	2012-03-29 17:55:51.000000000 +1000
@@ -3,12 +3,10 @@
    sine and cosine.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler-times "\tfsca\t" 1 } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler-times "fsca" 1 } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 double test(double f) { return sin(f) + cos(f); }
-#else
-asm ("fsca\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-sincosf.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sincosf.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-sincosf.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sincosf.c	2012-03-29 17:55:51.000000000 +1000
@@ -3,12 +3,10 @@
    sine and cosine.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler-times "\tfsca\t" 1 } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler-times "fsca" 1 } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 float test(float f) { return sinf(f) + cosf(f); }
-#else
-asm ("fsca\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/sh4a-sinf.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sinf.c
--- ./gcc/testsuite/gcc.target/sh/sh4a-sinf.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/sh4a-sinf.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,13 +1,11 @@
 /* Verify that we generate single-precision sine and cosine approximate
-   (fsca) in fast math mode.  */
+   (fsca) in fast math mode on SH4A with FPU.  */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-O -ffast-math" } */
-/* { dg-final { scan-assembler "\tfsca\t" } } */
+/* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m4a" "-m4a-single" "-m4a-single-only" } }  */
+/* { dg-final { scan-assembler "fsca" } } */
 
-#if defined __SH4A__ && ! defined __SH4_NOFPU__
 #include <math.h>
 
 float test(float f) { return sinf(f); }
-#else
-asm ("fsca\t");
-#endif
+
diff -ru ./gcc/testsuite/gcc.target/sh/struct-arg-dw2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/struct-arg-dw2.c
--- ./gcc/testsuite/gcc.target/sh/struct-arg-dw2.c	2014-06-06 11:50:24.663598948 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/gcc.target/sh/struct-arg-dw2.c	2012-03-29 17:55:51.000000000 +1000
@@ -1,4 +1,4 @@
-/* Verify that we don't generate fame related insn against stack adjustment
+/* Verify that we don't generate frame related insn against stack adjustment
    for the object sent partially in registers. */
 /* { dg-do compile { target "sh*-*-*" } } */
 /* { dg-options "-g" } */
diff -ru ./gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c
--- ./gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c	2014-06-06 11:50:20.643598795 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/compat/struct-layout-1_generate.c	2012-03-29 18:01:05.000000000 +1000
@@ -46,7 +46,7 @@
 "/* { dg-options \"%s-I%s\" } */\n",
 "/* { dg-options \"%s-I%s -mno-mmx -Wno-abi\" { target i?86-*-* x86_64-*-* } } */\n",
 "/* { dg-options \"%s-I%s -fno-common\" { target hppa*-*-hpux* powerpc*-*-darwin* *-*-mingw32* *-*-cygwin* } } */\n",
-"/* { dg-options \"%s-I%s -mno-mmx -fno-common -Wno-abi\" { target i?86-*-darwin* x86_64-*-darwin* } } */\n",
+"/* { dg-options \"%s-I%s -mno-mmx -fno-common -Wno-abi\" { target i?86-*-darwin* x86_64-*-darwin* i?86-*-mingw32* x86_64-*-mingw32* i?86-*-cygwin* } } */\n",
 "/* { dg-options \"%s-I%s -mno-base-addresses\" { target mmix-*-* } } */\n",
 "/* { dg-options \"%s-I%s -mlongcalls -mtext-section-literals\" { target xtensa*-*-* } } */\n"
 #define NDG_OPTIONS (sizeof (dg_options) / sizeof (dg_options[0]))
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/cpp0x: constexpr-52672.C
diff -ru ./gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C
--- ./gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C	2014-06-06 11:50:20.747598799 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-5.C	2012-03-29 18:00:09.000000000 +1000
@@ -13,3 +13,5 @@
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
diff -ru ./gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C
--- ./gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C	2014-06-06 11:50:20.747598799 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/ext/arm-fp16/arm-fp16-ops-6.C	2012-03-29 18:00:09.000000000 +1000
@@ -13,3 +13,5 @@
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h\[a-z\]*_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_h2f_ieee" } } */
 /* { dg-final { scan-assembler-not "\tbl\t__gnu_f2h_ieee" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_h2f" } } */
+/* { dg-final { scan-assembler-not "\tbl\t__aeabi_f2h" } } */
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/other: armv7m-1.C
diff -ru ./gcc/testsuite/g++.dg/torture/type-generic-1.C /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/torture/type-generic-1.C
--- ./gcc/testsuite/g++.dg/torture/type-generic-1.C	2014-06-06 11:50:20.943598806 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/torture/type-generic-1.C	2012-03-29 18:01:24.000000000 +1000
@@ -4,6 +4,7 @@
 /* { dg-do run } */
 /* { dg-add-options ieee } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
+/* { dg-options "-Wl,--defsym=__cs3_mips_float_type=2 -lcs3-mips-cp1 -lcs3-mips-fpemu" { target mips*-*sde*-* } } */
 
 #include "../../gcc.dg/tg-tests.h"
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/g++.dg/tree-ssa: sink-1.C
diff -ru ./gcc/testsuite/lib/lto.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/lib/lto.exp
--- ./gcc/testsuite/lib/lto.exp	2014-06-06 11:50:25.931598996 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/lib/lto.exp	2012-03-29 17:56:20.000000000 +1000
@@ -497,7 +497,7 @@
 	verbose "Testing $testcase, $option"
 
 	# There's a unique name for each executable we generate.
-	set execname "${execbase}-${count}1"
+	set execname "${execbase}-${count}1.exe"
 	incr count
 
 	file_on_host delete $execname
diff -ru ./gcc/testsuite/lib/prune.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/lib/prune.exp
--- ./gcc/testsuite/lib/prune.exp	2014-06-06 11:50:25.935598996 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/lib/prune.exp	2012-03-29 17:56:20.000000000 +1000
@@ -72,3 +72,34 @@
 	return $text
     }
 }
+
+# Extend prune_warnings (provided by DejaGNU itself) to prune more
+# things.  The prune_gcc_output function above is called only by some
+# tests; prune_warnings is used by all.
+if { [info procs prune_warnings_orig] == "" } {
+    rename prune_warnings prune_warnings_orig
+    
+    proc prune_warnings { text } {
+	set text [prune_warnings_orig $text]
+	
+	if { [ishost "sparc*-*-solaris2*"] } {
+	    # When testing a compiler built for SPARC Solaris 2.9 (or earlier)
+	    # on a host running Solaris 2.10 (or later), we get this warning 
+	    # from the static linker when building with g++:
+	    #
+	    #   libm.so.1, needed by .../libstdc++.so may conflict with
+	    #   libm.so
+	    #
+	    # The warning is issued because libstdc++ is linked against
+	    # libm.so.1 (from the Solaris 2.9 sysroot), whereas Solaris 2.10
+	    # provides both libm.so.2 and libm.so.1.  On Solaris 2.10, libc.so
+	    # depends on libm.so.2, so all programs pull in libm.so.2.
+	    #
+	    # Pulling both libraries must in fact be harmless, as, otherwise,
+	    # programs built for Solaris 2.9 would break on Solaris 2.10.
+	    regsub -all "(^|\n)\[^\n\]*: warning: libm.so.1, needed by \[^\n\]*, may conflict with libm.so.2" $text "" text
+	}
+
+	return $text
+    }
+}
diff -ru ./gcc/testsuite/lib/target-supports.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/lib/target-supports.exp
--- ./gcc/testsuite/lib/target-supports.exp	2014-06-06 14:25:27.550150555 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/testsuite/lib/target-supports.exp	2012-03-29 17:56:20.000000000 +1000
@@ -691,6 +691,12 @@
     } "-fopenmp"]
 }
 
+# Return 1 if the target supports mmap, 0 otherwise.
+
+proc check_effective_target_mmap {} {
+    return [check_function_available "mmap"]
+}
+
 # Return 1 if compilation with -pthread is error-free for trivial
 # code, 0 otherwise.
 
@@ -1842,6 +1848,15 @@
     }]
 }
 
+# Return 1 if this is a little-endian ARM target
+proc check_effective_target_arm_little_endian { } {
+    return [check_no_compiler_messages arm_little_endian assembly {
+	#if !defined(__arm__) || !defined(__ARMEL__)
+	#error FOO
+	#endif
+    }]
+}
+
 # Return 1 if this is an ARM target that only supports aligned vector accesses
 proc check_effective_target_arm_vect_no_misalign { } {
     return [check_no_compiler_messages arm_vect_no_misalign assembly {
@@ -2338,6 +2353,26 @@
 }
 
 
+# Return 1 if the target supports hardware vector shift operation for char.
+
+proc check_effective_target_vect_shift_char { } {
+    global et_vect_shift_char_saved
+
+    if [info exists et_vect_shift_char_saved] {
+	verbose "check_effective_target_vect_shift_char: using cached result" 2
+    } else {
+	set et_vect_shift_char_saved 0
+	if { ([istarget powerpc*-*-*]
+             && ![istarget powerpc-*-linux*paired*])
+	     || [check_effective_target_arm32] } {
+	   set et_vect_shift_char_saved 1
+	}
+    }
+
+    verbose "check_effective_target_vect_shift_char: returning $et_vect_shift_char_saved" 2
+    return $et_vect_shift_char_saved
+}
+
 # Return 1 if the target supports hardware vectors of long, 0 otherwise.
 #
 # This can change for different subtargets so do not cache the result.
@@ -2816,7 +2851,8 @@
              || [istarget i?86-*-*]
              || [istarget x86_64-*-*]
              || [istarget spu-*-*]
-             || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {
+             || ([istarget arm*-*-*] && [check_effective_target_arm_neon]
+		 && [check_effective_target_arm_little_endian]) } {
             set et_vect_pack_trunc_saved 1
         }
     }
@@ -2841,7 +2877,8 @@
              || [istarget x86_64-*-*] 
              || [istarget spu-*-*]
              || [istarget ia64-*-*]
-             || ([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {
+             || ([istarget arm*-*-*] && [check_effective_target_arm_neon]
+		 && [check_effective_target_arm_little_endian]) } {
             set et_vect_unpack_saved 1
         }
     }
@@ -2986,8 +3023,9 @@
     if [info exists et_vector_alignment_reachable_saved] {
         verbose "check_effective_target_vector_alignment_reachable: using cached result" 2
     } else {
-        if { [check_effective_target_vect_aligned_arrays]
-             || [check_effective_target_natural_alignment_32] } {
+        if { ([check_effective_target_vect_aligned_arrays]
+              || [check_effective_target_natural_alignment_32])
+	     && !([istarget arm*-*-*] && [check_effective_target_arm_neon]) } {
             set et_vector_alignment_reachable_saved 1
         } else {
             set et_vector_alignment_reachable_saved 0
@@ -3027,7 +3065,8 @@
 	verbose "check_effective_target_vect_element_align: using cached result" 2
     } else {
 	set et_vect_element_align 0
-	if { [istarget arm*-*-*]
+	if { ([istarget arm*-*-*]
+	      && ![check_effective_target_arm_vect_no_misalign])
 	     || [check_effective_target_vect_hw_misalign] } {
 	   set et_vect_element_align 1
 	}
@@ -3929,6 +3968,7 @@
         # default to avoid loss of precision.  We must pass -ffast-math to test
         # vectorization of float operations.
         lappend DEFAULT_VECTCFLAGS "-ffast-math"
+	lappend DEFAULT_VECTCFLAGS "-fno-unroll-loops"
         if [is-effective-target arm_neon_hw] {
             set dg-do-what-default run
         } else {
@@ -3941,6 +3981,17 @@
     return 1
 }
 
+# Add options to increase stack size, when that is a tunable parameter at
+# link time (e.g. uClinux).  Use for test cases which need a lot of stack
+# space.
+
+proc add_options_for_large_stack { flags } {
+    if { [istarget *-*-uclinux*] } {
+        return "$flags -Wl,-elf2flt=-s1500000"
+    }
+    return $flags
+}
+
 proc check_effective_target_non_strict_align {} {
     return [check_no_compiler_messages non_strict_align assembly {
 	char *y;
diff -ru ./gcc/timevar.def /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/timevar.def
--- ./gcc/timevar.def	2014-06-06 11:50:26.023598999 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/timevar.def	2012-03-29 18:03:19.000000000 +1000
@@ -159,6 +159,7 @@
 DEFTIMEVAR (TV_PREDCOM		     , "predictive commoning")
 DEFTIMEVAR (TV_TREE_LOOP_INIT	     , "tree loop init")
 DEFTIMEVAR (TV_TREE_LOOP_FINI	     , "tree loop fini")
+DEFTIMEVAR (TV_TREE_LOOP_PROMOTE     , "tree loop index promotion")
 DEFTIMEVAR (TV_TREE_CH		     , "tree copy headers")
 DEFTIMEVAR (TV_TREE_SSA_UNCPROP	     , "tree SSA uncprop")
 DEFTIMEVAR (TV_TREE_SSA_TO_NORMAL    , "tree SSA to normal")
@@ -166,6 +167,7 @@
 DEFTIMEVAR (TV_TREE_COPY_RENAME	     , "tree rename SSA copies")
 DEFTIMEVAR (TV_TREE_SSA_VERIFY       , "tree SSA verifier")
 DEFTIMEVAR (TV_TREE_STMT_VERIFY      , "tree STMT verifier")
+DEFTIMEVAR (TV_TREE_RLS              , "tree local static removal")
 DEFTIMEVAR (TV_TREE_SWITCH_CONVERSION, "tree switch initialization conversion")
 DEFTIMEVAR (TV_CGRAPH_VERIFY         , "callgraph verifier")
 DEFTIMEVAR (TV_DOM_FRONTIERS         , "dominance frontiers")
@@ -180,6 +182,7 @@
 DEFTIMEVAR (TV_VARCONST              , "varconst")
 DEFTIMEVAR (TV_LOWER_SUBREG	     , "lower subreg")
 DEFTIMEVAR (TV_JUMP                  , "jump")
+DEFTIMEVAR (TV_EE                    , "extension elimination")
 DEFTIMEVAR (TV_FWPROP                , "forward prop")
 DEFTIMEVAR (TV_CSE                   , "CSE")
 DEFTIMEVAR (TV_DCE                   , "dead code elimination")
diff -ru ./gcc/toplev.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/toplev.c
--- ./gcc/toplev.c	2014-06-06 14:25:27.550150555 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/toplev.c	2012-03-29 18:03:19.000000000 +1000
@@ -1326,6 +1326,13 @@
 	   "and -ftree-loop-linear)");
 #endif
 
+  if (flag_strict_volatile_bitfields > 0 && !abi_version_at_least (2))
+    {
+      warning (0, "-fstrict-volatile-bitfield disabled; "
+	       "it is incompatible with ABI versions < 2");
+      flag_strict_volatile_bitfields = 0;
+    }
+
   /* Unrolling all loops implies that standard loop unrolling must also
      be done.  */
   if (flag_unroll_all_loops)
diff -ru ./gcc/tree.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree.c
--- ./gcc/tree.c	2014-06-06 11:50:27.443599053 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree.c	2012-04-28 17:58:33.000000000 +1000
@@ -9447,6 +9447,10 @@
 	const char *p;
 	enum built_in_function mcode, dcode;
 	tree type, inner_type;
+	const char *prefix = "__";
+
+	if (targetm.libfunc_gnu_prefix)
+	  prefix = "__gnu_";
 
 	type = lang_hooks.types.type_for_mode ((enum machine_mode) mode, 0);
 	if (type == NULL)
@@ -9465,13 +9469,17 @@
 	  *q = TOLOWER (*p);
 	*q = '\0';
 
-	built_in_names[mcode] = concat ("__mul", mode_name_buf, "3", NULL);
+	built_in_names[mcode] = concat (prefix, "mul", mode_name_buf, "3",
+					NULL);
         local_define_builtin (built_in_names[mcode], ftype, mcode,
-			      built_in_names[mcode], ECF_CONST | ECF_NOTHROW | ECF_LEAF);
+			      built_in_names[mcode],
+			      ECF_CONST | ECF_NOTHROW | ECF_LEAF);
 
-	built_in_names[dcode] = concat ("__div", mode_name_buf, "3", NULL);
+	built_in_names[dcode] = concat (prefix, "div", mode_name_buf, "3",
+					NULL);
         local_define_builtin (built_in_names[dcode], ftype, dcode,
-			      built_in_names[dcode], ECF_CONST | ECF_NOTHROW | ECF_LEAF);
+			      built_in_names[dcode],
+			      ECF_CONST | ECF_NOTHROW | ECF_LEAF);
       }
   }
 }
@@ -10997,7 +11005,7 @@
 lhd_gcc_personality (void)
 {
   if (!gcc_eh_personality_decl)
-    gcc_eh_personality_decl = build_personality_function ("gcc");
+    gcc_eh_personality_decl = build_personality_function ("gcc", false);
   return gcc_eh_personality_decl;
 }
 
diff -ru ./gcc/tree-cfg.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-cfg.c
--- ./gcc/tree-cfg.c	2014-06-06 11:50:26.051599001 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-cfg.c	2012-03-29 18:03:19.000000000 +1000
@@ -45,6 +45,7 @@
 #include "value-prof.h"
 #include "pointer-set.h"
 #include "tree-inline.h"
+#include "target.h"
 
 /* This file contains functions for building the Control Flow Graph (CFG)
    for a function tree.  */
@@ -7345,6 +7346,9 @@
   edge e;
   edge_iterator ei;
 
+  if (!targetm.warn_func_result())
+    return 0;
+
   /* If we have a path to EXIT, then we do return.  */
   if (TREE_THIS_VOLATILE (cfun->decl)
       && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0)
diff -ru ./gcc/tree-eh.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-eh.c
--- ./gcc/tree-eh.c	2014-06-06 11:50:26.087599002 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-eh.c	2012-04-28 17:58:33.000000000 +1000
@@ -3129,7 +3129,10 @@
 
 	    c->label = NULL;
 	    tp_node = c->type_list;
-	    flt_node = c->filter_list;
+	    if (TARGET_COMPACT_EH)
+	      flt_node = c->compact_filter_list;
+	    else
+	      flt_node = c->filter_list;
 
 	    if (tp_node == NULL)
 	      {
diff -ru ./gcc/tree.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree.h
--- ./gcc/tree.h	2014-06-06 11:50:27.459599054 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree.h	2012-04-28 17:58:33.000000000 +1000
@@ -2653,6 +2653,9 @@
 #define DECL_FUNCTION_PERSONALITY(NODE) \
   (FUNCTION_DECL_CHECK (NODE)->function_decl.personality)
 
+#define DECL_FUNCTION_PERSONALITY2(NODE) \
+  (FUNCTION_DECL_CHECK (NODE)->function_decl.personality2)
+
 /* Nonzero for a given ..._DECL node means that the name of this node should
    be ignored for symbolic debug purposes.  For a TYPE_DECL, this means that
    the associated type should be ignored.  For a FUNCTION_DECL, the body of
@@ -3374,6 +3377,11 @@
   /* The personality function. Used for stack unwinding. */
   tree personality;
 
+  /* An alternative personality function for the compact-encoding scheme.
+     The decision on whether to use this version will be deferred
+     until final.  */
+  tree personality2;
+
   /* Function specific options that are used by this function.  */
   tree function_specific_target;	/* target options */
   tree function_specific_optimization;	/* optimization options */
@@ -5595,7 +5603,7 @@
 
 /* In expr.c.  */
 extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);
-extern tree build_personality_function (const char *);
+extern tree build_personality_function (const char *, bool);
 
 /* In tree-inline.c.  */
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc: tree-if-switch-conversion.c
diff -ru ./gcc/tree-pass.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-pass.h
--- ./gcc/tree-pass.h	2014-06-06 11:50:26.367599013 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-pass.h	2012-03-29 18:03:19.000000000 +1000
@@ -376,6 +376,7 @@
 extern struct gimple_opt_pass pass_record_bounds;
 extern struct gimple_opt_pass pass_graphite;
 extern struct gimple_opt_pass pass_graphite_transforms;
+extern struct gimple_opt_pass pass_promote_indices;
 extern struct gimple_opt_pass pass_if_conversion;
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
@@ -446,6 +447,7 @@
 extern struct gimple_opt_pass pass_warn_unused_result;
 extern struct gimple_opt_pass pass_split_functions;
 extern struct gimple_opt_pass pass_feedback_split_functions;
+extern struct gimple_opt_pass pass_remove_local_statics;
 
 /* IPA Passes */
 extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
@@ -483,6 +485,7 @@
 extern struct rtl_opt_pass pass_initial_value_sets;
 extern struct rtl_opt_pass pass_unshare_all_rtl;
 extern struct rtl_opt_pass pass_instantiate_virtual_regs;
+extern struct rtl_opt_pass pass_ee;
 extern struct rtl_opt_pass pass_rtl_fwprop;
 extern struct rtl_opt_pass pass_rtl_fwprop_addr;
 extern struct rtl_opt_pass pass_jump2;
@@ -547,6 +550,7 @@
 extern struct rtl_opt_pass pass_if_after_reload;
 extern struct rtl_opt_pass pass_regrename;
 extern struct rtl_opt_pass pass_cprop_hardreg;
+extern struct rtl_opt_pass pass_cprop_hardreg2;
 extern struct rtl_opt_pass pass_reorder_blocks;
 extern struct rtl_opt_pass pass_branch_target_load_optimize2;
 extern struct rtl_opt_pass pass_leaf_regs;
@@ -576,6 +580,7 @@
 extern struct gimple_opt_pass pass_all_early_optimizations;
 extern struct gimple_opt_pass pass_update_address_taken;
 extern struct gimple_opt_pass pass_convert_switch;
+extern struct gimple_opt_pass pass_if_to_switch;
 
 /* The root of the compilation pass tree, once constructed.  */
 extern struct opt_pass *all_passes, *all_small_ipa_passes, *all_lowering_passes,
diff -ru ./gcc/tree-ssa-loop-ivopts.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-loop-ivopts.c
--- ./gcc/tree-ssa-loop-ivopts.c	2014-06-06 11:50:27.043599038 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-loop-ivopts.c	2012-03-29 18:03:19.000000000 +1000
@@ -171,6 +171,7 @@
 			   the final value of the iv.  For iv elimination,
 			   the new bound to compare with.  */
   int inv_expr_id;      /* Loop invariant expression id.  */
+  enum tree_code comp;	/* For iv elimination, the comparison.  */
 };
 
 /* Use.  */
@@ -291,6 +292,9 @@
 
   /* Whether the loop body includes any function calls.  */
   bool body_includes_call;
+
+  /* Whether the loop body can only be exited via single exit.  */
+  bool loop_single_exit_p;
 };
 
 /* An assignment of iv candidates to uses.  */
@@ -377,6 +381,127 @@
 
 static VEC(tree,heap) *decl_rtl_to_reset;
 
+/* Detects whether A is of POINTER_TYPE, and modifies CODE and B to make
+   A CODE B type-safe.  */
+
+static inline void
+robust_plus (enum tree_code *code, tree a, tree *b)
+{
+  tree a_type = TREE_TYPE (a);
+  tree b_type = TREE_TYPE (*b);
+
+  if (POINTER_TYPE_P (a_type))
+    {
+      switch (*code)
+        {
+        case MINUS_EXPR:
+          *b = fold_build1 (NEGATE_EXPR, b_type, *b);
+
+          /* Fall-through.  */
+        case PLUS_EXPR:
+          *code = POINTER_PLUS_EXPR;
+          break;
+        default:
+          gcc_unreachable ();
+        }
+    }
+  else
+    *b = fold_convert (a_type, *b);
+}
+
+/* Returns (TREE_TYPE (A))(A CODE B), where CODE is either PLUS_EXPR or
+   MINUS_EXPR.  Handles the case that A is a pointer robustly.  */
+
+static inline tree
+fold_build_plus (enum tree_code code, tree a, tree b)
+{
+  robust_plus (&code, a, &b);
+  return fold_build2 (code, TREE_TYPE (a), a, b);
+}
+
+/* Folds (TREE_TYPE (A))(A CODE B), where CODE is either PLUS_EXPR or
+   MINUS_EXPR.  Returns the folded expression if folding is successful.
+   Otherwise, return NULL_TREE.  Handles the case that A is a pointer
+   robustly.  */
+
+static inline tree
+fold_plus (enum tree_code code, tree a, tree b)
+{
+  tree a_type = TREE_TYPE (a);
+  tree res;
+
+  STRIP_NOPS (a);
+  robust_plus (&code, a, &b);
+
+  res = fold_binary (code, TREE_TYPE (a), a, b);
+  if (res == NULL_TREE)
+    return NULL_TREE;
+
+  return fold_convert (a_type, res);
+}
+
+/* Folds (TREE_TYPE (A))(A - B), possibly using the defining stmt of A.  Returns
+   the folded expression if folding is successful and resulted in an ssa_name.
+   Otherwise, return NULL_TREE.  */
+
+static inline tree
+fold_diff_to_ssa_name (tree a, tree b)
+{
+  tree a_type = TREE_TYPE (a);
+  tree res, a0, a1;
+  gimple def_stmt;
+
+  res = fold_plus (MINUS_EXPR, a, b);
+  if (res != NULL_TREE)
+    {
+      STRIP_NOPS (res);
+      if (TREE_CODE (res) == SSA_NAME)
+	return fold_convert (a_type, res);
+    }
+
+  STRIP_NOPS (a);
+  STRIP_NOPS (b);
+
+  if (TREE_CODE (a) == PLUS_EXPR && TREE_CODE (b) == PLUS_EXPR
+      && tree_int_cst_equal (TREE_OPERAND (a, 1), TREE_OPERAND (b, 1)))
+    {
+      a = TREE_OPERAND (a, 0);
+      b = TREE_OPERAND (b, 0);
+
+      STRIP_NOPS (a);
+      STRIP_NOPS (b);
+
+      res = fold_plus (MINUS_EXPR, a, b);
+      if (res != NULL_TREE)
+	{
+	  STRIP_NOPS (res);
+	  if (TREE_CODE (res) == SSA_NAME)
+	    return fold_convert (a_type, res);
+	}
+    }
+
+  if (TREE_CODE (a) != SSA_NAME)
+    return NULL_TREE;
+
+  def_stmt = SSA_NAME_DEF_STMT (a);
+  if (!is_gimple_assign (def_stmt)
+      || (gimple_assign_rhs_code (def_stmt) != PLUS_EXPR
+	  && gimple_assign_rhs_code (def_stmt) != POINTER_PLUS_EXPR))
+    return NULL_TREE;
+  a0 = gimple_assign_rhs1 (def_stmt);
+  a1 = gimple_assign_rhs2 (def_stmt);
+
+  res = fold_plus (MINUS_EXPR, fold_build_plus (PLUS_EXPR, a0, a1), b);
+  if (res != NULL_TREE)
+    {
+      STRIP_NOPS (res);
+      if (TREE_CODE (res) == SSA_NAME)
+	return fold_convert (a_type, res);
+    }
+
+  return NULL_TREE;
+}
+
 /* Number of uses recorded in DATA.  */
 
 static inline unsigned
@@ -783,17 +908,25 @@
 
   if (!slot)
     {
-      /* Try to determine number of iterations.  We must know it
-	 unconditionally (i.e., without possibility of # of iterations
-	 being zero).  Also, we cannot safely work with ssa names that
-	 appear in phi nodes on abnormal edges, so that we do not create
-	 overlapping life ranges for them (PR 27283).  */
+      /* Try to determine number of iterations.  We cannot safely work with ssa
+         names that appear in phi nodes on abnormal edges, so that we do not
+         create overlapping life ranges for them (PR 27283).  */
       desc = XNEW (struct tree_niter_desc);
       if (number_of_iterations_exit (data->current_loop,
 				     exit, desc, true)
-	  && integer_zerop (desc->may_be_zero)
      	  && !contains_abnormal_ssa_name_p (desc->niter))
-	niter = desc->niter;
+	{
+	  if (!integer_zerop (desc->may_be_zero))
+            /* Construct COND_EXPR that describes the number of iterations.
+               Either the COND_EXPR is not too expensive, and we can use it as
+               loop bound, or we can deduce a LT_EXPR bound from it.  */
+	    niter
+	      = build3 (COND_EXPR, TREE_TYPE (desc->niter), desc->may_be_zero,
+			build_int_cst_type (TREE_TYPE (desc->niter), 0),
+			desc->niter);
+	  else
+	    niter = desc->niter;
+	}
       else
 	niter = NULL_TREE;
 
@@ -2351,18 +2484,7 @@
   if ((HAVE_PRE_INCREMENT && GET_MODE_SIZE (mem_mode) == cstepi)
       || (HAVE_PRE_DECREMENT && GET_MODE_SIZE (mem_mode) == -cstepi))
     {
-      enum tree_code code = MINUS_EXPR;
-      tree new_base;
-      tree new_step = step;
-
-      if (POINTER_TYPE_P (TREE_TYPE (base)))
-	{
-	  new_step = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);
-	  code = POINTER_PLUS_EXPR;
-	}
-      else
-	new_step = fold_convert (TREE_TYPE (base), new_step);
-      new_base = fold_build2 (code, TREE_TYPE (base), base, new_step);
+      tree new_base = fold_build_plus (MINUS_EXPR, base, step);
       add_candidate_1 (data, new_base, step, important, IP_BEFORE_USE, use,
 		       use->stmt);
     }
@@ -2654,13 +2776,12 @@
 
 /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends
    on invariants DEPENDS_ON and that the value used in expressing it
-   is VALUE.  */
-
+   is VALUE, and in case of iv elimination the comparison operator is COMP.  */
 static void
 set_use_iv_cost (struct ivopts_data *data,
 		 struct iv_use *use, struct iv_cand *cand,
 		 comp_cost cost, bitmap depends_on, tree value,
-                 int inv_expr_id)
+                 int inv_expr_id, enum tree_code comp)
 {
   unsigned i, s;
 
@@ -2677,6 +2798,7 @@
       use->cost_map[cand->id].depends_on = depends_on;
       use->cost_map[cand->id].value = value;
       use->cost_map[cand->id].inv_expr_id = inv_expr_id;
+      use->cost_map[cand->id].comp = comp;
       return;
     }
 
@@ -2697,6 +2819,7 @@
   use->cost_map[i].depends_on = depends_on;
   use->cost_map[i].value = value;
   use->cost_map[i].inv_expr_id = inv_expr_id;
+  use->cost_map[i].comp = comp;
 }
 
 /* Gets cost of (USE, CANDIDATE) pair.  */
@@ -4208,7 +4331,8 @@
   if (cand->pos == IP_ORIGINAL
       && cand->incremented_at == use->stmt)
     {
-      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE, -1);
+      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE, -1,
+		       ERROR_MARK);
       return true;
     }
 
@@ -4216,7 +4340,7 @@
                                NULL, &inv_expr_id);
 
   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE,
-                   inv_expr_id);
+                   inv_expr_id, ERROR_MARK);
 
   return !infinite_cost_p (cost);
 }
@@ -4244,7 +4368,7 @@
 	cost = infinite_cost;
     }
   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE,
-                   inv_expr_id);
+                   inv_expr_id, ERROR_MARK);
 
   return !infinite_cost_p (cost);
 }
@@ -4319,12 +4443,152 @@
   return (exit->flags & EDGE_TRUE_VALUE ? EQ_EXPR : NE_EXPR);
 }
 
+/* Get the loop bound and comparison operator of USE->iv, and store them in
+   BOUND_P and COMP_P.  Returns false if unsuccessful.  */
+
+static bool
+get_use_lt_bound (struct iv_use *use, tree use_iv, tree *bound_p,
+		  enum tree_code *comp_p)
+{
+  gimple stmt = use->stmt;
+
+  if (gimple_code (stmt) != GIMPLE_COND
+      || gimple_cond_lhs (stmt) != use_iv)
+    return false;
+
+  *comp_p = gimple_cond_code (stmt);
+  *bound_p = gimple_cond_rhs (stmt);
+
+  return true;
+}
+
+/* Tries to replace loop exit test USE, by one formulated in terms of a LT_EXPR
+   comparison with CAND.  Stores the resulting comparison in COMP_P and bound in
+   BOUND_P.  */
+
+static bool
+iv_elimination_compare_lt (struct ivopts_data *data, struct iv_use *use,
+                           struct iv_cand *cand, tree *bound_p,
+			   enum tree_code *comp_p)
+{
+  enum tree_code use_comp, canon_comp;
+  tree base_ptr, use_lt_bound, bound, *use_iv, base_cand_at_use;
+  bool ok;
+  tree use_type, cand_type, cand_iv_base = cand->iv->base;
+
+  /* Initialize cand_type, use_iv and use_type.  */
+  STRIP_NOPS (cand_iv_base);
+  cand_type = TREE_TYPE (cand_iv_base);
+  ok = extract_cond_operands (data, use->stmt, &use_iv, NULL, NULL, NULL);
+  gcc_assert (ok);
+  use_type = TREE_TYPE (*use_iv);
+
+  /* We're trying to replace 'i < n' with 'p < base + n' in
+
+     void
+     f1 (char *base, unsigned long int s, unsigned long int n)
+     {
+       unsigned long int i = s;
+       char *p = base + s;
+       do
+         {
+	   *p = '\0';
+	   p++;
+	   i++;
+	 }
+       while (i < n);
+     }
+
+     Overflow of base + n can't happen because either:
+     - s < n, and i will step to n, and p will step to base + n, or
+     - s >= n, so base + n < base + s, and assuming pointer arithmetic
+       doesn't overflow, base + s doesn't overflow, so base + n won't.
+
+     This transformation is not valid if i and n are signed, because
+     base + n might underflow.
+  */
+
+  /* Use should be an unsigned integral.  */
+  if (!INTEGRAL_TYPE_P (use_type) || !TYPE_UNSIGNED (use_type))
+    return false;
+
+  /* Cand should be a pointer, and pointer overflow should be undefined.  */
+  if (!POINTER_TYPE_P (cand_type) || !POINTER_TYPE_OVERFLOW_UNDEFINED)
+    return false;
+
+  /* Make sure that the loop iterates till the loop bound is hit.  */
+  if (!data->loop_single_exit_p)
+    return false;
+
+  /* We only handle this case for the moment.  */
+  if (!tree_int_cst_equal (use->iv->step, cand->iv->step))
+    return false;
+
+  if (cand->pos == IP_ORIGINAL)
+    {
+      /* If cand is a src level ptr iv, we know that
+	 cand->iv->base + nit * cand->iv->step won't overflow.  */
+
+      /* Now get the base of var_at_stmt (cand, use->stmt).  */
+      if (stmt_after_increment (data->current_loop, cand, use->stmt))
+	/* Get the base of var_after.  */
+	base_cand_at_use = fold_build_plus (PLUS_EXPR, cand->iv->base,
+					     cand->iv->step);
+      else
+	/* Get the base of var_before.  */
+	base_cand_at_use = cand->iv->base;
+    }
+  else
+    {
+      /* It is possible to also allow other pointer cands, provided we can prove
+	 cand->iv->base + nit * cand->iv->step doesn't overflow.  Return false
+	 for now.  */
+      return false;
+    }
+
+  /* Detect p = base + s.  */
+  base_ptr = fold_diff_to_ssa_name (base_cand_at_use,
+				    fold_convert (sizetype, use->iv->base));
+  if (base_ptr == NULL_TREE)
+    return false;
+  STRIP_NOPS (base_ptr);
+  /* Get the bound of the iv of the use.  */
+  if (!get_use_lt_bound (use, *use_iv, &use_lt_bound, &use_comp))
+    return false;
+
+  /* Determine canon_comp.  */
+  if (*comp_p == NE_EXPR)
+    canon_comp = use_comp;
+  else if (*comp_p == EQ_EXPR)
+    canon_comp = invert_tree_comparison (use_comp, false);
+  else
+    gcc_unreachable ();
+
+  /* Allow positive and negative step, and inclusive and exclusive bound.
+     To trigger inclusive bound, we need -funsafe-loop-optimizations.  */
+  if (canon_comp != LT_EXPR && canon_comp != GT_EXPR
+      && canon_comp != LE_EXPR && canon_comp != GE_EXPR)
+    return false;
+
+  /* Calculate bound.  */
+  bound = fold_build_plus (PLUS_EXPR, base_ptr,
+                           fold_convert (sizetype, use_lt_bound));
+  if (expression_expensive_p (bound))
+    return false;
+
+  *comp_p = use_comp;
+  *bound_p = bound;
+  return true;
+}
+
 /* Check whether it is possible to express the condition in USE by comparison
-   of candidate CAND.  If so, store the value compared with to BOUND.  */
+   of candidate CAND.  If so, store the value compared with to BOUND, and the
+   comparison operator to COMP.  */
 
 static bool
 may_eliminate_iv (struct ivopts_data *data,
-		  struct iv_use *use, struct iv_cand *cand, tree *bound)
+		  struct iv_use *use, struct iv_cand *cand, tree *bound,
+		  enum tree_code *comp)
 {
   basic_block ex_bb;
   edge exit;
@@ -4362,17 +4626,8 @@
   /* If the number of iterations is constant, compare against it directly.  */
   if (TREE_CODE (nit) == INTEGER_CST)
     {
-      /* See cand_value_at.  */
-      if (stmt_after_increment (loop, cand, use->stmt))
-        {
-          if (!tree_int_cst_lt (nit, period))
-            return false;
-        }
-      else
-        {
-          if (tree_int_cst_lt (period, nit))
-            return false;
-        }
+      if (tree_int_cst_lt (period, nit))
+        return false;
     }
 
   /* If not, and if this is the only possible exit of the loop, see whether
@@ -4383,8 +4638,6 @@
       double_int period_value, max_niter;
 
       max_niter = desc->max;
-      if (stmt_after_increment (loop, cand, use->stmt))
-        max_niter = double_int_add (max_niter, double_int_one);
       period_value = tree_to_double_int (period);
       if (double_int_ucmp (max_niter, period_value) > 0)
         {
@@ -4393,7 +4646,6 @@
             {
               if (!estimated_loop_iterations (loop, true, &max_niter))
                 return false;
-              /* The loop bound is already adjusted by adding 1.  */
               if (double_int_ucmp (max_niter, period_value) > 0)
                 return false;
             }
@@ -4405,6 +4657,23 @@
   cand_value_at (loop, cand, use->stmt, nit, &bnd);
 
   *bound = aff_combination_to_tree (&bnd);
+  *comp = iv_elimination_compare (data, use);
+
+  /* Try to implement nit using a '<' instead.  */
+  if (TREE_CODE (nit) == COND_EXPR)
+    {
+      if (iv_elimination_compare_lt (data, use, cand, bound, comp))
+        return true;
+
+      /* We could try to see if the non-lt bound is not too expensive, but the
+         cost infrastructure needs tuning for that first.  Even though
+         expression_expensive_p always returns true for COND_EXPRs, it happens
+         that the bound is folded into a MAX_EXPR, which is approved by
+         expression_expensive_p, but attributed a too low cost by force_var_cost
+         in case the MAX_EXPR would expand into control flow.  */
+      return false;
+    }
+
   /* It is unlikely that computing the number of iterations using division
      would be more profitable than keeping the original induction variable.  */
   if (expression_expensive_p (*bound))
@@ -4426,16 +4695,18 @@
   bool ok;
   int inv_expr_id = -1;
   tree *control_var, *bound_cst;
+  enum tree_code comp;
 
   /* Only consider real candidates.  */
   if (!cand->iv)
     {
-      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE, -1);
+      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE, -1,
+		       ERROR_MARK);
       return false;
     }
 
   /* Try iv elimination.  */
-  if (may_eliminate_iv (data, use, cand, &bound))
+  if (may_eliminate_iv (data, use, cand, &bound, &comp))
     {
       elim_cost = force_var_cost (data, bound, &depends_on_elim);
       /* The bound is a loop invariant, so it will be only computed
@@ -4482,9 +4753,10 @@
       depends_on = depends_on_express;
       depends_on_express = NULL;
       bound = NULL_TREE;
+      comp = ERROR_MARK;
     }
 
-  set_use_iv_cost (data, use, cand, cost, depends_on, bound, inv_expr_id);
+  set_use_iv_cost (data, use, cand, cost, depends_on, bound, inv_expr_id, comp);
 
   if (depends_on_elim)
     BITMAP_FREE (depends_on_elim);
@@ -6119,7 +6391,7 @@
           fprintf (dump_file, "Replacing exit test: ");
           print_gimple_stmt (dump_file, use->stmt, 0, TDF_SLIM);
         }
-      compare = iv_elimination_compare (data, use);
+      compare = cp->comp;
       bound = unshare_expr (fold_convert (var_type, bound));
       op = force_gimple_operand (bound, &stmts, true, NULL_TREE);
       if (stmts)
@@ -6351,7 +6623,7 @@
 {
   bool changed = false;
   struct iv_ca *iv_ca;
-  edge exit;
+  edge exit = single_dom_exit (loop);
   basic_block *body;
 
   gcc_assert (!data->niters);
@@ -6362,7 +6634,6 @@
     {
       fprintf (dump_file, "Processing loop %d\n", loop->num);
 
-      exit = single_dom_exit (loop);
       if (exit)
 	{
 	  fprintf (dump_file, "  single exit %d -> %d, exit condition ",
@@ -6379,6 +6650,8 @@
   renumber_gimple_stmt_uids_in_blocks (body, loop->num_nodes);
   free (body);
 
+  data->loop_single_exit_p = exit != NULL && loop_only_exit_p (loop, exit);
+
   /* For each ssa name determines whether it behaves as an induction variable
      in some loop.  */
   if (!find_induction_variables (data))
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc: tree-ssa-loop-promote.c
diff -ru ./gcc/tree-ssa-pre.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-pre.c
--- ./gcc/tree-ssa-pre.c	2014-06-06 11:50:27.151599042 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-pre.c	2012-03-29 18:03:19.000000000 +1000
@@ -3495,6 +3495,47 @@
 }
 
 
+/* Indicate if, when optimizing for speed, it is appropriate to make
+   INSERTS_NEEDED insertions in order to make EXPR in BLOCK redundant.  */
+static bool
+ppre_n_insert_for_speed_p (pre_expr expr, basic_block block,
+			   unsigned int inserts_needed)
+{
+  /* The more expensive EXPR is, the more we should be prepared to insert
+     in the predecessors of BLOCK to make EXPR fully redundant.
+     For now, only recognize AND, OR, XOR, PLUS and MINUS of a multiple-use
+     SSA_NAME with a constant as cheap.  */
+  int cost;
+
+  if (flag_tree_pre_partial_partial_obliviously)
+    return true;
+  if (expr->kind == NARY)
+    {
+      vn_nary_op_t nary = PRE_EXPR_NARY (expr);
+      switch (nary->opcode)
+	{
+	  tree name, cnst;
+	case BIT_AND_EXPR: case BIT_IOR_EXPR: case BIT_XOR_EXPR:
+	case PLUS_EXPR: case MINUS_EXPR:
+
+	  gcc_assert (nary->length == 2);
+	  name = nary->op[0];
+	  cnst = nary->op[1];
+	  if (TREE_CODE (name) != SSA_NAME || has_single_use (name))
+	    return true;
+	  if (!is_gimple_min_invariant (cnst))
+	    return true;
+	  cost = 1;
+	  break;
+	default:
+	  return true;
+	}
+    }
+  else
+    return true;
+  return EDGE_COUNT (block->preds) * cost >= inserts_needed;
+
+}
 
 /* Perform insertion of partially redundant values.
    For BLOCK, do the following:
@@ -3749,10 +3790,23 @@
 	  if (!cant_insert && by_all && dbg_cnt (treepre_insert))
 	    {
 	      pre_stats.pa_insert++;
-	      if (insert_into_preds_of_block (block, get_expression_id (expr),
-					      avail))
-		new_stuff = true;
-	    }
+	      /* Assuming the expression is 50% anticipatable, we have
+		 to multiply the number of insertions needed by two for a cost
+		 comparison.  */
+	      if (!optimize_function_for_speed_p (cfun)
+		  || ppre_n_insert_for_speed_p (expr, block,
+						2 * EDGE_COUNT (block->preds)))
+		{
+		  if (insert_into_preds_of_block (block,
+						  get_expression_id (expr),
+						  avail))
+		    new_stuff = true;
+		}  
+	      else if (dump_file && (dump_flags & TDF_DETAILS))
+		fprintf (dump_file, "Not inserting (optimizing for %s)\n",
+			 optimize_function_for_speed_p (cfun)
+			 ? "speed" : "size");
+	    }	    
 	  free (avail);
 	}
     }
@@ -4838,7 +4892,8 @@
 {
   unsigned int todo = 0;
 
-  do_partial_partial = optimize > 2 && optimize_function_for_speed_p (cfun);
+  do_partial_partial =
+    flag_tree_pre_partial_partial && optimize_function_for_speed_p (cfun);
 
   /* This has to happen before SCCVN runs because
      loop_optimizer_init may create new phis, etc.  */
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc: tree-ssa-remove-local-statics.c
diff -ru ./gcc/tree-ssa-sccvn.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-sccvn.c
--- ./gcc/tree-ssa-sccvn.c	2014-06-06 11:50:27.207599045 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-sccvn.c	2012-03-29 18:03:19.000000000 +1000
@@ -684,6 +684,7 @@
 	case COMPLEX_CST:
 	case VECTOR_CST:
 	case REAL_CST:
+	case FIXED_CST:
 	case CONSTRUCTOR:
 	case VAR_DECL:
 	case PARM_DECL:
diff -ru ./gcc/tree-ssa-sink.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-sink.c
--- ./gcc/tree-ssa-sink.c	2014-06-06 11:50:27.211599045 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-sink.c	2012-03-29 18:03:19.000000000 +1000
@@ -478,6 +478,7 @@
 	  last = false;
 	  continue;
 	}
+
       if (dump_file)
 	{
 	  fprintf (dump_file, "Sinking ");
diff -ru ./gcc/tree-ssa-uninit.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-uninit.c
--- ./gcc/tree-ssa-uninit.c	2014-06-06 11:50:27.275599047 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/tree-ssa-uninit.c	2012-03-29 18:03:19.000000000 +1000
@@ -1605,6 +1605,157 @@
   return true;
 }
 
+/* Comparison function used by qsort. It is used to
+   sort predicate chains to allow predicate
+   simplification.  */
+
+static int
+pred_chain_length_cmp (const void *p1, const void *p2)
+{
+  use_pred_info_t i1, i2;
+  VEC(use_pred_info_t, heap) * const *chain1
+      = (VEC(use_pred_info_t, heap) * const *)p1;
+  VEC(use_pred_info_t, heap) * const *chain2
+      = (VEC(use_pred_info_t, heap) * const *)p2;
+
+  if (VEC_length (use_pred_info_t, *chain1)
+      != VEC_length (use_pred_info_t, *chain2))
+    return (VEC_length (use_pred_info_t, *chain1)
+            - VEC_length (use_pred_info_t, *chain2));
+
+  i1 = VEC_index (use_pred_info_t, *chain1, 0);
+  i2 = VEC_index (use_pred_info_t, *chain2, 0);
+
+  /* Allow predicates with similar prefix come together.  */
+  if (!i1->invert && i2->invert)
+    return -1;
+  else if (i1->invert && !i2->invert)
+    return 1;
+
+  return gimple_uid (i1->cond) - gimple_uid (i2->cond);
+}
+
+/* x OR (!x AND y) is equivalent to x OR y.
+   This function normalizes x1 OR (!x1 AND x2) OR (!x1 AND !x2 AND x3)
+   into x1 OR x2 OR x3.  PREDS is the predicate chains, and N is
+   the number of chains. Returns true if normalization happens.  */
+
+static bool
+normalize_preds (VEC(use_pred_info_t, heap) **preds, size_t *n)
+{
+  size_t i, j, ll;
+  VEC(use_pred_info_t, heap) *pred_chain;
+  VEC(use_pred_info_t, heap) *x = 0;
+  use_pred_info_t xj = 0, nxj = 0;
+
+  if (*n < 2)
+    return false;
+
+  /* First sort the chains in ascending order of lengths.  */
+  qsort (preds, *n, sizeof (void *), pred_chain_length_cmp);
+  pred_chain = preds[0];
+  ll = VEC_length (use_pred_info_t, pred_chain);
+  if (ll != 1)
+   {
+     if (ll == 2)
+       {
+         use_pred_info_t xx, yy, xx2, nyy;
+         VEC(use_pred_info_t, heap) *pred_chain2 = preds[1];
+         if (VEC_length (use_pred_info_t, pred_chain2) != 2)
+           return false;
+
+         /* See if simplification x AND y OR x AND !y is possible.  */
+         xx = VEC_index (use_pred_info_t, pred_chain, 0);
+         yy = VEC_index (use_pred_info_t, pred_chain, 1);
+         xx2 = VEC_index (use_pred_info_t, pred_chain2, 0);
+         nyy = VEC_index (use_pred_info_t, pred_chain2, 1);
+         if (gimple_cond_lhs (xx->cond) != gimple_cond_lhs (xx2->cond)
+             || gimple_cond_rhs (xx->cond) != gimple_cond_rhs (xx2->cond)
+             || gimple_cond_code (xx->cond) != gimple_cond_code (xx2->cond)
+             || (xx->invert != xx2->invert))
+           return false;
+         if (gimple_cond_lhs (yy->cond) != gimple_cond_lhs (nyy->cond)
+             || gimple_cond_rhs (yy->cond) != gimple_cond_rhs (nyy->cond)
+             || gimple_cond_code (yy->cond) != gimple_cond_code (nyy->cond)
+             || (yy->invert == nyy->invert))
+           return false;
+
+         /* Now merge the first two chains.  */
+         free (yy);
+         free (nyy);
+         free (xx2);
+         VEC_free (use_pred_info_t, heap, pred_chain);
+         VEC_free (use_pred_info_t, heap, pred_chain2);
+         pred_chain = 0;
+         VEC_safe_push (use_pred_info_t, heap, pred_chain, xx);
+         preds[0] = pred_chain;
+         for (i = 1; i < *n - 1; i++)
+           preds[i] = preds[i + 1];
+
+         preds[*n - 1] = 0;
+         *n = *n - 1;
+       }
+     else
+       return false;
+   }
+
+  VEC_safe_push (use_pred_info_t, heap, x,
+                 VEC_index (use_pred_info_t, pred_chain, 0));
+
+  /* The loop extracts x1, x2, x3, etc from chains
+     x1 OR (!x1 AND x2) OR (!x1 AND !x2 AND x3) OR ...  */
+  for (i = 1; i < *n; i++)
+    {
+      pred_chain = preds[i];
+      if (VEC_length (use_pred_info_t, pred_chain) != i + 1)
+        return false;
+
+      for (j = 0; j < i; j++)
+        {
+          xj = VEC_index (use_pred_info_t, x, j);
+          nxj = VEC_index (use_pred_info_t, pred_chain, j);
+
+          /* Check if nxj is !xj  */
+          if (gimple_cond_lhs (xj->cond) != gimple_cond_lhs (nxj->cond)
+              || gimple_cond_rhs (xj->cond) != gimple_cond_rhs (nxj->cond)
+              || gimple_cond_code (xj->cond) != gimple_cond_code (nxj->cond)
+              || (xj->invert == nxj->invert))
+            return false;
+        }
+
+      VEC_safe_push (use_pred_info_t, heap, x,
+                     VEC_index (use_pred_info_t, pred_chain, i));
+    }
+
+  /* Now normalize the pred chains using the extraced x1, x2, x3 etc.  */
+  for (j = 0; j < *n; j++)
+    {
+      use_pred_info_t t;
+      xj = VEC_index (use_pred_info_t, x, j);
+
+      t = XNEW (struct use_pred_info);
+      *t = *xj;
+
+      VEC_replace (use_pred_info_t, x, j, t);
+    }
+
+  for (i = 0; i < *n; i++)
+    {
+      pred_chain = preds[i];
+      for (j = 0; j < VEC_length (use_pred_info_t, pred_chain); j++)
+        free (VEC_index (use_pred_info_t, pred_chain, j));
+      VEC_free (use_pred_info_t, heap, pred_chain);
+      pred_chain = 0;
+      /* A new chain.  */
+      VEC_safe_push (use_pred_info_t, heap, pred_chain,
+                     VEC_index (use_pred_info_t, x, i));
+      preds[i] = pred_chain;
+    }
+  return true;
+}
+
+
+
 /* Computes the predicates that guard the use and checks
    if the incoming paths that have empty (or possibly
    empty) defintion can be pruned/filtered. The function returns
@@ -1658,9 +1809,18 @@
 
   if (has_valid_preds)
     {
+      bool normed;
       if (dump_file)
         dump_predicates (phi, num_def_preds, def_preds,
                          "Operand defs of phi ");
+
+      normed = normalize_preds (def_preds, &num_def_preds);
+      if (normed && dump_file)
+        {
+          fprintf (dump_file, "\nNormalized to\n");
+          dump_predicates (phi, num_def_preds, def_preds,
+                           "Operand defs of phi ");
+        }
       is_properly_guarded =
           is_superset_of (def_preds, num_def_preds,
                           preds, num_preds);
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc: unwind-compact.c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc: unwind-compact.h
diff -ru ./gcc/unwind-compat.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-compat.c
--- ./gcc/unwind-compat.c	2014-06-06 11:50:27.471599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-compat.c	2012-04-28 17:58:33.000000000 +1000
@@ -207,4 +207,14 @@
   return __libunwind_Unwind_SetIP (context, val);
 }
 symver (_Unwind_SetIP, GCC_3.0);
+
+extern unsigned char __libunwind_Unwind_GetEhEncoding
+  (struct _Unwind_Context *);
+
+unsigned char
+_Unwind_GetEhEncoding (struct _Unwind_Context *context)
+{
+  return __libunwind_Unwind_GetEhEncoding (context, val);
+}
+symver (_Unwind_GetEhEncoding, GCC_3.0);
 #endif
diff -ru ./gcc/unwind-dw2.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2.c
--- ./gcc/unwind-dw2.c	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2.c	2012-04-28 17:58:33.000000000 +1000
@@ -327,6 +327,12 @@
 {
   return (_Unwind_Ptr) context->bases.tbase;
 }
+
+unsigned char
+_Unwind_GetEhEncoding (struct _Unwind_Context *context)
+{
+  return context->bases.eh_encoding;
+}
 #endif
 
 #ifdef MD_UNWIND_SUPPORT
@@ -1115,6 +1121,79 @@
     }
 }
 
+#ifdef MD_HAVE_COMPACT_EH
+static _Unwind_Reason_Code
+__gnu_compact_pr1 (int version ATTRIBUTE_UNUSED,
+		  _Unwind_Action actions ATTRIBUTE_UNUSED,
+		  _Unwind_Exception_Class exception_class ATTRIBUTE_UNUSED,
+		  struct _Unwind_Exception *ue_header ATTRIBUTE_UNUSED,
+		  struct _Unwind_Context *context ATTRIBUTE_UNUSED)
+{
+  return _URC_CONTINUE_UNWIND;
+}
+
+/* The C++ EH routines need to live in the C++ runtime.  These should
+   be pulled in via the unwinding tables when needed.  */
+extern _Unwind_Reason_Code __gnu_compact_pr2 (int,
+    _Unwind_Action, _Unwind_Exception_Class, struct _Unwind_Exception *,
+    struct _Unwind_Context *) TARGET_ATTRIBUTE_WEAK;
+extern _Unwind_Reason_Code __gnu_compact_pr3 (int,
+    _Unwind_Action, _Unwind_Exception_Class, struct _Unwind_Exception *,
+    struct _Unwind_Context *) TARGET_ATTRIBUTE_WEAK;
+
+static _Unwind_Reason_Code
+uw_frame_state_compact (struct _Unwind_Context *context,
+			_Unwind_FrameState *fs,
+			enum compact_entry_type entry_type,
+		       	struct compact_eh_bases *bases)
+{
+  const unsigned char *p;
+  unsigned int pr_index;
+  _Unwind_Ptr personality;
+  unsigned char buf[4];
+  _Unwind_Reason_Code rc;
+
+  p = bases->entry;
+  pr_index = *(p++);
+  switch (pr_index) {
+  case 0:
+      p = read_encoded_value (context, bases->eh_encoding, p, &personality);
+      fs->personality = (_Unwind_Personality_Fn)personality;
+      break;
+  case 1:
+      fs->personality = __gnu_compact_pr1;
+      break;
+  case 2:
+      fs->personality = __gnu_compact_pr2;
+      break;
+  case 3:
+      fs->personality = __gnu_compact_pr3;
+      break;
+  default:
+      fs->personality = NULL;
+  }
+
+  if (!fs->personality)
+    return _URC_FATAL_PHASE1_ERROR;
+
+  if (entry_type == CET_inline)
+    {
+      memcpy(buf, p, 3);
+      buf[3] = 0x5c;
+      p = buf;
+    }
+
+  rc = md_unwind_compact (context, fs, &p);
+  if (rc != _URC_NO_REASON)
+      return rc;
+
+  if (entry_type == CET_outline)
+    context->lsda = (void *)(_Unwind_Internal_Ptr)p;
+
+  return _URC_NO_REASON;
+}
+#endif
+
 /* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for
    its caller and decode it into FS.  This function also sets the
    args_size and lsda members of CONTEXT, as they are really information
@@ -1134,8 +1213,27 @@
   if (context->ra == 0)
     return _URC_END_OF_STACK;
 
+#ifdef MD_HAVE_COMPACT_EH
+    {
+      struct compact_eh_bases bases;
+      enum compact_entry_type type;
+      type = _Unwind_Find_Index (context->ra + _Unwind_IsSignalFrame (context)
+				 - 1, &bases);
+      context->bases.tbase = bases.tbase;
+      context->bases.dbase = bases.dbase;
+      context->bases.func = bases.func;
+      context->bases.eh_encoding = bases.eh_encoding;
+      if (type == CET_inline || type == CET_outline)
+	return uw_frame_state_compact (context, fs, type, &bases);
+      if (type == CET_FDE)
+	fde = bases.entry;
+      else
+	fde = NULL;
+    }
+#else
   fde = _Unwind_Find_FDE (context->ra + _Unwind_IsSignalFrame (context) - 1,
 			  &context->bases);
+#endif
   if (fde == NULL)
     {
 #ifdef MD_FALLBACK_FRAME_STATE_FOR
@@ -1423,16 +1521,12 @@
 /* Fill in CONTEXT for top-of-stack.  The only valid registers at this
    level will be the return address and the CFA.  */
 
-#define uw_init_context(CONTEXT)					   \
-  do									   \
-    {									   \
-      /* Do any necessary initialization to access arbitrary stack frames. \
-	 On the SPARC, this means flushing the register windows.  */	   \
-      __builtin_unwind_init ();						   \
-      uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \
-			 __builtin_return_address (0));			   \
-    }									   \
-  while (0)
+#define uw_init_context(CONTEXT)					\
+  /* Do any necessary initialization to access arbitrary stack frames.	\
+     On the SPARC, this means flushing the register windows.  */	\
+  (__builtin_unwind_init (),						\
+   uw_init_context_1 ((CONTEXT), __builtin_dwarf_cfa (),		\
+		      __builtin_return_address (0)))
 
 static inline void
 init_dwarf_reg_size_table (void)
@@ -1440,7 +1534,7 @@
   __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);
 }
 
-static void __attribute__((noinline))
+static _Unwind_Reason_Code __attribute__((noinline))
 uw_init_context_1 (struct _Unwind_Context *context,
 		   void *outer_cfa, void *outer_ra)
 {
@@ -1454,7 +1548,8 @@
   context->flags = EXTENDED_CONTEXT_BIT;
 
   code = uw_frame_state_for (context, &fs);
-  gcc_assert (code == _URC_NO_REASON);
+  if (code != _URC_NO_REASON)
+    return code;
 
 #if __GTHREADS
   {
@@ -1480,6 +1575,8 @@
      initialization context, then we can't see it in the given
      call frame data.  So have the initialization context tell us.  */
   context->ra = __builtin_extract_return_addr (outer_ra);
+
+  return _URC_NO_REASON;
 }
 
 static void _Unwind_DebugHook (void *, void *)
@@ -1598,6 +1695,7 @@
 alias (_Unwind_Resume_or_Rethrow);
 alias (_Unwind_SetGR);
 alias (_Unwind_SetIP);
+alias (_Unwind_GetEhEncoding);
 #endif
 
 #endif /* !USING_SJLJ_EXCEPTIONS */
diff -ru ./gcc/unwind-dw2-fde.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2-fde.c
--- ./gcc/unwind-dw2-fde.c	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2-fde.c	2012-03-29 18:03:19.000000000 +1000
@@ -24,7 +24,8 @@
 see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 <http://www.gnu.org/licenses/>.  */
 
-#ifndef _Unwind_Find_FDE
+#ifndef _Unwind_Find_registered_Index
+#define _Unwind_Find_registered_Index _Unwind_Find_Index
 #include "tconfig.h"
 #include "tsystem.h"
 #include "coretypes.h"
@@ -35,6 +36,9 @@
 #include "unwind-pe.h"
 #include "unwind-dw2-fde.h"
 #include "gthr.h"
+#ifdef MD_HAVE_COMPACT_EH
+#include "unwind-compact.h"
+#endif
 #endif
 
 /* The unseen_objects list contains objects that have been registered
@@ -67,22 +71,20 @@
 #define init_object_mutex_once()
 #endif
 
-/* Called from crtbegin.o to register the unwind info for an object.  */
+/* Initialize OB and add to list of objects.  */
 
-void
-__register_frame_info_bases (const void *begin, struct object *ob,
-			     void *tbase, void *dbase)
+static void
+__register_frame_info_1 (const void *begin, struct object *ob,
+			  void *tbase, void *dbase, int header)
 {
-  /* If .eh_frame is empty, don't register at all.  */
-  if ((const uword *) begin == 0 || *(const uword *) begin == 0)
-    return;
-
   ob->pc_begin = (void *)-1;
   ob->tbase = tbase;
   ob->dbase = dbase;
   ob->u.single = begin;
   ob->s.i = 0;
   ob->s.b.encoding = DW_EH_PE_omit;
+  ob->s.b.header = header;
+  ob->s.b.mixed_encoding = header;
 #ifdef DWARF2_OBJECT_END_PTR_EXTENSION
   ob->fde_end = NULL;
 #endif
@@ -96,6 +98,34 @@
   __gthread_mutex_unlock (&object_mutex);
 }
 
+/* Called from crtbegin.o to register the unwind info for an object.  */
+
+void
+__register_frame_info_header_bases (const void *begin, struct object *ob,
+				    void *tbase, void *dbase)
+{
+  /* Only register compact EH frame headers.  */
+  if (begin == NULL || *(const char *) begin != 2)
+    return;
+
+#ifdef MD_HAVE_COMPACT_EH
+  __register_frame_info_1 (begin, ob, tbase, dbase, 1);
+#endif
+}
+
+/* Called from crtbegin.o to register the unwind info for an object.  */
+
+void
+__register_frame_info_bases (const void *begin, struct object *ob,
+			     void *tbase, void *dbase)
+{
+  /* If .eh_frame is empty, don't register at all.  */
+  if ((const uword *) begin == 0 || *(const uword *) begin == 0)
+    return;
+
+  __register_frame_info_1 (begin, ob, tbase, dbase, 0);
+}
+
 void
 __register_frame_info (const void *begin, struct object *ob)
 {
@@ -947,9 +977,25 @@
   return NULL;
 }
 
-static const fde *
-search_object (struct object* ob, void *pc)
+static enum compact_entry_type
+search_object (struct object* ob, void *pc, struct compact_eh_bases *bases)
 {
+  const fde *f = NULL;
+
+#ifdef MD_HAVE_COMPACT_EH
+  if (ob->s.b.header)
+    {
+      const unsigned char *hdr = (const unsigned char *) ob->u.single;
+      if (ob->pc_begin == (void *) -1)
+	{
+	  const sword *first = (const sword *) (hdr + 8);
+	  ob->pc_begin = (void *)((*first & ~1) + (_Unwind_Ptr) first);
+	}
+
+      return _Unwind_Search_Compact_eh_hdr (pc, hdr, bases);
+    }
+#endif
+
   /* If the data hasn't been sorted, try to do this now.  We may have
      more memory available than last time we tried.  */
   if (! ob->s.b.sorted)
@@ -960,17 +1006,17 @@
 	 that we've not processed this object before.  A quick range
 	 check is in order.  */
       if (pc < ob->pc_begin)
-	return NULL;
+	return CET_not_found;
     }
 
   if (ob->s.b.sorted)
     {
       if (ob->s.b.mixed_encoding)
-	return binary_search_mixed_encoding_fdes (ob, pc);
+	f = binary_search_mixed_encoding_fdes (ob, pc);
       else if (ob->s.b.encoding == DW_EH_PE_absptr)
-	return binary_search_unencoded_fdes (ob, pc);
+	f = binary_search_unencoded_fdes (ob, pc);
       else
-	return binary_search_single_encoding_fdes (ob, pc);
+	f = binary_search_single_encoding_fdes (ob, pc);
     }
   else
     {
@@ -980,22 +1026,24 @@
 	  fde **p;
 	  for (p = ob->u.array; *p ; p++)
 	    {
-	      const fde *f = linear_search_fdes (ob, *p, pc);
+	      f = linear_search_fdes (ob, *p, pc);
 	      if (f)
-		return f;
+		break;
 	    }
-	  return NULL;
 	}
       else
-	return linear_search_fdes (ob, ob->u.single, pc);
+	f = linear_search_fdes (ob, ob->u.single, pc);
     }
+
+  bases->entry = f;
+  return f ? CET_FDE : CET_not_found;
 }
 
-const fde *
-_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
+enum compact_entry_type
+_Unwind_Find_registered_Index (void *pc, struct compact_eh_bases *bases)
 {
   struct object *ob;
-  const fde *f = NULL;
+  enum compact_entry_type t;
 
   init_object_mutex_once ();
   __gthread_mutex_lock (&object_mutex);
@@ -1006,8 +1054,8 @@
   for (ob = seen_objects; ob; ob = ob->next)
     if (pc >= ob->pc_begin)
       {
-	f = search_object (ob, pc);
-	if (f)
+	t = search_object (ob, pc, bases);
+	if (t != CET_not_found)
 	  goto fini;
 	break;
       }
@@ -1018,7 +1066,7 @@
       struct object **p;
 
       unseen_objects = ob->next;
-      f = search_object (ob, pc);
+      t = search_object (ob, pc, bases);
 
       /* Insert the object into the classified list.  */
       for (p = &seen_objects; *p ; p = &(*p)->next)
@@ -1027,21 +1075,26 @@
       ob->next = *p;
       *p = ob;
 
-      if (f)
+      if (t != CET_not_found)
 	goto fini;
     }
 
  fini:
   __gthread_mutex_unlock (&object_mutex);
 
-  if (f)
+  if (t == CET_not_found)
+    return CET_not_found;
+
+  bases->tbase = ob->tbase;
+  bases->dbase = ob->dbase;
+
+  if (t == CET_FDE)
     {
+      const fde *f;
       int encoding;
       _Unwind_Ptr func;
 
-      bases->tbase = ob->tbase;
-      bases->dbase = ob->dbase;
-
+      f = bases->entry;
       encoding = ob->s.b.encoding;
       if (ob->s.b.mixed_encoding)
 	encoding = get_fde_encoding (f);
@@ -1050,5 +1103,21 @@
       bases->func = (void *) func;
     }
 
-  return f;
+  return t;
+}
+
+const fde *
+_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
+{
+  enum compact_entry_type type;
+  struct compact_eh_bases data;
+
+  type = _Unwind_Find_Index (pc, &data);
+  if (type != CET_FDE)
+    return NULL;
+
+  bases->tbase = data.tbase;
+  bases->dbase = data.dbase;
+  bases->func = data.func;
+  return (const fde *) data.entry;
 }
diff -ru ./gcc/unwind-dw2-fde-glibc.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2-fde-glibc.c
--- ./gcc/unwind-dw2-fde-glibc.c	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2-fde-glibc.c	2012-03-29 18:03:19.000000000 +1000
@@ -45,6 +45,9 @@
 #include "unwind-dw2-fde.h"
 #include "unwind-compat.h"
 #include "gthr.h"
+#ifdef MD_HAVE_COMPACT_EH
+#include "unwind-compact.h"
+#endif
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
     && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \
@@ -72,11 +75,11 @@
 # define __RELOC_POINTER(ptr, base) ((ptr) + (base))
 #endif
 
-static const fde * _Unwind_Find_registered_FDE (void *pc, struct dwarf_eh_bases *bases);
+static enum compact_entry_type
+_Unwind_Find_registered_Index (void *pc, struct compact_eh_bases *bases);
 
-#define _Unwind_Find_FDE _Unwind_Find_registered_FDE
+#define _Unwind_Find_registered_Index _Unwind_Find_registered_Index
 #include "unwind-dw2-fde.c"
-#undef _Unwind_Find_FDE
 
 #ifndef PT_GNU_EH_FRAME
 #define PT_GNU_EH_FRAME (PT_LOOS + 0x474e550)
@@ -85,10 +88,8 @@
 struct unw_eh_callback_data
 {
   _Unwind_Ptr pc;
-  void *tbase;
-  void *dbase;
-  void *func;
-  const fde *ret;
+  struct compact_eh_bases *bases;
+  enum compact_entry_type type;
   int check_cache;
 };
 
@@ -131,9 +132,9 @@
       return 0;
 
     case DW_EH_PE_textrel:
-      return (_Unwind_Ptr) data->tbase;
+      return (_Unwind_Ptr) data->bases->tbase;
     case DW_EH_PE_datarel:
-      return (_Unwind_Ptr) data->dbase;
+      return (_Unwind_Ptr) data->bases->dbase;
     default:
       gcc_unreachable ();
     }
@@ -155,6 +156,7 @@
   _Unwind_Ptr eh_frame;
   struct object ob;
   _Unwind_Ptr pc_low = 0, pc_high = 0;
+  const fde *f;
 
   struct ext_dl_phdr_info
     {
@@ -303,12 +305,10 @@
   /* Read .eh_frame_hdr header.  */
   hdr = (const struct unw_eh_frame_hdr *)
     __RELOC_POINTER (p_eh_frame_hdr->p_vaddr, load_base);
-  if (hdr->version != 1)
-    return 1;
 
 #ifdef CRT_GET_RFIB_DATA
-# ifdef __i386__
-  data->dbase = NULL;
+# if defined(__i386__) || defined(__mips__)
+  data->bases->dbase = NULL;
   if (p_dynamic)
     {
       /* For dynamically linked executables and shared libraries,
@@ -318,19 +318,22 @@
       for (; dyn->d_tag != DT_NULL ; dyn++)
 	if (dyn->d_tag == DT_PLTGOT)
 	  {
-	    data->dbase = (void *) dyn->d_un.d_ptr;
-#if defined __linux__
+	    data->bases->dbase = (void *) dyn->d_un.d_ptr;
+#if defined(__mips__)
+	    /* On MIPS we need to relocate the value and offset.  */
+	    data->bases->dbase += load_base + 0x7ff0;
+#elif defined __linux__
 	    /* On IA-32 Linux, _DYNAMIC is writable and GLIBC has
 	       relocated it.  */
 #elif defined __sun__ && defined __svr4__
 	    /* On Solaris 2/x86, we need to do this ourselves.  */
-	    data->dbase += load_base;
+	    data->bases->dbase += load_base;
 #endif
 	    break;
 	  }
     }
 # elif defined __FRV_FDPIC__ && defined __linux__
-  data->dbase = load_base.got_value;
+  data->bases->dbase = load_base.got_value;
 # elif defined __x86_64__ && defined __sun__ && defined __svr4__
   /* While CRT_GET_RFIB_DATA is also defined for 64-bit Solaris 10+/x86, it
      doesn't apply since it uses DW_EH_PE_pcrel encoding.  */
@@ -339,6 +342,18 @@
 # endif
 #endif
 
+#ifdef MD_HAVE_COMPACT_EH
+  if (hdr->version == 2)
+    {
+      data->type = _Unwind_Search_Compact_eh_hdr ((void *)data->pc,
+	  (const unsigned char *) hdr, data->bases);
+      return 1;
+    }
+#endif
+
+  if (hdr->version != 1)
+    return 1;
+
   p = read_encoded_value_with_base (hdr->eh_frame_ptr_enc,
 				    base_from_cb_data (hdr->eh_frame_ptr_enc,
 						       data),
@@ -369,7 +384,6 @@
 	  const struct fde_table *table = (const struct fde_table *) p;
 	  size_t lo, hi, mid;
 	  _Unwind_Ptr data_base = (_Unwind_Ptr) hdr;
-	  fde *f;
 	  unsigned int f_enc, f_enc_size;
 	  _Unwind_Ptr range;
 
@@ -401,8 +415,11 @@
 	  read_encoded_value_with_base (f_enc & 0x0f, 0,
 					&f->pc_begin[f_enc_size], &range);
 	  if (data->pc < table[mid].initial_loc + data_base + range)
-	    data->ret = f;
-	  data->func = (void *) (table[mid].initial_loc + data_base);
+	    {
+	      data->bases->entry = f;
+	      data->type = CET_FDE;
+	    }
+	  data->bases->func = (void *) (table[mid].initial_loc + data_base);
 	  return 1;
 	}
     }
@@ -411,58 +428,55 @@
      As soon as GLIBC will provide API so to notify that a library has been
      removed, we could cache this (and thus use search_object).  */
   ob.pc_begin = NULL;
-  ob.tbase = data->tbase;
-  ob.dbase = data->dbase;
+  ob.tbase = data->bases->tbase;
+  ob.dbase = data->bases->dbase;
   ob.u.single = (fde *) eh_frame;
   ob.s.i = 0;
   ob.s.b.mixed_encoding = 1;  /* Need to assume worst case.  */
-  data->ret = linear_search_fdes (&ob, (fde *) eh_frame, (void *) data->pc);
-  if (data->ret != NULL)
+  f = linear_search_fdes (&ob, (fde *) eh_frame, (void *) data->pc);
+  data->bases->entry = f;
+  if (f != NULL)
     {
       _Unwind_Ptr func;
-      unsigned int encoding = get_fde_encoding (data->ret);
+      unsigned int encoding = get_fde_encoding (f);
 
       read_encoded_value_with_base (encoding,
 				    base_from_cb_data (encoding, data),
-				    data->ret->pc_begin, &func);
-      data->func = (void *) func;
+				    f->pc_begin, &func);
+      data->bases->func = (void *) func;
+      data->type = CET_FDE;
     }
   return 1;
 }
 
-const fde *
-_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)
+enum compact_entry_type
+_Unwind_Find_Index (void *pc, struct compact_eh_bases *bases)
 {
   struct unw_eh_callback_data data;
-  const fde *ret;
 
-  ret = _Unwind_Find_registered_FDE (pc, bases);
-  if (ret != NULL)
-    return ret;
+  data.type = _Unwind_Find_registered_Index (pc, bases);
+  if (data.type != CET_not_found)
+    return data.type;
 
   data.pc = (_Unwind_Ptr) pc;
-  data.tbase = NULL;
-  data.dbase = NULL;
-  data.func = NULL;
-  data.ret = NULL;
+  data.bases = bases;
+  data.type = CET_not_found;
   data.check_cache = 1;
 
   if (dl_iterate_phdr (_Unwind_IteratePhdrCallback, &data) < 0)
-    return NULL;
+    return CET_not_found;
 
-  if (data.ret)
-    {
-      bases->tbase = data.tbase;
-      bases->dbase = data.dbase;
-      bases->func = data.func;
-    }
-  return data.ret;
+  if (data.type != CET_not_found)
+    return data.type;
+
+  return CET_not_found;
 }
 
-#else
-/* Prevent multiple include of header files.  */
-#define _Unwind_Find_FDE _Unwind_Find_FDE
+#else /* !USE_PT_GNU_EH_FRAME */
+
+#define _Unwind_Find_registered_Index _Unwind_Find_Index
 #include "unwind-dw2-fde.c"
+
 #endif
 
 #if defined (USE_GAS_SYMVER) && defined (SHARED) && defined (USE_LIBUNWIND_EXCEPTIONS)
diff -ru ./gcc/unwind-dw2-fde.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2-fde.h
--- ./gcc/unwind-dw2-fde.h	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-dw2-fde.h	2012-04-28 17:58:33.000000000 +1000
@@ -54,10 +54,11 @@
       unsigned long sorted : 1;
       unsigned long from_array : 1;
       unsigned long mixed_encoding : 1;
+      unsigned long header : 1;
       unsigned long encoding : 8;
       /* ??? Wish there was an easy way to detect a 64-bit host here;
 	 we've got 32 bits left to play with...  */
-      unsigned long count : 21;
+      unsigned long count : 20;
     } b;
     size_t i;
   } s;
@@ -88,9 +89,12 @@
   void *tbase;
   void *dbase;
   void *func;
+  unsigned char eh_encoding;
 };
 
 
+extern void __register_frame_info_header_bases (const void *, struct object *,
+						void *, void *);
 extern void __register_frame_info_bases (const void *, struct object *,
 					 void *, void *);
 extern void __register_frame_info (const void *, struct object *);
@@ -166,6 +170,23 @@
 
 extern const fde * _Unwind_Find_FDE (void *, struct dwarf_eh_bases *);
 
+struct compact_eh_bases {
+    void *tbase;
+    void *dbase;
+    void *func;
+    const void *entry;
+    unsigned char eh_encoding;
+};
+enum compact_entry_type {
+    CET_not_found,
+    CET_FDE,
+    CET_inline,
+    CET_outline
+};
+
+extern enum compact_entry_type _Unwind_Find_Index (void *,
+    struct compact_eh_bases *);
+
 static inline int
 last_fde (struct object *obj __attribute__ ((__unused__)), const fde *f)
 {
diff -ru ./gcc/unwind-generic.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-generic.h
--- ./gcc/unwind-generic.h	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-generic.h	2012-04-28 17:58:33.000000000 +1000
@@ -164,6 +164,8 @@
 extern _Unwind_Ptr _Unwind_GetIPInfo (struct _Unwind_Context *, int *);
 extern void _Unwind_SetIP (struct _Unwind_Context *, _Unwind_Ptr);
 
+extern unsigned char _Unwind_GetEhEncoding (struct _Unwind_Context *);
+
 /* @@@ Retrieve the CFA of the given context.  */
 extern _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);
 
diff -ru ./gcc/unwind.inc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind.inc
--- ./gcc/unwind.inc	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind.inc	2012-03-29 18:03:19.000000000 +1000
@@ -85,7 +85,8 @@
   _Unwind_Reason_Code code;
 
   /* Set up this_context to describe the current stack frame.  */
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   /* Phase 1: Search.  Unwind the stack, calling the personality routine
@@ -198,7 +199,8 @@
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   exc->private_1 = (_Unwind_Ptr) stop;
@@ -221,7 +223,8 @@
   struct _Unwind_Context this_context, cur_context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   /* Choose between continuing to process _Unwind_RaiseException
@@ -251,7 +254,8 @@
   if (exc->private_1 == 0)
     return _Unwind_RaiseException (exc);
 
-  uw_init_context (&this_context);
+  code = uw_init_context (&this_context);
+  gcc_assert (code == _URC_NO_REASON);
   cur_context = this_context;
 
   code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);
@@ -280,7 +284,9 @@
   struct _Unwind_Context context;
   _Unwind_Reason_Code code;
 
-  uw_init_context (&context);
+  code = uw_init_context (&context);
+  if (code != _URC_NO_REASON)
+    return _URC_FATAL_PHASE1_ERROR;
 
   while (1)
     {
diff -ru ./gcc/unwind-sjlj.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-sjlj.c
--- ./gcc/unwind-sjlj.c	2014-06-06 11:50:27.475599055 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/unwind-sjlj.c	2012-03-29 18:03:19.000000000 +1000
@@ -292,10 +292,11 @@
   uw_update_context (context, fs);
 }
 
-static inline void
+static inline _Unwind_Reason_Code
 uw_init_context (struct _Unwind_Context *context)
 {
   context->fc = _Unwind_SjLj_GetContext ();
+  return _URC_NO_REASON;
 }
 
 static void __attribute__((noreturn))
diff -ru ./gcc/varasm.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/varasm.c
--- ./gcc/varasm.c	2014-06-06 14:25:27.570150555 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/gcc/varasm.c	2012-03-29 18:03:19.000000000 +1000
@@ -988,11 +988,14 @@
     {
 #ifdef DATA_ALIGNMENT
       unsigned int data_align = DATA_ALIGNMENT (TREE_TYPE (decl), align);
+#else
+      unsigned int data_align = align;
+#endif
+      data_align = alignment_for_aligned_arrays (TREE_TYPE (decl), data_align);
       /* Don't increase alignment too much for TLS variables - TLS space
 	 is too precious.  */
       if (! DECL_THREAD_LOCAL_P (decl) || data_align <= BITS_PER_WORD)
 	align = data_align;
-#endif
 #ifdef CONSTANT_ALIGNMENT
       if (DECL_INITIAL (decl) != 0 && DECL_INITIAL (decl) != error_mark_node)
 	{
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git: COMMIT_EDITMSG
diff -ru ./.git/config /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/config
--- ./.git/config	2014-06-06 04:24:47.055099859 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/config	2014-06-06 13:37:07.310040265 +1000
@@ -3,6 +3,3 @@
 	filemode = true
 	bare = false
 	logallrefupdates = true
-[remote "origin"]
-	url = https://github.com/mirrors/gcc
-	fetch = +refs/heads/*:refs/remotes/origin/*
Only in ./.git: FETCH_HEAD
diff -ru ./.git/HEAD /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/HEAD
--- ./.git/HEAD	2014-06-06 14:25:27.806150564 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/HEAD	2014-06-06 13:37:07.310040265 +1000
@@ -1 +1 @@
-31839765ee7d53766a69f418e9d7a4ed750de4e9
+ref: refs/heads/master
Binary files ./.git/index and /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/index differ
diff -ru ./.git/logs/HEAD /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/logs/HEAD
--- ./.git/logs/HEAD	2014-06-06 14:25:27.806150564 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/logs/HEAD	2014-06-06 13:39:28.334045628 +1000
@@ -1,4 +1 @@
-0000000000000000000000000000000000000000 632cb4d5f22f598d1395fbae90a10fb679e06054 Sacha <xsacha@gmail.com> 1402019439 +1000	checkout: moving from master to gcc-4_6_4-release
-632cb4d5f22f598d1395fbae90a10fb679e06054 31839765ee7d53766a69f418e9d7a4ed750de4e9 Sacha <xsacha@gmail.com> 1402025787 +1000	checkout: moving from 632cb4d5f22f598d1395fbae90a10fb679e06054 to gcc-4_6_3-release
-31839765ee7d53766a69f418e9d7a4ed750de4e9 632cb4d5f22f598d1395fbae90a10fb679e06054 Sacha <xsacha@gmail.com> 1402028544 +1000	checkout: moving from 31839765ee7d53766a69f418e9d7a4ed750de4e9 to gcc-4_6_4-release
-632cb4d5f22f598d1395fbae90a10fb679e06054 31839765ee7d53766a69f418e9d7a4ed750de4e9 Sacha <xsacha@gmail.com> 1402028727 +1000	checkout: moving from 632cb4d5f22f598d1395fbae90a10fb679e06054 to gcc-4_6_3-release
+0000000000000000000000000000000000000000 f70e530631bd3d1f7aefb49f63f66b8d653a0b7a Sacha <xsacha@gmail.com> 1402025968 +1000	commit (initial): Symbian 4.6.3 source.
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/logs/refs: heads
Only in ./.git/logs/refs: remotes
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 00
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 01
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 02
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 03
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 04
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 05
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 06
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 07
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 08
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 09
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 0a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 0b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 0c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 0d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 0e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 0f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 10
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 11
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 12
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 13
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 14
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 15
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 16
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 17
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 18
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 19
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 1a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 1b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 1c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 1d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 1e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 1f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 20
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 21
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 22
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 23
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 24
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 25
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 26
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 27
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 28
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 29
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 2a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 2b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 2c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 2d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 2e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 2f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 30
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 31
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 32
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 33
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 34
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 35
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 36
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 37
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 38
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 39
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 3a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 3b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 3c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 3d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 3e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 3f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 40
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 41
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 42
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 43
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 44
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 45
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 46
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 47
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 48
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 49
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 4a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 4b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 4c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 4d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 4e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 4f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 50
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 51
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 52
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 53
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 54
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 55
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 56
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 57
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 58
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 59
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 5a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 5b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 5c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 5d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 5e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 5f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 60
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 61
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 62
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 63
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 64
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 65
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 66
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 67
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 68
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 69
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 6a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 6b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 6c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 6d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 6e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 6f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 70
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 71
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 72
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 73
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 74
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 75
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 76
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 77
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 78
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 79
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 7a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 7b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 7c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 7d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 7e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 7f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 80
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 81
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 82
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 83
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 84
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 85
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 86
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 87
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 88
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 89
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 8a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 8b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 8c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 8d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 8e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 8f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 90
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 91
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 92
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 93
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 94
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 95
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 96
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 97
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 98
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 99
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 9a
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 9b
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 9c
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 9d
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 9e
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: 9f
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a0
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a2
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a3
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a4
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a5
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a6
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a7
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: a9
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: aa
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ab
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ac
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ad
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ae
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: af
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b0
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b2
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b3
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b4
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b5
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b6
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b7
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: b9
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ba
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: bb
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: bc
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: bd
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: be
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: bf
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c0
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c2
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c3
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c4
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c5
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c6
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c7
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: c9
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ca
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: cb
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: cc
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: cd
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ce
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: cf
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d0
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d2
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d3
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d4
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d5
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d6
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d7
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: d9
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: da
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: db
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: dc
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: dd
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: de
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: df
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e0
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e2
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e3
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e4
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e5
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e6
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e7
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: e9
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ea
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: eb
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ec
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ed
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ee
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ef
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f0
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f1
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f2
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f3
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f4
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f5
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f6
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f7
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: f9
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: fa
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: fb
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: fc
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: fd
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: fe
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/objects: ff
Only in ./.git/objects/pack: pack-4fdca8214785f00b1fb4a8bd6b93acef0fe93491.idx
Only in ./.git/objects/pack: pack-4fdca8214785f00b1fb4a8bd6b93acef0fe93491.pack
Only in ./.git/objects/pack: tmp_pack_z3z2X8
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/.git/refs/heads: master
Only in ./.git/refs: remotes
Only in ./.git/refs/tags: alpha-v0.1
Only in ./.git/refs/tags: gcc-4_0_0-release
Only in ./.git/refs/tags: gcc-4_0_1-release
Only in ./.git/refs/tags: gcc-4_0_2-release
Only in ./.git/refs/tags: gcc-4_0_3-release
Only in ./.git/refs/tags: gcc-4_0_4-release
Only in ./.git/refs/tags: gcc-4_1_0-release
Only in ./.git/refs/tags: gcc-4_1_1-release
Only in ./.git/refs/tags: gcc-4_1_2-release
Only in ./.git/refs/tags: gcc-4_2_0-release
Only in ./.git/refs/tags: gcc-4_2_1-release
Only in ./.git/refs/tags: gcc-4_2_2-release
Only in ./.git/refs/tags: gcc-4_2_3-release
Only in ./.git/refs/tags: gcc-4_2_4-release
Only in ./.git/refs/tags: gcc-4_3_0-release
Only in ./.git/refs/tags: gcc-4_3_1-release
Only in ./.git/refs/tags: gcc-4_3_2-release
Only in ./.git/refs/tags: gcc-4_3_3-release
Only in ./.git/refs/tags: gcc-4_3_4-release
Only in ./.git/refs/tags: gcc-4_3_5-release
Only in ./.git/refs/tags: gcc-4_3_6-release
Only in ./.git/refs/tags: gcc-4_4_0-release
Only in ./.git/refs/tags: gcc-4_4_1-release
Only in ./.git/refs/tags: gcc-4_4_2-release
Only in ./.git/refs/tags: gcc-4_4_3-release
Only in ./.git/refs/tags: gcc-4_4_4-release
Only in ./.git/refs/tags: gcc-4_4_5-release
Only in ./.git/refs/tags: gcc-4_4_6-release
Only in ./.git/refs/tags: gcc-4_4_7-release
Only in ./.git/refs/tags: gcc-4_5_0-release
Only in ./.git/refs/tags: gcc-4_5_1-release
Only in ./.git/refs/tags: gcc-4_5_2-release
Only in ./.git/refs/tags: gcc-4_5_3-release
Only in ./.git/refs/tags: gcc-4_5_4-release
Only in ./.git/refs/tags: gcc-4_6_0-release
Only in ./.git/refs/tags: gcc-4_6_1-release
Only in ./.git/refs/tags: gcc-4_6_2-release
Only in ./.git/refs/tags: gcc-4_6_3-release
Only in ./.git/refs/tags: gcc-4_6_4-release
Only in ./.git/refs/tags: gcc-4_7_0-release
Only in ./.git/refs/tags: gcc-4_7_1-release
Only in ./.git/refs/tags: gcc-4_7_2-release
Only in ./.git/refs/tags: gcc-4_7_3-release
Only in ./.git/refs/tags: gcc-4_8_0-release
Only in ./.git/refs/tags: gcc-4_8_1-release
Only in ./.git/refs/tags: gcc-4_8_2-release
diff -ru ./include/libiberty.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/include/libiberty.h
--- ./include/libiberty.h	2014-06-06 11:50:27.555599058 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/include/libiberty.h	2012-03-29 17:53:47.000000000 +1000
@@ -605,6 +605,10 @@
 
 extern int pwait (int, int *, int);
 
+/* Convert a Cygwin path to a Windows path.  */
+
+extern int cygpath (const char *, char []);
+
 #if !HAVE_DECL_ASPRINTF
 /* Like sprintf but provides a pointer to malloc'd storage, which must
    be freed by the caller.  */
diff -ru ./libgcc/config/arm/bpabi-lib.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/arm/bpabi-lib.h
--- ./libgcc/config/arm/bpabi-lib.h	2014-06-06 11:50:27.887599070 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/arm/bpabi-lib.h	2012-03-29 17:54:57.000000000 +1000
@@ -71,3 +71,8 @@
 #ifdef L_floatundisf
 #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatundisf, ul2f)
 #endif
+
+/* For ARM bpabi, we only want to use a "__gnu_" prefix for the fixed-point
+   helper functions - not everything in libgcc - in the interests of
+   maintaining backward compatibility.  */
+#define LIBGCC2_FIXEDBIT_GNU_PREFIX
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/arm: t-divmod-ef
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_adddf3.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_add_exception.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_cmpdf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_divdf3.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_eqdf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_extendsfdf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_fixdfdi.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_fixdfsi.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_fixunsdfdi.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_fixunsdfsi.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_floatdidf.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_floatsidf.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_floatundidf.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_floatunsidf.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_gedf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_ledf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_muldf3.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_muldiv_scale2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_neg.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_subdf3.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_truncdfsf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_unorddf2.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: spe_unord_sub.S
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/rs6000: t-spe-fprules
diff -ru ./libgcc/config/s390/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/s390/t-linux
--- ./libgcc/config/s390/t-linux	2014-06-06 11:50:27.999599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/s390/t-linux	2012-03-29 17:54:59.000000000 +1000
@@ -2,6 +2,6 @@
 
 # Override t-slibgcc-elf-ver to export some libgcc symbols with
 # the symbol versions that glibc used.
-SHLIB_MAPFILES = $(gcc_srcdir)/libgcc-std.ver $(srcdir)/config/s390/libgcc-glibc.ver
+SHLIB_MAPFILES = libgcc-std.ver $(srcdir)/config/s390/libgcc-glibc.ver
 
 HOST_LIBGCC2_CFLAGS += -mlong-double-128
\ No newline at end of file
diff -ru ./libgcc/config/sh/t-linux /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/sh/t-linux
--- ./libgcc/config/sh/t-linux	2014-06-06 11:50:27.999599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/sh/t-linux	2012-03-29 17:54:59.000000000 +1000
@@ -5,7 +5,7 @@
 # routines which should not be called via PLT.  We have to create
 # the list from scratch.
 SHLIB_MAPFILES = \
-	$(gcc_srcdir)/libgcc-std.ver \
+	libgcc-std.ver \
 	$(gcc_srcdir)/config/sh/libgcc-excl.ver \
 	$(gcc_srcdir)/config/sh/libgcc-glibc.ver
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config: t-fixedpoint-gnu-prefix
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config: t-gnu-prefix
diff -ru ./libgcc/config/t-slibgcc-darwin /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/t-slibgcc-darwin
--- ./libgcc/config/t-slibgcc-darwin	2014-06-06 11:50:27.999599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config/t-slibgcc-darwin	2012-03-29 17:54:59.000000000 +1000
@@ -24,7 +24,7 @@
 
 SHLIB_MKMAP = $(gcc_srcdir)/mkmap-flat.awk
 SHLIB_MKMAP_OPTS = -v leading_underscore=1
-SHLIB_MAPFILES += $(gcc_srcdir)/libgcc-std.ver $(gcc_srcdir)/libgcc-libsystem.ver
+SHLIB_MAPFILES += libgcc-std.ver $(gcc_srcdir)/libgcc-libsystem.ver
 
 # we're only going to build the stubs if the target slib is /usr/lib
 # there is no other case in which they're useful in a live system.
diff -ru ./libgcc/config.host /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config.host
--- ./libgcc/config.host	2014-06-06 11:50:27.887599070 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/config.host	2012-03-29 17:54:59.000000000 +1000
@@ -202,12 +202,15 @@
 arm*-*-netbsd*)
 	;;
 arm*-*-linux*)			# ARM GNU/Linux with ELF
+	tmake_file="${tmake_file} arm/t-divmod-ef t-fixedpoint-gnu-prefix"
 	;;
 arm*-*-uclinux*)		# ARM ucLinux
+	tmake_file="${tmake_file} arm/t-divmod-ef t-fixedpoint-gnu-prefix"
 	;;
 arm*-*-ecos-elf)
 	;;
-arm*-*-eabi* | arm*-*-symbianelf* )
+arm*-*-eabi* | arm*-*-nucleuseabi* | arm*-*-symbianelf* )
+	tmake_file="${tmake_file} arm/t-divmod-ef t-fixedpoint-gnu-prefix"
 	;;
 arm*-*-rtems*)
 	;;
@@ -467,16 +470,26 @@
 powerpc-*-eabisim*)
 	;;
 powerpc-*-elf*)
+	tmake_file="${tmake_file} rs6000/t-ppccomm"
+	if test x"${ppc_has_spe}" = xyes; then
+		tmake_file="${tmake_file} rs6000/t-spe-fprules"
+	fi
 	;;
 powerpc-*-eabialtivec*)
 	;;
 powerpc-*-eabi*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm"
+	if test x"${ppc_has_spe}" = xyes; then
+		tmake_file="${tmake_file} rs6000/t-spe-fprules"
+	fi
 	;;
 powerpc-*-rtems*)
 	;;
 powerpc-*-linux* | powerpc64-*-linux*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-ldbl128 t-softfp"
+	if test x"${ppc_has_spe}" = xyes; then
+		tmake_file="${tmake_file} rs6000/t-spe-fprules"
+	fi
 	;;
 powerpc64-*-gnu*)
 	tmake_file="${tmake_file} rs6000/t-ldbl128 t-softfp"
diff -ru ./libgcc/configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/configure
--- ./libgcc/configure	2014-06-06 11:50:28.007599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/configure	2012-03-29 17:54:59.000000000 +1000
@@ -3781,6 +3781,21 @@
     ;;
 esac
 
+# Check SPE for rs6000.
+case ${host} in
+powerpc*)
+  cat > conftest.c <<EOF
+#ifdef __SPE__
+ppc_has_spe=yes
+#else
+ppc_has_spe=no
+#endif
+EOF
+    eval `${CC-cc} -E conftest.c | grep ppc_has_spe=`
+    rm -f conftest.c
+    ;;
+esac
+
 # Collect host-machine-specific information.
 . ${srcdir}/config.host
 
diff -ru ./libgcc/configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/configure.ac
--- ./libgcc/configure.ac	2014-06-06 11:50:28.007599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/configure.ac	2012-03-29 17:54:59.000000000 +1000
@@ -192,6 +192,21 @@
     ;;
 esac
 
+# Check SPE for rs6000.
+case ${host} in
+powerpc*)
+  cat > conftest.c <<EOF
+#ifdef __SPE__
+ppc_has_spe=yes
+#else
+ppc_has_spe=no
+#endif
+EOF
+    eval `${CC-cc} -E conftest.c | grep ppc_has_spe=`
+    rm -f conftest.c
+    ;;
+esac
+
 # Collect host-machine-specific information.
 . ${srcdir}/config.host
 
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc: libgcc-std.ver.in
diff -ru ./libgcc/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/Makefile.in
--- ./libgcc/Makefile.in	2014-06-06 14:25:27.586150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/Makefile.in	2012-03-29 17:54:59.000000000 +1000
@@ -250,6 +250,11 @@
 objects = $(filter %$(objext),$^)
 
 # Collect any host-specific information from Makefile fragments.
+
+LIBGCC_VER_GNU_PREFIX = __
+LIBGCC_VER_FIXEDPOINT_GNU_PREFIX = __
+LIBGCC_VER_SYMBOLS_PREFIX =
+
 tmake_file = @tmake_file@
 include $(srcdir)/empty.mk $(tmake_file)
 
@@ -407,18 +412,24 @@
 endif
 endif
 
+ifeq ($(LIB2_DIVMOD_EXCEPTION_FLAGS),)
+# Provide default flags for compiling divmod functions, if they haven't been
+# set already by a target-specific Makefile fragment.
+LIB2_DIVMOD_EXCEPTION_FLAGS := -fexceptions -fnon-call-exceptions
+endif
+
 # Build LIB2_DIVMOD_FUNCS.
 lib2-divmod-o = $(patsubst %,%$(objext),$(LIB2_DIVMOD_FUNCS))
 $(lib2-divmod-o): %$(objext): $(gcc_srcdir)/libgcc2.c
 	$(gcc_compile) -DL$* -c $(gcc_srcdir)/libgcc2.c \
-	  -fexceptions -fnon-call-exceptions $(vis_hide)
+	  $(LIB2_DIVMOD_EXCEPTION_FLAGS) $(vis_hide)
 libgcc-objects += $(lib2-divmod-o)
 
 ifeq ($(enable_shared),yes)
 lib2-divmod-s-o = $(patsubst %,%_s$(objext),$(LIB2_DIVMOD_FUNCS))
 $(lib2-divmod-s-o): %_s$(objext): $(gcc_srcdir)/libgcc2.c
 	$(gcc_s_compile) -DL$* -c $(gcc_srcdir)/libgcc2.c \
-	  -fexceptions -fnon-call-exceptions
+	  $(LIB2_DIVMOD_EXCEPTION_FLAGS)
 libgcc-s-objects += $(lib2-divmod-s-o)
 endif
 
@@ -795,6 +806,10 @@
 mapfile = libgcc.map
 endif
 
+libgcc-std.ver: $(srcdir)/libgcc-std.ver.in
+	sed -e 's/__PFX__/$(LIBGCC_VER_GNU_PREFIX)/g' \
+	    -e 's/__FIXPTPFX__/$(LIBGCC_VER_FIXEDPOINT_GNU_PREFIX)/g' < $< > $@
+
 libgcc_s$(SHLIB_EXT): $(libgcc-s-objects) $(extra-parts)
 	# @multilib_flags@ is still needed because this may use
 	# $(GCC_FOR_TARGET) and $(LIBGCC2_CFLAGS) directly.
diff -ru ./libgcc/shared-object.mk /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/shared-object.mk
--- ./libgcc/shared-object.mk	2014-06-06 11:50:28.007599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/shared-object.mk	2012-03-29 17:54:59.000000000 +1000
@@ -8,11 +8,13 @@
 
 ifeq ($(suffix $o),.c)
 
+c_flags-$(base)$(objext) := $(c_flags)
 $(base)$(objext): $o
-	$(gcc_compile) $(c_flags) -c $< $(vis_hide)
+	$(gcc_compile) $(c_flags-$@) -c $< $(vis_hide)
 
+c_flags-$(base)_s$(objext) := $(c_flags)
 $(base)_s$(objext): $o
-	$(gcc_s_compile) $(c_flags) -c $<
+	$(gcc_s_compile) $(c_flags-$@) -c $<
 
 else
 
diff -ru ./libgcc/static-object.mk /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/static-object.mk
--- ./libgcc/static-object.mk	2014-06-06 11:50:28.007599075 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgcc/static-object.mk	2012-03-29 17:54:59.000000000 +1000
@@ -8,8 +8,9 @@
 
 ifeq ($(suffix $o),.c)
 
+c_flags-$(base)$(objext) := $(c_flags)
 $(base)$(objext): $o
-	$(gcc_compile) $(c_flags) -c $< $(vis_hide)
+	$(gcc_compile) $(c_flags-$@) -c $< $(vis_hide)
 
 else
 
diff -ru ./libgomp/config/linux/mips/futex.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgomp/config/linux/mips/futex.h
--- ./libgomp/config/linux/mips/futex.h	2014-06-06 11:50:29.603599136 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgomp/config/linux/mips/futex.h	2012-03-29 17:52:54.000000000 +1000
@@ -28,20 +28,26 @@
 #define FUTEX_WAIT 0
 #define FUTEX_WAKE 1
 
+#ifdef __mips16
+static void __attribute__((noinline,nomips16))
+#else
 static inline void
+#endif
 sys_futex0 (int *addr, int op, int val)
 {
-  register unsigned long __v0 asm("$2") = (unsigned long) SYS_futex;
+  register unsigned long __v0 asm("$2");
   register unsigned long __a0 asm("$4") = (unsigned long) addr;
   register unsigned long __a1 asm("$5") = (unsigned long) op;
   register unsigned long __a2 asm("$6") = (unsigned long) val;
   register unsigned long __a3 asm("$7") = 0;
 
-  __asm volatile ("syscall"
+  __asm volatile ("li $2, %6\n\t"
+		  "syscall"
 		  /* returns $a3 (errno), $v0 (return value) */
 		  : "=r" (__v0), "=r" (__a3)
-		  /* arguments in v0 (syscall) a0-a3 */
-		  : "r" (__v0), "r" (__a0), "r" (__a1), "r" (__a2), "r" (__a3)
+		  /* arguments in a0-a3, and syscall number */
+		  : "r" (__a0), "r" (__a1), "r" (__a2), "r" (__a3),
+                    "IK" (SYS_futex)
 		  /* clobbers at, v1, t0-t9, memory */
 		  : "$1", "$3", "$8", "$9", "$10", "$11", "$12", "$13", "$14",
 		    "$15", "$24", "$25", "memory");
diff -ru ./libgomp/libgomp.texi /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgomp/libgomp.texi
--- ./libgomp/libgomp.texi	2014-06-06 11:50:29.619599136 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libgomp/libgomp.texi	2012-03-29 17:52:55.000000000 +1000
@@ -94,7 +94,7 @@
                                How you can copy and share this manual.
 * Funding::                    How to help assure continued work for free 
                                software.
-* Index::                      Index of this documentation.
+* Library Index::              Index of this documentation.
 @end menu
 
 
@@ -1714,8 +1714,8 @@
 @c Index
 @c ---------------------------------------------------------------------
 
-@node Index
-@unnumbered Index
+@node Library Index
+@unnumbered Library Index
 
 @printindex cp
 
diff -ru ./libiberty/configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/configure
--- ./libiberty/configure	2014-06-06 11:50:29.655599138 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/configure	2012-03-29 17:53:50.000000000 +1000
@@ -6561,6 +6561,18 @@
 esac
 
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	case " $LIBOBJS " in
+  *" cygpath.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS cygpath.$ac_objext"
+ ;;
+esac
+
+	;;
+esac
+
 if test x$gcc_no_link = xyes; then
   if test "x${ac_cv_func_mmap_fixed_mapped+set}" != xset; then
     ac_cv_func_mmap_fixed_mapped=no
diff -ru ./libiberty/configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/configure.ac
--- ./libiberty/configure.ac	2014-06-06 11:50:29.655599138 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/configure.ac	2012-03-29 17:53:50.000000000 +1000
@@ -683,6 +683,13 @@
 esac
 AC_SUBST(pexecute)
 
+# On MinGW, add support for Cygwin paths.
+case "${host}" in
+     *-*-mingw*)
+	AC_LIBOBJ([cygpath])
+	;;
+esac
+
 libiberty_AC_FUNC_STRNCMP
 
 # Install a library built with a cross compiler in $(tooldir) rather
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty: cygpath.c
diff -ru ./libiberty/lrealpath.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/lrealpath.c
--- ./libiberty/lrealpath.c	2014-06-06 11:50:29.663599138 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/lrealpath.c	2012-03-29 17:53:50.000000000 +1000
@@ -138,6 +138,17 @@
   {
     char buf[MAX_PATH];
     char* basename;
+
+    if (_access (filename, F_OK) != 0)
+      {
+	char cygbuf[MAX_PATH + 1];
+	/* The file does not exist.  It's fine to call lrealpath
+	   on a non-existing path... but if this would be an existing
+	   path after cygpath conversion, use that instead.  */
+	if (cygpath (filename, cygbuf) && _access (cygbuf, F_OK) == 0)
+	  filename = cygbuf;
+      }
+
     DWORD len = GetFullPathName (filename, MAX_PATH, buf, &basename);
     if (len == 0 || len > MAX_PATH - 1)
       return strdup (filename);
diff -ru ./libiberty/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/Makefile.in
--- ./libiberty/Makefile.in	2014-06-06 11:50:29.651599137 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/Makefile.in	2012-03-29 17:53:50.000000000 +1000
@@ -125,7 +125,7 @@
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c crc32.c				\
+	 cp-demint.c cplus-dem.c cygpath.c crc32.c			\
 	dyn-string.c							\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -196,7 +196,7 @@
 	./basename.$(objext) ./bcmp.$(objext) ./bcopy.$(objext)		\
 	./bsearch.$(objext) ./bzero.$(objext)				\
 	./calloc.$(objext) ./clock.$(objext) ./copysign.$(objext)	\
-	./_doprnt.$(objext)						\
+	./cygpath.$(objext) ./_doprnt.$(objext)				\
 	 ./ffs.$(objext)						\
 	./getcwd.$(objext) ./getpagesize.$(objext)			\
 	 ./gettimeofday.$(objext)					\
@@ -619,6 +619,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/crc32.c $(OUTPUT_OPTION)
 
+./cygpath.$(objext): $(srcdir)/cygpath.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./dyn-string.$(objext): $(srcdir)/dyn-string.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -ru ./libiberty/pex-win32.c /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/pex-win32.c
--- ./libiberty/pex-win32.c	2014-06-06 11:50:29.667599138 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libiberty/pex-win32.c	2012-03-29 17:53:50.000000000 +1000
@@ -119,7 +119,7 @@
 pex_win32_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
 		     int binary)
 {
-  return _open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
+  return open (name, _O_RDONLY | (binary ? _O_BINARY : _O_TEXT));
 }
 
 /* Open a file for writing.  */
@@ -130,10 +130,10 @@
 {
   /* Note that we can't use O_EXCL here because gcc may have already
      created the temporary file via make_temp_file.  */
-  return _open (name,
-		(_O_WRONLY | _O_CREAT | _O_TRUNC
-		 | (binary ? _O_BINARY : _O_TEXT)),
-		_S_IREAD | _S_IWRITE);
+  return open (name,
+	       (_O_WRONLY | _O_CREAT | _O_TRUNC
+		| (binary ? _O_BINARY : _O_TEXT)),
+	       _S_IREAD | _S_IWRITE);
 }
 
 /* Close a file.  */
@@ -753,20 +753,14 @@
      original descriptors.  */
   orig_in = in;
   in = _dup (orig_in);
-  if (orig_in != STDIN_FILENO)
-    _close (orig_in);
   
   orig_out = out;
   out = _dup (orig_out);
-  if (orig_out != STDOUT_FILENO)
-    _close (orig_out);
   
   if (separate_stderr)
     {
       orig_err = errdes;
       errdes = _dup (orig_err);
-      if (orig_err != STDERR_FILENO)
-	_close (orig_err);
     }
 
   stdin_handle = INVALID_HANDLE_VALUE;
@@ -844,6 +838,17 @@
       *errmsg = "CreateProcess";
     }
 
+  if (pid != (pid_t) -1)
+    {
+      if (orig_in != STDIN_FILENO)
+	_close (orig_in);
+      if (orig_out != STDOUT_FILENO)
+	_close (orig_out);
+      if (separate_stderr
+	  && orig_err != STDERR_FILENO)
+	_close (orig_err);
+    }
+
   /* Close the standard input, standard output and standard error handles
      in the parent.  */ 
 
diff -ru ./libjava/classpath/configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/configure
--- ./libjava/classpath/configure	2014-06-06 11:50:29.739599141 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/configure	2012-03-29 17:54:33.000000000 +1000
@@ -745,6 +745,9 @@
 glibjdir
 nativeexeclibdir
 toolexeclibdir
+toolexecmainlibdir
+toolexecdir
+target_noncanonical
 CREATE_GJDOC_FALSE
 CREATE_GJDOC_TRUE
 CREATE_PLUGIN_FALSE
@@ -898,6 +901,7 @@
 enable_plugin
 enable_gmp
 enable_gjdoc
+enable_version_specific_runtime_libs
 with_native_libdir
 with_glibj_dir
 with_antlr_jar
@@ -1615,6 +1619,9 @@
                           (disabled by --disable-gmp) default=yes
   --disable-gjdoc         compile GJDoc (disabled by --disable-gjdoc)
                           default=yes
+  --enable-version-specific-runtime-libs
+                          specify that runtime libraries should be installed
+                          in a compiler-specific directory
   --enable-regen-headers  automatically regenerate JNI headers default=yes if
                           headers don't exist
   --enable-regen-gjdoc-parser
@@ -5519,12 +5526,58 @@
 fi
 
 
+# Check whether --enable-version-specific-runtime-libs was given.
+if test "${enable_version_specific_runtime_libs+set}" = set; then :
+  enableval=$enable_version_specific_runtime_libs; case "$enableval" in
+      yes) version_specific_libs=yes ;;
+      no)  version_specific_libs=no ;;
+      *)   as_fn_error "Unknown argument to enable/disable version-specific libs" "$LINENO" 5;;
+     esac
+else
+  version_specific_libs=no
+
+fi
+
 
-  multi_os_directory=`$CC -print-multi-os-directory`
-  case $multi_os_directory in
-    .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
-    *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+  case ${host_alias} in
+    "") host_noncanonical=${build_noncanonical} ;;
+    *) host_noncanonical=${host_alias} ;;
   esac
+  case ${target_alias} in
+    "") target_noncanonical=${host_noncanonical} ;;
+    *) target_noncanonical=${target_alias} ;;
+  esac
+
+
+  case ${version_specific_libs} in
+    yes)
+      # Need the gcc compiler version to know where to install libraries
+      # and header files if --enable-version-specific-runtime-libs option
+      # is selected.
+      includedir='$(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include/'
+      toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
+      toolexecmainlibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+      toolexeclibdir=$toolexecmainlibdir
+      ;;
+    no)
+      if test -n "$with_cross_host" &&
+	 test x"$with_cross_host" != x"no"; then
+	# Install a library built with a cross compiler in tooldir, not libdir.
+	toolexecdir='$(exec_prefix)/$(target_noncanonical)'
+	toolexecmainlibdir='$(toolexecdir)/lib'
+      else
+	toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'
+	toolexecmainlibdir='$(libdir)'
+      fi
+      multi_os_directory=`$CC -print-multi-os-directory`
+      case $multi_os_directory in
+	.) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+	*) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+      esac
+      ;;
+  esac
+
+
 
 
 
@@ -11811,7 +11864,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11814 "configure"
+#line 11867 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11917,7 +11970,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11920 "configure"
+#line 11973 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -23814,7 +23867,7 @@
 JAVA_TEST=Object.java
 CLASS_TEST=Object.class
 cat << \EOF > $JAVA_TEST
-/* #line 23817 "configure" */
+/* #line 23870 "configure" */
 package java.lang;
 
 public class Object
@@ -23907,7 +23960,7 @@
 if uudecode$EXEEXT Test.uue; then
         ac_cv_prog_uudecode_base64=yes
 else
-        echo "configure: 23910: uudecode had trouble decoding base 64 file 'Test.uue'" >&5
+        echo "configure: 23963: uudecode had trouble decoding base 64 file 'Test.uue'" >&5
         echo "configure: failed file was:" >&5
         cat Test.uue >&5
         ac_cv_prog_uudecode_base64=no
@@ -23935,7 +23988,7 @@
 CLASS_TEST=Test.class
 TEST=Test
 cat << \EOF > $JAVA_TEST
-/* [#]line 23938 "configure" */
+/* [#]line 23991 "configure" */
 public class Test {
 public static void main (String args[]) {
         System.exit (0);
@@ -24143,7 +24196,7 @@
   JAVA_TEST=Test.java
   CLASS_TEST=Test.class
   cat << \EOF > $JAVA_TEST
-  /* #line 24146 "configure" */
+  /* #line 24199 "configure" */
   public class Test
   {
     public static void main(String args)
diff -ru ./libjava/classpath/configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/configure.ac
--- ./libjava/classpath/configure.ac	2014-06-06 14:25:27.594150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/configure.ac	2012-03-29 17:54:33.000000000 +1000
@@ -317,6 +317,16 @@
 dnl so that we can refer to the multilib installation directories from
 dnl classpath's build files.
 dnl -----------------------------------------------------------
+AC_ARG_ENABLE(version-specific-runtime-libs,
+  AS_HELP_STRING([--enable-version-specific-runtime-libs],    
+                 [specify that runtime libraries should be installed in a compiler-specific directory]),
+    [case "$enableval" in
+      yes) version_specific_libs=yes ;;
+      no)  version_specific_libs=no ;;
+      *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;
+     esac],
+    [version_specific_libs=no]
+)
 CLASSPATH_TOOLEXECLIBDIR
 
 dnl -----------------------------------------------------------
diff -ru ./libjava/classpath/doc/api/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/doc/api/Makefile.in
--- ./libjava/classpath/doc/api/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/doc/api/Makefile.in	2012-03-29 17:54:02.000000000 +1000
@@ -274,9 +274,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/doc/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/doc/Makefile.in
--- ./libjava/classpath/doc/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/doc/Makefile.in	2012-03-29 17:54:02.000000000 +1000
@@ -349,9 +349,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/examples/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/examples/Makefile.in
--- ./libjava/classpath/examples/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/examples/Makefile.in	2012-03-29 17:54:33.000000000 +1000
@@ -297,9 +297,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/external/jsr166/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/jsr166/Makefile.in
--- ./libjava/classpath/external/jsr166/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/jsr166/Makefile.in	2012-03-29 17:54:06.000000000 +1000
@@ -272,9 +272,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/external/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/Makefile.in
--- ./libjava/classpath/external/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/Makefile.in	2012-03-29 17:54:06.000000000 +1000
@@ -312,9 +312,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/external/relaxngDatatype/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/relaxngDatatype/Makefile.in
--- ./libjava/classpath/external/relaxngDatatype/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/relaxngDatatype/Makefile.in	2012-03-29 17:54:06.000000000 +1000
@@ -272,9 +272,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/external/sax/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/sax/Makefile.in
--- ./libjava/classpath/external/sax/Makefile.in	2014-06-06 14:25:27.598150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/sax/Makefile.in	2012-03-29 17:54:06.000000000 +1000
@@ -272,9 +272,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/external/w3c_dom/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/w3c_dom/Makefile.in
--- ./libjava/classpath/external/w3c_dom/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/external/w3c_dom/Makefile.in	2012-03-29 17:54:06.000000000 +1000
@@ -272,9 +272,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/include/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/include/Makefile.in
--- ./libjava/classpath/include/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/include/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -273,9 +273,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/lib/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/lib/Makefile.in
--- ./libjava/classpath/lib/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/lib/Makefile.in	2012-03-29 17:54:30.000000000 +1000
@@ -277,9 +277,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/m4/acinclude.m4 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/m4/acinclude.m4
--- ./libjava/classpath/m4/acinclude.m4	2014-06-06 11:50:32.919599262 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/m4/acinclude.m4	2012-03-29 17:54:07.000000000 +1000
@@ -247,11 +247,45 @@
 dnl -----------------------------------------------------------
 AC_DEFUN([CLASSPATH_TOOLEXECLIBDIR],
 [
-  multi_os_directory=`$CC -print-multi-os-directory`
-  case $multi_os_directory in
-    .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
-    *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+  case ${host_alias} in
+    "") host_noncanonical=${build_noncanonical} ;;
+    *) host_noncanonical=${host_alias} ;;
   esac
+  case ${target_alias} in
+    "") target_noncanonical=${host_noncanonical} ;;
+    *) target_noncanonical=${target_alias} ;;
+  esac
+  AC_SUBST(target_noncanonical)
+
+  case ${version_specific_libs} in
+    yes)
+      # Need the gcc compiler version to know where to install libraries
+      # and header files if --enable-version-specific-runtime-libs option
+      # is selected.
+      includedir='$(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include/'
+      toolexecdir='$(libdir)/gcc/$(target_noncanonical)'
+      toolexecmainlibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'
+      toolexeclibdir=$toolexecmainlibdir
+      ;;
+    no)
+      if test -n "$with_cross_host" &&
+	 test x"$with_cross_host" != x"no"; then
+	# Install a library built with a cross compiler in tooldir, not libdir.
+	toolexecdir='$(exec_prefix)/$(target_noncanonical)'
+	toolexecmainlibdir='$(toolexecdir)/lib'
+      else
+	toolexecdir='$(libdir)/gcc-lib/$(target_noncanonical)'
+	toolexecmainlibdir='$(libdir)'
+      fi
+      multi_os_directory=`$CC -print-multi-os-directory`
+      case $multi_os_directory in
+	.) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+	*) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+      esac
+      ;;
+  esac
+  AC_SUBST(toolexecdir)
+  AC_SUBST(toolexecmainlibdir)
   AC_SUBST(toolexeclibdir)
 ])
 
diff -ru ./libjava/classpath/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/Makefile.in
--- ./libjava/classpath/Makefile.in	2014-06-06 14:25:27.594150556 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/Makefile.in	2012-03-29 17:54:33.000000000 +1000
@@ -351,9 +351,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/fdlibm/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/fdlibm/Makefile.in
--- ./libjava/classpath/native/fdlibm/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/fdlibm/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -301,9 +301,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jawt/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jawt/Makefile.in
--- ./libjava/classpath/native/jawt/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jawt/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -318,9 +318,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/classpath/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/classpath/Makefile.in
--- ./libjava/classpath/native/jni/classpath/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/classpath/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -292,9 +292,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/gconf-peer/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/gconf-peer/Makefile.in
--- ./libjava/classpath/native/jni/gconf-peer/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/gconf-peer/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -318,9 +318,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/gstreamer-peer/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/gstreamer-peer/Makefile.in
--- ./libjava/classpath/native/jni/gstreamer-peer/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/gstreamer-peer/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -320,9 +320,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/gtk-peer/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/gtk-peer/Makefile.in
--- ./libjava/classpath/native/jni/gtk-peer/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/gtk-peer/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -356,9 +356,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/java-io/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-io/Makefile.in
--- ./libjava/classpath/native/jni/java-io/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-io/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -317,9 +317,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/java-lang/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-lang/Makefile.in
--- ./libjava/classpath/native/jni/java-lang/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-lang/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -331,9 +331,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/java-math/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-math/Makefile.in
--- ./libjava/classpath/native/jni/java-math/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-math/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -318,9 +318,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/java-net/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-net/Makefile.in
--- ./libjava/classpath/native/jni/java-net/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-net/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -327,9 +327,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/java-nio/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-nio/Makefile.in
--- ./libjava/classpath/native/jni/java-nio/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-nio/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -325,9 +325,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/java-util/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-util/Makefile.in
--- ./libjava/classpath/native/jni/java-util/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/java-util/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -314,9 +314,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/Makefile.in
--- ./libjava/classpath/native/jni/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -311,9 +311,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/midi-alsa/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/midi-alsa/Makefile.in
--- ./libjava/classpath/native/jni/midi-alsa/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/midi-alsa/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -320,9 +320,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/midi-dssi/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/midi-dssi/Makefile.in
--- ./libjava/classpath/native/jni/midi-dssi/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/midi-dssi/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -320,9 +320,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/native-lib/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/native-lib/Makefile.in
--- ./libjava/classpath/native/jni/native-lib/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/native-lib/Makefile.in	2012-03-29 17:54:07.000000000 +1000
@@ -292,9 +292,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/qt-peer/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/qt-peer/Makefile.in
--- ./libjava/classpath/native/jni/qt-peer/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/qt-peer/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -322,9 +322,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/jni/xmlj/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/xmlj/Makefile.in
--- ./libjava/classpath/native/jni/xmlj/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/jni/xmlj/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -316,9 +316,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/Makefile.in
--- ./libjava/classpath/native/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -311,9 +311,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/native/plugin/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/plugin/Makefile.in
--- ./libjava/classpath/native/plugin/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/native/plugin/Makefile.in	2012-03-29 17:54:08.000000000 +1000
@@ -318,9 +318,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/resource/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/resource/Makefile.in
--- ./libjava/classpath/resource/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/resource/Makefile.in	2012-03-29 17:53:59.000000000 +1000
@@ -296,9 +296,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/scripts/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/scripts/Makefile.in
--- ./libjava/classpath/scripts/Makefile.in	2014-06-06 14:25:27.602150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/scripts/Makefile.in	2012-03-29 17:53:57.000000000 +1000
@@ -273,9 +273,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/classpath/tools/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/tools/Makefile.in
--- ./libjava/classpath/tools/Makefile.in	2014-06-06 14:25:27.606150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/classpath/tools/Makefile.in	2012-03-29 17:54:02.000000000 +1000
@@ -448,9 +448,12 @@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
+target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
 toolexeclibdir = @toolexeclibdir@
+toolexecmainlibdir = @toolexecmainlibdir@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
diff -ru ./libjava/configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/configure
--- ./libjava/configure	2014-06-06 14:25:27.610150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/configure	2012-03-29 18:03:38.000000000 +1000
@@ -23827,10 +23827,10 @@
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
   .)
-   dbexecdir='$(libdir)/'$gcjsubdir # Avoid /.
+   dbexecdir='$(toolexeclibdir)/'$gcjsubdir # Avoid /.
    ;;
   *)
-   dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+   dbexecdir='$(toolexeclibdir)/'$multi_os_directory/$gcjsubdir
    ;;
 esac
 
diff -ru ./libjava/configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/configure.ac
--- ./libjava/configure.ac	2014-06-06 14:25:27.614150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/configure.ac	2012-03-29 17:54:56.000000000 +1000
@@ -1607,10 +1607,10 @@
 multi_os_directory=`$CC -print-multi-os-directory`
 case $multi_os_directory in
   .)
-   dbexecdir='$(libdir)/'$gcjsubdir # Avoid /.
+   dbexecdir='$(toolexeclibdir)/'$gcjsubdir # Avoid /.
    ;;
   *)
-   dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+   dbexecdir='$(toolexeclibdir)/'$multi_os_directory/$gcjsubdir
    ;;
 esac
 AC_SUBST(dbexecdir)
diff -ru ./libjava/Makefile.am /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/Makefile.am
--- ./libjava/Makefile.am	2014-06-06 11:50:29.707599140 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/Makefile.am	2012-03-29 17:54:56.000000000 +1000
@@ -221,9 +221,14 @@
 
 dbexec_LTLIBRARIES = libjvm.la
 
-pkgconfigdir = $(libdir)/pkgconfig
+# Install the pkgconfig file in a target-specific directory, since the
+# libraries it indicates
 
-jardir = $(datadir)/java
+pkgconfigdir = $(toolexeclibdir)/pkgconfig
+
+# We install the JAR in a target-specific directory so that toolchains
+# build from different sources can be installed in the same directory.
+jardir = $(prefix)/$(target_noncanonical)/share/java
 jar_DATA = libgcj-$(gcc_version).jar libgcj-tools-$(gcc_version).jar
 if INSTALL_ECJ_JAR
 jar_DATA += $(ECJ_BUILD_JAR)
diff -ru ./libjava/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/Makefile.in
--- ./libjava/Makefile.in	2014-06-06 11:50:29.711599140 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libjava/Makefile.in	2012-03-29 18:03:38.000000000 +1000
@@ -937,7 +937,10 @@
 @BUILD_SUBLIBS_TRUE@LIBJAVA_CORE_EXTRA = @LIBGCJ_SUBLIB_CORE_EXTRA_DEPS@
 dbexec_LTLIBRARIES = libjvm.la
 pkgconfigdir = $(libdir)/pkgconfig
-jardir = $(datadir)/java
+
+# We install the JAR in a target-specific directory so that toolchains
+# build from different sources can be installed in the same directory.
+jardir = $(prefix)/$(target_noncanonical)/share/java
 jar_DATA = libgcj-$(gcc_version).jar libgcj-tools-$(gcc_version).jar \
 	$(am__append_5)
 @JAVA_HOME_SET_FALSE@JAVA_HOME_DIR = $(prefix)
diff -ru ./libstdc++-v3/acinclude.m4 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/acinclude.m4
--- ./libstdc++-v3/acinclude.m4	2014-06-06 14:25:27.614150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/acinclude.m4	2012-03-29 17:53:42.000000000 +1000
@@ -3213,6 +3213,23 @@
   ])
 ])
 
+# Check whether or not we are using CSLIBC.  If using CSLIBC, you
+# should configure with --with-cslibc *in addition to* --with-newlib.
+AC_DEFUN([GLIBCXX_WITH_CSLIBC], [
+  AC_ARG_WITH([cslibc],
+    AC_HELP_STRING([--with-cslibc],
+                   [assume CSLIBC as system C library]),,
+    [with_cslibc=no])
+  if test "$with_cslibc" = yes; then
+    cslibc_define=1
+  else
+    cslibc_define=0
+  fi
+  GLIBCXX_CONDITIONAL(GLIBCXX_CSLIBC, test $with_cslibc = yes)
+  AC_DEFINE_UNQUOTED(_GLIBCXX_CSLIBC, $cslibc_define,
+    [Define to 1 if building for use with CSLIBC, or 0 otherwise.])
+])
+
 # Macros from the top-level gcc directory.
 m4_include([../config/gc++filt.m4])
 m4_include([../config/tls.m4])
diff -ru ./libstdc++-v3/config/abi/pre/gnu.ver /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/abi/pre/gnu.ver
--- ./libstdc++-v3/config/abi/pre/gnu.ver	2014-06-06 11:50:36.331599391 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/abi/pre/gnu.ver	2012-04-28 17:58:32.000000000 +1000
@@ -1315,6 +1315,8 @@
     __cxa_vec_new;
     __gxx_personality_v0;
     __gxx_personality_sj0;
+    __gnu_compact_pr2;
+    __gnu_compact_pr3;
     __dynamic_cast;
 
     # *_type_info classes, ctor and dtor
diff -ru ./libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver
--- ./libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver	2014-06-06 11:50:36.331599391 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver	2012-04-28 17:58:32.000000000 +1000
@@ -177,6 +177,8 @@
     __cxa_vec_new;
     __gxx_personality_v0;
     __gxx_personality_sj0;
+    __gnu_compact_pr2;
+    __gnu_compact_pr3;
     __dynamic_cast;
 
     # std::exception_ptr
diff -ru ./libstdc++-v3/config/locale/gnu/c_locale.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/c_locale.cc
--- ./libstdc++-v3/config/locale/gnu/c_locale.cc	2014-06-06 11:50:36.355599392 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/c_locale.cc	2012-03-29 17:53:40.000000000 +1000
@@ -212,3 +212,21 @@
   extern "C" void ldbl (void) __attribute__ ((alias (#dbl)))
 _GLIBCXX_LDBL_COMPAT(_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct, _ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct);
 #endif // _GLIBCXX_LONG_DOUBLE_COMPAT
+
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+_GLIBCXX_LOCALE_COMPAT (_ZNSt6locale5facet17_S_clone_c_localeERPi, _ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt6locale5facet18_S_create_c_localeERPiPKcS1_, _ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt6locale5facet19_S_destroy_c_localeERPi, _ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct);
+_GLIBCXX_LOCALE_COMPAT (_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKPi, _ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct);
+_GLIBCXX_LOCALE_COMPAT (_ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKPi, _ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct);
+_GLIBCXX_LOCALE_COMPAT (_ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKPi, _ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct);
+#ifdef _GLIBCXX_LONG_DOUBLE_COMPAT
+_GLIBCXX_LOCALE_COMPAT (_ZSt14__convert_to_vIgEvPKcRT_RSt12_Ios_IostateRKPi, _ZSt14__convert_to_vIgEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct);
+#endif
diff -ru ./libstdc++-v3/config/locale/gnu/monetary_members.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/monetary_members.cc
--- ./libstdc++-v3/config/locale/gnu/monetary_members.cc	2014-06-06 11:50:36.355599392 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/monetary_members.cc	2012-03-29 17:53:40.000000000 +1000
@@ -933,3 +933,18 @@
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
+
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEPiPKc, _ZNSt10moneypunctIcLb0EE24_M_initialize_moneypunctEP15__locale_structPKc);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb1EE24_M_initialize_moneypunctEPiPKc, _ZNSt10moneypunctIcLb1EE24_M_initialize_moneypunctEP15__locale_structPKc);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb0EE24_M_initialize_moneypunctEPiPKc, _ZNSt10moneypunctIwLb0EE24_M_initialize_moneypunctEP15__locale_structPKc);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb1EE24_M_initialize_moneypunctEPiPKc, _ZNSt10moneypunctIwLb1EE24_M_initialize_moneypunctEP15__locale_structPKc);
+#endif
diff -ru ./libstdc++-v3/config/locale/gnu/numeric_members.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/numeric_members.cc
--- ./libstdc++-v3/config/locale/gnu/numeric_members.cc	2014-06-06 11:50:36.355599392 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/numeric_members.cc	2012-03-29 17:53:40.000000000 +1000
@@ -216,3 +216,16 @@
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
+
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIcE22_M_initialize_numpunctEPi, _ZNSt8numpunctIcE22_M_initialize_numpunctEP15__locale_struct);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIwE22_M_initialize_numpunctEPi, _ZNSt8numpunctIwE22_M_initialize_numpunctEP15__locale_struct);
+#endif
diff -ru ./libstdc++-v3/config/locale/gnu/time_members.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/time_members.cc
--- ./libstdc++-v3/config/locale/gnu/time_members.cc	2014-06-06 11:50:36.355599392 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/locale/gnu/time_members.cc	2012-03-29 17:53:40.000000000 +1000
@@ -399,3 +399,16 @@
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
+
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIcE23_M_initialize_timepunctEPi, _ZNSt11__timepunctIcE23_M_initialize_timepunctEP15__locale_struct);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIwE23_M_initialize_timepunctEPi, _ZNSt11__timepunctIwE23_M_initialize_timepunctEP15__locale_struct);
+#endif
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config/os: nucleus
diff -ru ./libstdc++-v3/config.h.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config.h.in
--- ./libstdc++-v3/config.h.in	2014-06-06 14:25:27.618150557 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/config.h.in	2012-03-29 17:53:42.000000000 +1000
@@ -689,6 +689,9 @@
 /* Define to use concept checking code from the boost libraries. */
 #undef _GLIBCXX_CONCEPT_CHECKS
 
+/* Define to 1 if building for use with CSLIBC, or 0 otherwise. */
+#undef _GLIBCXX_CSLIBC
+
 /* Define if a fully dynamic basic_string is wanted. */
 #undef _GLIBCXX_FULLY_DYNAMIC_STRING
 
diff -ru ./libstdc++-v3/configure /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/configure
--- ./libstdc++-v3/configure	2014-06-06 14:25:27.638150558 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/configure	2012-03-29 17:53:42.000000000 +1000
@@ -729,6 +729,8 @@
 FGREP
 SED
 LIBTOOL
+GLIBCXX_CSLIBC_FALSE
+GLIBCXX_CSLIBC_TRUE
 EGREP
 GREP
 CPP
@@ -834,6 +836,7 @@
 with_cross_host
 with_newlib
 enable_maintainer_mode
+with_cslibc
 enable_shared
 enable_static
 with_pic
@@ -1565,6 +1568,7 @@
                           configuring in a subdirectory
   --with-cross-host=HOST  configuring with a cross compiler
   --with-newlib           assume newlib as a system C library
+  --with-cslibc           assume CSLIBC as system C library
   --with-pic              try to use only PIC/non-PIC objects [default=use
                           both]
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
@@ -5267,6 +5271,29 @@
 
 
 
+# Check to see if we are using CSLIBC.
+
+
+# Check whether --with-cslibc was given.
+if test "${with_cslibc+set}" = set; then :
+  withval=$with_cslibc;
+else
+  with_cslibc=no
+fi
+
+  if test "$with_cslibc" = yes; then
+    cslibc_define=1
+  else
+    cslibc_define=0
+  fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define _GLIBCXX_CSLIBC $cslibc_define
+_ACEOF
+
+
+
 if test "x${with_newlib}" != "xyes"; then
   enable_dlopen=yes
 
@@ -6242,6 +6269,10 @@
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
+nucleuseabi*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -6346,6 +6377,10 @@
   lt_cv_deplibs_check_method=pass_all
   ;;
 
+symbian*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -10869,6 +10904,21 @@
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -10956,6 +11006,14 @@
   need_version=yes
   ;;
 
+symbian*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+  library_names_spec='${libname}.dll'
+  ;;
+
 sysv4 | sysv4.3*)
   version_type=linux
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
@@ -11484,7 +11542,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11487 "configure"
+#line 11545 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11590,7 +11648,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11593 "configure"
+#line 11651 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -13438,6 +13496,10 @@
       # Interix 3.x gcc -fpic/-fPIC options generate broken code.
       # Instead, we relocate shared libraries at runtime.
       ;;
+    symbian*)
+      # symbian does not have PIC, the loader relocates non-pic shared objects
+      lt_prog_compiler_pic_CXX=
+      ;;
     sysv4*MP*)
       if test -d /usr/nec; then
 	lt_prog_compiler_pic_CXX=-Kconform_pic
@@ -14552,6 +14614,21 @@
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -14639,6 +14716,14 @@
   need_version=yes
   ;;
 
+symbian*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+  library_names_spec='${libname}.dll'
+  ;;
+
 sysv4 | sysv4.3*)
   version_type=linux
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
@@ -14948,7 +15033,7 @@
     #
     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.
     cat > conftest.$ac_ext << EOF
-#line 14951 "configure"
+#line 15036 "configure"
 struct S { ~S(); };
 void bar();
 void foo()
@@ -15316,7 +15401,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15319 "configure"
+#line 15404 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15353,7 +15438,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15356 "configure"
+#line 15441 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15390,7 +15475,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15393 "configure"
+#line 15478 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15428,7 +15513,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15431 "configure"
+#line 15516 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15504,7 +15589,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15507 "configure"
+#line 15592 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -18729,6 +18814,7 @@
 
 
 # For the EOF, SEEK_CUR, and SEEK_END integer constants.
+if test $is_hosted = yes; then
 
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the value of EOF" >&5
@@ -18797,6 +18883,7 @@
 _ACEOF
 
 
+fi
 
 # For gettimeofday support.
 
@@ -63792,7 +63879,8 @@
 if test "${ac_cv_sizeof_void_p+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (void *))" "ac_cv_sizeof_void_p"        "$ac_includes_default"; then :
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (void *))" "ac_cv_sizeof_void_p"        "/* no standard headers */
+"; then :
 
 else
   if test "$ac_cv_type_void_p" = yes; then
@@ -63830,7 +63918,8 @@
 if test "${ac_cv_sizeof_long+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "$ac_includes_default"; then :
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (long))" "ac_cv_sizeof_long"        "/* no standard headers */
+"; then :
 
 else
   if test "$ac_cv_type_long" = yes; then
@@ -63868,7 +63957,8 @@
 if test "${ac_cv_sizeof_int+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "$ac_includes_default"; then :
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (int))" "ac_cv_sizeof_int"        "/* no standard headers */
+"; then :
 
 else
   if test "$ac_cv_type_int" = yes; then
@@ -63902,7 +63992,8 @@
 if test "${ac_cv_sizeof_short+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (short))" "ac_cv_sizeof_short"        "$ac_includes_default"; then :
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (short))" "ac_cv_sizeof_short"        "/* no standard headers */
+"; then :
 
 else
   if test "$ac_cv_type_short" = yes; then
@@ -63936,7 +64027,8 @@
 if test "${ac_cv_sizeof_char+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (char))" "ac_cv_sizeof_char"        "$ac_includes_default"; then :
+  if ac_fn_c_compute_int "$LINENO" "(long int) (sizeof (char))" "ac_cv_sizeof_char"        "/* no standard headers */
+"; then :
 
 else
   if test "$ac_cv_type_char" = yes; then
@@ -65334,6 +65426,15 @@
 # Determine cross-compile flags and AM_CONDITIONALs.
 #AC_SUBST(GLIBCXX_IS_NATIVE)
 #AM_CONDITIONAL(CANADIAN, test $CANADIAN = yes)
+    if test $with_cslibc = yes; then
+  GLIBCXX_CSLIBC_TRUE=
+  GLIBCXX_CSLIBC_FALSE='#'
+else
+  GLIBCXX_CSLIBC_TRUE='#'
+  GLIBCXX_CSLIBC_FALSE=
+fi
+
+
     if test $is_hosted = yes; then
   GLIBCXX_HOSTED_TRUE=
   GLIBCXX_HOSTED_FALSE='#'
@@ -65832,6 +65933,10 @@
   as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${GLIBCXX_CSLIBC_TRUE}" && test -z "${GLIBCXX_CSLIBC_FALSE}"; then
+  as_fn_error "conditional \"GLIBCXX_CSLIBC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${GLIBCXX_HOSTED_TRUE}" && test -z "${GLIBCXX_HOSTED_FALSE}"; then
   as_fn_error "conditional \"GLIBCXX_HOSTED\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff -ru ./libstdc++-v3/configure.ac /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/configure.ac
--- ./libstdc++-v3/configure.ac	2014-06-06 14:25:27.638150558 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/configure.ac	2012-03-29 17:53:42.000000000 +1000
@@ -88,6 +88,9 @@
 # up critical shell variables.
 GLIBCXX_CONFIGURE
 
+# Check to see if we are using CSLIBC.
+GLIBCXX_WITH_CSLIBC
+
 if test "x${with_newlib}" != "xyes"; then
   AC_LIBTOOL_DLOPEN
 fi
@@ -152,7 +155,9 @@
 GLIBCXX_CHECK_C99_TR1
 
 # For the EOF, SEEK_CUR, and SEEK_END integer constants.
-GLIBCXX_COMPUTE_STDIO_INTEGER_CONSTANTS
+if test $is_hosted = yes; then
+   GLIBCXX_COMPUTE_STDIO_INTEGER_CONSTANTS
+fi
 
 # For gettimeofday support.
 GLIBCXX_CHECK_GETTIMEOFDAY
diff -ru ./libstdc++-v3/configure.host /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/configure.host
--- ./libstdc++-v3/configure.host	2014-06-06 11:50:36.435599395 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/configure.host	2012-03-29 17:53:42.000000000 +1000
@@ -327,6 +327,9 @@
 	;;
     esac
     ;;
+  arm*-*-nucleuseabi)
+    port_specific_symbol_files="\$(srcdir)/../config/os/nucleus/arm-eabi-extra.ver"
+    ;;
   powerpc*-*-darwin*)
     port_specific_symbol_files="\$(srcdir)/../config/os/bsd/darwin/ppc-extra.ver"
     ;;
diff -ru ./libstdc++-v3/libsupc++/cxxabi.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/cxxabi.h
--- ./libstdc++-v3/libsupc++/cxxabi.h	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/cxxabi.h	2012-03-29 17:53:10.000000000 +1000
@@ -619,6 +619,83 @@
     virtual ~recursive_init_error() throw ();
   };
 }
+
+#if defined(__arm__) && defined(__ARM_EABI__)
+
+// Also include the ARM specific routines.  This ensures they have
+// the correct visibility attributes.
+
+namespace __aeabiv1
+{
+  extern "C" void *
+  __aeabi_vec_ctor_nocookie_nodtor (void *array_address,
+				    abi::__cxa_cdtor_type constructor,
+				    size_t element_size,
+				    size_t element_count);
+  extern "C" void *
+  __aeabi_vec_ctor_cookie_nodtor (void *array_address,
+				  abi::__cxa_cdtor_type constructor,
+				  size_t element_size,
+				  size_t element_count);
+  
+  extern "C" void *
+  __aeabi_vec_cctor_nocookie_nodtor (void *dest_array,
+				     void *src_array, 
+				     size_t element_size, 
+				     size_t element_count,
+				     void *(*constructor) (void *, void *));
+
+  extern "C" void *
+  __aeabi_vec_new_cookie_noctor (size_t element_size, 
+				 size_t element_count);
+
+  extern "C" void *
+  __aeabi_vec_new_nocookie (size_t element_size, 
+			    size_t element_count,
+			    abi::__cxa_cdtor_type constructor);
+
+  extern "C" void *
+  __aeabi_vec_new_cookie_nodtor (size_t element_size, 
+				 size_t element_count,
+				 abi::__cxa_cdtor_type constructor);
+
+  extern "C" void *
+  __aeabi_vec_new_cookie(size_t element_size, 
+			 size_t element_count,
+			 abi::__cxa_cdtor_type constructor,
+			 abi::__cxa_cdtor_type destructor);
+  
+  extern "C" void *
+  __aeabi_vec_dtor (void *array_address, 
+		    abi::__cxa_cdtor_type destructor,
+		    size_t element_size, 
+		    size_t element_count);
+
+  extern "C" void *
+  __aeabi_vec_dtor_cookie (void *array_address, 
+			   abi::__cxa_cdtor_type destructor);
+  
+  extern "C" void
+  __aeabi_vec_delete (void *array_address, 
+		      abi::__cxa_cdtor_type destructor);
+
+  extern "C" void
+  __aeabi_vec_delete3 (void *array_address, 
+		       abi::__cxa_cdtor_type destructor,
+		       void (*dealloc) (void *, size_t));
+
+  extern "C" void
+  __aeabi_vec_delete3_nodtor (void *array_address,
+			      void (*dealloc) (void *, size_t));
+
+  extern "C" int
+  __aeabi_atexit (void *object, 
+		  void (*destructor) (void *),
+		  void *dso_handle) throw ();
+} // namespace __aeabiv1
+
+#endif // defined(__arm__) && defined(__ARM_EABI__)
+
 #endif // __cplusplus
 
 #pragma GCC visibility pop
diff -ru ./libstdc++-v3/libsupc++/eh_arm.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_arm.cc
--- ./libstdc++-v3/libsupc++/eh_arm.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_arm.cc	2012-03-29 17:53:10.000000000 +1000
@@ -22,6 +22,7 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.
 
+#include <typeinfo>
 #include <cxxabi.h>
 #include "unwind-cxx.h"
 
@@ -29,63 +30,63 @@
 
 using namespace __cxxabiv1;
 
-
-// Given the thrown type THROW_TYPE, pointer to a variable containing a
-// pointer to the exception object THROWN_PTR_P and a type CATCH_TYPE to
-// compare against, return whether or not there is a match and if so,
-// update *THROWN_PTR_P.
+// Given the thrown type THROW_TYPE, exception object UE_HEADER and a
+// type CATCH_TYPE to compare against, return whether or not there is
+// a match and if so, update *THROWN_PTR_P to point to either the
+// type-matched object, or in the case of a pointer type, the object
+// pointed to by the pointer.
 
 extern "C" __cxa_type_match_result
-__cxa_type_match(_Unwind_Exception* ue_header,
-		 const std::type_info* catch_type,
-		 bool is_reference __attribute__((__unused__)),
-		 void** thrown_ptr_p)
+__cxxabiv1::__cxa_type_match(_Unwind_Exception* ue_header,
+			     const std::type_info* catch_type,
+			     bool is_reference __attribute__((__unused__)),
+			     void** thrown_ptr_p)
 {
-  bool forced_unwind = __is_gxx_forced_unwind_class(ue_header->exception_class);
-  bool foreign_exception = !forced_unwind && !__is_gxx_exception_class(ue_header->exception_class);
-  bool dependent_exception =
-    __is_dependent_exception(ue_header->exception_class);
+  bool forced_unwind
+    = __is_gxx_forced_unwind_class(ue_header->exception_class);
+  bool foreign_exception
+    = !forced_unwind && !__is_gxx_exception_class(ue_header->exception_class);
+  bool dependent_exception
+    = __is_dependent_exception(ue_header->exception_class);
   __cxa_exception* xh = __get_exception_header_from_ue(ue_header);
   __cxa_dependent_exception *dx = __get_dependent_exception_from_ue(ue_header);
   const std::type_info* throw_type;
+  void *thrown_ptr = 0;
 
   if (forced_unwind)
     throw_type = &typeid(abi::__forced_unwind);
   else if (foreign_exception)
     throw_type = &typeid(abi::__foreign_exception);
-  else if (dependent_exception)
-    throw_type = __get_exception_header_from_obj
-      (dx->primaryException)->exceptionType;
   else
-    throw_type = xh->exceptionType;
-
-  void* thrown_ptr = *thrown_ptr_p;
+    {
+      if (dependent_exception)
+	xh = __get_exception_header_from_obj (dx->primaryException);
+      throw_type = xh->exceptionType;
+      // We used to require the caller set the target of thrown_ptr_p,
+      // but that's incorrect -- the EHABI makes no such requirement
+      // -- and not all callers will set it.  Fortunately callers that
+      // do initialize will always pass us the value we calculate
+      // here, so there's no backwards compatibility problem.
+      thrown_ptr = __get_object_from_ue (ue_header);
+    }
+  
+  __cxa_type_match_result result = ctm_succeeded;
 
   // Pointer types need to adjust the actual pointer, not
   // the pointer to pointer that is the exception object.
   // This also has the effect of passing pointer types
   // "by value" through the __cxa_begin_catch return value.
   if (throw_type->__is_pointer_p())
-    thrown_ptr = *(void**) thrown_ptr;
+    {
+      thrown_ptr = *(void**) thrown_ptr;
+      // We need to indicate the indirection to our caller.
+      result = ctm_succeeded_with_ptr_to_base;
+    }
 
   if (catch_type->__do_catch(throw_type, &thrown_ptr, 1))
     {
       *thrown_ptr_p = thrown_ptr;
-
-      if (typeid(*catch_type) == typeid (typeid(void*)))
-	{
-	  const __pointer_type_info *catch_pointer_type =
-	    static_cast<const __pointer_type_info *> (catch_type);
-	  const __pointer_type_info *throw_pointer_type =
-	    static_cast<const __pointer_type_info *> (throw_type);
-
-	  if (typeid (*catch_pointer_type->__pointee) != typeid (void)
-	      && (*catch_pointer_type->__pointee != 
-		  *throw_pointer_type->__pointee))
-	    return ctm_succeeded_with_ptr_to_base;
-	}
-
-      return ctm_succeeded;
+      return result;
     }
 
   return ctm_failed;
@@ -93,7 +94,7 @@
 
 // ABI defined routine called at the start of a cleanup handler.
 extern "C" bool
-__cxa_begin_cleanup(_Unwind_Exception* ue_header)
+__cxxabiv1::__cxa_begin_cleanup(_Unwind_Exception* ue_header)
 {
   __cxa_eh_globals *globals = __cxa_get_globals();
   __cxa_exception *header = __get_exception_header_from_ue(ue_header);
diff -ru ./libstdc++-v3/libsupc++/eh_call.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_call.cc
--- ./libstdc++-v3/libsupc++/eh_call.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_call.cc	2012-03-29 17:53:10.000000000 +1000
@@ -38,8 +38,10 @@
 // terminate.
 
 extern "C" void
-__cxa_call_terminate(_Unwind_Exception* ue_header) throw ()
-{
+__cxxabiv1::__cxa_call_terminate(__gnu_cxa_call_arg exc_obj_in) throw ()
+ {
+  _Unwind_Exception* ue_header
+    = reinterpret_cast<_Unwind_Exception*>(exc_obj_in);
 
   if (ue_header)
     {
@@ -65,7 +67,7 @@
 // The ARM EABI __cxa_call_unexpected has the same semantics as the generic
 // routine, but the exception specification has a different format.
 extern "C" void
-__cxa_call_unexpected(void* exc_obj_in)
+__cxxabiv1::__cxa_call_unexpected(_Unwind_Control_Block* exc_obj_in)
 {
   _Unwind_Exception* exc_obj
     = reinterpret_cast<_Unwind_Exception*>(exc_obj_in);
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++: eh_compact_pr.cc
diff -ru ./libstdc++-v3/libsupc++/eh_personality.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_personality.cc
--- ./libstdc++-v3/libsupc++/eh_personality.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_personality.cc	2012-04-28 17:58:32.000000000 +1000
@@ -247,6 +247,33 @@
   return false;
 }
 
+// Return true if THROW_TYPE matches one of the exception spec entries.
+static bool
+check_compact_exception_spec (_throw_typet* throw_type, void* thrown_ptr,
+			      const unsigned char *xh_lsda,
+			      _Unwind_Sword xh_switch_value,
+			      _Unwind_Ptr base)
+
+{
+  int i;
+  _uleb128_t no_of_types;
+  _Unwind_Ptr type_ptr;
+  const std::type_info* type_entry;
+  unsigned char encoding = xh_switch_value & 0xff;
+  const unsigned char *p = (const unsigned char *)
+			    xh_lsda + (xh_switch_value >> 8);
+
+  p = read_uleb128 (p, &no_of_types);
+  for (i = 0; i < (int) no_of_types; i++)
+    {
+      p = read_encoded_value_with_base (encoding, base, p, &type_ptr);
+      type_entry = reinterpret_cast<const std::type_info *>(type_ptr);
+      if (get_adjusted_ptr (type_entry, throw_type, &thrown_ptr))
+	return true;
+    }
+  return false;
+}
+
 // Return true if THROW_TYPE matches one if the filter types.
 
 static bool
@@ -347,6 +374,8 @@
 #define PERSONALITY_FUNCTION	__gxx_personality_v0
 #endif
 
+#pragma GCC visibility push(default)
+
 extern "C" _Unwind_Reason_Code
 #ifdef __ARM_EABI_UNWINDER__
 PERSONALITY_FUNCTION (_Unwind_State state,
@@ -384,6 +413,8 @@
   switch (state & _US_ACTION_MASK)
     {
     case _US_VIRTUAL_UNWIND_FRAME:
+      if (state & _US_FORCE_UNWIND)
+	CONTINUE_UNWINDING;
       actions = _UA_SEARCH_PHASE;
       break;
 
@@ -718,6 +749,8 @@
   return _URC_INSTALL_CONTEXT;
 }
 
+#pragma GCC visibility pop
+
 /* The ARM EABI implementation of __cxa_call_unexpected is in a
    different file so that the personality routine (PR) can be used
    standalone.  The generic routine shared datastructures with the PR
@@ -762,22 +795,41 @@
       __cxa_exception *new_xh = globals->caughtExceptions;
       void *new_ptr = __get_object_from_ambiguous_exception (new_xh);
 
-      // We don't quite have enough stuff cached; re-parse the LSDA.
-      parse_lsda_header (0, xh_lsda, &info);
+      if (xh_switch_value > 0)
+	{
+	  _throw_typet *new_type = __get_exception_header_from_obj
+				    (new_ptr)->exceptionType;
+	  if (check_compact_exception_spec (new_type, new_ptr, xh_lsda,
+					    xh_switch_value, info.ttype_base))
+	      __throw_exception_again;
+	}
+      else
+	{
+	  // We don't quite have enough stuff cached; re-parse the LSDA.
+	  parse_lsda_header (0, xh_lsda, &info);
+
+          // If this new exception meets the exception spec, allow it.
+	  if (check_exception_spec (&info, __get_exception_header_from_obj
+						(new_ptr)->exceptionType,
+						new_ptr, xh_switch_value))
+	    __throw_exception_again;
+	}
 
-      // If this new exception meets the exception spec, allow it.
-      if (check_exception_spec (&info, __get_exception_header_from_obj
-                                  (new_ptr)->exceptionType,
-				new_ptr, xh_switch_value))
-	__throw_exception_again;
-
-      // If the exception spec allows std::bad_exception, throw that.
-      // We don't have a thrown object to compare against, but since
-      // bad_exception doesn't have virtual bases, that's OK; just pass 0.
+// If the exception spec allows std::bad_exception, throw that.
+// We don't have a thrown object to compare against, but since
+// bad_exception doesn't have virtual bases, that's OK; just pass 0.
 #if defined(__EXCEPTIONS) && defined(__GXX_RTTI)
       const std::type_info &bad_exc = typeid (std::bad_exception);
-      if (check_exception_spec (&info, &bad_exc, 0, xh_switch_value))
-	throw std::bad_exception();
+      if (xh_switch_value > 0)
+	{
+	  if (check_compact_exception_spec (&bad_exc, 0, xh_lsda,
+					    xh_switch_value, info.ttype_base))
+	    throw std::bad_exception();
+	}
+      else if (check_exception_spec (&info, &bad_exc, 0, xh_switch_value))
+	{
+	  throw std::bad_exception();
+	}
 #endif   
 
       // Otherwise, die.
diff -ru ./libstdc++-v3/libsupc++/eh_ptr.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_ptr.cc
--- ./libstdc++-v3/libsupc++/eh_ptr.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_ptr.cc	2012-03-29 17:53:10.000000000 +1000
@@ -203,8 +203,8 @@
   dep->primaryException = obj;
   __sync_add_and_fetch (&eh->referenceCount, 1);
 
-  dep->unexpectedHandler = __unexpected_handler;
-  dep->terminateHandler = __terminate_handler;
+  dep->unexpectedHandler = __get_unexpected_handler ();
+  dep->terminateHandler = __get_terminate_handler ();
   __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(dep->unwindHeader.exception_class);
   dep->unwindHeader.exception_cleanup = __gxx_dependent_exception_cleanup;
 
diff -ru ./libstdc++-v3/libsupc++/eh_term_handler.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_term_handler.cc
--- ./libstdc++-v3/libsupc++/eh_term_handler.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_term_handler.cc	2012-03-29 17:53:10.000000000 +1000
@@ -36,11 +36,21 @@
 # include <cstdlib>
 #endif
 
-/* The current installed user handler.  */
-std::terminate_handler __cxxabiv1::__terminate_handler =
 #if _GLIBCXX_HOSTED
-	__gnu_cxx::__verbose_terminate_handler;
+#define DEFAULT_TERMINATE_HANDLER __gnu_cxx::__verbose_terminate_handler
 #else
-	std::abort;
+#define DEFAULT_TERMINATE_HANDLER std::abort
 #endif
+/* The current installed user handler.  */
+#ifdef __symbian__
+/* SymbianOS does not allow initialized data, so use a constructor function.  */
+std::terminate_handler __cxxabiv1::__terminate_handler;
 
+void __cxxabiv1::__init_terminate_handler(void)
+{
+  __cxxabiv1::__terminate_handler = DEFAULT_TERMINATE_HANDLER;
+}
+#else /* !__symbian__ */
+std::terminate_handler __cxxabiv1::__terminate_handler =
+  DEFAULT_TERMINATE_HANDLER;
+#endif
diff -ru ./libstdc++-v3/libsupc++/eh_terminate.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_terminate.cc
--- ./libstdc++-v3/libsupc++/eh_terminate.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_terminate.cc	2012-03-29 17:53:10.000000000 +1000
@@ -47,7 +47,7 @@
 void
 std::terminate () throw()
 {
-  __terminate (__terminate_handler);
+  __terminate (__get_terminate_handler ());
 }
 
 void
@@ -60,7 +60,7 @@
 void
 std::unexpected ()
 {
-  __unexpected (__unexpected_handler);
+  __unexpected (__get_unexpected_handler ());
 }
 
 std::terminate_handler
diff -ru ./libstdc++-v3/libsupc++/eh_throw.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_throw.cc
--- ./libstdc++-v3/libsupc++/eh_throw.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_throw.cc	2012-03-29 17:53:10.000000000 +1000
@@ -67,8 +67,8 @@
   header->referenceCount = 1;
   header->exc.exceptionType = tinfo;
   header->exc.exceptionDestructor = dest;
-  header->exc.unexpectedHandler = __unexpected_handler;
-  header->exc.terminateHandler = __terminate_handler;
+  header->exc.unexpectedHandler = __get_unexpected_handler ();
+  header->exc.terminateHandler = __get_terminate_handler ();
   __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header->exc.unwindHeader.exception_class);
   header->exc.unwindHeader.exception_cleanup = __gxx_exception_cleanup;
 
diff -ru ./libstdc++-v3/libsupc++/eh_unex_handler.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_unex_handler.cc
--- ./libstdc++-v3/libsupc++/eh_unex_handler.cc	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/eh_unex_handler.cc	2012-03-29 17:53:10.000000000 +1000
@@ -25,5 +25,14 @@
 #include "unwind-cxx.h"
 
 /* The current installed user handler.  */
-std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;
+#ifdef __symbian__
+/* SymbianOS does not allow initialized data, so use a constructor function.  */
+std::unexpected_handler __cxxabiv1::__unexpected_handler;
 
+void __cxxabiv1::__init_unexpected_handler (void)
+{
+  __cxxabiv1::__unexpected_handler = std::terminate;
+}
+#else /* !__symbian__ */
+std::unexpected_handler __cxxabiv1::__unexpected_handler = std::terminate;
+#endif
diff -ru ./libstdc++-v3/libsupc++/guard.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/guard.cc
--- ./libstdc++-v3/libsupc++/guard.cc	2014-06-06 11:50:38.307599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/guard.cc	2012-03-29 17:53:10.000000000 +1000
@@ -203,7 +203,10 @@
   static inline void
   throw_recursive_init_exception()
   {
-#ifdef __EXCEPTIONS
+    // When building for use with CSLIBC, avoid the overhead of throwing
+    // an exception.  Recursive initialization is undefined behavior, so
+    // crashing is acceptable.
+#if defined(__EXCEPTIONS) && !_GLIBCXX_CSLIBC
 	throw __gnu_cxx::recursive_init_error();
 #else
 	// Use __builtin_trap so we don't require abort().
diff -ru ./libstdc++-v3/libsupc++/Makefile.am /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/Makefile.am
--- ./libstdc++-v3/libsupc++/Makefile.am	2014-06-06 11:50:38.299599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/Makefile.am	2012-04-28 17:58:32.000000000 +1000
@@ -1,7 +1,7 @@
 ## Makefile for the GNU C++ Support library.
 ##
 ## Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
-## 2009, 2010, 2011
+## 2009, 2010, 2011, 2012
 ## Free Software Foundation, Inc.
 ##
 ## Process this file with automake to produce Makefile.in.
@@ -62,6 +62,7 @@
 	eh_aux_runtime.cc \
 	eh_call.cc \
 	eh_catch.cc \
+	eh_compact_pr.cc \
 	eh_exception.cc \
 	eh_globals.cc \
 	eh_personality.cc \
@@ -86,7 +87,6 @@
 	pbase_type_info.cc \
 	pmem_type_info.cc \
 	pointer_type_info.cc \
-	pure.cc \
 	si_class_type_info.cc \
 	tinfo.cc \
 	tinfo2.cc \
@@ -94,6 +94,13 @@
 	vmi_class_type_info.cc \
 	vterminate.cc
 
+if !GLIBCXX_CSLIBC
+# CSLIBC (or, more accurately, CS3) provides its own implementation of
+# __cxa_pure_virtual.
+sources += \
+	pure.cc
+endif
+
 libsupc___la_SOURCES = $(sources) $(c_sources) 
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources)
 
diff -ru ./libstdc++-v3/libsupc++/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/Makefile.in
--- ./libstdc++-v3/libsupc++/Makefile.in	2014-06-06 11:50:38.303599466 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/Makefile.in	2012-04-28 17:58:32.000000000 +1000
@@ -38,6 +38,12 @@
 target_triplet = @target@
 DIST_COMMON = $(top_srcdir)/fragment.am $(srcdir)/Makefile.in \
 	$(srcdir)/Makefile.am $(bits_HEADERS) $(std_HEADERS)
+
+# CSLIBC (or, more accurately, CS3) provides its own implementation of
+# __cxa_pure_virtual.
+@GLIBCXX_CSLIBC_FALSE@am__append_1 = \
+@GLIBCXX_CSLIBC_FALSE@	pure.cc
+
 subdir = libsupc++
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
@@ -90,23 +96,25 @@
 	"$(DESTDIR)$(stddir)"
 LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
 libsupc___la_LIBADD =
-am__objects_1 = array_type_info.lo atexit_arm.lo bad_alloc.lo \
+@GLIBCXX_CSLIBC_FALSE@am__objects_1 = pure.lo
+am__objects_2 = array_type_info.lo atexit_arm.lo bad_alloc.lo \
 	bad_cast.lo bad_typeid.lo class_type_info.lo del_op.lo \
 	del_opnt.lo del_opv.lo del_opvnt.lo dyncast.lo eh_alloc.lo \
 	eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \
-	eh_exception.lo eh_globals.lo eh_personality.lo eh_ptr.lo \
-	eh_term_handler.lo eh_terminate.lo eh_throw.lo eh_type.lo \
-	eh_unex_handler.lo enum_type_info.lo function_type_info.lo \
-	fundamental_type_info.lo guard.lo guard_error.lo hash_bytes.lo \
-	nested_exception.lo new_handler.lo new_op.lo new_opnt.lo \
-	new_opv.lo new_opvnt.lo pbase_type_info.lo pmem_type_info.lo \
-	pointer_type_info.lo pure.lo si_class_type_info.lo tinfo.lo \
-	tinfo2.lo vec.lo vmi_class_type_info.lo vterminate.lo
-@GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo
-am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2)
+	eh_compact_pr.lo eh_exception.lo eh_globals.lo \
+	eh_personality.lo eh_ptr.lo eh_term_handler.lo eh_terminate.lo \
+	eh_throw.lo eh_type.lo eh_unex_handler.lo enum_type_info.lo \
+	function_type_info.lo fundamental_type_info.lo guard.lo \
+	guard_error.lo hash_bytes.lo nested_exception.lo \
+	new_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo \
+	pbase_type_info.lo pmem_type_info.lo pointer_type_info.lo \
+	si_class_type_info.lo tinfo.lo tinfo2.lo vec.lo \
+	vmi_class_type_info.lo vterminate.lo $(am__objects_1)
+@GLIBCXX_HOSTED_TRUE@am__objects_3 = cp-demangle.lo
+am_libsupc___la_OBJECTS = $(am__objects_2) $(am__objects_3)
 libsupc___la_OBJECTS = $(am_libsupc___la_OBJECTS)
 libsupc__convenience_la_LIBADD =
-am_libsupc__convenience_la_OBJECTS = $(am__objects_1) $(am__objects_2)
+am_libsupc__convenience_la_OBJECTS = $(am__objects_2) $(am__objects_3)
 libsupc__convenience_la_OBJECTS =  \
 	$(am_libsupc__convenience_la_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
@@ -351,55 +359,18 @@
 @GLIBCXX_HOSTED_TRUE@c_sources = \
 @GLIBCXX_HOSTED_TRUE@	cp-demangle.c 
 
-sources = \
-	array_type_info.cc \
-	atexit_arm.cc \
-	bad_alloc.cc \
-	bad_cast.cc \
-	bad_typeid.cc \
-	class_type_info.cc \
-	del_op.cc \
-	del_opnt.cc \
-	del_opv.cc \
-	del_opvnt.cc \
-	dyncast.cc \
-	eh_alloc.cc \
-	eh_arm.cc \
-	eh_aux_runtime.cc \
-	eh_call.cc \
-	eh_catch.cc \
-	eh_exception.cc \
-	eh_globals.cc \
-	eh_personality.cc \
-	eh_ptr.cc \
-	eh_term_handler.cc \
-	eh_terminate.cc \
-	eh_throw.cc \
-	eh_type.cc \
-	eh_unex_handler.cc \
-	enum_type_info.cc \
-	function_type_info.cc \
-	fundamental_type_info.cc \
-	guard.cc \
-	guard_error.cc \
-	hash_bytes.cc \
-	nested_exception.cc \
-	new_handler.cc \
-	new_op.cc \
-	new_opnt.cc \
-	new_opv.cc \
-	new_opvnt.cc \
-	pbase_type_info.cc \
-	pmem_type_info.cc \
-	pointer_type_info.cc \
-	pure.cc \
-	si_class_type_info.cc \
-	tinfo.cc \
-	tinfo2.cc \
-	vec.cc \
-	vmi_class_type_info.cc \
-	vterminate.cc
-
+sources = array_type_info.cc atexit_arm.cc bad_alloc.cc bad_cast.cc \
+	bad_typeid.cc class_type_info.cc del_op.cc del_opnt.cc \
+	del_opv.cc del_opvnt.cc dyncast.cc eh_alloc.cc eh_arm.cc \
+	eh_aux_runtime.cc eh_call.cc eh_catch.cc eh_compact_pr.cc \
+	eh_exception.cc eh_globals.cc eh_personality.cc eh_ptr.cc \
+	eh_term_handler.cc eh_terminate.cc eh_throw.cc eh_type.cc \
+	eh_unex_handler.cc enum_type_info.cc function_type_info.cc \
+	fundamental_type_info.cc guard.cc guard_error.cc hash_bytes.cc \
+	nested_exception.cc new_handler.cc new_op.cc new_opnt.cc \
+	new_opv.cc new_opvnt.cc pbase_type_info.cc pmem_type_info.cc \
+	pointer_type_info.cc si_class_type_info.cc tinfo.cc tinfo2.cc \
+	vec.cc vmi_class_type_info.cc vterminate.cc $(am__append_1)
 libsupc___la_SOURCES = $(sources) $(c_sources) 
 libsupc__convenience_la_SOURCES = $(sources) $(c_sources)
 
diff -ru ./libstdc++-v3/libsupc++/unwind-cxx.h /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/unwind-cxx.h
--- ./libstdc++-v3/libsupc++/unwind-cxx.h	2014-06-06 11:50:38.307599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/libsupc++/unwind-cxx.h	2012-04-28 17:58:32.000000000 +1000
@@ -186,13 +186,6 @@
 
 // @@@ These are not directly specified by the IA-64 C++ ABI.
 
-// Handles re-checking the exception specification if unexpectedHandler
-// throws, and if bad_exception needs to be thrown.  Called from the
-// compiler.
-extern "C" void __cxa_call_unexpected (void *) __attribute__((__noreturn__));
-extern "C" void __cxa_call_terminate (_Unwind_Exception*) throw ()
-  __attribute__((__noreturn__));
-
 #ifdef __ARM_EABI_UNWINDER__
 // Arm EABI specified routines.
 typedef enum {
@@ -200,13 +193,24 @@
   ctm_succeeded = 1,
   ctm_succeeded_with_ptr_to_base = 2
 } __cxa_type_match_result;
-extern "C" __cxa_type_match_result __cxa_type_match(_Unwind_Exception*,
-						    const std::type_info*,
-						    bool, void**);
+extern "C" __cxa_type_match_result
+__cxa_type_match (_Unwind_Exception*, const std::type_info*, bool, void**);
 extern "C" bool __cxa_begin_cleanup (_Unwind_Exception*);
 extern "C" void __cxa_end_cleanup (void);
+#define __gnu_cxa_call_arg _Unwind_Control_Block*
+#else
+#define __gnu_cxa_call_arg void*
 #endif
 
+// Handles re-checking the exception specification if unexpectedHandler
+// throws, and if bad_exception needs to be thrown.  Called from the
+// compiler.
+#define __cxa_call_arg
+extern "C" void
+__cxa_call_unexpected (__gnu_cxa_call_arg) __attribute__((noreturn));
+extern "C" void
+__cxa_call_terminate (__gnu_cxa_call_arg) throw () __attribute__((noreturn));
+
 // Invokes given handler, dying appropriately if the user handler was
 // so inconsiderate as to return.
 extern void __terminate(std::terminate_handler) throw () 
@@ -218,6 +222,29 @@
 extern std::terminate_handler __terminate_handler;
 extern std::unexpected_handler __unexpected_handler;
 
+#ifdef __symbian__
+extern "C" void __init_terminate_handler(void);
+extern "C" void __init_unexpected_handler(void);
+#endif
+
+static inline std::terminate_handler __get_terminate_handler(void)
+{
+#ifdef __symbian__
+  if (!__terminate_handler)
+    __init_terminate_handler();
+#endif
+  return __terminate_handler;
+}
+
+static inline std::unexpected_handler __get_unexpected_handler(void)
+{
+#ifdef __symbian__
+  if (!__unexpected_handler)
+    __init_unexpected_handler();
+#endif
+  return __unexpected_handler;
+}
+
 // These are explicitly GNU C++ specific.
 
 // Acquire the C++ exception header from the C++ object.
@@ -383,6 +410,16 @@
      (int, _Unwind_Action, _Unwind_Exception_Class,
       struct _Unwind_Exception *, struct _Unwind_Context *);
 
+// GNU C++ compact eh personality routine.
+extern "C" _Unwind_Reason_Code __gnu_compact_pr2
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
+// GNU C++ compact eh personality routine.
+extern "C" _Unwind_Reason_Code __gnu_compact_pr3
+     (int, _Unwind_Action, _Unwind_Exception_Class,
+      struct _Unwind_Exception *, struct _Unwind_Context *);
+
 // GNU C++ sjlj personality routine, Version 0.
 extern "C" _Unwind_Reason_Code __gxx_personality_sj0
      (int, _Unwind_Action, _Unwind_Exception_Class,
diff -ru ./libstdc++-v3/python/Makefile.am /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/python/Makefile.am
--- ./libstdc++-v3/python/Makefile.am	2014-06-06 11:50:38.311599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/python/Makefile.am	2012-03-29 17:52:56.000000000 +1000
@@ -23,7 +23,7 @@
 include $(top_srcdir)/fragment.am
 
 ## Where to install the module code.
-pythondir = $(datadir)/gcc-$(gcc_version)/python
+pythondir = $(tooldir)/share/gcc-$(gcc_version)/python
 
 all-local: gdb.py
 
@@ -36,6 +36,7 @@
 	sed -e 's,@pythondir@,$(pythondir),' \
 	    -e 's,@toolexeclibdir@,$(toolexeclibdir),' < $(srcdir)/hook.in > $@
 
+if GLIBCXX_HOSTED
 install-data-local: gdb.py
 	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
 ## We want to install gdb.py as SOMETHING-gdb.py.  SOMETHING is the
@@ -57,3 +58,4 @@
 	cd $$here; \
 	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
 	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+endif
diff -ru ./libstdc++-v3/python/Makefile.in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/python/Makefile.in
--- ./libstdc++-v3/python/Makefile.in	2014-06-06 11:50:38.311599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/python/Makefile.in	2012-03-29 17:52:56.000000000 +1000
@@ -298,7 +298,7 @@
 
 # -I/-D flags to pass when compiling.
 AM_CPPFLAGS = $(GLIBCXX_INCLUDES)
-pythondir = $(datadir)/gcc-$(gcc_version)/python
+pythondir = $(tooldir)/share/gcc-$(gcc_version)/python
 nobase_python_DATA = \
     libstdcxx/v6/printers.py \
     libstdcxx/v6/__init__.py \
@@ -404,6 +404,7 @@
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
+@GLIBCXX_HOSTED_FALSE@install-data-local:
 clean: clean-am
 
 clean-am: clean-generic clean-libtool mostlyclean-am
@@ -492,22 +493,22 @@
 	sed -e 's,@pythondir@,$(pythondir),' \
 	    -e 's,@toolexeclibdir@,$(toolexeclibdir),' < $(srcdir)/hook.in > $@
 
-install-data-local: gdb.py
-	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
-	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
-	  for file in libstdc++*; do \
-	    case $$file in \
-	      *-gdb.py) ;; \
-	      *.la) ;; \
-	      *) if test -h $$file; then \
-	           continue; \
-	         fi; \
-	         libname=$$file;; \
-	    esac; \
-	  done; \
-	cd $$here; \
-	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
-	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
+@GLIBCXX_HOSTED_TRUE@install-data-local: gdb.py
+@GLIBCXX_HOSTED_TRUE@	@$(mkdir_p) $(DESTDIR)$(toolexeclibdir)
+@GLIBCXX_HOSTED_TRUE@	@here=`pwd`; cd $(DESTDIR)$(toolexeclibdir); \
+@GLIBCXX_HOSTED_TRUE@	  for file in libstdc++*; do \
+@GLIBCXX_HOSTED_TRUE@	    case $$file in \
+@GLIBCXX_HOSTED_TRUE@	      *-gdb.py) ;; \
+@GLIBCXX_HOSTED_TRUE@	      *.la) ;; \
+@GLIBCXX_HOSTED_TRUE@	      *) if test -h $$file; then \
+@GLIBCXX_HOSTED_TRUE@	           continue; \
+@GLIBCXX_HOSTED_TRUE@	         fi; \
+@GLIBCXX_HOSTED_TRUE@	         libname=$$file;; \
+@GLIBCXX_HOSTED_TRUE@	    esac; \
+@GLIBCXX_HOSTED_TRUE@	  done; \
+@GLIBCXX_HOSTED_TRUE@	cd $$here; \
+@GLIBCXX_HOSTED_TRUE@	echo " $(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py"; \
+@GLIBCXX_HOSTED_TRUE@	$(INSTALL_DATA) gdb.py $(DESTDIR)$(toolexeclibdir)/$$libname-gdb.py
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -ru ./libstdc++-v3/src/codecvt.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/codecvt.cc
--- ./libstdc++-v3/src/codecvt.cc	2014-06-06 11:50:38.315599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/codecvt.cc	2012-03-29 17:52:58.000000000 +1000
@@ -149,3 +149,29 @@
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
+
+#if _GLIBCXX_C_LOCALE_GNU
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+#ifdef _GLIBCXX_SIZE_T_IS_UINT
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIcc11__mbstate_tEC1EPij, _ZNSt7codecvtIcc11__mbstate_tEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIcc11__mbstate_tEC2EPij, _ZNSt7codecvtIcc11__mbstate_tEC2EP15__locale_structj);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIwc11__mbstate_tEC1EPij, _ZNSt7codecvtIwc11__mbstate_tEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIwc11__mbstate_tEC2EPij, _ZNSt7codecvtIwc11__mbstate_tEC2EP15__locale_structj);
+#endif
+#else
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIcc11__mbstate_tEC1EPim, _ZNSt7codecvtIcc11__mbstate_tEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIcc11__mbstate_tEC2EPim, _ZNSt7codecvtIcc11__mbstate_tEC2EP15__locale_structm);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIwc11__mbstate_tEC1EPim, _ZNSt7codecvtIwc11__mbstate_tEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7codecvtIwc11__mbstate_tEC2EPim, _ZNSt7codecvtIwc11__mbstate_tEC2EP15__locale_structm);
+#endif
+#endif
+#endif
diff -ru ./libstdc++-v3/src/ctype.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/ctype.cc
--- ./libstdc++-v3/src/ctype.cc	2014-06-06 11:50:38.319599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/ctype.cc	2012-03-29 17:52:58.000000000 +1000
@@ -137,3 +137,29 @@
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
+
+#if _GLIBCXX_C_LOCALE_GNU
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+#ifdef _GLIBCXX_SIZE_T_IS_UINT
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIcEC1EPiPKtbj, _ZNSt5ctypeIcEC1EP15__locale_structPKtbj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIcEC2EPiPKtbj, _ZNSt5ctypeIcEC2EP15__locale_structPKtbj);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIwEC1EPij, _ZNSt5ctypeIwEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIwEC2EPij, _ZNSt5ctypeIwEC2EP15__locale_structj);
+#endif
+#else
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIcEC1EPiPKtbm, _ZNSt5ctypeIcEC1EP15__locale_structPKtbm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIcEC2EPiPKtbm, _ZNSt5ctypeIcEC2EP15__locale_structPKtbm);
+#ifdef _GLIBCXX_USE_WCHAR_T
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIwEC1EPim, _ZNSt5ctypeIwEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt5ctypeIwEC2EPim, _ZNSt5ctypeIwEC2EP15__locale_structm);
+#endif
+#endif
+#endif
diff -ru ./libstdc++-v3/src/locale-inst.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/locale-inst.cc
--- ./libstdc++-v3/src/locale-inst.cc	2014-06-06 11:50:38.323599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/locale-inst.cc	2012-03-29 17:52:58.000000000 +1000
@@ -362,3 +362,41 @@
 		     _ZNKSt9money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE9_M_insertILb1EEES3_S3_RSt8ios_basecRKSs);
 
 #endif // _GLIBCXX_LONG_DOUBLE_COMPAT
+
+#if _GLIBCXX_C_LOCALE_GNU && defined C_is_char
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+#ifdef _GLIBCXX_SIZE_T_IS_UINT
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb0EEC1EPiPKcj, _ZNSt10moneypunctIcLb0EEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb0EEC2EPiPKcj, _ZNSt10moneypunctIcLb0EEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb1EEC1EPiPKcj, _ZNSt10moneypunctIcLb1EEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb1EEC2EPiPKcj, _ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIcEC1EPiPKcj, _ZNSt11__timepunctIcEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIcEC2EPiPKcj, _ZNSt11__timepunctIcEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIcEC1EPij, _ZNSt7collateIcEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIcEC2EPij, _ZNSt7collateIcEC2EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIcEC1EPiPKcj, _ZNSt8messagesIcEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIcEC2EPiPKcj, _ZNSt8messagesIcEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIcEC1EPij, _ZNSt8numpunctIcEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIcEC2EPij, _ZNSt8numpunctIcEC2EP15__locale_structj);
+#else
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb0EEC1EPiPKcm, _ZNSt10moneypunctIcLb0EEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb0EEC2EPiPKcm, _ZNSt10moneypunctIcLb0EEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb1EEC1EPiPKcm, _ZNSt10moneypunctIcLb1EEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIcLb1EEC2EPiPKcm, _ZNSt10moneypunctIcLb1EEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIcEC1EPiPKcm, _ZNSt11__timepunctIcEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIcEC2EPiPKcm, _ZNSt11__timepunctIcEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIcEC1EPim, _ZNSt7collateIcEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIcEC2EPim, _ZNSt7collateIcEC2EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIcEC1EPiPKcm, _ZNSt8messagesIcEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIcEC2EPiPKcm, _ZNSt8messagesIcEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIcEC1EPim, _ZNSt8numpunctIcEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIcEC2EPim, _ZNSt8numpunctIcEC2EP15__locale_structm);
+#endif
+#endif
diff -ru ./libstdc++-v3/src/wlocale-inst.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/wlocale-inst.cc
--- ./libstdc++-v3/src/wlocale-inst.cc	2014-06-06 11:50:38.327599467 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/src/wlocale-inst.cc	2012-03-29 17:52:58.000000000 +1000
@@ -73,4 +73,42 @@
 		     _ZNKSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE9_M_insertILb1EEES3_S3_RSt8ios_basewRKSbIwS2_SaIwEE);
 
 #endif // _GLIBCXX_LONG_DOUBLE_COMPAT
+
+#if _GLIBCXX_C_LOCALE_GNU
+/* Because of a bad cross-compilation fallback in a configure test,
+   Sourcery G++ toolchains for GNU/Linux targets formerly used the
+   "generic" locale model in libstdc++.  Improve compatibility with
+   those toolchains by exporting symbol aliases under the "generic"
+   names for the "gnu" functions.  */
+#define _GLIBCXX_LOCALE_COMPAT(generic, gnu) \
+  extern "C" void generic (void) __attribute__ ((alias (#gnu), weak))
+
+#ifdef _GLIBCXX_SIZE_T_IS_UINT
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb0EEC1EPiPKcj, _ZNSt10moneypunctIwLb0EEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb0EEC2EPiPKcj, _ZNSt10moneypunctIwLb0EEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb1EEC1EPiPKcj, _ZNSt10moneypunctIwLb1EEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb1EEC2EPiPKcj, _ZNSt10moneypunctIwLb1EEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIwEC1EPiPKcj, _ZNSt11__timepunctIwEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIwEC2EPiPKcj, _ZNSt11__timepunctIwEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIwEC1EPij, _ZNSt7collateIwEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIwEC2EPij, _ZNSt7collateIwEC2EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIwEC1EPiPKcj, _ZNSt8messagesIwEC1EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIwEC2EPiPKcj, _ZNSt8messagesIwEC2EP15__locale_structPKcj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIwEC1EPij, _ZNSt8numpunctIwEC1EP15__locale_structj);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIwEC2EPij, _ZNSt8numpunctIwEC2EP15__locale_structj);
+#else
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb0EEC1EPiPKcm, _ZNSt10moneypunctIwLb0EEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb0EEC2EPiPKcm, _ZNSt10moneypunctIwLb0EEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb1EEC1EPiPKcm, _ZNSt10moneypunctIwLb1EEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt10moneypunctIwLb1EEC2EPiPKcm, _ZNSt10moneypunctIwLb1EEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIwEC1EPiPKcm, _ZNSt11__timepunctIwEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt11__timepunctIwEC2EPiPKcm, _ZNSt11__timepunctIwEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIwEC1EPim, _ZNSt7collateIwEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt7collateIwEC2EPim, _ZNSt7collateIwEC2EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIwEC1EPiPKcm, _ZNSt8messagesIwEC1EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8messagesIwEC2EPiPKcm, _ZNSt8messagesIwEC2EP15__locale_structPKcm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIwEC1EPim, _ZNSt8numpunctIwEC1EP15__locale_structm);
+_GLIBCXX_LOCALE_COMPAT (_ZNSt8numpunctIwEC2EPim, _ZNSt8numpunctIwEC2EP15__locale_structm);
+#endif
+#endif
 #endif
diff -ru ./libstdc++-v3/testsuite/22_locale/num_put/put/char/9780-2.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/testsuite/22_locale/num_put/put/char/9780-2.cc
--- ./libstdc++-v3/testsuite/22_locale/num_put/put/char/9780-2.cc	2014-06-06 14:25:27.642150558 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/testsuite/22_locale/num_put/put/char/9780-2.cc	2012-03-29 17:53:27.000000000 +1000
@@ -1,7 +1,7 @@
 // { dg-require-namedlocale "de_DE" }
 // { dg-require-namedlocale "es_ES" }
 
-// Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+// Copyright (C) 2004, 2005, 2009, 2011 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -22,23 +22,60 @@
 #include <locale>
 #include <testsuite_hooks.h>
 
-int main()
+// Make sure that formatted output uses the locale in the output stream.
+using namespace std;
+locale l1 = locale("de_DE");
+const num_put<char>& np = use_facet<num_put<char> >(l1);
+const numpunct<char>& npunct = use_facet<numpunct<char> >(l1);
+
+void test01()
 {
-  using namespace std;
+  bool test __attribute__((unused)) = true;
+
+  locale l2 = locale("C");
+  const numpunct<char>& npunct2 = use_facet<numpunct<char> >(l2);
+  char c = npunct2.thousands_sep();
+  string s = npunct2.grouping();
+
+  ostringstream oss;
+  oss.imbue(l2);
+
+  long l = 1234567890;
+  np.put(oss.rdbuf(), oss, ' ', l);
+  string res = oss.str();
+
+  VERIFY( res == "1234567890" );
+}
 
+void test02()
+{
   bool test __attribute__((unused)) = true;
-  locale l1 = locale("de_DE");
+
   locale l2 = locale("es_ES");
-  
-  const num_put<char>& np = use_facet<num_put<char> >(l1);  
+  const numpunct<char>& npunct3 = use_facet<numpunct<char> >(l2);
+  char c = npunct3.thousands_sep();
+  string s = npunct3.grouping();
+
   ostringstream oss;
   oss.imbue(l2);
 
   long l = 1234567890;
-  np.put(oss.rdbuf(), oss, ' ', l); // 1234567890
+  np.put(oss.rdbuf(), oss, ' ', l);
   string res = oss.str();
-  
-  VERIFY( res == "1234567890" );
 
+  if (!s.empty())
+    VERIFY( res == "1.234.567.890" );
+  else
+    VERIFY( res == "1234567890" );
+}
+
+int main()
+{
+  // Sanity check.
+  char c = npunct.thousands_sep();
+  string s = npunct.grouping();
+
+  test01();
+  test02();
   return 0;
 }
diff -ru ./libstdc++-v3/testsuite/25_algorithms/random_shuffle/moveable.cc /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/testsuite/25_algorithms/random_shuffle/moveable.cc
--- ./libstdc++-v3/testsuite/25_algorithms/random_shuffle/moveable.cc	2014-06-06 11:50:38.907599489 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/testsuite/25_algorithms/random_shuffle/moveable.cc	2012-03-29 17:53:12.000000000 +1000
@@ -1,4 +1,5 @@
 // { dg-options "-std=gnu++0x" }
+// { dg-add-options large_stack }
 
 // Copyright (C) 2009, 2010 Free Software Foundation, Inc.
 //
diff -ru ./libstdc++-v3/testsuite/lib/prune.exp /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/testsuite/lib/prune.exp
--- ./libstdc++-v3/testsuite/lib/prune.exp	2014-06-06 11:50:39.079599496 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libstdc++-v3/testsuite/lib/prune.exp	2012-03-29 17:53:29.000000000 +1000
@@ -62,5 +62,23 @@
 	}
     }
 
+    if { [ishost "sparc*-*-solaris2*"] } {
+	# When testing a compiler built for SPARC Solaris 2.9 (or earlier)
+	# on a host running Solaris 2.10 (or later), we get this warning 
+	# from the static linker when building with g++:
+	#
+	#   libm.so.1, needed by .../libstdc++.so may conflict with
+	#   libm.so
+	#
+	# The warning is issued because libstdc++ is linked against
+	# libm.so.1 (from the Solaris 2.9 sysroot), whereas Solaris 2.10
+	# provides both libm.so.2 and libm.so.1.  On Solaris 2.10, libc.so
+	# depends on libm.so.2, so all programs pull in libm.so.2.
+	#
+	# Pulling both libraries must in fact be harmless, as, otherwise,
+	# programs built for Solaris 2.9 would break on Solaris 2.10.
+	regsub -all "(^|\n)\[^\n\]*: warning: libm.so.1, needed by \[^\n\]*, may conflict with libm.so.2" $text "" text
+    }
+
     return $text
 }
diff -ru ./libtool.m4 /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libtool.m4
--- ./libtool.m4	2014-06-06 11:50:39.147599499 +1000
+++ /scratch/nsidwell/nokia/src/gcc-4.6-2012.03/libtool.m4	2012-03-29 18:03:38.000000000 +1000
@@ -2506,6 +2506,21 @@
   shlibpath_overrides_runpath=yes
   ;;
 
+nucleus*)
+  case $host_vendor in
+    samsung)
+      version_type=linux
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+      soname_spec='$libname${shared_ext}$major'
+      shlibpath_var=LD_LIBRARY_PATH
+      hardcode_into_libs=yes
+      ;;
+    *)
+      dynamic_linker=no
+      ;;
+  esac
+  ;;
+
 *nto* | *qnx*)
   version_type=qnx
   need_lib_prefix=no
@@ -2593,6 +2608,14 @@
   need_version=yes
   ;;
 
+symbian*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+  library_names_spec='${libname}.dll'
+  ;;
+
 sysv4 | sysv4.3*)
   version_type=linux
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
@@ -3014,6 +3037,10 @@
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
+nucleuseabi*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 darwin* | rhapsody*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -3118,6 +3145,10 @@
   lt_cv_deplibs_check_method=pass_all
   ;;
 
+symbian*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
 sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
   lt_cv_deplibs_check_method=pass_all
   ;;
@@ -3619,6 +3650,10 @@
       # Interix 3.x gcc -fpic/-fPIC options generate broken code.
       # Instead, we relocate shared libraries at runtime.
       ;;
+    symbian*)
+      # symbian does not have PIC, the loader relocates non-pic shared objects
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+      ;;
     sysv4*MP*)
       if test -d /usr/nec; then
 	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
Only in /scratch/nsidwell/nokia/src/gcc-4.6-2012.03: release-notes-csl.xml
Only in .: symbiandiff.txt
